{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MCP Labs - Learning Series","text":"<p>Welcome to the Model Context Protocol (MCP) hands-on learning series! </p> <p>This comprehensive set of labs will take you from MCP fundamentals to building production-ready MCP servers.</p>"},{"location":"#what-youll-learn","title":"What You\u2019ll Learn","text":"<p>Through these five progressive labs, you\u2019ll master:</p> <ul> <li>MCP Architecture - Understanding the client-server model and core concepts</li> <li>Server Development - Building MCP servers from scratch with TypeScript</li> <li>Tools Implementation - Creating sophisticated tools that interact with external systems</li> <li>Resource Management - Exposing contextual data through MCP resources</li> <li>Prompt Engineering - Building reusable prompt templates for common tasks</li> </ul>"},{"location":"#lab-overview","title":"Lab Overview","text":""},{"location":"#lab-1-mcp-fundamentals","title":"Lab 1: MCP Fundamentals","text":"<p>Get started with the basics! Learn what MCP is, why it exists, and understand its architecture and core components.</p> <p>Topics:</p> <ul> <li>What is MCP and the problem it solves</li> <li>Client-server architecture</li> <li>Core capabilities: Tools, Resources, and Prompts</li> <li>MCP communication model and lifecycle</li> <li>Common use cases</li> </ul> <p>Duration: 30-45 minutes</p>"},{"location":"#lab-2-building-your-first-mcp-server","title":"Lab 2: Building Your First MCP Server","text":"<p>Build a complete, working MCP server from the ground up.</p> <p>Topics:</p> <ul> <li>Project setup with Node.js and TypeScript</li> <li>Implementing the MCP protocol</li> <li>Creating your first tool</li> <li>Testing with MCP Inspector</li> <li>Connecting to Claude Desktop</li> </ul> <p>Duration: 1-1.5 hours</p>"},{"location":"#lab-3-implementing-mcp-tools","title":"Lab 3: Implementing MCP Tools","text":"<p>Master the art of creating sophisticated, production-ready tools.</p> <p>Topics:</p> <ul> <li>Advanced input validation with JSON Schema</li> <li>Real-world tool examples (Weather API, File operations, Database queries)</li> <li>Returning rich content types</li> <li>Error handling patterns</li> <li>Performance optimization and caching</li> </ul> <p>Duration: 1.5-2 hours</p>"},{"location":"#lab-4-working-with-mcp-resources","title":"Lab 4: Working with MCP Resources","text":"<p>Learn to expose contextual data that LLMs can read and reference.</p> <p>Topics:</p> <ul> <li>Understanding tools vs. resources</li> <li>Implementing different resource types</li> <li>Resource URI schemes and templates</li> <li>Resource subscriptions for live updates</li> <li>Combining tools and resources</li> </ul> <p>Duration: 1-1.5 hours</p>"},{"location":"#lab-5-mcp-prompts-and-complete-integration","title":"Lab 5: MCP Prompts and Complete Integration","text":"<p>Complete your MCP education with prompts and production best practices.</p> <p>Topics:</p> <ul> <li>Creating reusable prompt templates</li> <li>Embedding resources in prompts</li> <li>Building a complete server with all capabilities</li> <li>Production deployment and configuration</li> <li>Debugging and troubleshooting</li> </ul> <p>Duration: 1.5-2 hours</p>"},{"location":"#lab-6-k-agent-integration","title":"Lab 6: K-Agent Integration","text":"<p>Implement a specialized MCP server (K-Agent) that interacts with Kubernetes clusters to provide AI-driven log collection and analysis.</p> <p>Topics:</p> <ul> <li>MCP server architecture for Kubernetes</li> <li>Secure communication with Kubernetes API</li> <li>Implementing tools for pod discovery and log retrieval</li> <li>Collecting and structuring logs for LLM consumption</li> <li>Containerizing and deploying the K-Agent server</li> </ul> <p>Duration: 2-3 hours</p>"},{"location":"#tasks","title":"Tasks","text":"<p>Duration: Varies</p> <p>A dedicated section with exercises and challenges to reinforce your learning from all labs.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js v18 or later</li> <li>Basic knowledge of JavaScript/TypeScript</li> <li>A code editor (VS Code recommended)</li> <li>Terminal/command line familiarity</li> </ul>"},{"location":"#recommended-path","title":"Recommended Path","text":"<ol> <li>Start with Lab 1 - Even if you\u2019re experienced, the fundamentals are important</li> <li>Complete labs in order - Each builds on previous knowledge</li> <li>Do the hands-on exercises - Practice is key to mastery</li> <li>Experiment freely - Try variations and explore beyond the examples</li> </ol>"},{"location":"#lab-format","title":"Lab Format","text":"<p>Each lab includes:</p> <ul> <li>Clear learning objectives</li> <li>Detailed explanations</li> <li>Complete code examples</li> <li>Hands-on exercises</li> <li>Key takeaways</li> <li>Links to additional resources</li> </ul>"},{"location":"#tips-for-success","title":"Tips for Success","text":"<ol> <li>Set aside focused time - Labs require concentration and experimentation</li> <li>Type the code yourself - Don\u2019t just copy-paste; understand each line</li> <li>Test frequently - Run your code after each major change</li> <li>Read error messages carefully - They often tell you exactly what\u2019s wrong</li> <li>Experiment with modifications - Try changing parameters and adding features</li> <li>Join the community - Connect with other MCP learners and developers</li> </ol>"},{"location":"#development-tools","title":"Development Tools","text":"<p>You\u2019ll use these tools throughout the labs:</p> <ul> <li>MCP TypeScript SDK - Official SDK for building servers</li> <li>MCP Inspector - Essential testing tool</li> </ul>"},{"location":"#additional-resources","title":"Additional Resources","text":"<ul> <li>MCP Official Documentation</li> <li>MCP Specification</li> <li>MCP GitHub Organization</li> <li>Example Servers Repository</li> <li>JSON-RPC 2.0 Specification</li> </ul>"},{"location":"#after-completing-the-labs","title":"After Completing the Labs","text":"<p>Once you\u2019ve finished all five labs, you\u2019ll be ready to:</p> <ul> <li>Build custom MCP servers for your specific needs</li> <li>Integrate LLMs with your company\u2019s tools and data</li> <li>Contribute to the MCP open source ecosystem</li> <li>Share your servers with the community</li> <li>Help others learn MCP</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>Stack Overflow - Tag questions with <code>model-context-protocol</code></li> <li>MCP Discord - Ask questions, share projects</li> <li>GitHub Organization - Contribute to the ecosystem</li> <li>Official Documentation - Comprehensive reference</li> <li>MCP Specification - Protocol details</li> </ul>"},{"location":"#ready-to-begin","title":"Ready to Begin?","text":"<p>Start with Lab 1: MCP Fundamentals \u2192</p> <p>Let\u2019s build something amazing with MCP!</p>"},{"location":"explanations/","title":"Explanations","text":"<p>This document provides detailed explanations of key concepts in the MCP (Model Context Protocol) server implementation, including endpoints, function calls, and RAGs (Retrieval-Augmented Generation).</p>"},{"location":"explanations/#endpoints","title":"Endpoints","text":""},{"location":"explanations/#general-meaning-of-endpoints-in-this-mcp-server","title":"General Meaning of Endpoints in This MCP Server","text":"<p>In the context of this MCP (Model Context Protocol) server, the \u201cendpoints\u201d refer to the API routes (URLs) that the server exposes for clients (like MCP inspectors, AI assistants, or other tools) to interact with it. </p> <p>These endpoints are part of the server\u2019s manifest, which is a metadata document that describes the server\u2019s capabilities, transport method (e.g., \u201cstreamable-http\u201d), and available routes. </p> <p>The manifest is served at <code>/.well-known/mcp</code> and helps clients discover and connect to the server.</p> <p>The endpoints follow RESTful conventions and support HTTP methods like GET, POST, and OPTIONS (for CORS preflight). They enable core MCP functionalities such as tool execution, resource access, prompt management, and server health checks. The server uses FastMCP (a framework for building MCP servers) and runs on port 8889 by default. </p> <p>Each endpoint is implemented as a custom route in the code, often with CORS headers for browser-based clients.</p> <p>Below, you\u2019ll find explanations for each endpoint from the manifest, including its purpose, typical HTTP methods, and what it does based on the code implementation. </p> <p>They are grouped logically for clarity.</p>"},{"location":"explanations/#core-server-and-discovery-endpoints","title":"Core Server and Discovery Endpoints","text":"<p>These handle basic server operations, discovery, and connection setup.</p> <ul> <li> <p>manifest (<code>/.well-known/mcp</code>):   Serves the MCP manifest (metadata about the server, including capabilities and all endpoints). Clients use this to understand what the server supports. Handled by <code>mcp_manifest()</code> \u2013 returns JSON with server info, base URL, and endpoint list.</p> </li> <li> <p>health (<code>/health</code>):   Simple health check to confirm the server is running. Returns a plain text response like \u201cMCP Server Running\u201d. Handled by <code>health_check()</code>.</p> </li> <li> <p>ping (<code>/ping</code>):   Connection health check with more details. Returns JSON with status (\u201cok\u201d), timestamp, and server name. Handled by <code>ping()</code>.</p> </li> <li> <p>root (<code>/</code>):   Root endpoint for basic server status. Similar to health, returns \u201cMCP Server Running\u201d. Handled by <code>root_health_check()</code>.</p> </li> <li> <p>negotiate (<code>/negotiate</code>):   Used for connection negotiation (e.g., transport setup and optional authentication via tokens). Clients send tokens here; the server responds with connection details. Handled by <code>negotiate()</code> \u2013 supports proxy tokens from headers or query params.</p> </li> <li> <p>metadata (<code>/metadata</code>):   Provides detailed server metadata, including protocol version and capabilities (e.g., support for tools, prompts). Handled by <code>metadata()</code> \u2013 returns JSON with server info and feature flags.</p> </li> <li> <p>events (<code>/mcp</code>):   The main MCP event stream endpoint for streamable HTTP transport. This is where real-time communication happens (e.g., tool calls, responses). It\u2019s the core mount path for the FastMCP server. Handled by the FastMCP framework\u2019s run method.</p> </li> </ul>"},{"location":"explanations/#tool-related-endpoints","title":"Tool-Related Endpoints","text":"<p>These manage MCP tools (functions the server exposes, like \u201chello\u201d or \u201cadd\u201d).</p> <ul> <li> <p>tools (<code>/tools</code>):   Lists all available tools with metadata (names, descriptions, arguments). Clients use this to discover tools. Handled by <code>tools_list()</code> \u2013 returns JSON with tool details from the server\u2019s <code>list_tools()</code> method.</p> </li> <li> <p>tools_execute (<code>/tools/execute</code>):   Executes a single tool synchronously. Clients send the tool name and arguments; the server runs it and returns the result. Handled by <code>tool_execute()</code> \u2013 validates args, executes via <code>execute_tool()</code>, and tracks executions.</p> </li> <li> <p>tools_batch (<code>/tools/batch</code>):   Executes multiple tools in a batch (array of calls). Useful for efficiency. Handled by <code>tool_batch_execute()</code> \u2013 processes each call and returns results.</p> </li> <li> <p>tools_stream (<code>/tools/stream</code>):   Executes a tool with streaming responses (e.g., for long-running tasks). Returns NDJSON (newline-delimited JSON) events like \u201cstart\u201d, \u201cresult\u201d, and \u201cend\u201d. Handled by <code>tool_stream_execute()</code>.</p> </li> <li> <p>tools_history (<code>/tools/history</code>):   Retrieves execution history for tools (recent runs, with optional limit). Handled by <code>tool_history()</code> \u2013 returns JSON with past executions from <code>TOOL_EXECUTIONS</code>.</p> </li> </ul>"},{"location":"explanations/#prompt-and-resource-endpoints","title":"Prompt and Resource Endpoints","text":"<p>These handle reusable prompts and static resources.</p> <ul> <li> <p>prompts (<code>/prompts</code>):   Lists available prompt templates (e.g., \u201ccode_review_prompt\u201d). Clients can use these for structured interactions. Handled by <code>prompts_list()</code> \u2013 returns JSON with prompt metadata.</p> </li> <li> <p>resources (<code>/resources</code>):   Lists available resources (e.g., server source code or info). Handled by <code>resources_list()</code> \u2013 returns JSON with resource URIs and descriptions.</p> </li> </ul>"},{"location":"explanations/#sampling-and-roots-endpoints","title":"Sampling and Roots Endpoints","text":"<p>These support advanced MCP features like LLM sampling and file system access.</p> <ul> <li> <p>sampling (<code>/sampling</code>):   Provides LLM sampling (text generation) using Ollama. Clients send a prompt; the server generates a response. Handled by <code>sampling()</code> \u2013 integrates with Ollama API for completions.</p> </li> <li> <p>roots (<code>/roots</code>):   Lists file system roots (e.g., the current working directory). Used for file-based operations. Handled by <code>roots_list()</code> \u2013 returns JSON with root URIs.</p> </li> </ul>"},{"location":"explanations/#customollama-specific-endpoint","title":"Custom/Ollama-Specific Endpoint","text":"<ul> <li>ollama_status (<code>/ollama/status</code>):   Checks the status of the connected Ollama instance (local LLM server). Returns model info, connection status, and available models. Handled by <code>ollama_status()</code> \u2013 queries Ollama\u2019s <code>/api/tags</code> endpoint.</li> </ul> <p>All endpoints include CORS headers for cross-origin requests and handle OPTIONS preflights. The server tracks tool executions globally for history/debugging.</p>"},{"location":"explanations/#function-calls","title":"Function Calls","text":""},{"location":"explanations/#what-are-function-calls","title":"What Are Function Calls?","text":"<p>In the context of MCP (Model Context Protocol) and AI systems, function calls (often referred to as \u201ctools\u201d in MCP terminology) are mechanisms that allow AI models or clients to invoke external functions or services dynamically. </p> <p>Instead of generating plain text responses, the AI can decide to call a predefined function with specific arguments, execute it on the server, and incorporate the results into its response. </p> <p>This enables more interactive, tool-augmented AI behaviors, such as performing calculations, querying databases, or interacting with APIs.</p> <p>In this MCP server, tools are essentially function calls exposed via the <code>/tools</code> endpoints. For example, the <code>hello</code> tool is a function that takes a <code>name</code> argument and returns a greeting string.</p>"},{"location":"explanations/#what-do-they-do","title":"What Do They Do?","text":"<p>Function calls allow the AI to extend its capabilities beyond static knowledge. </p> <p>They enable:</p> <ul> <li>Dynamic Execution: The AI can perform real-time actions, like adding numbers or generating text via Ollama.</li> <li>Structured Interactions: Clients (e.g., an AI assistant) can call functions to retrieve data or perform tasks, then use the output in conversations.</li> <li>Modularity: Developers can add new functions without retraining the AI model.</li> <li>Safety and Control: Arguments are validated, and executions are tracked for auditing.</li> </ul> <p>In MCP, tools are registered with decorators like <code>@mcp.tool()</code>, and clients discover them via the <code>/tools</code> endpoint.</p>"},{"location":"explanations/#how-to-set-them-up","title":"How to Set Them Up","text":"<ol> <li> <p>Define the Function: Write a Python function with type hints and a docstring. For example:    <pre><code>@mcp.tool()\ndef my_tool(arg1: str, arg2: int = 0) -&gt; str:\n    \"\"\"Description of what the tool does.\"\"\"\n    # Implementation here\n    return f\"Result: {arg1} and {arg2}\"\n</code></pre></p> <ul> <li>Use <code>@mcp.tool()</code> to register it with FastMCP.</li> <li>Arguments should have types; defaults are optional.</li> </ul> </li> <li> <p>Validation and Execution: The server automatically validates arguments against the function signature (via <code>validate_tool_arguments</code>) and executes it (via <code>execute_tool</code>). Results are tracked in <code>TOOL_EXECUTIONS</code>.</p> </li> <li> <p>Expose via Endpoints: Tools are listed at <code>/tools</code>, executed at <code>/tools/execute</code>, etc. No additional setup needed beyond registration.</p> </li> <li> <p>Testing: Use the <code>/tools/history</code> endpoint to debug executions. Ensure the function handles errors gracefully.</p> </li> <li> <p>Integration with AI: Clients (e.g., via MCP inspectors) can call these functions. For LLM integration, the AI might be prompted to output function call JSON, which the client then executes.</p> </li> </ol> <p>Function calls are asynchronous if the function is a coroutine (<code>async def</code>).</p>"},{"location":"explanations/#rags-retrieval-augmented-generation","title":"RAGs (Retrieval-Augmented Generation)","text":""},{"location":"explanations/#what-are-rags","title":"What Are RAGs?","text":"<p>RAGs stand for Retrieval-Augmented Generation, a technique in AI where an LLM (Large Language Model) retrieves relevant information from external data sources before generating a response. </p> <p>This improves accuracy, reduces hallucinations, and allows the model to access up-to-date or domain-specific knowledge not in its training data. </p> <p>Instead of relying solely on pre-trained knowledge, RAGs \u201caugment\u201d generation with retrieved context.</p> <p>In this MCP server context, RAGs can be implemented using resources (static data) or sampling (dynamic retrieval via Ollama). </p> <p>For example, retrieving code snippets or server info to inform responses.</p>"},{"location":"explanations/#how-do-they-work","title":"How Do They Work?","text":"<ol> <li>Retrieval Phase: When a query is made, the system searches a knowledge base (e.g., documents, databases) for relevant chunks of data.</li> <li>Augmentation: Retrieved data is fed into the LLM\u2019s prompt as context.</li> <li>Generation: The LLM generates a response based on both the query and retrieved data.</li> </ol> <ul> <li> <p>Key components:</p> <ul> <li>Data Sources: Could be files, APIs, or databases.</li> <li>Retriever: Searches and ranks relevant data (e.g., via embeddings or keywords).</li> <li>Generator: The LLM that produces the final output.</li> </ul> </li> </ul> <p>In MCP, resources at <code>/resources</code> can serve as static data sources, while sampling at <code>/sampling</code> can generate augmented responses.</p>"},{"location":"explanations/#how-to-set-them-up_1","title":"How to Set Them Up","text":"<ol> <li> <p>Define Data Sources: Use MCP resources for static data. For example:    <pre><code>@mcp.resource(\"mcp://my-data\")\ndef get_data() -&gt; str:\n    \"\"\"Returns relevant data.\"\"\"\n    return \"Retrieved information here.\"\n</code></pre></p> <ul> <li>Resources are listed at <code>/resources</code> and can be queried by URI.</li> </ul> </li> <li> <p>Implement Retrieval: For dynamic retrieval, integrate with tools or sampling. For instance, use a tool to query a database or API, then pass results to Ollama via <code>/sampling</code>.</p> </li> <li> <p>Augment with Sampling: At <code>/sampling</code>, send a prompt that includes retrieved context:    <pre><code>{\n  \"prompt\": \"Using this data: [retrieved info]. Answer: [query]\",\n  \"model\": \"llama3.2:latest\"\n}\n</code></pre></p> <ul> <li>Ollama generates the response with augmentation.</li> </ul> </li> <li> <p>Full RAG Pipeline:</p> <ul> <li>Client queries the server.</li> <li>Server retrieves data (e.g., via a tool or resource).</li> <li>Data is injected into a prompt.</li> <li>Sampling generates the augmented response.</li> </ul> </li> <li> <p>Tools for RAG: Add tools like <code>search_documents</code> that retrieve data. Combine with prompts for structured queries.</p> </li> <li> <p>Best Practices: Use embeddings (e.g., via Ollama or external services) for semantic search. Cache retrieved data for efficiency. Ensure data sources are secure and up-to-date.</p> </li> </ol> <p>RAGs enhance MCP servers by making them knowledge-aware, useful for applications like chatbots with custom data or code assistants.</p>"},{"location":"explanations/#additional-mcp-inspector-tabs-and-configuration","title":"Additional MCP Inspector Tabs and Configuration","text":"<p>The MCP Inspector provides various tabs that correspond to different capabilities and endpoints in your MCP server. </p> <p>These tabs allow you to test and interact with the server\u2019s features. Below, you\u2019ll find explanations for each tab mentioned (resources, prompts, tools, ping, sampling, elicitations, roots, auth, metadata) and how to configure them in the JSON manifest within <code>mcp02.py</code>.</p> <p>The manifest is defined in the <code>mcp_manifest()</code> function. It includes a <code>\"capabilities\"</code> object (boolean flags indicating support) and an <code>\"endpoints\"</code> object (URL paths). To enable or configure a feature, update these sections accordingly.</p>"},{"location":"explanations/#resources-tab","title":"Resources Tab","text":"<ul> <li>Purpose: Displays static data sources (e.g., files, server info) that clients can access.</li> <li>Configuration: <ul> <li>Set <code>\"resources\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"resources\": \"/resources\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/resources</code> endpoint to list available resources (e.g., URIs like <code>mcp://code</code>).</li> <li>Register resources with <code>@mcp.resource(\"uri\")</code> decorators.</li> </ul> </li> <li>Example: In <code>mcp02.py</code>, resources like <code>get_code()</code> and <code>get_server_info()</code> are registered and listed via <code>/resources</code>.</li> </ul>"},{"location":"explanations/#prompts-tab","title":"Prompts Tab","text":"<ul> <li>Purpose: Shows reusable prompt templates for structured interactions (e.g., code review prompts).</li> <li>Configuration:<ul> <li>Set <code>\"prompts\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"prompts\": \"/prompts\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/prompts</code> endpoint to return a list of prompt metadata.</li> <li>Register prompts with <code>@mcp.prompt()</code> decorators.</li> </ul> </li> <li>Example: Prompts like <code>code_review_prompt()</code> are defined and exposed via <code>/prompts</code>.</li> </ul>"},{"location":"explanations/#tools-tab","title":"Tools Tab","text":"<ul> <li>Purpose: Lists executable functions (tools) that clients can invoke (e.g., <code>hello</code>, <code>add</code>).</li> <li>Configuration:<ul> <li>Set <code>\"tools\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"tools\": \"/tools\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/tools</code> to return tool metadata from <code>mcp.list_tools()</code>.</li> <li>Register tools with <code>@mcp.tool()</code> decorators.</li> </ul> </li> <li>Example: Tools like <code>hello()</code> and <code>add()</code> are registered and discoverable via <code>/tools</code>.</li> </ul>"},{"location":"explanations/#ping-tab","title":"Ping Tab","text":"<ul> <li>Purpose: Tests server connectivity and health with a simple ping.</li> <li>Configuration:<ul> <li>Add <code>\"ping\": \"/ping\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/ping</code> endpoint to return JSON with status, timestamp, and server name.</li> </ul> </li> <li>Example: The <code>ping()</code> function returns <code>{\"status\": \"ok\", ...}</code>.</li> </ul>"},{"location":"explanations/#sampling-tab","title":"Sampling Tab","text":"<ul> <li>Purpose: Allows LLM text generation (e.g., via Ollama) for completions.</li> <li>Configuration:<ul> <li>Set <code>\"sampling\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"sampling\": \"/sampling\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/sampling</code> to accept prompts and return generated text.</li> </ul> </li> <li>Example: Uses Ollama API to generate responses based on input prompts.</li> </ul>"},{"location":"explanations/#elicitations-tab","title":"Elicitations Tab","text":"<ul> <li>Purpose: Likely refers to logging or event elicitation (capturing server events/logs). In MCP, this may map to <code>\"logging\"</code> capability for debugging.</li> <li>Configuration:<ul> <li>Set <code>\"logging\": true</code> in <code>\"capabilities\"</code>.</li> <li>No specific endpoint needed, but ensure logging is enabled in the server framework.</li> </ul> </li> <li>Note: If this refers to \u201cevents,\u201d use the <code>/mcp</code> endpoint for streamable HTTP events.</li> </ul>"},{"location":"explanations/#roots-tab","title":"Roots Tab","text":"<ul> <li>Purpose: Lists file system roots for file-based operations.</li> <li>Configuration:<ul> <li>Set <code>\"roots\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"roots\": \"/roots\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/roots</code> to return root URIs (e.g., current directory).</li> </ul> </li> <li>Example: Returns <code>[{\"uri\": \"file://current/dir\", \"name\": \"Current Directory\"}]</code>.</li> </ul>"},{"location":"explanations/#auth-tab","title":"Auth Tab","text":"<ul> <li>Purpose: Handles authentication (e.g., token-based access).</li> <li>Configuration:<ul> <li>Use the <code>/negotiate</code> endpoint for auth negotiation.</li> <li>Accept tokens via headers (e.g., <code>Authorization: Bearer &lt;token&gt;</code>).</li> <li>In the manifest, no direct flag, but ensure <code>/negotiate</code> supports auth.</li> </ul> </li> <li>Example: The <code>negotiate()</code> function checks for tokens and includes them in responses.</li> </ul>"},{"location":"explanations/#metadata-tab","title":"Metadata Tab","text":"<ul> <li>Purpose: Provides server metadata (version, capabilities, protocol info).</li> <li>Configuration:<ul> <li>Add <code>\"metadata\": \"/metadata\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/metadata</code> to return detailed server info.</li> </ul> </li> <li>Example: Returns JSON with <code>serverInfo</code> and <code>capabilities</code>.</li> </ul> <p>To update the manifest in <code>mcp02.py</code>, edit the <code>manifest</code> dictionary in <code>mcp_manifest()</code>. For instance, to add a new capability, include it in <code>\"capabilities\"</code> and its endpoint in <code>\"endpoints\"</code>. Restart the server after changes.</p>"},{"location":"explanations/#creating-a-personal-custom-rag","title":"Creating a Personal Custom RAG","text":"<p>Retrieval-Augmented Generation (RAG) allows you to build a custom knowledge system by combining data retrieval with LLM generation. </p> <p>Here\u2019s how to create one in your MCP server context:</p>"},{"location":"explanations/#step-1-define-data-sources","title":"Step 1: Define Data Sources","text":"<ul> <li>Static Data: Use MCP resources for fixed content (e.g., documents, code).<ul> <li>Register with <code>@mcp.resource(\"mcp://my-data\")</code>.</li> <li>Store data in files, databases, or variables.</li> </ul> </li> <li>Dynamic Data: Integrate APIs or databases for real-time retrieval.<ul> <li>Create tools to query external sources (e.g., a tool that searches a vector database).</li> </ul> </li> </ul>"},{"location":"explanations/#step-2-implement-retrieval","title":"Step 2: Implement Retrieval","text":"<ul> <li>Simple Retrieval: Use keyword search or basic queries.<ul> <li>Example: A tool that reads from a JSON file or API.</li> </ul> </li> <li>Advanced Retrieval: Use embeddings for semantic search.<ul> <li>Install libraries like <code>sentence-transformers</code> or <code>faiss</code>.</li> <li>Embed your data and queries, then find similar vectors.</li> <li>Example: Store document chunks in a vector DB, retrieve top matches for a query.</li> </ul> </li> </ul>"},{"location":"explanations/#step-3-augment-with-llm","title":"Step 3: Augment with LLM","text":"<ul> <li>Integration: Pass retrieved data into prompts.<ul> <li>Use the <code>/sampling</code> endpoint or a tool like <code>ollama_generate()</code>.</li> <li>Example Prompt: <code>\"Using this data: {retrieved_info}. Answer: {user_query}\"</code>.</li> </ul> </li> <li>Pipeline:<ol> <li>User queries the server.</li> <li>Retrieve relevant data (via tool or resource).</li> <li>Inject data into LLM prompt.</li> <li>Generate response via sampling.</li> </ol> </li> </ul>"},{"location":"explanations/#step-4-set-up-in-mcp-server","title":"Step 4: Set Up in MCP Server","text":"<ul> <li>Add Tools/Resources: Register retrieval functions as tools (e.g., <code>@mcp.tool() def search_docs(query: str)</code>).</li> <li>Configure Endpoints: Ensure <code>/resources</code>, <code>/tools</code>, and <code>/sampling</code> are enabled.</li> <li>Testing: Use the Inspector to test retrieval and generation.</li> </ul>"},{"location":"explanations/#best-practices","title":"Best Practices","text":"<ul> <li>Data Management: Keep data secure and up-to-date.</li> <li>Performance: Cache embeddings; use efficient search.</li> <li>Scalability: For large datasets, use external vector DBs like Pinecone or Weaviate.</li> <li> <p>Example Code Snippet:</p> <pre><code>@mcp.tool()\ndef rag_query(query: str) -&gt; str:\n    # Retrieve data (simplified)\n    retrieved = \"Relevant info from your data source.\"\n    # Augment and generate\n    prompt = f\"Data: {retrieved}. Query: {query}\"\n    return ollama_generate(prompt)\n</code></pre> </li> </ul> <p>This creates a personal RAG tailored to your data, enhancing AI responses with custom knowledge.</p>"},{"location":"explanations/#adding-clients-internal-llm","title":"Adding Clients (Internal LLM)","text":"<p>To integrate an internal Large Language Model (LLM) as a client with your MCP server, you need to set up a client that can connect to the MCP server, discover its capabilities, and invoke tools, resources, or prompts. </p> <p>This allows the LLM to augment its responses using the server\u2019s functionalities, such as executing custom tools or retrieving data.</p>"},{"location":"explanations/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>MCP Server Running: Ensure your MCP server is running and accessible (e.g., at <code>http://localhost:8889</code>).</p> </li> <li> <p>Client Library: Use an MCP-compatible client library. For Python, you can use libraries like <code>mcp-client</code> or integrate with frameworks like LangChain or LlamaIndex that support MCP. For other languages, check for MCP SDKs (e.g., Node.js MCP clients).</p> </li> <li> <p>LLM Setup: Have an internal LLM ready, such as Ollama running locally, or another model that supports tool calling (e.g., via function calling APIs).</p> </li> <li> <p>Information Needed:</p> <ul> <li>Server Base URL: The full URL where the MCP server is hosted (e.g., <code>http://localhost:8889</code>).</li> <li>Manifest URL: The URL to the manifest endpoint (e.g., <code>http://localhost:8889/.well-known/mcp</code>). This provides metadata about the server\u2019s capabilities and endpoints.</li> <li>Authentication Token (optional): If the server requires authentication, obtain a token (e.g., via the <code>/negotiate</code> endpoint). Pass it in headers like <code>Authorization: Bearer &lt;token&gt;</code>.</li> <li>Transport Method: Confirm the server uses \u201cstreamable-http\u201d transport, as indicated in the manifest.</li> </ul> </li> </ul>"},{"location":"explanations/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Install Required Libraries:</p> <ul> <li>For Python: Install the MCP client library if available (e.g., <code>pip install mcp-client</code> or similar). If using LangChain, install <code>langchain</code> and MCP integrations.</li> <li>For other setups: Ensure your LLM framework supports MCP (e.g., LlamaIndex has MCP connectors).</li> </ul> </li> <li> <p>Fetch the Server Manifest:</p> <ul> <li>Make a GET request to the manifest URL to retrieve the server\u2019s metadata.</li> <li>Example (using curl): <code>curl http://localhost:8889/.well-known/mcp</code></li> <li>Parse the JSON response to understand available endpoints (e.g., <code>/tools</code>, <code>/resources</code>, <code>/sampling</code>) and capabilities (e.g., <code>tools: true</code>).</li> </ul> </li> <li> <p>Initialize the MCP Client:</p> <ul> <li>In your client code, create an MCP client instance and connect to the server.</li> <li>Provide the base URL and any authentication details.</li> <li> <p>Example in Python (pseudo-code):</p> <pre><code>from mcp_client import MCPClient  # Assuming a library exists\n\nclient = MCPClient(base_url=\"http://localhost:8889\", auth_token=\"your_token_if_needed\")\nclient.connect()\n</code></pre> </li> </ul> </li> <li> <p>Discover Capabilities:</p> <ul> <li>Use the client to list available tools, resources, or prompts.</li> <li>Example: Call <code>client.list_tools()</code> to get tool metadata, which includes names, descriptions, and argument schemas.</li> </ul> </li> <li> <p>Integrate with the Internal LLM:</p> <ul> <li>Configure the LLM to use the MCP client for tool calling.</li> <li>For LLMs that support function calling (e.g., GPT models or local models via libraries), map MCP tools to callable functions.</li> <li>Example workflow:<ul> <li>When the LLM generates a response, check if it needs to call a tool (e.g., based on a prompt or decision).</li> <li>Use the MCP client to execute the tool: <code>result = client.call_tool(\"tool_name\", args={\"arg1\": \"value\"})</code>.</li> <li>Feed the result back into the LLM\u2019s context for the final response.</li> </ul> </li> <li>For Ollama or similar local LLMs, you may need a wrapper script that handles the tool calling logic.</li> </ul> </li> <li> <p>Handle Sampling or Generation:</p> <ul> <li>If the LLM needs to generate text augmented by the server, use the <code>/sampling</code> endpoint via the client.</li> <li>Example: <code>response = client.sample(prompt=\"Your prompt here\", model=\"llama3.2:latest\")</code>.</li> </ul> </li> <li> <p>Test the Integration:</p> <ul> <li>Run a test query where the LLM invokes a tool (e.g., the \u201chello\u201d tool).</li> <li>Verify that the client connects, executes the tool, and the LLM incorporates the result.</li> <li>Check logs on the server side (e.g., via <code>/tools/history</code>) for executions.</li> </ul> </li> <li> <p>Handle Errors and Authentication:</p> <ul> <li>Implement error handling for failed connections or tool executions.</li> <li>If authentication fails, renegotiate tokens via <code>/negotiate</code>.</li> <li>Ensure CORS and security settings allow the client to connect.</li> </ul> </li> <li> <p>Advanced Setup:</p> <ul> <li>For streaming: Use the <code>/tools/stream</code> endpoint for real-time tool execution.</li> <li>For batch operations: Call multiple tools at once via <code>/tools/batch</code>.</li> <li>Integrate with prompts: Use <code>/prompts</code> to retrieve structured prompts for the LLM.</li> </ul> </li> </ol> <p>By following these steps, your internal LLM can act as an MCP client, leveraging the server\u2019s tools and resources to provide more capable and context-aware responses. </p> <p>If using a specific LLM framework, refer to its documentation for MCP integration details.</p>"},{"location":"labs/","title":"MCP Labs - Learning Series","text":"<ul> <li>Welcome to the Model Context Protocol (MCP) hands-on learning series! </li> <li>This comprehensive set of labs will take you from MCP fundamentals to building production-ready MCP servers.</li> <li>Here you\u2019ll Learn and Build Model Context Protocol (MCP) from Scratch</li> <li>Whether you\u2019re new to MCP or looking to deepen your understanding, this learning series will take you from fundamentals to building production-ready MCP servers.</li> </ul>"},{"location":"labs/#what-youll-learn","title":"What You\u2019ll Learn","text":"<p>Through these 6 progressive labs, you\u2019ll master:</p> Topic Description MCP Architecture Understanding and mastering the client-server model and core concepts Server Development Building MCP servers from scratch with TypeScript using the official SDK Tools Implementation Creating sophisticated tools that interact with external systems and developing functions that LLMs can call to perform actions Resource Management Exposing contextual data through MCP resources that LLMs can read and reference Prompt Engineering Building reusable prompt templates for common tasks Production Deployment Applying best practices for real-world applications"},{"location":"labs/#labs-overview","title":"Labs Overview","text":""},{"location":"labs/#lab-1-mcp-fundamentals","title":"Lab 1: MCP Fundamentals","text":"<p>Get started with the basics! Learn what MCP is, why it exists, and understand its architecture and core components.</p> <p>Topics:</p> <ul> <li>What is MCP and the problem it solves</li> <li>Client-server architecture</li> <li>Core capabilities: Tools, Resources, and Prompts</li> <li>MCP communication model and lifecycle</li> <li>Common use cases</li> </ul>"},{"location":"labs/#lab-2-building-your-first-mcp-server","title":"Lab 2: Building Your First MCP Server","text":"<p>Build a complete, working MCP server from the ground up.</p> <p>Topics:</p> <ul> <li>Project setup with Node.js and TypeScript</li> <li>Implementing the MCP protocol</li> <li>Creating your first tool</li> <li>Testing with MCP Inspector</li> <li>Connecting to Claude Desktop</li> </ul>"},{"location":"labs/#lab-3-implementing-mcp-tools","title":"Lab 3: Implementing MCP Tools","text":"<p>Master the art of creating sophisticated, production-ready tools.</p> <p>Topics:</p> <ul> <li>Advanced input validation with JSON Schema</li> <li>Real-world tool examples (Weather API, File operations, Database queries)</li> <li>Returning rich content types</li> <li>Error handling patterns</li> <li>Performance optimization and caching</li> </ul>"},{"location":"labs/#lab-4-working-with-mcp-resources","title":"Lab 4: Working with MCP Resources","text":"<p>Learn to expose contextual data that LLMs can read and reference.</p> <p>Topics:</p> <ul> <li>Understanding tools vs. resources</li> <li>Implementing different resource types</li> <li>Resource URI schemes and templates</li> <li>Resource subscriptions for live updates</li> <li>Combining tools and resources</li> </ul>"},{"location":"labs/#lab-5-mcp-prompts-and-complete-integration","title":"Lab 5: MCP Prompts and Complete Integration","text":"<p>Complete your MCP education with prompts and production best practices.</p> <p>Topics:</p> <ul> <li>Creating reusable prompt templates</li> <li>Embedding resources in prompts</li> <li>Building a complete server with all capabilities</li> <li>Production deployment and configuration</li> <li>Debugging and troubleshooting</li> </ul>"},{"location":"labs/#lab-6-k-agent-integration","title":"Lab 6: K-Agent Integration","text":"<p>Implement a specialized MCP server (K-Agent) that interacts with Kubernetes clusters to provide AI-driven log collection and analysis.</p> <p>Topics:</p> <ul> <li>MCP server architecture for Kubernetes</li> <li>Secure communication with Kubernetes API</li> <li>Implementing tools for pod discovery and log retrieval</li> <li>Collecting and structuring logs for LLM consumption</li> <li>Containerizing and deploying the K-Agent server</li> </ul>"},{"location":"labs/#ready-to-begin","title":"Ready to Begin?","text":"<p>Start with Lab 1: MCP Fundamentals \u2192</p> <p>Let\u2019s build something amazing with MCP!</p>"},{"location":"resources/","title":"MCP Server Examples","text":"<p>This section provides complete, working examples of MCP servers in both TypeScript and Python. These examples demonstrate the core concepts of MCP server development and can be used as starting points for your own implementations.</p>"},{"location":"resources/#typescript-mcp-server-example","title":"TypeScript MCP Server Example","text":""},{"location":"resources/#complete-mcp-server-with-tools-resources-and-prompts","title":"Complete MCP Server with Tools, Resources, and Prompts","text":"<pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { readFileSync } from \"fs\";\nimport fetch from \"node-fetch\";\n\nclass MCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"example-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // Tools handlers\n    this.server.setRequestHandler(\"tools/list\", async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"calculate\",\n            description: \"Perform basic arithmetic operations\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                operation: {\n                  type: \"string\",\n                  enum: [\"add\", \"subtract\", \"multiply\", \"divide\"]\n                },\n                a: { type: \"number\" },\n                b: { type: \"number\" }\n              },\n              required: [\"operation\", \"a\", \"b\"]\n            }\n          },\n          {\n            name: \"get_weather\",\n            description: \"Get current weather for a city\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: { type: \"string\" }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"read_file\",\n            description: \"Read contents of a file\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                path: { type: \"string\" }\n              },\n              required: [\"path\"]\n            }\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"calculate\":\n          return this.handleCalculate(args);\n        case \"get_weather\":\n          return this.handleWeather(args);\n        case \"read_file\":\n          return this.handleReadFile(args);\n        default:\n          throw new Error(`Unknown tool: ${name}`);\n      }\n    });\n\n    // Resources handlers\n    this.server.setRequestHandler(\"resources/list\", async () =&gt; {\n      return {\n        resources: [\n          {\n            uri: \"file://server-info\",\n            name: \"Server Information\",\n            description: \"Information about this MCP server\",\n            mimeType: \"application/json\"\n          },\n          {\n            uri: \"file://system-status\",\n            name: \"System Status\",\n            description: \"Current system status and metrics\",\n            mimeType: \"application/json\"\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n      const { uri } = request.params;\n\n      switch (uri) {\n        case \"file://server-info\":\n          return {\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                name: \"Example MCP Server\",\n                version: \"1.0.0\",\n                capabilities: [\"tools\", \"resources\", \"prompts\"],\n                uptime: process.uptime()\n              }, null, 2)\n            }]\n          };\n        case \"file://system-status\":\n          return {\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                platform: process.platform,\n                nodeVersion: process.version,\n                memory: process.memoryUsage(),\n                cpuUsage: process.cpuUsage()\n              }, null, 2)\n            }]\n          };\n        default:\n          throw new Error(`Resource not found: ${uri}`);\n      }\n    });\n\n    // Prompts handlers\n    this.server.setRequestHandler(\"prompts/list\", async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"code_review\",\n            description: \"Review code for best practices and improvements\",\n            arguments: [\n              {\n                name: \"code\",\n                description: \"The code to review\",\n                required: true\n              },\n              {\n                name: \"language\",\n                description: \"Programming language\",\n                required: false\n              }\n            ]\n          },\n          {\n            name: \"debug_help\",\n            description: \"Get help debugging an issue\",\n            arguments: [\n              {\n                name: \"problem\",\n                description: \"Description of the problem\",\n                required: true\n              },\n              {\n                name: \"code\",\n                description: \"Relevant code snippet\",\n                required: false\n              }\n            ]\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"code_review\":\n          return {\n            description: \"Code Review Assistant\",\n            messages: [\n              {\n                role: \"user\",\n                content: {\n                  type: \"text\",\n                  text: `Please review the following ${args.language || 'code'} for best practices, potential bugs, and improvements:\\n\\n${args.code}\\n\\nPlease provide:\\n1. Code quality assessment\\n2. Potential issues or bugs\\n3. Suggestions for improvement\\n4. Best practices recommendations`\n                }\n              }\n            ]\n          };\n        case \"debug_help\":\n          return {\n            description: \"Debugging Assistant\",\n            messages: [\n              {\n                role: \"user\",\n                content: {\n                  type: \"text\",\n                  text: `I'm experiencing this problem: ${args.problem}\\n\\n${args.code ? `Here's the relevant code:\\n${args.code}\\n` : ''}\\n\\nPlease help me:\\n1. Understand what might be causing this issue\\n2. Suggest debugging steps\\n3. Provide potential solutions\\n4. Recommend best practices to avoid similar issues`\n                }\n              }\n            ]\n          };\n        default:\n          throw new Error(`Unknown prompt: ${name}`);\n      }\n    });\n  }\n\n  private handleCalculate(args: any) {\n    const { operation, a, b } = args;\n    let result: number;\n\n    switch (operation) {\n      case \"add\":\n        result = a + b;\n        break;\n      case \"subtract\":\n        result = a - b;\n        break;\n      case \"multiply\":\n        result = a * b;\n        break;\n      case \"divide\":\n        if (b === 0) throw new Error(\"Division by zero\");\n        result = a / b;\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Result: ${result}`\n      }]\n    };\n  }\n\n  private async handleWeather(args: any) {\n    const { city } = args;\n    const apiKey = process.env.WEATHER_API_KEY;\n\n    if (!apiKey) {\n      throw new Error(\"Weather API key not configured\");\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${city}&amp;appid=${apiKey}&amp;units=metric`\n      );\n\n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Weather in ${city}: ${data.weather[0].description}, ${data.main.temp}\u00b0C`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Weather fetch failed: ${error.message}`);\n    }\n  }\n\n  private handleReadFile(args: any) {\n    const { path } = args;\n\n    try {\n      const content = readFileSync(path, \"utf-8\");\n      return {\n        content: [{\n          type: \"text\",\n          text: content\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n\n  async start() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"MCP Server started\");\n  }\n}\n\n// Start the server\nconst server = new MCPServer();\nserver.start().catch(console.error);\n</code></pre>"},{"location":"resources/#packagejson-for-typescript-mcp-server","title":"package.json for TypeScript MCP Server","text":"<pre><code>{\n  \"name\": \"example-mcp-server-ts\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Example MCP server in TypeScript\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\",\n    \"node-fetch\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre>"},{"location":"resources/#tsconfigjson","title":"tsconfig.json","text":"<pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre>"},{"location":"resources/#python-mcp-server-example","title":"Python MCP Server Example","text":""},{"location":"resources/#complete-mcp-server-with-tools-resources-and-prompts_1","title":"Complete MCP Server with Tools, Resources, and Prompts","text":"<pre><code>#!/usr/bin/env python3\n\nimport asyncio\nimport json\nimport os\nimport sys\nfrom typing import Any, Dict, List\nimport httpx\nfrom mcp import Tool, types\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\n\nserver = Server(\"example-mcp-server\")\n\n@server.list_tools()\nasync def list_tools() -&gt; List[Tool]:\n    \"\"\"List available tools.\"\"\"\n    return [\n        Tool(\n            name=\"calculate\",\n            description=\"Perform basic arithmetic operations\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"operation\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"]\n                    },\n                    \"a\": {\"type\": \"number\"},\n                    \"b\": {\"type\": \"number\"}\n                },\n                \"required\": [\"operation\", \"a\", \"b\"]\n            }\n        ),\n        Tool(\n            name=\"get_weather\",\n            description=\"Get current weather for a city\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"city\": {\"type\": \"string\"}\n                },\n                \"required\": [\"city\"]\n            }\n        ),\n        Tool(\n            name=\"read_file\",\n            description=\"Read contents of a file\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\"type\": \"string\"}\n                },\n                \"required\": [\"path\"]\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    if name == \"calculate\":\n        return await handle_calculate(arguments)\n    elif name == \"get_weather\":\n        return await handle_weather(arguments)\n    elif name == \"read_file\":\n        return await handle_read_file(arguments)\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n\nasync def handle_calculate(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle calculator tool.\"\"\"\n    operation = args[\"operation\"]\n    a = args[\"a\"]\n    b = args[\"b\"]\n\n    if operation == \"add\":\n        result = a + b\n    elif operation == \"subtract\":\n        result = a - b\n    elif operation == \"multiply\":\n        result = a * b\n    elif operation == \"divide\":\n        if b == 0:\n            raise ValueError(\"Division by zero\")\n        result = a / b\n    else:\n        raise ValueError(f\"Unknown operation: {operation}\")\n\n    return [types.TextContent(type=\"text\", text=f\"Result: {result}\")]\n\nasync def handle_weather(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle weather tool.\"\"\"\n    city = args[\"city\"]\n    api_key = os.getenv(\"WEATHER_API_KEY\")\n\n    if not api_key:\n        raise ValueError(\"Weather API key not configured\")\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            f\"https://api.openweathermap.org/data/2.5/weather?q={city}&amp;appid={api_key}&amp;units=metric\"\n        )\n\n        if response.status_code != 200:\n            raise ValueError(f\"Weather API error: {response.status_code}\")\n\n        data = response.json()\n        weather_desc = data[\"weather\"][0][\"description\"]\n        temp = data[\"main\"][\"temp\"]\n\n        return [types.TextContent(\n            type=\"text\",\n            text=f\"Weather in {city}: {weather_desc}, {temp}\u00b0C\"\n        )]\n\nasync def handle_read_file(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle file reading tool.\"\"\"\n    path = args[\"path\"]\n\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        return [types.TextContent(type=\"text\", text=content)]\n    except Exception as e:\n        raise ValueError(f\"Failed to read file: {e}\")\n\n@server.list_resources()\nasync def list_resources() -&gt; List[types.Resource]:\n    \"\"\"List available resources.\"\"\"\n    return [\n        types.Resource(\n            uri=\"file://server-info\",\n            name=\"Server Information\",\n            description=\"Information about this MCP server\",\n            mimeType=\"application/json\"\n        ),\n        types.Resource(\n            uri=\"file://system-status\",\n            name=\"System Status\",\n            description=\"Current system status and metrics\",\n            mimeType=\"application/json\"\n        )\n    ]\n\n@server.read_resource()\nasync def read_resource(uri: str) -&gt; str:\n    \"\"\"Read resource content.\"\"\"\n    if uri == \"file://server-info\":\n        import psutil\n        import time\n\n        info = {\n            \"name\": \"Example MCP Server\",\n            \"version\": \"1.0.0\",\n            \"capabilities\": [\"tools\", \"resources\", \"prompts\"],\n            \"uptime\": time.time() - psutil.boot_time()\n        }\n        return json.dumps(info, indent=2)\n\n    elif uri == \"file://system-status\":\n        import psutil\n\n        status = {\n            \"cpu_percent\": psutil.cpu_percent(interval=1),\n            \"memory\": {\n                \"total\": psutil.virtual_memory().total,\n                \"available\": psutil.virtual_memory().available,\n                \"percent\": psutil.virtual_memory().percent\n            },\n            \"disk\": {\n                \"total\": psutil.disk_usage('/').total,\n                \"free\": psutil.disk_usage('/').free,\n                \"percent\": psutil.disk_usage('/').percent\n            }\n        }\n        return json.dumps(status, indent=2)\n\n    else:\n        raise ValueError(f\"Resource not found: {uri}\")\n\n@server.list_prompts()\nasync def list_prompts() -&gt; List[types.Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        types.Prompt(\n            name=\"code_review\",\n            description=\"Review code for best practices and improvements\",\n            arguments=[\n                types.PromptArgument(\n                    name=\"code\",\n                    description=\"The code to review\",\n                    required=True\n                ),\n                types.PromptArgument(\n                    name=\"language\",\n                    description=\"Programming language\",\n                    required=False\n                )\n            ]\n        ),\n        types.Prompt(\n            name=\"debug_help\",\n            description=\"Get help debugging an issue\",\n            arguments=[\n                types.PromptArgument(\n                    name=\"problem\",\n                    description=\"Description of the problem\",\n                    required=True\n                ),\n                types.PromptArgument(\n                    name=\"code\",\n                    description=\"Relevant code snippet\",\n                    required=False\n                )\n            ]\n        )\n    ]\n\n@server.get_prompt()\nasync def get_prompt(name: str, arguments: Dict[str, Any]) -&gt; types.GetPromptResult:\n    \"\"\"Get prompt content.\"\"\"\n    if name == \"code_review\":\n        code = arguments.get(\"code\", \"\")\n        language = arguments.get(\"language\", \"\")\n\n        return types.GetPromptResult(\n            description=\"Code Review Assistant\",\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(\n                        type=\"text\",\n                        text=f\"\"\"Please review the following {language or 'code'} for best practices, potential bugs, and improvements:\n\n{code}\n\nPlease provide:\n1. Code quality assessment\n2. Potential issues or bugs\n3. Suggestions for improvement\n4. Best practices recommendations\"\"\"\n                    )\n                )\n            ]\n        )\n\n    elif name == \"debug_help\":\n        problem = arguments.get(\"problem\", \"\")\n        code = arguments.get(\"code\", \"\")\n\n        content = f\"I'm experiencing this problem: {problem}\\n\\n\"\n        if code:\n            content += f\"Here's the relevant code:\\n{code}\\n\\n\"\n\n        content += \"\"\"Please help me:\n1. Understand what might be causing this issue\n2. Suggest debugging steps\n3. Provide potential solutions\n4. Recommend best practices to avoid similar issues\"\"\"\n\n        return types.GetPromptResult(\n            description=\"Debugging Assistant\",\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(type=\"text\", text=content)\n                )\n            ]\n        )\n\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\nasync def main():\n    \"\"\"Main server function.\"\"\"\n    async with stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            server.create_initialization_options()\n        )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"resources/#requirementstxt-for-python-mcp-server","title":"requirements.txt for Python MCP Server","text":"<pre><code>mcp&gt;=0.1.0\nhttpx&gt;=0.25.0\npsutil&gt;=5.9.0\n</code></pre>"},{"location":"resources/#pyprojecttoml-alternative-to-requirementstxt","title":"pyproject.toml (Alternative to requirements.txt)","text":"<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"example-mcp-server-py\"\nversion = \"1.0.0\"\ndescription = \"Example MCP server in Python\"\ndependencies = [\n    \"mcp&gt;=0.1.0\",\n    \"httpx&gt;=0.25.0\",\n    \"psutil&gt;=5.9.0\"\n]\n\n[project.scripts]\nmcp-server = \"main:main\"\n\n[tool.setuptools]\npackages = [\".\"]\n</code></pre>"},{"location":"resources/#running-the-examples","title":"Running the Examples","text":""},{"location":"resources/#typescript-server","title":"TypeScript Server","text":"<pre><code># Install dependencies\nnpm install\n\n# Build the server\nnpm run build\n\n# Run the server\nnpm start\n</code></pre>"},{"location":"resources/#python-server","title":"Python Server","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Run the server\npython server.py\n</code></pre>"},{"location":"resources/#configuration-for-roo-code","title":"Configuration for Roo Code","text":"<p>To use these servers with Roo Code, add them to your MCP configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"typescript-server\": {\n      \"command\": \"node\",\n      \"args\": [\"/path/to/typescript-server/dist/index.js\"]\n    },\n    \"python-server\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/python-server/server.py\"]\n    }\n  }\n}\n</code></pre>"},{"location":"resources/#key-differences-typescript-vs-python","title":"Key Differences: TypeScript vs Python","text":""},{"location":"resources/#typescript-advantages","title":"TypeScript Advantages:","text":"<ul> <li>Strong typing and compile-time error checking</li> <li>Rich ecosystem and tooling</li> <li>Better IDE support</li> <li>More mature MCP SDK</li> </ul>"},{"location":"resources/#python-advantages","title":"Python Advantages:","text":"<ul> <li>Simpler syntax and faster development</li> <li>Great for data processing and AI/ML integration</li> <li>Extensive scientific computing libraries</li> <li>Easier deployment in some environments</li> </ul> <p>Both implementations provide the same MCP functionality and can be used interchangeably based on your project requirements and preferences.</p>"},{"location":"welcome/","title":"Welcome to the MCP Labs","text":"<p>Here you\u2019ll Learn and Build Model Context Protocol (MCP) from Scratch</p> <p></p>"},{"location":"welcome/#introduction","title":"Introduction","text":"<p>Welcome to the MCP Labs - a comprehensive, hands-on guide to mastering the Model Context Protocol! </p> <p>Whether you\u2019re new to MCP or looking to deepen your understanding, this learning series will take you from fundamentals to building production-ready MCP servers.</p>"},{"location":"welcome/#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is an open protocol that standardizes how applications provide context to Large Language Models (LLMs). </p> <p>Think of it as a universal adapter that allows AI applications to connect to various data sources, tools, and services in a consistent and scalable way.</p>"},{"location":"welcome/#what-youll-learn","title":"What You\u2019ll Learn","text":"<p>Through hands-on labs, you\u2019ll:</p> <ul> <li>Understand MCP Architecture - Master the client-server model and protocol fundamentals</li> <li>Build MCP Servers - Create servers from scratch using TypeScript and the official SDK</li> <li>Implement Tools - Develop functions that LLMs can call to perform actions</li> <li>Expose Resources - Provide contextual data that LLMs can read and reference</li> <li>Create Prompts - Build reusable templates for common tasks</li> <li>Deploy to Production - Apply best practices for real-world applications</li> </ul>"},{"location":"welcome/#learning-path","title":"Learning Path","text":"<p>This course consists of 5 progressive labs, each building on the previous one:</p>"},{"location":"welcome/#lab-1-mcp-fundamentals","title":"Lab 1: MCP Fundamentals","text":"<p>Duration: 30-45 minutes</p> <p>Understand what MCP is, why it exists, and learn the core architecture and concepts.</p> <p></p>"},{"location":"welcome/#lab-2-building-your-first-mcp-server","title":"Lab 2: Building Your First MCP Server","text":"<p>Duration: 1-1.5 hours</p> <p>Build a complete, working MCP server from the ground up with hands-on coding.</p> <p></p>"},{"location":"welcome/#lab-3-implementing-mcp-tools","title":"Lab 3: Implementing MCP Tools","text":"<p>Duration: 1.5-2 hours</p> <p>Master creating sophisticated tools that interact with external systems like APIs, files, and databases.</p> <p></p>"},{"location":"welcome/#lab-4-implementing-mcp-resources","title":"Lab 4: Implementing MCP Resources","text":"<p>Duration: 1-1.5 hours</p> <p>Learn to expose contextual data through resources and understand the difference between tools and resources.</p> <p></p>"},{"location":"welcome/#lab-5-mcp-prompts-and-complete-integration","title":"Lab 5: MCP Prompts and Complete Integration","text":"<p>Duration: 1.5-2 hours</p> <p>Complete your MCP education with prompts, production best practices, and deployment strategies.</p> <p></p>"},{"location":"welcome/#lab-6-k-agent-integration","title":"Lab 6: K-Agent Integration","text":"<p>Duration: 2-3 hours</p> <p>Implement a specialized MCP server (K-Agent) that interacts with Kubernetes clusters to provide AI-driven log collection and analysis.</p>"},{"location":"welcome/#tasks","title":"Tasks","text":"<p>Duration: Varies</p> <p>A dedicated section with exercises and challenges to reinforce your learning from all labs.</p>"},{"location":"welcome/#who-is-this-for","title":"Who Is This For?","text":"<p>This learning series is designed for:</p> <ul> <li>Developers building AI-powered applications</li> <li>Engineers integrating LLMs with existing systems</li> <li>Technical Architects designing AI infrastructure</li> <li>DevOps Professionals deploying and maintaining MCP servers</li> <li>AI Enthusiasts wanting to understand standardized AI application development</li> <li>Anyone curious about standardized AI application development</li> </ul>"},{"location":"welcome/#prerequisites","title":"Prerequisites","text":"<p>To get the most out of these labs, you should have:</p> <ul> <li>Basic Programming Knowledge - Familiarity with JavaScript/TypeScript</li> <li>Node.js Experience - Understanding of npm and basic Node.js concepts</li> <li>Command Line Skills - Comfortable with terminal/shell commands</li> <li>Code Editor - VS Code or similar IDEs (VS Code recommended)</li> </ul>"},{"location":"welcome/#required-software","title":"Required Software","text":"<p>Before starting, ensure you have installed:</p> <ul> <li>Node.js v18 or later (download)</li> <li>npm or yarn package manager</li> <li>Git for version control</li> <li>A code editor (VS Code with TypeScript is support recommended)</li> </ul>"},{"location":"welcome/#tools-youll-use","title":"Tools You\u2019ll Use","text":"<p>Throughout the labs, you\u2019ll work with:</p> <ul> <li>@modelcontextprotocol/sdk - Official TypeScript SDK</li> <li>MCP Inspector - Essential testing tool</li> <li>TypeScript - Type-safe server development</li> <li>JSON-RPC 2.0 - Communication protocol</li> </ul>"},{"location":"welcome/#learning-approach","title":"Learning Approach","text":"<p>Each lab includes:</p> <ul> <li>Clear Objectives - Know what you\u2019ll learn before you start</li> <li>Detailed Explanations - Understand the \u201cwhy\u201d behind the code</li> <li>Complete Code Examples - Working, tested code you can run</li> <li>Hands-on Exercises - Practice what you\u2019ve learned</li> <li>Key Takeaways - Reinforce important concepts</li> <li>Additional Resources - Dive deeper on specific topics</li> </ul> <p>In addition, you\u2019ll find a complete Tasks section dedicated just to exercises and challenges to solidify your understanding.</p>"},{"location":"welcome/#getting-started","title":"Getting Started","text":"<p>Ready to begin your MCP journey? </p> <p>Here\u2019s how to start:</p> <ol> <li>Browse the Labs - See an overview of all available labs</li> <li>Start with Lab 1 - Begin with the fundamentals</li> <li>Complete the various labs in Order - Each lab builds on previous knowledge</li> <li>Practice &amp; Experiment - Try variations and explore beyond examples in the Tasks section</li> </ol>"},{"location":"welcome/#community-support","title":"Community &amp; Support","text":"<p>Join the growing MCP community:</p> <ul> <li>MCP Discord - Ask questions, share projects</li> <li>GitHub Organization - Contribute to the ecosystem</li> <li>Official Documentation - Comprehensive reference</li> <li>MCP Specification - Protocol details</li> </ul>"},{"location":"welcome/#why-learn-mcp","title":"Why Learn MCP?","text":"<p>MCP is revolutionizing how we build AI applications:</p> <ul> <li>Universal Connectivity - One integration works across all MCP-compatible apps</li> <li>Reusability - Build once, use everywhere</li> <li>Scalability - Add new capabilities without rebuilding integrations</li> <li>Standardization - Consistent patterns and best practices</li> <li>Growing Ecosystem - Join a vibrant, expanding community</li> </ul>"},{"location":"welcome/#after-this-course","title":"After This Course","text":"<p>Upon completion, you\u2019ll be able to:</p> <ul> <li>Build custom MCP servers for your specific needs</li> <li>Integrate LLMs with your company\u2019s tools and data sources</li> <li>Contribute to the MCP open source ecosystem</li> <li>Create servers that others can use</li> <li>Help others learn and adopt MCP</li> </ul>"},{"location":"welcome/#next-steps","title":"Next StepsReady to Build the Future of AI Applications?","text":"<p>View All Labs \u2192 - See the complete learning path</p> <p>Start Lab 1 \u2192 - Begin your MCP journey!</p> <p>Let's get started!</p>"},{"location":"01-MCP-Workflow/","title":"Complete MCP Server - Hands-On Lab","text":""},{"location":"01-MCP-Workflow/#mcp-server-structure-lab","title":"MCP Server Structure Lab","text":""},{"location":"01-MCP-Workflow/#lab-objective","title":"Lab Objective","text":"<ul> <li>In this hands-on lab, you\u2019ll build a complete MCP (Model Context Protocol) server from scratch. </li> <li>You\u2019ll learn how each component works by implementing it yourself, understanding why each piece is necessary, and seeing the complete architecture come together.</li> </ul>"},{"location":"01-MCP-Workflow/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher installed</li> <li>Basic understanding of Python programming</li> <li>Terminal/command line access</li> <li>Text editor or IDE</li> </ul>"},{"location":"01-MCP-Workflow/#getting-started","title":"Getting Started","text":""},{"location":"01-MCP-Workflow/#step-1-create-your-project-file","title":"Step 1: Create Your Project File","text":"<ol> <li>Create a new file called <code>my_mcp_server.py</code></li> <li>Open it in your favorite text editor</li> <li>We\u2019ll build this server step by step!</li> </ol>"},{"location":"01-MCP-Workflow/#step-01-adding-imports","title":"Step 01: Adding Imports","text":"<ul> <li>Before we write any code, we need to understand what libraries we\u2019re using and why.</li> </ul>"},{"location":"01-MCP-Workflow/#asyncio-asynchronous-io","title":"<code>asyncio</code> - Asynchronous I/O","text":"<p>asyncio</p>"},{"location":"01-MCP-Workflow/#definition","title":"Definition:","text":"<ul> <li><code>asyncio</code> is a Python library for writing concurrent code using the async/await syntax.</li> </ul>"},{"location":"01-MCP-Workflow/#why","title":"Why:","text":"<ul> <li>Enables asynchronous programming in Python</li> <li>MCP servers handle multiple concurrent operations (I/O, requests) without blocking</li> </ul>"},{"location":"01-MCP-Workflow/#usage","title":"Usage:","text":"<ul> <li><code>async</code>/<code>await</code> keywords, event loops, concurrent task execution</li> </ul>"},{"location":"01-MCP-Workflow/#json-javascript-object-notation","title":"<code>json</code> - JavaScript Object Notation","text":"<p>json</p>"},{"location":"01-MCP-Workflow/#definition_1","title":"Definition:","text":"<ul> <li>JSON encoding/decoding for data serialization</li> </ul>"},{"location":"01-MCP-Workflow/#why_1","title":"Why:","text":"<ul> <li>MCP uses JSON-RPC protocol; resources return JSON data</li> </ul>"},{"location":"01-MCP-Workflow/#usage_1","title":"Usage:","text":"<ul> <li><code>json.dumps()</code> to serialize Python dicts, <code>json.loads()</code> to parse</li> </ul>"},{"location":"01-MCP-Workflow/#typing-type-hints","title":"<code>typing</code> - Type Hints","text":"<p>typing</p>"},{"location":"01-MCP-Workflow/#definition_2","title":"Definition:","text":"<ul> <li>Type hints for better code documentation and IDE support</li> </ul>"},{"location":"01-MCP-Workflow/#why_2","title":"Why:","text":"<ul> <li>Makes code more maintainable and catches type errors early</li> </ul>"},{"location":"01-MCP-Workflow/#usage_2","title":"Usage:","text":"<ul> <li>Function parameters, return types (Any = any type, Optional = can be None)</li> </ul>"},{"location":"01-MCP-Workflow/#mcpserver-core-mcp-server","title":"<code>mcp.server</code> - Core MCP Server","text":"<p>mcp.server</p>"},{"location":"01-MCP-Workflow/#definition_3","title":"Definition:","text":"<ul> <li>Core MCP Server class - the foundation of our server</li> </ul>"},{"location":"01-MCP-Workflow/#why_3","title":"Why:","text":"<ul> <li>Provides all MCP protocol implementation and lifecycle management</li> </ul>"},{"location":"01-MCP-Workflow/#usage_3","title":"Usage:","text":"<ul> <li>Create server instance, register handlers, manage connections</li> </ul>"},{"location":"01-MCP-Workflow/#mcpserverstdio-standard-io-transport","title":"<code>mcp.server.stdio</code> - Standard I/O Transport","text":"<p>mcp.server.stdio</p>"},{"location":"01-MCP-Workflow/#definition_4","title":"Definition:","text":"<ul> <li>Standard Input/Output transport layer for MCP</li> </ul>"},{"location":"01-MCP-Workflow/#why_4","title":"Why:","text":"<ul> <li>MCP servers communicate via stdio (standard in/out streams)</li> </ul>"},{"location":"01-MCP-Workflow/#usage_4","title":"Usage:","text":"<ul> <li>Connects server to clients through stdin/stdout pipes</li> </ul>"},{"location":"01-MCP-Workflow/#mcptypes-protocol-types","title":"<code>mcp.types</code> - Protocol Types","text":"<p>mcp.types</p>"},{"location":"01-MCP-Workflow/#definition_5","title":"Definition:","text":"<ul> <li>MCP protocol type definitions for structured data</li> </ul>"},{"location":"01-MCP-Workflow/#why_5","title":"Why:","text":"<ul> <li>Type-safe definitions for all MCP primitives (tools, resources, prompts)</li> </ul>"},{"location":"01-MCP-Workflow/#usage_5","title":"Usage:","text":"<ul> <li>Tool = executable functions, Resource = readable data, Prompt = templates, TextContent = text responses</li> </ul>"},{"location":"01-MCP-Workflow/#sys-system-functions","title":"<code>sys</code> - System Functions","text":"<p>sys</p>"},{"location":"01-MCP-Workflow/#definition_6","title":"Definition:","text":"<ul> <li>System-specific parameters and functions</li> </ul>"},{"location":"01-MCP-Workflow/#why_6","title":"Why:","text":"<ul> <li>Handle system exits, command-line arguments, and stdio streams</li> </ul>"},{"location":"01-MCP-Workflow/#usage_6","title":"Usage:","text":"<ul> <li><code>sys.exit()</code> for graceful shutdown, <code>sys.stdin</code>/<code>stdout</code> for I/O</li> </ul>"},{"location":"01-MCP-Workflow/#step-02-skeleton-code","title":"Step 02: Skeleton Code","text":""},{"location":"01-MCP-Workflow/#skeleton-01-imports","title":"Skeleton 01: <code>Imports</code>","text":"<ul> <li> <p>Set thfollowing  imports inside the <code>my_mcp_server.py</code>:</p> <p>```python</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n</code></pre> </li> <li> <p>Defines the behavior of each prompt</p> </li> <li> <p>Handlers make prompts functional</p> <pre><code>from mcp.server import Server\n</code></pre> <p>from mcp.server.stdio import stdio_server   from mcp.types import (       Tool,       Resource,       Prompt,       TextContent,       ImageContent,       EmbeddedResource,   )   import sys   ```</p> </li> <li> <p>Create the <code>requirements.txt</code> file with the following content:</p> <pre><code>mcp\n</code></pre> </li> <li> <p>Install the MCP library:</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> </ul>"},{"location":"01-MCP-Workflow/#skeleton-02-class","title":"Skeleton 02: <code>Class</code>","text":"<ul> <li> <p>Add thislass definition after the imports in your <code>my_mcp_server.py</code> file:</p> <p>```python   class CompleteMCPServer:       \u201c\u201d\u201d       A comprehensive MCP Server implementation showcasing all        - Enables clients to get ready-to-use prompts       - Connects prompt templates to actual content       protocol features.</p> <pre><code>This class demonstrates:\n\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Defines the behavior of each prompt\n  - Handlers make prompts functional\n\n  - Request handling\n\"\"\"\n</code></pre> <p>``` </p> </li> </ul>"},{"location":"01-MCP-Workflow/#skeleton-03-constructor","title":"Skeleton 03: <code>Constructor</code>","text":""},{"location":"01-MCP-Workflow/#method__init__-constructor","title":"Method<code>__init__</code> (Constructor)","text":"<p>Capabilities:</p> <pre><code>- Initializes the MCP Server instance\n- Creates the server object with name and version\n- Sets up the foundation for all MCP operations\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Prepares data structures for tools, resources, and prompts</li> </ul> <p>Why This Runs First:</p> <pre><code>- Constructor must run before any other methods\n- Creates the server object that all other methods will use\n- Defines the behavior of each prompt\n- Handlers make prompts functional\n</code></pre> <ul> <li>No other operations can occur without this initialization</li> <li>Sets up the basic state of the server</li> </ul> <ul> <li>Add this class definition after inside your <code>CompleteMCPServer</code> class:</li> </ul> <pre><code>def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n</code></pre>"},{"location":"01-MCP-Workflow/#code-break-down","title":"Code break down:","text":"<ul> <li><code>Server(\"complete-mcp-server\")</code> creates the MCP server with a name</li> <li><code>self.data_store = {}</code> creates an empty dictionary for storing data</li> <li>This object will be used throughout all other methods</li> </ul>"},{"location":"01-MCP-Workflow/#skeleton-04-register-tools","title":"Skeleton 04: Register Tools","text":""},{"location":"01-MCP-Workflow/#methodregister_tools","title":"Method<code>register_tools</code>","text":"<p>Capabilities:</p> <pre><code>- Registers all available tools with the MCP server\n- Defines tool schemas (name, description, parameters)\n- Makes tools discoverable to clients\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Sets up the tool execution infrastructure</li> </ul> <p>Why This Runs Second:</p> <pre><code>- After server initialization, we need to define what tools are available\n- Defines the behavior of each prompt\n- Handlers make prompts functional\n</code></pre> <ul> <li>Tools must be registered before they can be called</li> <li>Defines the capabilities clients can invoke</li> </ul> <p>What is a Tool?</p> <ul> <li>A tool is an executable function that clients can invoke. </li> <li>Think of it like an API endpoint that performs an action.</li> <li>Tools have names, descriptions, and input parameters.</li> <li>Clients can discover and call these tools to perform operations.</li> <li>Examples: calculator, data storage, text processing</li> <li>Tools are central to MCP\u2019s functionality.</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n        \"\"\"\n        Return the list of available tools.\n        This is called when clients want to discover what tools are available.\n        \"\"\"\n        return [\n            Tool(\n                name=\"calculate\",\n                description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"operation\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                            \"description\": \"The operation to perform\"\n                        },\n                        \"a\": {\n                            \"type\": \"number\",\n                            \"description\": \"First number\"\n                        },\n                        \"b\": {\n                            \"type\": \"number\",\n                            \"description\": \"Second number\"\n                        }\n                    },\n                    \"required\": [\"operation\", \"a\", \"b\"]\n                }\n            ),\n            Tool(\n                name=\"store_data\",\n                description=\"Store a key-value pair in the server's data store\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"key\": {\n                            \"type\": \"string\",\n                            \"description\": \"The key to store\"\n                        },\n                        \"value\": {\n                            \"type\": \"string\",\n                            \"description\": \"The value to store\"\n                        }\n                    },\n                    \"required\": [\"key\", \"value\"]\n                }\n            ),\n            Tool(\n                name=\"retrieve_data\",\n                description=\"Retrieve a value from the server's data store\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"key\": {\n                            \"type\": \"string\",\n                            \"description\": \"The key to retrieve\"\n                        }\n                    },\n                    \"required\": [\"key\"]\n                }\n            ),\n            Tool(\n                name=\"echo\",\n                description=\"Echo back the input text\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Text to echo back\"\n                        }\n                    },\n                    \"required\": [\"text\"]\n                }\n            )\n        ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.list_tools()</code> decorator registers a handler for tool listing</li> <li>Each <code>Tool</code> object defines the tool\u2019s name, description, and input schema</li> <li>The <code>inputSchema</code> uses JSON Schema format to validate inputs</li> <li>When a client calls <code>list_tools()</code>, they get this list</li> <li>This makes the tools discoverable and usable by clients</li> </ul>"},{"location":"01-MCP-Workflow/#hands-on-exercise","title":"Hands-On Exercise:","text":"<ul> <li>Add a new tool called <code>greeting</code> that takes a string input <code>name</code> and returns a greeting message.</li> <li>Define its name, description, and input schema similar to the other tools.</li> <li>Test it later when we implement tool handlers.</li> <li>Hint: Use the existing tools as a reference for structure.</li> <li>After adding, your <code>list_tools</code> method should include the new <code>greeting</code> tool.</li> <li>This exercise helps you understand how to define and register new tools in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> \ud83d\udca1 Solution for Greeting Tool <pre><code>Tool(\n    name=\"greeting\",\n    description=\"Return a greeting message for the given name\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\n                \"type\": \"string\",\n                \"description\": \"The name to greet\"\n            }\n        },\n        \"required\": [\"name\"]\n    }\n)\n</code></pre>"},{"location":"01-MCP-Workflow/#skeleton-05-tools-handlers","title":"Skeleton 05: Tool(s) Handlers","text":""},{"location":"01-MCP-Workflow/#methodregister_tool_handlers","title":"Method<code>register_tool_handlers</code>","text":"<p>Capabilities:</p> <pre><code>- Implements the actual logic for each tool\n- Handles tool execution requests from clients\n- Processes input parameters and returns results\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Provides error handling for tool execution</li> <li>Enables dynamic tool functionality</li> </ul> <p>Why This Runs Third:</p> <pre><code>- After tools are registered, we need to define what happens when \n- Defines the behavior of each prompt\n- Handlers make prompts functional\neach tool is called\n</code></pre> <ul> <li>Without handlers, tools are just definitions with no action</li> <li>Tools need implementation before they can be executed</li> <li>Connects tool schemas to actual functionality</li> <li>Defines the behavior of each tool</li> <li>Handlers make tools operational</li> <li>Clients rely on these handlers to perform tasks</li> <li>This is where the server\u2019s capabilities come to life</li> <li>Handlers are essential for a functional MCP server</li> <li>They bridge the gap between tool definition and execution</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n        \"\"\"\n        Handle tool execution requests.\n        This is called when a client wants to execute a tool.\n        \"\"\"\n        if name == \"calculate\":\n            operation = arguments.get(\"operation\")\n            a = arguments.get(\"a\")\n            b = arguments.get(\"b\")\n\n            if operation == \"add\":\n                result = a + b\n            elif operation == \"subtract\":\n                result = a - b\n            elif operation == \"multiply\":\n                result = a * b\n            elif operation == \"divide\":\n                if b == 0:\n                    return [TextContent(\n                        type=\"text\",\n                        text=\"Error: Cannot divide by zero\"\n                    )]\n                result = a / b\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown operation '{operation}'\"\n                )]\n\n            return [TextContent(\n                type=\"text\",\n                text=f\"Result: {a} {operation} {b} = {result}\"\n            )]\n\n        elif name == \"store_data\":\n            key = arguments.get(\"key\")\n            value = arguments.get(\"value\")\n            self.data_store[key] = value\n            return [TextContent(\n                type=\"text\",\n                text=f\"Stored: {key} = {value}\"\n            )]\n\n        elif name == \"retrieve_data\":\n            key = arguments.get(\"key\")\n            value = self.data_store.get(key)\n            if value is None:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Key '{key}' not found\"\n                )]\n            return [TextContent(\n                type=\"text\",\n                text=f\"Retrieved: {key} = {value}\"\n            )]\n\n        elif name == \"echo\":\n            text = arguments.get(\"text\")\n            return [TextContent(\n                type=\"text\",\n                text=f\"Echo: {text}\"\n            )]\n\n        else:\n            return [TextContent(\n                type=\"text\",\n                text=f\"Error: Unknown tool '{name}'\"\n            )]\n\n    print(\"Tool handlers implemented\")\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.call_tool()</code> decorator registers the execution handler</li> <li>Each tool\u2019s logic is in an <code>if/elif</code> block</li> <li>Results are wrapped in <code>TextContent</code> objects</li> <li>Error handling is included for edge cases (like division by zero)</li> <li>When a client calls a tool, this handler processes the request and returns the output</li> <li>This makes the tools functional and usable by clients</li> </ul>"},{"location":"01-MCP-Workflow/#hands-on-exercise_1","title":"Hands-On Exercise:","text":"<ul> <li>Implement the handler logic for the <code>greeting</code> tool you added earlier.</li> <li>The tool should take the <code>name</code> parameter and return a greeting message like \u201cHello, {name}!\u201d.</li> <li>Test it later when we run the server.</li> <li>Hint: Follow the structure of the other tool handlers.</li> <li>After adding, your <code>call_tool</code> method should include the new <code>greeting</code> tool logic.</li> <li>This exercise helps you understand how to implement tool functionality in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Greeting Tool Handler <pre><code>elif name == \"greeting\":\n    name = arguments.get(\"name\")\n    return [TextContent(\n        type=\"text\",\n        text=f\"Hello, {name}!\"\n    )]\n</code></pre>"},{"location":"01-MCP-Workflow/#skeleton-06-register-resources","title":"Skeleton 06: Register Resources","text":""},{"location":"01-MCP-Workflow/#methodregister_resources","title":"Method<code>register_resources</code>","text":"<p>Capabilities:</p> <pre><code>- Registers resources that clients can access\n- Defines resource URIs and metadata\n- Makes static and dynamic content available\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Enables resource discovery and retrieval</li> <li> <p>Provides additional data for clients</p> <ul> <li>Supports richer interactions with the server</li> <li>Expands server capabilities beyond tools</li> <li>Facilitates data sharing and information access</li> </ul> </li> <li> <p>Defines the behavior of each prompt</p> </li> <li>Handlers make prompts functional</li> </ul> <p>Why This Runs Fourth:</p> <ul> <li>After tools are set up, we add resources which provide additional data</li> <li>Resources are complementary to tools</li> <li>Provides data that tools might reference</li> </ul> <p>What is a Resource?</p> <ul> <li>A resource is readable data or content. </li> <li>Think of it like a file or endpoint you can read from (but not execute).</li> <li>Resources have URIs (like URLs) and metadata (name, description, MIME type).</li> <li>Clients can discover and read these resources.</li> <li>Examples: server info, data store contents, welcome message</li> <li>Resources enhance the server\u2019s functionality by providing static or dynamic data.</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n        \"\"\"\n        Return the list of available resources.\n        This is called when clients want to discover what resources are available.\n        \"\"\"\n        return [\n            Resource(\n                uri=\"resource://server-info\",\n                name=\"Server Information\",\n                description=\"Information about this MCP server\",\n                mimeType=\"application/json\"\n            ),\n            Resource(\n                uri=\"resource://data-store\",\n                name=\"Data Store\",\n                description=\"Current contents of the data store\",\n                mimeType=\"application/json\"\n            ),\n            Resource(\n                uri=\"resource://welcome\",\n                name=\"Welcome Message\",\n                description=\"Welcome message and server capabilities\",\n                mimeType=\"text/plain\"\n            )\n        ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.list_resources()</code> decorator registers the resource listing handler</li> <li>Each <code>Resource</code> defines a URI (like a URL), name, description, and MIME type</li> <li>URIs use the <code>resource://</code> scheme to identify resources</li> <li>When a client calls <code>list_resources()</code>, they get this list</li> <li>This makes the resources discoverable and accessible by clients</li> <li>Resources provide additional data that clients can read </li> <li>Enhances the server\u2019s capabilities beyond just tools</li> </ul>"},{"location":"01-MCP-Workflow/#hands-on-exercise_2","title":"Hands-On Exercise:","text":"<ul> <li>Add a new resource called <code>server-author</code> that return your name as the author of the server.</li> <li>Define its URI, name, description, and MIME type similar to the other resources.</li> <li>Test it later when we implement resource handlers.</li> <li>Hint: Use the existing resources as a reference for structure.</li> <li>After adding, your <code>list_resources</code> method should include the new <code>server-author</code> resource.</li> <li>This exercise helps you understand how to define and register new resources in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Server Stats Resource <pre><code>Resource(\n    uri=\"resource://server-author\",\n    name=\"Server Author\",\n    description=\"Author of the MCP server\",\n    mimeType=\"text/plain\"\n)\n</code></pre>"},{"location":"01-MCP-Workflow/#skeleton-07-resource-handlers","title":"Skeleton 07: Resource Handlers","text":""},{"location":"01-MCP-Workflow/#methodregister_resource_handlers","title":"Method<code>register_resource_handlers</code>","text":"<p>Capabilities:</p> <pre><code>- Implements resource retrieval logic\n- Returns actual content for each resource\n- Handles dynamic resource generation\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Provides resource access control</li> <li> <p>Enables clients to read server data</p> <ul> <li>Supports various content types (JSON, text)</li> <li>Facilitates data sharing with clients</li> <li>Connects resource definitions to actual data</li> <li>Enhances server usability and information access</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> </ul> </li> </ul> <p>Why This Runs Fifth:</p> <ul> <li>After resources are registered, we need to implement what content is returned</li> <li>Resources need implementation to return actual data</li> <li>Connects resource URIs to actual content</li> <li>Defines the behavior of each resource</li> <li>Handlers make resources accessible</li> <li>Clients rely on these handlers to read data</li> <li>This is where resource definitions become functional</li> <li>Handlers are essential for a usable MCP server</li> <li>They bridge the gap between resource definition and content delivery</li> <li>Without handlers, resources are just placeholders with no data</li> <li>Handlers bring resources to life</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n    async def read_resource(uri: str) -&gt; str:\n        \"\"\"\n        Handle resource read requests.\n        This is called when a client wants to read a resource.\n        \"\"\"\n        if uri == \"resource://server-info\":\n            info = {\n                \"name\": \"complete-mcp-server\",\n                \"version\": \"1.0.0\",\n                \"description\": \"A comprehensive MCP server implementation\",\n                \"capabilities\": {\n                    \"tools\": 4,\n                    \"resources\": 3,\n                    \"prompts\": 2\n                }\n            }\n            return json.dumps(info, indent=2)\n\n        elif uri == \"resource://data-store\":\n            return json.dumps(self.data_store, indent=2)\n\n        elif uri == \"resource://welcome\":\n            return \"\"\"Welcome to the Complete MCP Server!\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.read_resource()</code> decorator registers the read handler</li> <li>Each resource URI returns appropriate content</li> <li>JSON resources use <code>json.dumps()</code> to serialize data</li> <li>Plain text resources return strings directly</li> <li>When a client reads a resource, this handler processes the request and returns the content</li> <li>This makes the resources functional and usable by clients</li> </ul>"},{"location":"01-MCP-Workflow/#hands-on-exercise_3","title":"Hands-On Exercise:","text":"<ul> <li>Implement the handler logic for the <code>server-author</code> resource you added earlier.</li> <li>The resource should return your name as plain text.</li> <li>Test it later when we run the server.</li> <li>Hint: Follow the structure of the other resource handlers.</li> <li>After adding, your <code>read_resource</code> method should include the new <code>server-author</code> resource logic.</li> <li>This exercise helps you understand how to implement resource functionality in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Server Author Resource Handler <pre><code>elif uri == \"resource://server-author\":\n    return \"Author: Your Name Here\"\n</code></pre>"},{"location":"01-MCP-Workflow/#handle-errors","title":"Handle Errors","text":"<ul> <li>Add Error Handling for Unknown Resources</li> <li> <p>Add this at the end of the <code>read_resource</code> method to handle unknown resources:</p> <pre><code>        else:\n            raise ValueError(f\"Unknown resource: {uri}\")\n</code></pre> </li> </ul>"},{"location":"01-MCP-Workflow/#skeleton-08-register-prompts","title":"Skeleton 08: Register Prompts","text":""},{"location":"01-MCP-Workflow/#method-register_prompts","title":"Method <code>register_prompts</code>","text":"<p>Capabilities:</p> <ul> <li>Registers prompt templates for clients</li> <li>Defines structured prompts with parameters</li> <li>Enables prompt discovery</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> <li>Provides reusable prompt patterns</li> <li>Facilitates advanced AI interactions</li> <li>Supports dynamic prompt generation</li> </ul> <p>Why This Runs Sixth:</p> <ul> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> <li>After tools and resources, prompts add higher-level interaction patterns</li> <li>Prompts build on available tools and resources</li> <li>Provides templates for AI assistants</li> </ul> <p>What is a Prompt?</p> <ul> <li>A prompt is a template that guides AI assistants on how to use the server\u2019s tools and resources effectively.</li> <li>Prompts have names, descriptions, and parameters.</li> <li>Clients can discover and request prompts.</li> <li>Examples: code review prompt, data analysis prompt</li> <li>Prompts enhance the server\u2019s capabilities by providing structured interaction patterns.</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>def register_prompts(self):\n    \"\"\"Register prompt templates for clients.\"\"\"\n\n    @self.server.list_prompts()\n    async def list_prompts() -&gt; list[Prompt]:\n        \"\"\"\n        Return the list of available prompts.\n        This is called when clients want to discover what prompts are available.\n        \"\"\"\n        return [\n            Prompt(\n                name=\"analyze-data\",\n                description=\"Analyze data stored in the server\",\n                arguments=[\n                    {\n                        \"name\": \"key\",\n                        \"description\": \"The key of the data to analyze\",\n                        \"required\": True\n                    }\n                ]\n            ),\n            Prompt(\n                name=\"calculate-scenario\",\n                description=\"Walk through a calculation scenario\",\n                arguments=[\n                    {\n                        \"name\": \"operation\",\n                        \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n                        \"required\": True\n                    }\n                ]\n            )\n        ]\n\n    print(\"Prompts registered: analyze-data, calculate-scenario\")\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.list_prompts()</code> decorator registers the prompt listing handler</li> <li>Each <code>Prompt</code> defines a name, description, and arguments</li> <li>Arguments specify what parameters the prompt template needs</li> <li>When a client calls <code>list_prompts()</code>, they get this list</li> <li>This makes the prompts discoverable and usable by clients</li> <li>Prompts provide structured templates for AI interactions</li> </ul>"},{"location":"01-MCP-Workflow/#hands-on-exercise_4","title":"Hands-On Exercise:","text":"<ul> <li>Add a new prompt called <code>greet-user</code> that prompts the AI to greet a user by name.</li> <li>Define its name, description, and arguments similar to the other prompts.</li> <li>Test it later when we implement prompt handlers.</li> <li>Hint: Use the existing prompts as a reference for structure.</li> <li>After adding, your <code>list_prompts</code> method should include the new <code>greet-user</code> prompt.</li> <li>This exercise helps you understand how to define and register new prompts in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Greet User Prompt <pre><code>Prompt(\n    name=\"greet-user\",\n    description=\"Prompt the AI to greet a user by name\",\n    arguments=[\n        {\n            \"name\": \"name\",\n            \"description\": \"The name of the user to greet\",\n            \"required\": True\n        }\n    ]\n)\n</code></pre>"},{"location":"01-MCP-Workflow/#skeleton-09-prompt-handlers","title":"Skeleton 09: Prompt Handlers","text":""},{"location":"01-MCP-Workflow/#method-register_prompt_handlers","title":"Method: <code>register_prompt_handlers</code>","text":"<p>Capabilities:</p> <ul> <li>Implements prompt generation logic</li> <li>Returns formatted prompts with embedded context</li> <li>Handles prompt parameters and customization</li> <li>Provides dynamic prompt content</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> </ul> <p>Why This Runs Seventh:</p> <ul> <li>After prompts are registered, we implement the logic that generates prompt content</li> <li>Prompts need implementation to generate actual text</li> <li>Connects prompt templates to actual content</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>def register_prompt_handlers(self):\n    \"\"\"Implement prompt generation logic.\"\"\"\n\n    @self.server.get_prompt()\n    async def get_prompt(name: str, arguments: dict) -&gt; list[TextContent]:\n        \"\"\"\n        Handle prompt generation requests.\n        This is called when a client wants to get a prompt.\n        \"\"\"\n        if name == \"analyze-data\":\n            key = arguments.get(\"key\", \"unknown\")\n            value = self.data_store.get(key, \"not found\")\n\n            prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            elif name == \"calculate-scenario\":\n                operation = arguments.get(\"operation\", \"add\")\n\n                prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown prompt '{name}'\"\n                )]\n\n        print(\"Prompt handlers implemented\")\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.get_prompt()</code> decorator registers the prompt generation handler</li> <li>Each prompt returns formatted text based on the parameters</li> <li>Prompts can reference tools and resources</li> <li>Dynamic content is generated based on current server state</li> </ul>"},{"location":"01-MCP-Workflow/#hands-on","title":"Hands On:","text":"<ul> <li>Implement the handler logic for the <code>greet-user</code> prompt you added earlier.</li> <li>The prompt should return a greeting message using the provided <code>name</code> parameter.</li> <li>Test it later when we run the server.</li> <li>Hint: Follow the structure of the other prompt handlers.</li> <li>After adding, your <code>get_prompt</code> method should include the new <code>greet-user</code> prompt logic.</li> <li>This exercise helps you understand how to implement prompt functionality in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Greet User Prompt Handler <pre><code>elif name == \"greet-user\":\n    name = arguments.get(\"name\", \"Guest\")\n    prompt_text = f\"Hello, {name}! Welcome to the Complete MCP Server. How can I assist you today?\"\n    return [TextContent(type=\"text\", text=prompt_text)]\n</code></pre>"},{"location":"01-MCP-Workflow/#skeleton-10-lifecycle-handlers","title":"Skeleton 10: Lifecycle Handlers","text":""},{"location":"01-MCP-Workflow/#method-setup_lifecycle_handlers","title":"Method: <code>setup_lifecycle_handlers</code>","text":"<p>Capabilities:</p> <ul> <li>Handles server initialization events</li> <li>Manages server shutdown procedures</li> <li>Logs server lifecycle events</li> <li>Ensures clean startup and teardown</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> <li>Maintains server stability and reliability</li> </ul> <p>Why This Runs Eighth:</p> <ul> <li>After all features are configured, we set up lifecycle management</li> <li>Lifecycle handlers need complete server setup</li> <li>Prepares server for actual runtime operations</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> <li>Ensures proper resource management during startup/shutdown</li> <li>Critical for long-running server processes</li> <li>Helps prevent resource leaks and data corruption</li> </ul> <p>Why Servers Need Shutdown Procedures:</p> <ul> <li>Release system resources (memory, file handles, connections)</li> <li>Save any pending data or state to disk</li> <li>Close network connections gracefully</li> <li>Notify connected clients of server shutdown</li> <li>Clean up temporary files and caches</li> <li>Log final statistics and status</li> <li>Prevent data corruption from abrupt termination</li> <li>Allow pending operations to complete</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>def setup_lifecycle_handlers(self):\n    \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n    print(\"Lifecycle management configured\")\n</code></pre> </li> </ul> <p>Note</p> <ul> <li>Note: MCP servers typically don\u2019t have explicit lifecycle hooks</li> <li>This is a conceptual method showing where such logic would go</li> </ul> <p>Tip</p> <ul> <li>You can implement custom startup/shutdown logic here if needed</li> <li>Use this as a placeholder for lifecycle management        </li> <li>The actual \u201clifecycle\u201d of the server is managed implicitly by:</li> <li>Startup: When <code>asyncio.run(main())</code> is called and <code>server.run()</code> begins the event loop.</li> <li>Shutdown: When the process receives a signal (like <code>KeyboardInterrupt / Ctrl+C</code>), which is caught in the if <code>__name__ == \"__main__\":</code> block to exit gracefully.</li> </ul> <p>What\u2019s Happening:</p> <ul> <li>MCP servers use the standard Python lifecycle</li> <li>Cleanup happens when the server process exits</li> <li>You can use <code>try/except/finally</code> blocks in the main function for cleanup</li> <li>This method is a placeholder for lifecycle logic</li> <li>In real-world servers, you might add logging or resource management here</li> <li>This prepares the server for stable operation</li> <li>Enhances reliability during startup and shutdown</li> <li>Critical for production-grade servers</li> <li>Though MCP lacks explicit lifecycle hooks, this method indicates where such logic would be placed</li> <li>It serves as a reminder to consider lifecycle management in server design</li> <li>Helps maintain server health over long runtimes</li> <li>Prepares for future enhancements that may introduce lifecycle events</li> <li>Ensures the server is robust and reliable</li> <li>Maintains server integrity during its lifecycle</li> </ul>"},{"location":"01-MCP-Workflow/#skeleton-11-run-the-server","title":"Skeleton 11: Run the Server","text":""},{"location":"01-MCP-Workflow/#method-run","title":"Method: <code>run</code>","text":"<ul> <li>This is the final method to add to your class.</li> <li>It starts the MCP server and begins listening for client requests.</li> </ul> <p>Capabilities:</p> <ul> <li>Starts the MCP server</li> <li>Connects to stdio transport</li> <li>Begins listening for client requests</li> <li>Runs the main event loop</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> <li>Facilitates real-time client-server communication</li> </ul> <p>Why This Runs Last:</p> <ul> <li>All tools, resources, and prompts must be registered first</li> <li>This starts the actual server operation</li> <li>After this, the server is live and accepting requests</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> <li>This is the final step to make the server operational</li> <li>Without this, the server would not run</li> <li>This method initiates the event loop that processes requests</li> <li>Critical for real-time interactions with clients</li> </ul>"},{"location":"01-MCP-Workflow/#how-does-mcp-server-start","title":"How does MCP Server Start:","text":"<ol> <li> <p>Create stdio transport: <code>stdio_server()</code></p> <ul> <li>Opens stdin (standard input) for receiving messages</li> <li>Opens stdout (standard output) for sending responses</li> </ul> </li> <li> <p>Run server with streams: <code>server.run(read_stream, write_stream)</code></p> <ul> <li>Listens on stdin for JSON-RPC messages from client</li> <li>Sends JSON-RPC responses back on stdout</li> </ul> </li> <li> <p>Event loop processes requests asynchronously</p> <ul> <li>Handles multiple concurrent requests</li> <li>Executes tools, returns resources, generates prompts</li> </ul> </li> </ol>"},{"location":"01-MCP-Workflow/#what-is-stdio-standard-inputoutput","title":"What is STDIO (Standard Input/Output)?","text":"Component Description stdio Standard Input/Output streams stdin Channel for receiving data (keyboard, pipe) stdout Channel for sending data (screen, pipe) Usage MCP uses stdio for client-server communication Flow Client stdin \u2192 Server stdout \u2192 Client"},{"location":"01-MCP-Workflow/#alternatives-to-stdio","title":"Alternatives to STDIO:","text":"Component Description HTTP/HTTPS Web-based API (REST or GraphQL) WebSockets Bidirectional real-time communication gRPC High-performance RPC framework Unix Domain Sockets Local inter-process communication TCP/IP Sockets Network communication <p>Why STDIO for MCP?</p> <ul> <li>\u2713 Simple: No network configuration needed</li> <li>\u2713 Secure: Stays within local process boundary</li> <li>\u2713 Universal: Works on all operating systems</li> <li>\u2713 Easy to integrate: Pipe to any process</li> <li>\u2713 Lightweight: Minimal overhead for communication</li> <li>\u2713 Ideal for local AI assistant integrations</li> <li>\u2713 Fits well with command-line tools and scripts</li> <li>\u2713 Perfect for development and testing</li> <li>\u2713 Common in LSP (Language Server Protocol) implementations</li> <li>\u2713 Easy to debug: View raw messages in terminal</li> <li>\u2713 No firewall or network issues</li> <li>\u2713 Works well with containerized environments</li> </ul> <p>Async Event Loop Explained:</p> <ul> <li>Event Loop: Central coordinator for async operations</li> <li>Async/Await: Write concurrent code that looks sequential</li> <li>Non-blocking: Server handles multiple requests simultaneously</li> <li>Efficient: Uses single thread for many connections</li> <li>Scalable: Easily handles growing workloads</li> </ul> <p>How It Works:</p> <ol> <li>Event loop starts and waits for events (<code>messages</code>)</li> <li>When message arrives, creates a Task to handle it</li> <li>While waiting for I/O ( <code>tool execution</code>), processes other tasks</li> <li>When task completes, sends response back to client</li> <li>Continues looping until server shuts down</li> <li>This allows high concurrency with minimal threads</li> </ol> <p>Benefits:</p> <ul> <li>\u2713 Handle 1000s of connections with single thread</li> <li>\u2713 No waiting: Process other requests during I/O</li> <li>\u2713 Memory efficient: No thread per connection</li> <li>\u2713 Scalable: Add more tasks without more threads</li> <li>\u2713 Responsive: Quick handling of many clients</li> <li>\u2713 Ideal for I/O-bound workloads (like MCP servers)</li> <li>\u2713 Simplifies concurrency model</li> <li>\u2713 Reduces complexity of multi-threaded code</li> <li>\u2713 Easier to maintain and debug</li> <li>\u2713 Leverages Python\u2019s async capabilities effectively</li> </ul> <ul> <li> <p>Add this method to your class:</p> <pre><code>async def run(self):\n    \"\"\"Start the MCP server and begin serving requests.\"\"\"\n    print(\"Starting MCP server...\")\n    print(\"Server is now running and ready to accept connections\")\n\n    async with stdio_server() as (read_stream, write_stream):\n        await self.server.run(\n            read_stream,\n            write_stream,\n            self.server.create_initialization_options()\n        )\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li><code>stdio_server()</code> creates the stdin/stdout transport</li> <li><code>self.server.run()</code> starts the server event loop</li> <li>The server now listens for JSON-RPC messages on stdin</li> <li>Responses are sent back on stdout</li> <li>The server can now handle tool calls, resource reads, and prompt requests</li> <li>This is the final step to make the server operational</li> <li>The server runs indefinitely until interrupted</li> <li>Clients can now connect and interact with the server</li> <li>This method is asynchronous, allowing concurrent request handling</li> <li>The server is now live and ready for use</li> </ul>"},{"location":"01-MCP-Workflow/#skeleton-12-main-entry-point","title":"Skeleton 12: Main / Entry Point","text":"<ul> <li>Now we need to create the main function that orchestrates everything and the entry point that runs when the script is executed.</li> <li>This is where we call all the setup methods in order and start the server.</li> <li>This is the final piece to complete your MCP server implementation.</li> <li>Let\u2019s add the main function and entry point.</li> </ul> <ul> <li> <p>Add these functions at the end of your file (outside the class):</p> <pre><code>async def main():\n    \"\"\"\n    Main entry point for the MCP server.\n\n    This function orchestrates the complete server setup and execution:\n    1. Creates server instance (constructor)\n    2. Registers tools\n    3. Registers tool handlers\n    4. Registers resources\n    5. Registers resource handlers\n    6. Registers prompts\n    7. Registers prompt handlers\n    8. Sets up lifecycle handlers\n    9. Runs the server\n    \"\"\"\n    print(\"=\"*80)\n    print(\"\ud83c\udf1f COMPLETE MCP SERVER - STARTING\")\n    print(\"=\"*80)\n\n    # Step 1: Create server instance\n    server = CompleteMCPServer()\n\n    # Step 2: Register tools\n    server.register_tools()\n\n    # Step 3: Register tool handlers\n    server.register_tool_handlers()\n\n    # Step 4: Register resources\n    server.register_resources()\n\n    # Step 5: Register resource handlers\n    server.register_resource_handlers()\n\n    # Step 6: Register prompts\n    server.register_prompts()\n\n    # Step 7: Register prompt handlers\n    server.register_prompt_handlers()\n\n    # Step 8: Setup lifecycle handlers\n    server.setup_lifecycle_handlers()\n\n    print(\"=\"*80)\n    print(\"All components registered successfully!\")\n    print(\"=\"*80)\n\n    # Step 9: Run the server\n    await server.run()\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Entry point when script is run directly.\n\n    This runs when you execute: python my_mcp_server.py\n    \"\"\"\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\n\ud83d\udc4b Server shutdown complete\")\n        sys.exit(0)\n</code></pre> </li> </ul> <p>What\u2019s Happening:</p> <ul> <li>The <code>main()</code> function calls all setup methods in order</li> <li>The <code>if __name__ == \"__main__\"</code> block runs when the script is executed</li> <li><code>asyncio.run(main())</code> starts the async event loop</li> <li><code>KeyboardInterrupt</code> handler allows graceful shutdown with Ctrl+C</li> <li>This is the final orchestration of the MCP server</li> </ul>"},{"location":"01-MCP-Workflow/#code-review","title":"Code Review","text":"<p>At this point, your <code>my_mcp_server.py</code> file should have:</p> <ol> <li>All imports at the top</li> <li><code>CompleteMCPServer</code> class with all 9 methods</li> <li><code>main()</code> function</li> <li>Entry point with <code>if __name__ == \"__main__\"</code></li> </ol> <p>Your file structure should look like: <pre><code>#!/usr/bin/env python3\n# Imports\n# Class definition\n#   __init__\n#   register_tools\n#   register_tool_handlers\n#   register_resources\n#   register_resource_handlers\n#   register_prompts\n#   register_prompt_handlers\n#   setup_lifecycle_handlers\n#   run\n# main() function\n# if __name__ == \"__main__\" block\n</code></pre></p>"},{"location":"01-MCP-Workflow/#testing-with-mcp-inspector","title":"Testing with MCP Inspector","text":"<ul> <li>Now that you\u2019ve built your complete MCP server, it\u2019s time to test it!</li> <li>We\u2019ll use MCP Inspector, a web-based tool for debugging MCP servers.</li> <li>Follow the steps below to install MCP Inspector, run your server, and test all the tools, resources, and prompts you implemented.</li> </ul>"},{"location":"01-MCP-Workflow/#what-is-mcp-inspector","title":"What is MCP Inspector?","text":"<p>MCP Inspector is a web-based debugging tool for MCP servers. Think of it like a browser developer console for your MCP server - it lets you:</p> <ul> <li>Connect to your server</li> <li>See all available tools, resources, and prompts</li> <li>Execute tools with custom parameters</li> <li>Read resources</li> <li>Generate prompts</li> <li>View JSON-RPC messages</li> <li>Debug server behavior</li> </ul>"},{"location":"01-MCP-Workflow/#installing-mcp-inspector","title":"Installing MCP Inspector","text":"<p>Open a terminal and run:</p> <pre><code># Install MCP Inspector globally\nnpm install -g @modelcontextprotocol/inspector\n\n# Run the MCP Inspector\nnpx @modelcontextprotocol/inspector python3 \"my_mcp_server.py\"\n</code></pre>"},{"location":"01-MCP-Workflow/#testing-your-tools","title":"Testing Your Tools","text":"<p>Follow these steps in the MCP Inspector:</p>"},{"location":"01-MCP-Workflow/#test-01-connect-to-the-server","title":"Test 01: Connect to the Server","text":"<ol> <li>Click the \u201cConnect\u201d button at the bottom left of the interface</li> <li>Wait for the connection status to show \u201cConnected\u201d (green indicator)</li> <li>If not connected, set the following:</li> <li>transport: <code>stdio</code></li> <li>Command: <code>python3</code></li> <li>Arguments: <code>my_mcp_server.py</code></li> <li>Click \u201cConnect\u201d again</li> <li>You should see the server name and version in the top right corner</li> <li>Success! </li> </ol>"},{"location":"01-MCP-Workflow/#test-02-explore-tools","title":"Test 02: Explore Tools","text":"<ol> <li>Click the \u201cTools\u201d tab in the upper menu</li> <li>Click \u201cList tools\u201d to see all available tools</li> <li>You should see: <code>calculate</code>, <code>store_data</code>, <code>retrieve_data</code>, <code>echo</code></li> <li>If you added the <code>greeting</code> tool, you should see that too!</li> </ol>"},{"location":"01-MCP-Workflow/#test-03-test-the-calculate-tool","title":"Test 03: Test the Calculate Tool","text":"<ol> <li>Click on \u201ccalculate\u201d in the tools list</li> <li>The tool interface opens on the right side</li> <li>Fill in the parameters:<ul> <li>operation: Select \u201cadd\u201d from the dropdown<ul> <li>a: Enter <code>10</code></li> <li>b: Enter <code>5</code></li> </ul> </li> </ul> </li> <li>Click \u201cRun Tool\u201d</li> <li>Scroll down to see the result: <code>\"Result: 10 add 5 = 15\"</code></li> <li>Success! </li> </ol>"},{"location":"01-MCP-Workflow/#test-04-test-the-store-data-tool","title":"Test 04: Test the Store Data Tool","text":"<ol> <li>Click on \u201cstore_data\u201d in the tools list</li> <li>Fill in the parameters:<ul> <li>key: Enter <code>username</code></li> <li>value: Enter <code>Alice</code></li> </ul> </li> <li>Click \u201cRun Tool\u201d</li> <li>Result: <code>\"Stored: username = Alice\"</code></li> <li>Try storing another key-value pair to see it works!</li> <li>Success!</li> </ol>"},{"location":"01-MCP-Workflow/#test-05-test-the-retrieve-data-tool","title":"Test 05: Test the Retrieve Data Tool","text":"<ol> <li>Click on \u201cretrieve_data\u201d in the tools list</li> <li>Fill in the parameter:</li> <li>key: Enter <code>username</code></li> <li>Click \u201cRun Tool\u201d</li> <li>Result: <code>\"Retrieved: username = Alice\"</code></li> <li>Try retrieving a non-existent key to see error handling!</li> </ol>"},{"location":"01-MCP-Workflow/#test-06-test-the-echo-tool","title":"Test 06: Test the Echo Tool","text":"<ol> <li>Click on \u201cecho\u201d in the tools list</li> <li>Fill in the parameter:</li> <li>text: Enter <code>Hello, MCP World!</code></li> <li>Click \u201cRun Tool\u201d</li> <li>Result: <code>\"Echo: Hello, MCP World!\"</code></li> </ol>"},{"location":"01-MCP-Workflow/#test-07-test-resources","title":"Test 07: Test Resources","text":"<ol> <li>Click the \u201cResources\u201d tab in the upper menu</li> <li>Click \u201cList resources\u201d to see all available resources</li> <li>You should see: <code>server-info</code>, <code>data-store</code>, <code>welcome</code></li> <li>If you added the <code>server-author</code> resource, you should see that too!</li> </ol>"},{"location":"01-MCP-Workflow/#test-resource-server-info","title":"Test Resource: server-info","text":"<ol> <li>Click on \u201cresource://server-info\u201d</li> <li>View the JSON response showing server metadata</li> <li>Notice it shows 4 tools, 3 resources, 2 prompts</li> </ol>"},{"location":"01-MCP-Workflow/#test-resource-data-store","title":"Test Resource: data-store","text":"<ol> <li>Click on \u201cresource://data-store\u201d</li> <li>View the current contents of the data store</li> <li>You should see the <code>username: Alice</code> you stored earlier!</li> </ol>"},{"location":"01-MCP-Workflow/#test-resource-welcome","title":"Test Resource: welcome","text":"<ol> <li>Click on \u201cresource://welcome\u201d</li> <li>View the welcome message explaining server capabilities</li> <li>If you added the <code>server-author</code> resource, click on it to see your name displayed</li> <li>Success!</li> </ol>"},{"location":"01-MCP-Workflow/#test-08-testing-your-prompts","title":"Test 08: Testing Your Prompts","text":"<ol> <li>Click the \u201cPrompts\u201d tab in the upper menu</li> <li>Click \u201cList prompts\u201d to see all available prompts</li> <li>You should see: <code>analyze-data</code>, <code>calculate-scenario</code></li> </ol>"},{"location":"01-MCP-Workflow/#test-prompt-calculate-scenario","title":"Test Prompt: calculate-scenario","text":"<ol> <li>Click on \u201ccalculate-scenario\u201d</li> <li>Fill in the argument:<ul> <li>operation: Enter <code>multiply</code></li> </ul> </li> <li>Click \u201cGet Prompt\u201d</li> <li>View the generated prompt that explains how to use the calculate tool</li> </ol>"},{"location":"01-MCP-Workflow/#test-prompt-analyze-data","title":"Test Prompt: analyze-data","text":"<ol> <li>Click on \u201canalyze-data\u201d</li> <li>Fill in the argument:<ul> <li>key: Enter <code>username</code></li> </ul> </li> <li>Click \u201cGet Prompt\u201d</li> <li>View the generated prompt that analyzes the stored data</li> </ol>"},{"location":"01-MCP-Workflow/#understanding-the-inspector-interface","title":"Understanding the Inspector Interface","text":"<p>Left Panel: Navigation</p> <ul> <li>Tools, Resources, Prompts tabs</li> <li>List and select items to test</li> </ul> <p>Right Panel: Details</p> <ul> <li>Shows selected item details</li> <li>Input forms for parameters</li> <li>Execute button</li> <li>Results display</li> </ul> <p>Bottom Panel: JSON-RPC Messages</p> <ul> <li>Shows raw protocol messages</li> <li>Useful for debugging</li> <li>See requests and responses</li> </ul> <p>Connection Status</p> <ul> <li>Top right corner</li> <li>Green = Connected</li> <li>Red = Disconnected</li> <li>Shows server name and version</li> </ul>"},{"location":"01-MCP-Workflow/#advanced-experiments","title":"Advanced Experiments","text":"<ul> <li>Now that you have a working server, try these challenges:</li> </ul>"},{"location":"01-MCP-Workflow/#challenge-1-modify-the-calculate-tool","title":"Challenge 1: Modify the Calculate Tool","text":"<p>Add support for: - <code>power</code> operation (a^b) - <code>modulus</code> operation (a % b)</p>"},{"location":"01-MCP-Workflow/#challenge-2-add-roots","title":"Challenge 2: Add Roots","text":"<p>Add support for: - Listing files in a directory (referencing client roots) - Reading file contents (referencing client roots)</p>"},{"location":"02-MCP-Ollama/","title":"Implementing Live MCP Server (With Ollama Integration)","text":""},{"location":"02-MCP-Ollama/#overview","title":"Overview","text":"<ul> <li>In this lab, you\u2019ll master the art of creating sophisticated, production-ready <code>MCP</code> tools that can handle complex inputs, perform real-world operations, and return rich content types.</li> </ul>"},{"location":"02-MCP-Ollama/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Design robust tool schemas with advanced validation</li> <li>Implement tools that interact with external systems (APIs, databases, file systems)</li> <li>Return multiple content types (text, images, resources)</li> <li>Handle errors gracefully with detailed feedback</li> <li>Implement async operations and streaming responses</li> <li>Apply best practices for tool composition</li> <li>Test tools thoroughly with various edge cases</li> </ul>"},{"location":"02-MCP-Ollama/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completion of previous MCP labs or equivalent experience</li> <li>Understanding of async/await in JavaScript/TypeScript</li> <li>Basic knowledge of REST APIs and JSON</li> <li>Node.js development environment set up</li> </ul>"},{"location":"02-MCP-Ollama/#weather-information-with-ollama","title":"Weather Information with Ollama","text":""},{"location":"02-MCP-Ollama/#goal","title":"Goal","text":"<ul> <li>Create a production-ready weather tool that uses Ollama (local AI) to generate weather information, handles errors gracefully, and returns formatted information.</li> </ul>"},{"location":"02-MCP-Ollama/#complete-weather-tool-implementation-with-ollama","title":"Complete Weather Tool Implementation with Ollama","text":"<ul> <li>Here is the complete <code>src/index.ts</code> file with the Ollama-based weather tool added. </li> </ul> Click to expand code <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n* Create an MCP server with core capabilities\n*/\nclass MyFirstMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"my-first-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          {\n            name: \"get_weather\",\n            description: \"Get current weather information for a city using AI\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: {\n                  type: \"string\",\n                  description: \"City name (e.g., 'London', 'New York')\"\n                },\n                units: {\n                  type: \"string\",\n                  description: \"Temperature units\",\n                  enum: [\"celsius\", \"fahrenheit\"],\n                  default: \"celsius\"\n                }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"hello_world\",\n            description: \"Returns a friendly greeting message\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                name: {\n                  type: \"string\",\n                  description: \"The name to greet\",\n                },\n              },\n              required: [\"name\"],\n            },\n          },\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        if (name === \"get_weather\") {\n          try {\n            // Extract and validate parameters\n            const city = args.city as string;\n            const units = (args.units as string) || \"celsius\";\n\n            if (!city || city.trim().length === 0) {\n              throw new Error(\"City name cannot be empty\");\n            }\n\n            // Use Ollama to generate weather information\n            const prompt = `Generate realistic current weather information for ${city}.\n            Return ONLY a JSON object with this exact structure:\n            {\n              \"name\": \"${city}\",\n              \"sys\": {\"country\": \"XX\"},\n              \"main\": {\"temp\": 20.5, \"feels_like\": 22.1, \"humidity\": 65},\n              \"weather\": [{\"description\": \"clear sky\"}],\n              \"wind\": {\"speed\": 3.2}\n            }\n\n            Use realistic weather data appropriate for the location. Temperature should be in Celsius. Choose an appropriate 2-letter country code for the city. Make the weather description realistic for the location and season.`;\n\n            // Call Ollama API\n            const response = await fetch('http://localhost:11434/api/generate', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                model: 'gpt-oss:20b',\n                prompt: prompt,\n                stream: false,\n                format: 'json'\n              }),\n            });\n\n            if (!response.ok) {\n              throw new Error(`Ollama API error: ${response.status} ${response.statusText}. Make sure Ollama is running with 'ollama serve'.`);\n            }\n\n            const ollamaResult = await response.json();\n            let data;\n\n            try {\n              // Parse the JSON response from Ollama\n              data = JSON.parse(ollamaResult.response);\n            } catch (parseError) {\n              // Fallback to mock data if parsing fails\n              console.warn('Failed to parse Ollama response, using fallback data');\n              const fallbackData: Record&lt;string, any&gt; = {\n                \"london\": {\n                  name: \"London\",\n                  sys: { country: \"GB\" },\n                  main: { temp: 15.2, feels_like: 14.8, humidity: 82 },\n                  weather: [{ description: \"light rain\" }],\n                  wind: { speed: 3.6 }\n                },\n                \"new york\": {\n                  name: \"New York\",\n                  sys: { country: \"US\" },\n                  main: { temp: 22.5, feels_like: 24.1, humidity: 65 },\n                  weather: [{ description: \"clear sky\" }],\n                  wind: { speed: 2.1 }\n                },\n                \"tokyo\": {\n                  name: \"Tokyo\",\n                  sys: { country: \"JP\" },\n                  main: { temp: 18.7, feels_like: 18.2, humidity: 78 },\n                  weather: [{ description: \"few clouds\" }],\n                  wind: { speed: 1.8 }\n                },\n                \"paris\": {\n                  name: \"Paris\",\n                  sys: { country: \"FR\" },\n                  main: { temp: 12.8, feels_like: 11.9, humidity: 71 },\n                  weather: [{ description: \"overcast clouds\" }],\n                  wind: { speed: 4.2 }\n                },\n                \"sydney\": {\n                  name: \"Sydney\",\n                  sys: { country: \"AU\" },\n                  main: { temp: 24.3, feels_like: 25.1, humidity: 73 },\n                  weather: [{ description: \"sunny\" }],\n                  wind: { speed: 2.8 }\n                }\n              };\n              data = fallbackData[city.toLowerCase().trim()] || fallbackData[\"london\"];\n            }\n\n            // Format response\n            const tempUnit = units === \"fahrenheit\" ? \"\u00b0F\" : \"\u00b0C\";\n            const weatherText = `\nWeather in ${data.name}, ${data.sys.country}:\n- Temperature: ${data.main.temp}${tempUnit}\n- Feels like: ${data.main.feels_like}${tempUnit}\n- Conditions: ${data.weather[0].description}\n- Humidity: ${data.main.humidity}%\n- Wind Speed: ${data.wind.speed} m/s\n\n*Generated by Ollama AI*\n`.trim();\n\n            // Return MCP response\n            return {\n              content: [\n                {\n                  type: \"text\",\n                  text: weatherText\n                }\n              ]\n            };\n\n          } catch (error) {\n            // Handle errors\n            throw new Error(\n              `Failed to get weather: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n        }\n\n        if (name === \"hello_world\") {\n          const userName = args?.name as string;\n\n          if (!userName) {\n            throw new Error(\"Name parameter is required\");\n          }\n\n          return {\n            content: [\n              {\n                type: \"text\",\n                text: `Hello, ${userName}! Welcome to your first MCP server! \ud83c\udf89`,\n              },\n            ],\n          };\n        }\n\n        throw new Error(`Unknown tool: ${name}`);\n      }\n    );\n  }\n\n  /**\n  * Set up error handling\n  */\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  /**\n  * Start the server\n  */\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n\n    console.error(\"My First MCP Server running on stdio\");\n  }\n}\n\n/**\n* Main entry point\n*/\nasync function main() {\n  const server = new MyFirstMCPServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"02-MCP-Ollama/#test-the-weather-tool","title":"Test the Weather Tool","text":"<ul> <li>This MCP is wriitten in TypeScript. Make sure you have all dependencies installed with <code>npm install</code>.</li> </ul> <pre><code># Install dependencies\nnpm install @types/node tsx typescript\n\n# Test the MCP server\n# Start the MCP Inspector** (in a new terminal):\nnpx @modelcontextprotocol/inspector tsx mcp.ts\n</code></pre> <ol> <li> <p>In the MCP Inspector interface:</p> <ul> <li>You should see both <code>get_weather</code> and <code>hello_world</code> tools listed</li> <li>Click on <code>get_weather</code> tool</li> <li>Enter a city name like \u201cLondon\u201d, \u201cNew York\u201d, \u201cTokyo\u201d, \u201cParis\u201d, or \u201cSydney\u201d</li> <li>Optionally set units to \u201cfahrenheit\u201d for Fahrenheit temperatures</li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test different scenarios:</p> <ul> <li>Valid cities: \u201cLondon\u201d, \u201cNew York\u201d, \u201cTokyo\u201d, \u201cParis\u201d, \u201cSydney\u201d</li> <li>Invalid cities: \u201cInvalidCity123\u201d (will use fallback data)</li> <li>Different units: Try both \u201ccelsius\u201d and \u201cfahrenheit\u201d</li> <li>Empty city: Try with empty string (should show validation error)</li> </ul> </li> <li> <p>Test error cases:</p> <ul> <li>Stop Ollama server and try calling the tool (should show API error)</li> <li>Try with invalid model name in the code (should show error)</li> </ul> </li> <li> <p>You should see AI-generated weather information formatted like this:</p> <pre><code>Weather in London, GB:\n- Temperature: 15.2\u00b0C\n- Feels like: 14.8\u00b0C\n- Conditions: light rain\n- Humidity: 82%\n- Wind Speed: 3.6 m/s\n\n*Generated by Ollama AI*\n</code></pre> </li> </ol>"},{"location":"02-MCP-Ollama/#tool-2-file-operations","title":"Tool 2: File Operations","text":""},{"location":"02-MCP-Ollama/#goal_1","title":"Goal","text":"<ul> <li>Create a secure file reading tool that can handle various file types, validate paths, and return formatted content with metadata.</li> </ul>"},{"location":"02-MCP-Ollama/#complete-file-operations-tool-implementation","title":"Complete File Operations Tool Implementation","text":"<ul> <li>Do NOT copy the entire code block below. </li> <li>Instead, add the <code>read_file</code> tool to your existing <code>src/index.ts</code> file by following these specific steps:</li> </ul> <ol> <li> <p>Add the import at the top of your file (after existing imports):    <pre><code>import * as fs from 'fs/promises';\nimport * as path from 'path';\n</code></pre></p> </li> <li> <p>Add the <code>read_file</code> tool to your tools array in the <code>ListToolsRequestSchema</code> handler:    <pre><code>{\n  name: \"read_file\",\n  description: \"Read contents of a text file with security validation\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      filepath: {\n        type: \"string\",\n        description: \"Absolute path to the file\"\n      },\n      encoding: {\n        type: \"string\",\n        description: \"File encoding\",\n        enum: [\"utf8\", \"ascii\", \"base64\"],\n        default: \"utf8\"\n      },\n      maxSize: {\n        type: \"number\",\n        description: \"Maximum file size in bytes\",\n        minimum: 1,\n        maximum: 10485760,\n        default: 1048576\n      }\n    },\n    required: [\"filepath\"]\n  }\n}\n</code></pre></p> </li> <li> <p>Add the <code>read_file</code> handler in the <code>CallToolRequestSchema</code> handler (before the final <code>throw new Error</code>):    <pre><code>if (name === \"read_file\") {\n  try {\n    const filepath = args.filepath as string;\n    const encoding = (args.encoding as BufferEncoding) || \"utf8\";\n    const maxSize = (args.maxSize as number) || 1048576;\n\n    // Security: Validate input\n    if (!filepath || typeof filepath !== 'string' || filepath.trim().length === 0) {\n      throw new Error(\"filepath must be a non-empty string\");\n    }\n\n    // Security: Resolve and validate path\n    const resolvedPath = path.resolve(filepath);\n\n    // Prevent directory traversal attacks\n    if (!resolvedPath.startsWith(process.cwd())) {\n      throw new Error(\"Access denied: file path outside allowed directory\");\n    }\n\n    // Check if file exists and is readable\n    try {\n      await fs.access(resolvedPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(`File not found or not readable: ${filepath}`);\n    }\n\n    // Get file stats\n    const stats = await fs.stat(resolvedPath);\n\n    // Check if it's actually a file (not a directory)\n    if (!stats.isFile()) {\n      throw new Error(`Path is not a file: ${filepath}`);\n    }\n\n    // Check file size\n    if (stats.size &gt; maxSize) {\n      throw new Error(\n        `File too large: ${stats.size} bytes (max: ${maxSize})`\n      );\n    }\n\n    // Read file content\n    const content = await fs.readFile(resolvedPath, encoding);\n\n    // Format response with metadata\n    const fileInfo = {\n      path: resolvedPath,\n      size: stats.size,\n      modified: stats.mtime.toISOString(),\n      encoding: encoding\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `File Information:\\n${JSON.stringify(fileInfo, null, 2)}\\n\\nContent:\\n${content}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(\n      `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"02-MCP-Ollama/#testing-the-file-operations-tool","title":"Testing the File Operations Tool","text":""},{"location":"02-MCP-Ollama/#step-1-create-test-file","title":"Step 1: Create Test File","text":"<pre><code># Create a test directory and files\nmkdir -p test-files\necho \"Hello, this is a test file\\!\" &gt; test-files/hello.txt\necho '{\"name\": \"test\", \"value\": 123}' &gt; test-files/data.json\necho \"Line 1\\nLine 2\\nLine 3\" &gt; test-files/lines.txt\n</code></pre>"},{"location":"02-MCP-Ollama/#step-2-start-the-mcp-inspector","title":"Step 2: Start the MCP Inspector","text":"<pre><code>npx @modelcontextprotocol/inspector tsx mcp.ts\n</code></pre>"},{"location":"02-MCP-Ollama/#step-3-test-file-reading","title":"Step 3: Test File Reading","text":"<ol> <li> <p>Test with a simple text file:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/hello.txt</code> (use the full absolute path)</li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test with JSON file:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/data.json</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test with different encoding:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/hello.txt</code></li> <li>encoding: <code>base64</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test file size limit:</p> <ul> <li>Create a large file: <code>dd if=/dev/zero of=test-files/large.txt bs=1M count=2</code></li> <li>Try reading it with default maxSize (1MB)</li> <li>Try with maxSize: <code>2097152</code> (2MB)</li> </ul> </li> </ol>"},{"location":"02-MCP-Ollama/#step-4-test-error-cases","title":"Step 4: Test Error Cases","text":"<ol> <li> <p>Non-existent file:</p> <ul> <li>filepath: <code>/absolute/path/to/test-files/nonexistent.txt</code></li> </ul> </li> <li> <p>Directory instead of file:</p> <ul> <li>filepath: <code>/absolute/path/to/test-files</code> (the directory itself)</li> </ul> </li> <li> <p>Empty filepath:</p> <ul> <li>filepath: <code>\"\"</code></li> </ul> </li> <li> <p>Path traversal attempt:</p> <ul> <li>filepath: <code>/absolute/path/../../../etc/passwd</code></li> </ul> </li> </ol>"},{"location":"02-MCP-Ollama/#step-5-verify-output","title":"Step 5: Verify Output","text":"<ul> <li> <p>You should see output like:</p> <pre><code>File Information:\n{\n  \"path\": \"/Users/username/project/test-files/hello.txt\",\n  \"size\": 27,\n  \"modified\": \"2024-01-06T10:30:00.000Z\",\n  \"encoding\": \"utf8\"\n}\n\nContent:\nHello, this is a test file!\n</code></pre> </li> </ul>"},{"location":"02-MCP-Ollama/#troubleshooting","title":"Troubleshooting:","text":"<ul> <li>\u201cFile not found\u201d: Make sure you\u2019re using the absolute path</li> <li>\u201cAccess denied\u201d: The file path is outside your project directory</li> <li>\u201cPath is not a file\u201d: You tried to read a directory</li> <li>\u201cFile too large\u201d: Increase the maxSize parameter</li> </ul>"},{"location":"02-MCP-Ollama/#key-learning-points","title":"Key Learning Points:","text":"<ul> <li>Path security and preventing directory traversal attacks</li> <li>File system operations with Node.js fs/promises</li> <li>Input validation beyond JSON Schema</li> <li>File metadata extraction and formatting</li> <li>Error handling for various file system scenarios</li> <li>Resource limits to prevent abuse</li> </ul>"},{"location":"02-MCP-Ollama/#tool-3-database-query","title":"Tool 3: Database Query","text":""},{"location":"02-MCP-Ollama/#goal_2","title":"Goal","text":"<ul> <li>Create a secure database query tool that can execute <code>SELECT</code> statements on a <code>SQLite</code> database with proper validation and safety measures.</li> </ul>"},{"location":"02-MCP-Ollama/#complete-database-query-tool-implementation","title":"Complete Database Query Tool Implementation","text":"<ul> <li> <p>First, install the SQLite dependency:</p> <pre><code>npm install -g better-sqlite3\nnpm install -g @types/better-sqlite3\n</code></pre> </li> <li> <p>Now add the <code>query_database</code> tool to your existing <code>src/index.ts</code> file by following these specific steps:</p> </li> <li> <p>Add the imports at the top of your file (after existing imports):    <pre><code>import Database from 'better-sqlite3';\n</code></pre></p> </li> <li> <p>Add the <code>query_database</code> tool to your tools array in the <code>ListToolsRequestSchema</code> handler:    <pre><code>{\n  name: \"query_database\",\n  description: \"Execute SELECT queries on a SQLite database\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"SQL SELECT query to execute\"\n      },\n      parameters: {\n        type: \"array\",\n        description: \"Query parameters for prepared statement\",\n        items: {\n          type: [\"string\", \"number\", \"boolean\", \"null\"]\n        },\n        default: []\n      },\n      limit: {\n        type: \"number\",\n        description: \"Maximum number of rows to return\",\n        minimum: 1,\n        maximum: 1000,\n        default: 100\n      }\n    },\n    required: [\"query\"]\n  }\n}\n</code></pre></p> </li> <li> <p>Add the <code>query_database</code> handler in the <code>CallToolRequestSchema</code> handler (before the final <code>throw new Error</code>):    <pre><code>if (name === \"query_database\") {\n  try {\n    const query = args.query as string;\n    const parameters = (args.parameters as any[]) || [];\n    const limit = (args.limit as number) || 100;\n\n    // Security: Validate input\n    if (!query || typeof query !== 'string' || query.trim().length === 0) {\n      throw new Error(\"query must be a non-empty string\");\n    }\n\n    // Security: Only allow SELECT queries\n    const trimmedQuery = query.trim().toUpperCase();\n    if (!trimmedQuery.startsWith('SELECT')) {\n      throw new Error(\"Only SELECT queries are allowed for security\");\n    }\n\n    // Check if database file exists\n    const dbPath = './data.db';\n    try {\n      await fs.access(dbPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(\"Database file 'data.db' not found in project root\");\n    }\n\n    // Open database in read-only mode\n    const db = new Database(dbPath, { readonly: true });\n\n    try {\n      // Prepare statement\n      const stmt = db.prepare(query + ' LIMIT ?');\n\n      // Execute query\n      const rows = stmt.all(...parameters, limit);\n\n      // Format results\n      const resultText = rows.length &gt; 0\n        ? JSON.stringify(rows, null, 2)\n        : \"No results found\";\n\n      // Get query info\n      const info = stmt.columns();\n      const columnNames = info.map(col =&gt; col.name);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Query executed successfully.\\nDatabase: ${dbPath}\\nColumns: ${columnNames.join(', ')}\\nRows returned: ${rows.length}\\n\\nResults:\\n${resultText}`\n          }\n        ]\n      };\n\n    } finally {\n      db.close();\n    }\n\n  } catch (error) {\n    throw new Error(\n      `Database query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n</code></pre></p> </li> </ul>"},{"location":"02-MCP-Ollama/#testing-the-database-query-tool","title":"Testing the Database Query Tool","text":"<p>Step 1: Install SQLite</p> <pre><code># Install sqlite3 command-line tool (if not already installed)\n\n# On macOS:\nbrew install sqlite3\n\n# On Linux (Ubuntu/Debian):\nsudo apt-get update &amp;&amp; sudo apt-get install sqlite3\n\n# On Linux (CentOS/RHEL/Fedora):\nsudo yum install sqlite3    # or sudo dnf install sqlite3\n\n# On Windows (using Chocolatey):\nchoco install sqlite\n\n# On Windows (manual download):\n# Download from: https://www.sqlite.org/download.html\n# Extract sqlite3.exe to a folder in your PATH\n\n# Verify installation:\nsqlite3 --version\n</code></pre> <p>Step 2: Create a Sample Database</p> <p>Navigate to your MCP server directory</p> <pre><code>cd /Users/orni/Code-Wizard/MCP_Lab/MCP_Lab/lab_solution/my-first-mcp-server\n</code></pre> <p>Run the database creation command</p> <pre><code>sqlite3 data.db &lt;&lt; 'EOF'\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  email TEXT UNIQUE,\n  age INTEGER,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  price REAL,\n  category TEXT,\n  in_stock BOOLEAN DEFAULT 1\n);\n\nINSERT INTO users (name, email, age) VALUES \n  ('Alice Johnson', 'alice@example.com', 28),\n  ('Bob Smith', 'bob@example.com', 34),\n  ('Charlie Brown', 'charlie@example.com', 22);\n\nINSERT INTO products (name, price, category, in_stock) VALUES \n  ('Laptop', 999.99, 'Electronics', 1),\n  ('Book', 19.99, 'Education', 1),\n  ('Coffee Mug', 12.50, 'Kitchen', 0);\n\n.quit\nEOF\n</code></pre> <p>Verify the database was created</p> <pre><code>sqlite3 data.db \"SELECT name FROM sqlite_master WHERE type='table';\"\n</code></pre> <ul> <li> <p>You should see output like:</p> <pre><code>users\nproducts\n</code></pre> </li> </ul> <p>What this does:</p> <ul> <li>Creates a SQLite database file called <code>data.db</code> in your project directory</li> <li>Creates two tables: <code>users</code> and <code>products</code></li> <li>Inserts sample data into both tables</li> <li>This gives you test data to query with your <code>query_database</code> tool</li> </ul> <p>Step 2: Start the MCP Inspector</p> <pre><code>npx @modelcontextprotocol/inspector tsx mcp.ts\n</code></pre> <p>Step 3: Test Database Queries</p> <ol> <li> <p>Simple SELECT query:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM users</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with WHERE clause:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT name, email FROM users WHERE age &gt; 25</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with parameters:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM products WHERE category = ?</code></li> <li>parameters: <code>[\"Electronics\"]</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with LIMIT:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM users</code></li> <li>limit: <code>2</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>JOIN query:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT u.name, p.name as product FROM users u CROSS JOIN products p LIMIT 5</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> </ol> <p>Step 4: Test Error Cases</p> <ol> <li> <p>Non-SELECT query:</p> <ul> <li>query: <code>DELETE FROM users WHERE id = 1</code></li> </ul> </li> <li> <p>Invalid SQL syntax:</p> <ul> <li>query: <code>SELECT * FROM nonexistent_table</code></li> </ul> </li> <li> <p>Missing database file:</p> <ul> <li>Rename <code>data.db</code> to <code>data.db.backup</code> and try a query</li> </ul> </li> <li> <p>Empty query:</p> <ul> <li>query: <code>\"\"</code></li> </ul> </li> </ol> <p>Step 5: Verify Output</p> <ul> <li> <p>You should see output like:</p> <pre><code>Query executed successfully.\nDatabase: ./data.db\nColumns: id, name, email, age, created_at\nRows returned: 3\n\nResults:\n[\n  {\n    \"id\": 1,\n    \"name\": \"Alice Johnson\",\n    \"email\": \"alice@example.com\",\n    \"age\": 28,\n    \"created_at\": \"2024-01-06 10:30:00\"\n  },\n  ...\n]\n</code></pre> </li> </ul> <p>Troubleshooting:</p> <ul> <li>\u201cDatabase file not found\u201d: Make sure <code>data.db</code> exists in your project root</li> <li>\u201cOnly SELECT queries are allowed\u201d: The tool only allows SELECT statements for security</li> <li>\u201cno such table\u201d: Check your table names in the database</li> <li>\u201csqlite3: command not found\u201d: Install sqlite3 CLI tool</li> </ul>"},{"location":"02-MCP-Ollama/#key-learning-points_1","title":"Key Learning Points:","text":"<ul> <li>SQL injection prevention using prepared statements</li> <li>Database security with read-only access and query restrictions</li> <li>SQLite operations with better-sqlite3</li> <li>Query parameterization for safe dynamic queries</li> <li>Result formatting and metadata extraction</li> <li>Resource management with proper database connection handling</li> </ul>"},{"location":"02-MCP-Ollama/#returning-rich-content","title":"Returning Rich Content","text":"<ul> <li>MCP supports multiple content types in tool responses, allowing you to return not just text but also images, resources, and combinations of different content types. </li> <li>This enables richer, more interactive responses that can include visual data, file references, and structured information.</li> </ul>"},{"location":"02-MCP-Ollama/#1-text-content","title":"1. Text Content","text":"<p>Text content is the most common and basic type of response.  Use it for any string-based information like analysis results, status messages, or formatted data.</p> <pre><code>return {\n  content: [\n    {\n      type: \"text\",\n      text: \"Simple text response\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Most tool responses will use text content.  It\u2019s perfect for:</p> <ul> <li>Status messages and confirmations</li> <li>Formatted data output (JSON, tables, lists)</li> <li>Error messages and explanations</li> <li>Analysis results and summaries</li> </ul>"},{"location":"02-MCP-Ollama/#2-image-content","title":"2. Image Content","text":"<p>Image content allows you to return visual data directly in the response. The image data must be base64-encoded and include the appropriate MIME type.</p> <pre><code>return {\n  content: [\n    {\n      type: \"image\",\n      data: base64ImageData,\n      mimeType: \"image/png\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Ideal for tools that generate or process visual content:</p> <ul> <li>Charts and graphs from data analysis</li> <li>Screenshots or visual captures</li> <li>Generated diagrams or illustrations</li> <li>Image processing results</li> </ul> <p>Important: Always specify the correct MIME type (image/png, image/jpeg, image/svg+xml, etc.) and ensure the base64 data is properly encoded.</p>"},{"location":"02-MCP-Ollama/#3-resource-content","title":"3. Resource Content","text":"<p>Resource content references external resources rather than including their data directly. This is useful for large files or when you want to provide access to resources without embedding them.</p> <pre><code>return {\n  content: [\n    {\n      type: \"resource\",\n      resource: {\n        uri: \"file:///path/to/file.txt\",\n        mimeType: \"text/plain\",\n        text: \"File contents...\"\n      }\n    }\n  ]\n};\n</code></pre> <p>When to use - Best for:</p> <ul> <li>Large files that would make responses too bulky</li> <li>References to external files or URLs</li> <li>When the client should handle the resource directly</li> <li>Providing access to generated files</li> </ul> <p>Note: The <code>text</code> field is optional - you can omit it if the resource content is too large or if you just want to provide a reference.</p>"},{"location":"02-MCP-Ollama/#4-multiple-content-items","title":"4. Multiple Content Items","text":"<p>Multiple content items allow you to combine different types of content in a single response. This creates rich, multi-part responses that can include text explanations alongside visual data.</p> <pre><code>return {\n  content: [\n    {\n      type: \"text\",\n      text: \"Analysis complete:\"\n    },\n    {\n      type: \"text\",\n      text: \"Details:\\n- Item 1\\n- Item 2\"\n    },\n    {\n      type: \"image\",\n      data: chartImage,\n      mimeType: \"image/png\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Perfect for comprehensive responses that need multiple components:</p> <ul> <li>Analysis reports with both text summaries and visual charts</li> <li>File processing results with metadata and content preview</li> <li>Multi-step operations with status updates and final results</li> <li>Complex data with both tabular and graphical representations</li> </ul> <p>Tip: Order your content logically - start with text explanations, then show supporting images or resources.</p>"},{"location":"02-MCP-Ollama/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Error handling is crucial for robust MCP tools. Different situations require different approaches to handle failures gracefully while providing useful feedback to users. Here are three essential patterns for handling errors effectively.</p>"},{"location":"02-MCP-Ollama/#pattern-1-input-validation","title":"Pattern 1: Input Validation","text":"<p>Input validation ensures that tool arguments meet your requirements before processing begins. This prevents runtime errors and provides clear feedback when users provide invalid data.</p> <pre><code>function validateInput(args: any): void {\n  if (!args.filepath || typeof args.filepath !== 'string') {\n    throw new Error(\"filepath must be a non-empty string\");\n  }\n\n  if (args.maxSize &amp;&amp; (args.maxSize &lt; 1 || args.maxSize &gt; 10485760)) {\n    throw new Error(\"maxSize must be between 1 and 10485760 bytes\");\n  }\n}\n</code></pre> <p>When to use - Always validate inputs before processing, even when using JSON Schema validation. This pattern is essential for:</p> <ul> <li>Type checking beyond JSON Schema capabilities</li> <li>Business logic validation (file size limits, path security)</li> <li>Preventing runtime errors from malformed data</li> <li>Providing specific, actionable error messages</li> </ul> <p>Why it matters: Early validation fails fast and gives users clear guidance on how to fix their input.</p>"},{"location":"02-MCP-Ollama/#pattern-2-graceful-degradation","title":"Pattern 2: Graceful Degradation","text":"<p>Graceful degradation provides partial functionality when full operation isn\u2019t possible. Instead of failing completely, the tool returns useful information or falls back to alternative approaches.</p> <pre><code>try {\n  const data = await fetchFromAPI(url);\n  return formatSuccess(data);\n} catch (error) {\n  // Log error but return partial results if possible\n  console.error(\"API call failed:\", error);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: \"\u26a0\ufe0f Could not fetch live data. Using cached results...\"\n      }\n    ]\n  };\n}\n</code></pre> <p>When to use - For external dependencies that might be unreliable:</p> <ul> <li>API calls that could timeout or fail</li> <li>Network-dependent operations</li> <li>Services with occasional downtime</li> <li>When partial results are better than no results</li> </ul> <p>Why it matters: Users get some value even when systems are partially broken, improving overall reliability and user experience.</p>"},{"location":"02-MCP-Ollama/#pattern-3-detailed-error-context","title":"Pattern 3: Detailed Error Context","text":"<p>Detailed error context provides comprehensive information for debugging while keeping user-facing messages clean. Log full details internally but expose only safe, helpful information to users.</p> <pre><code>catch (error) {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  const errorContext = {\n    tool: name,\n    arguments: args,\n    timestamp: new Date().toISOString(),\n    error: errorMessage\n  };\n\n  console.error(\"[Tool Error]\", JSON.stringify(errorContext));\n\n  throw new Error(\n    `Tool '${name}' failed: ${errorMessage}. Check server logs for details.`\n  );\n}\n</code></pre> <p>When to use - For complex operations where debugging might be needed:</p> <ul> <li>Multi-step processes with potential failure points</li> <li>Operations involving external systems</li> <li>When you need to track error patterns over time</li> <li>Production environments where detailed logging is crucial</li> </ul> <p>Why it matters: Developers can diagnose issues effectively while users get clear, non-technical error messages.</p>"},{"location":"02-MCP-Ollama/#best-practices-for-error-handling","title":"Best Practices for Error Handling:","text":"<ul> <li>Fail Fast: Validate inputs early and stop processing on critical errors</li> <li>Log Internally: Use <code>console.error()</code> for detailed logging (goes to stderr, not stdout)</li> <li>User-Friendly Messages: Keep error messages clear and actionable</li> <li>Don\u2019t Leak Sensitive Data: Never expose file paths, credentials, or internal details</li> <li>Consistent Format: Use similar error message patterns across tools</li> <li>Recovery Options: When possible, suggest how users can resolve the issue</li> </ul>"},{"location":"02-MCP-Ollama/#async-operations-and-performance","title":"Async Operations and Performance","text":"<p>MCP tools often need to handle asynchronous operations and optimize performance. Long-running tasks require special handling to prevent timeouts and provide feedback, while expensive operations benefit from caching to improve response times and reduce resource usage.</p>"},{"location":"02-MCP-Ollama/#long-running-operations","title":"Long-Running Operations","text":"<p>Long-running operations need monitoring and progress feedback to prevent timeouts and keep users informed. Use logging and timing to track operation progress and provide completion status.</p> <pre><code>if (name === \"analyze_large_file\") {\n  const filepath = args.filepath as string;\n\n  // For very long operations, consider streaming or progress updates\n  console.error(`[INFO] Starting analysis of ${filepath}...`);\n\n  try {\n    const startTime = Date.now();\n\n    // Perform analysis\n    const result = await performLongAnalysis(filepath);\n\n    const duration = Date.now() - startTime;\n    console.error(`[INFO] Analysis completed in ${duration}ms`);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Analysis Results (completed in ${duration}ms):\\n\\n${result}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    console.error(`[ERROR] Analysis failed after ${Date.now() - startTime}ms`);\n    throw error;\n  }\n}\n</code></pre> <p>When to use - For operations that take more than a few seconds:</p> <ul> <li>Large file processing or analysis</li> <li>Complex computations</li> <li>External API calls with potential delays</li> <li>Batch operations on multiple items</li> </ul> <p>Why it matters: Prevents timeouts, provides user feedback, enables monitoring and debugging of slow operations.</p>"},{"location":"02-MCP-Ollama/#caching-results","title":"Caching Results","text":"<p>Caching results stores expensive operation results to avoid redundant computation. Use time-based expiration and proper cache keys for efficient reuse of results.</p> <pre><code>class CachedMCPServer {\n  private cache: Map&lt;string, { data: any; timestamp: number }&gt;;\n  private cacheTTL: number = 60000; // 1 minute\n\n  constructor() {\n    this.cache = new Map();\n  }\n\n  private getCacheKey(toolName: string, args: any): string {\n    return `${toolName}:${JSON.stringify(args)}`;\n  }\n\n  private getCached(key: string): any | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n\n    if (Date.now() - cached.timestamp &gt; this.cacheTTL) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return cached.data;\n  }\n\n  private setCache(key: string, data: any): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n}\n</code></pre> <p>When to use - For expensive operations that return consistent results:</p> <ul> <li>API calls to external services</li> <li>Complex calculations or data processing</li> <li>Database queries with static data</li> <li>File analysis that doesn\u2019t change frequently</li> </ul> <p>Why it matters: Dramatically improves response times, reduces resource usage, and provides better user experience for repeated requests.</p>"},{"location":"02-MCP-Ollama/#best-practices-for-async-operations-and-performance","title":"Best Practices for Async Operations and Performance:","text":"<ul> <li>Monitor Execution Time: Log start/end times for operations over 1 second</li> <li>Set Reasonable Timeouts: Use appropriate timeouts for external calls (5-30 seconds)</li> <li>Cache Strategically: Cache expensive operations but consider data freshness</li> <li>Use Streaming: For very large responses, consider streaming or pagination</li> <li>Resource Cleanup: Always clean up connections, file handles, and memory</li> <li>Progress Feedback: For long operations, provide progress updates via logging</li> <li>Memory Management: Be mindful of memory usage in long-running processes</li> </ul>"},{"location":"02-MCP-Ollama/#tool-composition","title":"Tool Composition","text":"<p>Tool composition is the art of designing MCP tools that work seamlessly together, allowing LLMs to chain multiple tools to accomplish complex tasks. Well-composed tools create a powerful ecosystem where each tool handles a specific responsibility while enabling sophisticated workflows through intelligent combination.</p>"},{"location":"02-MCP-Ollama/#example-multi-step-analysis","title":"Example: Multi-Step Analysis","text":"<p>Multi-step analysis demonstrates how simple, focused tools can be combined to perform complex data processing workflows. Each tool has a clear responsibility and can be used independently or as part of larger operations.</p> <pre><code>// Tool 1: List files\n{\n  name: \"list_files\",\n  description: \"List files in a directory\",\n  inputSchema: { ... }\n}\n\n// Tool 2: Read file\n{\n  name: \"read_file\",\n  description: \"Read a specific file\",\n  inputSchema: { ... }\n}\n\n// Tool 3: Analyze content\n{\n  name: \"analyze_text\",\n  description: \"Analyze text content\",\n  inputSchema: { ... }\n}\n</code></pre> <p>When to use - For workflows that require multiple processing steps:</p> <ul> <li>Data analysis pipelines</li> <li>File processing workflows</li> <li>Multi-stage computations</li> <li>Complex research tasks</li> </ul> <p>Why it matters: Breaks down complex problems into manageable, reusable components that can be combined in flexible ways.</p>"},{"location":"02-MCP-Ollama/#llm-tool-chaining","title":"LLM Tool Chaining","text":"<p>LLM tool chaining allows AI models to automatically sequence tool calls based on intermediate results. The LLM analyzes outputs from one tool and determines which tool to call next, creating intelligent workflows without explicit programming.</p> <p>The LLM can chain these tools:</p> <ol> <li>List files in directory - Discover available files</li> <li>Read interesting files - Access content based on filenames</li> <li>Analyze their content - Process and extract insights</li> </ol> <p>When to use - When tasks naturally break down into sequential steps:</p> <ul> <li>Research and analysis workflows</li> <li>Data processing pipelines</li> <li>Content generation chains</li> <li>Problem-solving sequences</li> </ul> <p>Why it matters: Enables complex, multi-step reasoning and problem-solving that would be difficult to implement in single tools.</p>"},{"location":"02-MCP-Ollama/#testing-composed-tools","title":"Testing Composed Tools","text":"<p>Testing composed tools ensures that individual tools work correctly both in isolation and when chained together. Use comprehensive test suites that cover single-tool usage and multi-tool workflows.</p> <pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Weather Tool', () =&gt; {\n  it('should validate city name', async () =&gt; {\n    await expect(\n      callTool('get_weather', { city: '' })\n    ).rejects.toThrow('City name cannot be empty');\n  });\n\n  it('should handle invalid city', async () =&gt; {\n    await expect(\n      callTool('get_weather', { city: 'InvalidCity12345' })\n    ).rejects.toThrow('not found');\n  });\n\n  it('should return weather data', async () =&gt; {\n    const result = await callTool('get_weather', {\n      city: 'London',\n      units: 'celsius'\n    });\n\n    expect(result.content).toHaveLength(1);\n    expect(result.content[0].text).toContain('Temperature');\n  });\n});\n</code></pre> <p>When to use - For validating tool behavior in different scenarios:</p> <ul> <li>Unit testing individual tools</li> <li>Integration testing tool chains</li> <li>Regression testing after changes</li> <li>Edge case validation</li> </ul> <p>Why it matters: Ensures reliability and predictability when tools are used individually or in combination.</p>"},{"location":"02-MCP-Ollama/#best-practices-for-tool-composition","title":"Best Practices for Tool Composition:","text":"<ul> <li>Single Responsibility: Each tool should do one thing well</li> <li>Consistent Interfaces: Use similar parameter patterns across tools</li> <li>Clear Dependencies: Document which tools work well together</li> <li>Error Propagation: Handle failures gracefully in tool chains</li> <li>State Management: Avoid tools that require complex state between calls</li> <li>Flexible Outputs: Design tool outputs to be usable as inputs for other tools</li> <li>Documentation: Clearly explain how tools can be combined</li> <li>Version Compatibility: Ensure tool interfaces remain stable</li> </ul>"},{"location":"02-MCP-Ollama/#best-practices-checklist","title":"Best Practices Checklist","text":"<p>Schema Design</p> <ul> <li>Use descriptive names and descriptions</li> <li>Add examples in descriptions</li> <li>Set reasonable defaults</li> <li>Use enums for constrained values</li> <li>Add min/max for numbers</li> </ul> <p>Implementation</p> <ul> <li>Validate all inputs, even with schemas</li> <li>Handle errors gracefully</li> <li>Log to stderr, not stdout</li> <li>Use async/await properly</li> <li>Clean up resources (file handles, connections)</li> </ul> <p>Security</p> <ul> <li>Validate and sanitize file paths</li> <li>Use prepared statements for SQL</li> <li>Limit resource usage (file sizes, API calls)</li> <li>Don\u2019t expose sensitive data in errors</li> <li>Implement rate limiting</li> </ul> <p>Performance</p> <ul> <li>Cache expensive operations</li> <li>Set reasonable timeouts</li> <li>Limit result sizes</li> <li>Use streaming for large data</li> <li>Monitor execution time</li> </ul> <p>User Experience</p> <ul> <li>Provide clear error messages</li> <li>Return structured data when possible</li> <li>Include relevant context in responses</li> <li>Handle edge cases gracefully</li> <li>Document expected behavior</li> </ul>"},{"location":"02-MCP-Ollama/#hands-on-exercises","title":"Hands-On Exercises","text":""},{"location":"02-MCP-Ollama/#exercise-1-text-processing-tool","title":"Exercise 1: Text Processing Tool","text":"<p>Create a tool that:</p> <ul> <li>Counts words, characters, lines</li> <li>Finds specific patterns</li> <li>Calculates reading time</li> <li>Detects language</li> </ul> \ud83d\udca1 Solution: Text Processing Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"process_text\",\n  description: \"Analyze and process text content with various metrics and operations\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      text: {\n        type: \"string\",\n        description: \"The text content to process\"\n      },\n      operations: {\n        type: \"array\",\n        description: \"Operations to perform\",\n        items: {\n          type: \"string\",\n          enum: [\"count\", \"find_pattern\", \"reading_time\", \"detect_language\"]\n        },\n        default: [\"count\"]\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Regex pattern for find_pattern operation\"\n      }\n    },\n    required: [\"text\"]\n  }\n}\n</code></pre>  Implementation - Add this handler in your \"CallToolRequestSchema\" handler:  <pre><code>if (name === \"process_text\") {\n  try {\n    const text = args.text as string;\n    const operations = (args.operations as string[]) || [\"count\"];\n    const pattern = args.pattern as string;\n\n    let results: string[] = [];\n\n    for (const op of operations) {\n      switch (op) {\n        case \"count\":\n          const lines = text.split('\\n').length;\n          const words = text.split(/\\s+/).filter(w =&gt; w.length &gt; 0).length;\n          const chars = text.length;\n          results.push(`\ud83d\udcca Text Statistics:\\n- Lines: ${lines}\\n- Words: ${words}\\n- Characters: ${chars}`);\n          break;\n\n        case \"find_pattern\":\n          if (!pattern) {\n            results.push(\"\u274c Pattern required for find_pattern operation\");\n            break;\n          }\n          try {\n            const regex = new RegExp(pattern, 'g');\n            const matches = text.match(regex);\n            results.push(`\ud83d\udd0d Pattern Matches (${pattern}):\\nFound ${matches ? matches.length : 0} matches:\\n${matches ? matches.slice(0, 10).join('\\n') : 'None'}`);\n          } catch (e) {\n            results.push(`\u274c Invalid regex pattern: ${pattern}`);\n          }\n          break;\n\n        case \"reading_time\":\n          // Average reading speed: 200 words per minute\n          const wordCount = text.split(/\\s+/).filter(w =&gt; w.length &gt; 0).length;\n          const readingTime = Math.ceil(wordCount / 200);\n          results.push(`\u23f1\ufe0f Reading Time: Approximately ${readingTime} minute${readingTime !== 1 ? 's' : ''} (${wordCount} words at 200 WPM)`);\n          break;\n\n        case \"detect_language\":\n          // Simple language detection based on common words\n          const englishWords = /\\b(the|and|or|but|in|on|at|to|for|of|with|by)\\b/gi;\n          const spanishWords = /\\b(el|la|los|las|y|o|pero|en|sobre|a|para|de|con|por)\\b/gi;\n          const frenchWords = /\\b(le|la|les|et|ou|mais|dans|sur|\u00e0|pour|de|avec|par)\\b/gi;\n\n          const englishMatches = (text.match(englishWords) || []).length;\n          const spanishMatches = (text.match(spanishWords) || []).length;\n          const frenchMatches = (text.match(frenchWords) || []).length;\n\n          const maxMatches = Math.max(englishMatches, spanishMatches, frenchMatches);\n          let detectedLang = \"Unknown\";\n\n          if (maxMatches &gt; 0) {\n            if (englishMatches === maxMatches) detectedLang = \"English\";\n            else if (spanishMatches === maxMatches) detectedLang = \"Spanish\";\n            else if (frenchMatches === maxMatches) detectedLang = \"French\";\n          }\n\n          results.push(`\ud83c\udf0d Detected Language: ${detectedLang} (confidence: ${maxMatches} common words)`);\n          break;\n      }\n    }\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: results.join('\\n\\n')\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(`Text processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n</code></pre>  Testing - Test with different inputs:  <pre><code>// Basic counting\n{ text: \"Hello world\\nThis is a test\", operations: [\"count\"] }\n\n// Pattern matching\n{ text: \"The quick brown fox jumps over the lazy dog\", operations: [\"find_pattern\"], pattern: \"\\\\b\\\\w{4}\\\\b\" }\n\n// Multiple operations\n{ text: \"This is a longer piece of text to analyze for various metrics and patterns.\", operations: [\"count\", \"reading_time\", \"detect_language\"] }\n</code></pre>"},{"location":"02-MCP-Ollama/#exercise-2-json-validator-tool","title":"Exercise 2: JSON Validator Tool","text":"<p>Create a tool that:</p> <ul> <li>Validates JSON syntax</li> <li>Validates against JSON Schema</li> <li>Formats/pretty-prints JSON</li> <li>Compares two JSON objects</li> </ul> \ud83d\udca1 Solution: JSON Validator Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"validate_json\",\n  description: \"Validate, format, and compare JSON data\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      json: {\n        type: \"string\",\n        description: \"JSON string to validate or format\"\n      },\n      operation: {\n        type: \"string\",\n        description: \"Operation to perform\",\n        enum: [\"validate\", \"format\", \"schema_validate\", \"compare\"],\n        default: \"validate\"\n      },\n      schema: {\n        type: \"string\",\n        description: \"JSON Schema for schema validation (as JSON string)\"\n      },\n      json2: {\n        type: \"string\",\n        description: \"Second JSON string for comparison\"\n      }\n    },\n    required: [\"json\", \"operation\"]\n  }\n}\n</code></pre>  Implementation - First, install the required dependency:  <pre><code>npm install ajv\n</code></pre>  Add the import:  <pre><code>import Ajv from 'ajv';\n</code></pre>  Add this handler in your \"CallToolRequestSchema\" handler:  <pre><code>if (name === \"validate_json\") {\n  try {\n    const json = args.json as string;\n    const operation = args.operation as string;\n    const schema = args.schema as string;\n    const json2 = args.json2 as string;\n\n    let result = \"\";\n\n    switch (operation) {\n      case \"validate\":\n        try {\n          JSON.parse(json);\n          result = \"\u2705 Valid JSON syntax\";\n        } catch (e) {\n          result = `\u274c Invalid JSON: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"format\":\n        try {\n          const parsed = JSON.parse(json);\n          result = `\ud83d\udcc4 Formatted JSON:\\n\\`\\`\\`json\\n${JSON.stringify(parsed, null, 2)}\\n\\`\\`\\``;\n        } catch (e) {\n          result = `\u274c Cannot format invalid JSON: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"schema_validate\":\n        if (!schema) {\n          result = \"\u274c Schema required for schema validation\";\n          break;\n        }\n        try {\n          const ajv = new Ajv();\n          const parsedJson = JSON.parse(json);\n          const parsedSchema = JSON.parse(schema);\n\n          const validate = ajv.compile(parsedSchema);\n          const valid = validate(parsedJson);\n\n          if (valid) {\n            result = \"\u2705 JSON validates against schema\";\n          } else {\n            result = `\u274c Schema validation failed:\\n${JSON.stringify(validate.errors, null, 2)}`;\n          }\n        } catch (e) {\n          result = `\u274c Schema validation error: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"compare\":\n        if (!json2) {\n          result = \"\u274c Second JSON required for comparison\";\n          break;\n        }\n        try {\n          const obj1 = JSON.parse(json);\n          const obj2 = JSON.parse(json2);\n\n          const differences: string[] = [];\n\n          // Simple comparison - check if objects are equal\n          if (JSON.stringify(obj1) === JSON.stringify(obj2)) {\n            result = \"\u2705 JSON objects are identical\";\n          } else {\n            // Find differences\n            const keys1 = Object.keys(obj1);\n            const keys2 = Object.keys(obj2);\n\n            const added = keys2.filter(k =&gt; !keys1.includes(k));\n            const removed = keys1.filter(k =&gt; !keys2.includes(k));\n            const modified = keys1.filter(k =&gt; keys2.includes(k) &amp;&amp; JSON.stringify(obj1[k]) !== JSON.stringify(obj2[k]));\n\n            if (added.length &gt; 0) differences.push(`Added keys: ${added.join(', ')}`);\n            if (removed.length &gt; 0) differences.push(`Removed keys: ${removed.join(', ')}`);\n            if (modified.length &gt; 0) differences.push(`Modified keys: ${modified.join(', ')}`);\n\n            result = `\u26a0\ufe0f JSON objects differ:\\n${differences.join('\\n')}`;\n          }\n        } catch (e) {\n          result = `\u274c Comparison error: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n    }\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: result\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(`JSON validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n</code></pre>  Testing - Test different operations:  <pre><code>// Validate syntax\n{ json: '{\"name\": \"test\", \"value\": 123}', operation: \"validate\" }\n\n// Format JSON\n{ json: '{\"name\":\"test\",\"value\":123}', operation: \"format\" }\n\n// Schema validation\n{ \n  json: '{\"name\": \"John\", \"age\": 30}', \n  operation: \"schema_validate\",\n  schema: '{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}, \"age\": {\"type\": \"number\"}}}'\n}\n\n// Compare JSON\n{\n  json: '{\"a\": 1, \"b\": 2}',\n  json2: '{\"a\": 1, \"c\": 3}',\n  operation: \"compare\"\n}\n</code></pre>"},{"location":"02-MCP-Ollama/#exercise-3-web-scraper-tool","title":"Exercise 3: Web Scraper Tool","text":"<p>Create a tool that:</p> <ul> <li>Fetches web page content</li> <li>Extracts specific elements</li> <li>Returns clean text</li> <li>Handles errors gracefully</li> </ul> \ud83d\udca1 Solution: Web Scraper Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"scrape_web\",\n  description: \"Fetch and extract content from web pages\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      url: {\n        type: \"string\",\n        description: \"URL to scrape\",\n        format: \"uri\"\n      },\n      selector: {\n        type: \"string\",\n        description: \"CSS selector to extract specific elements (optional)\",\n        default: \"body\"\n      },\n      includeText: {\n        type: \"boolean\",\n        description: \"Extract only text content (remove HTML)\",\n        default: true\n      },\n      maxLength: {\n        type: \"number\",\n        description: \"Maximum length of extracted content\",\n        minimum: 100,\n        maximum: 10000,\n        default: 2000\n      },\n      timeout: {\n        type: \"number\",\n        description: \"Request timeout in milliseconds\",\n        minimum: 1000,\n        maximum: 30000,\n        default: 10000\n      }\n    },\n    required: [\"url\"]\n  }\n}\n</code></pre>  Implementation - First, install the required dependencies:  <pre><code>npm install axios cheerio\n</code></pre>  Add the imports:  <pre><code>import axios from 'axios';\nimport * as cheerio from 'cheerio';\n</code></pre>  Add this handler in your `CallToolRequestSchema` handler:  <pre><code>if (name === \"scrape_web\") {\n  try {\n    const url = args.url as string;\n    const selector = (args.selector as string) || \"body\";\n    const includeText = (args.includeText !== false); // default true\n    const maxLength = (args.maxLength as number) || 2000;\n    const timeout = (args.timeout as number) || 10000;\n\n    // Validate URL\n    try {\n      new URL(url);\n    } catch {\n      throw new Error(\"Invalid URL format\");\n    }\n\n    // Fetch the webpage\n    const response = await axios.get(url, {\n      timeout: timeout,\n      headers: {\n        'User-Agent': 'MCP-Web-Scraper/1.0 (Educational Tool)'\n      },\n      maxContentLength: 5 * 1024 * 1024, // 5MB limit\n    });\n\n    // Load HTML into cheerio\n    const $ = cheerio.load(response.data);\n\n    // Extract content based on selector\n    let extractedContent = \"\";\n\n    if (selector === \"body\") {\n      extractedContent = includeText ? $('body').text() : $('body').html() || \"\";\n    } else {\n      const elements = $(selector);\n      if (elements.length === 0) {\n        throw new Error(`No elements found matching selector: ${selector}`);\n      }\n\n      if (includeText) {\n        extractedContent = elements.map((_, el) =&gt; $(el).text()).get().join('\\n\\n');\n      } else {\n        extractedContent = elements.map((_, el) =&gt; $.html(el)).get().join('\\n\\n');\n      }\n    }\n\n    // Clean up the content\n    extractedContent = extractedContent\n      .replace(/\\s+/g, ' ')  // Replace multiple whitespace with single space\n      .replace(/\\n\\s*\\n/g, '\\n')  // Remove empty lines\n      .trim();\n\n    // Truncate if too long\n    if (extractedContent.length &gt; maxLength) {\n      extractedContent = extractedContent.substring(0, maxLength - 3) + \"...\";\n    }\n\n    // Prepare metadata\n    const metadata = {\n      url: url,\n      statusCode: response.status,\n      contentType: response.headers['content-type'],\n      contentLength: response.data.length,\n      extractedLength: extractedContent.length,\n      selector: selector,\n      elementsFound: selector === \"body\" ? 1 : $(selector).length\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `\ud83c\udf10 Web Scraping Results\\n\\n\ud83d\udcca Metadata:\\n${Object.entries(metadata).map(([k, v]) =&gt; `- ${k}: ${v}`).join('\\n')}\\n\\n\ud83d\udcc4 Extracted Content:\\n${extractedContent}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    if (axios.isAxiosError(error)) {\n      if (error.code === 'ENOTFOUND') {\n        throw new Error(`Could not resolve hostname: ${args.url}`);\n      } else if (error.code === 'ECONNREFUSED') {\n        throw new Error(`Connection refused: ${args.url}`);\n      } else if (error.response) {\n        throw new Error(`HTTP ${error.response.status}: ${error.response.statusText}`);\n      } else if (error.code === 'ETIMEDOUT') {\n        throw new Error(`Request timeout after ${args.timeout || 10000}ms`);\n      } else {\n        throw new Error(`Network error: ${error.message}`);\n      }\n    } else {\n      throw new Error(`Web scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n}\n</code></pre>  Testing - Test with different websites and selectors:  <pre><code>// Basic page scraping\n{ url: \"https://httpbin.org/html\" }\n\n// Extract specific elements\n{ url: \"https://httpbin.org/html\", selector: \"h1\" }\n\n// Get HTML instead of text\n{ url: \"https://httpbin.org/html\", selector: \"p\", includeText: false }\n\n// Test error handling\n{ url: \"https://nonexistent-domain-12345.com\" }\n{ url: \"https://httpbin.org/status/404\" }\n</code></pre>  #### Security Notes  - This tool includes basic security measures but should not be used for production scraping - Always respect robots.txt and terms of service - Consider rate limiting to avoid being blocked - Some websites may block requests without proper headers"},{"location":"02-MCP-Ollama/tasks/","title":"MCP Lab Tasks - Lab 3","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"02-MCP-Ollama/tasks/#exercise-31-calculator-tool","title":"Exercise 3.1: Calculator Tool","text":"<p>Implement a calculator tool that supports basic arithmetic operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"calculate\") {\n    const { operation, a, b } = args;\n    let result: number;\n\n    switch (operation) {\n      case \"add\":\n        result = a + b;\n        break;\n      case \"subtract\":\n        result = a - b;\n        break;\n      case \"multiply\":\n        result = a * b;\n        break;\n      case \"divide\":\n        if (b === 0) throw new Error(\"Division by zero\");\n        result = a / b;\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-32-file-reader-tool","title":"Exercise 3.2: File Reader Tool","text":"<p>Create a tool that reads and returns file contents.</p> Solution <pre><code>import { readFileSync } from \"fs\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"read_file\") {\n    const { path } = args;\n    try {\n      const content = readFileSync(path, \"utf-8\");\n      return {\n        content: [{ type: \"text\", text: content }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-33-http-request-tool","title":"Exercise 3.3: HTTP Request Tool","text":"<p>Implement a tool that makes HTTP requests.</p> Solution <pre><code>import fetch from \"node-fetch\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"http_request\") {\n    const { url, method = \"GET\", headers = {} } = args;\n\n    try {\n      const response = await fetch(url, { method, headers });\n      const data = await response.text();\n\n      return {\n        content: [\n          { type: \"text\", text: `Status: ${response.status}` },\n          { type: \"text\", text: `Body: ${data}` }\n        ]\n      };\n    } catch (error) {\n      throw new Error(`HTTP request failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-34-json-parser-tool","title":"Exercise 3.4: JSON Parser Tool","text":"<p>Create a tool that parses and validates JSON data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_json\") {\n    const { json_string } = args;\n\n    try {\n      const parsed = JSON.parse(json_string);\n      return {\n        content: [\n          { type: \"text\", text: \"JSON is valid\" },\n          { type: \"text\", text: `Parsed: ${JSON.stringify(parsed, null, 2)}` }\n        ]\n      };\n    } catch (error) {\n      return {\n        content: [{ type: \"text\", text: `Invalid JSON: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-35-string-manipulation-tool","title":"Exercise 3.5: String Manipulation Tool","text":"<p>Implement a tool for common string operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"string_ops\") {\n    const { operation, text } = args;\n    let result: string;\n\n    switch (operation) {\n      case \"uppercase\":\n        result = text.toUpperCase();\n        break;\n      case \"lowercase\":\n        result = text.toLowerCase();\n        break;\n      case \"reverse\":\n        result = text.split('').reverse().join('');\n        break;\n      case \"length\":\n        result = text.length.toString();\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-36-database-query-tool","title":"Exercise 3.6: Database Query Tool","text":"<p>Create a tool that executes simple database queries.</p> Solution <pre><code>import sqlite3 from \"sqlite3\";\n\nconst db = new sqlite3.Database(':memory:');\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"db_query\") {\n    const { query } = args;\n\n    return new Promise((resolve, reject) =&gt; {\n      db.all(query, [], (err, rows) =&gt; {\n        if (err) {\n          reject(new Error(`Database error: ${err.message}`));\n        } else {\n          resolve({\n            content: [{ type: \"text\", text: JSON.stringify(rows, null, 2) }]\n          });\n        }\n      });\n    });\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-37-image-processing-tool","title":"Exercise 3.7: Image Processing Tool","text":"<p>Implement a tool that gets image metadata.</p> Solution <pre><code>import sharp from \"sharp\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"image_info\") {\n    const { image_path } = args;\n\n    try {\n      const metadata = await sharp(image_path).metadata();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Width: ${metadata.width}, Height: ${metadata.height}, Format: ${metadata.format}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Image processing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-38-code-linter-tool","title":"Exercise 3.8: Code Linter Tool","text":"<p>Create a tool that lints JavaScript/TypeScript code.</p> Solution <pre><code>import { ESLint } from \"eslint\";\n\nconst eslint = new ESLint();\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"lint_code\") {\n    const { code, filename = \"temp.js\" } = args;\n\n    try {\n      const results = await eslint.lintText(code, { filePath: filename });\n      const formatter = await eslint.loadFormatter(\"stylish\");\n      const resultText = formatter.format(results);\n\n      return {\n        content: [{ type: \"text\", text: resultText || \"No linting issues found\" }]\n      };\n    } catch (error) {\n      throw new Error(`Linting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-39-weather-api-tool","title":"Exercise 3.9: Weather API Tool","text":"<p>Implement a tool that fetches weather data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"get_weather\") {\n    const { city } = args;\n    const apiKey = process.env.WEATHER_API_KEY;\n\n    if (!apiKey) {\n      throw new Error(\"Weather API key not configured\");\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${city}&amp;appid=${apiKey}&amp;units=metric`\n      );\n\n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Weather in ${city}: ${data.weather[0].description}, ${data.main.temp}\u00b0C`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Weather fetch failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-310-git-operations-tool","title":"Exercise 3.10: Git Operations Tool","text":"<p>Create a tool for basic Git operations.</p> Solution <pre><code>import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"git_status\") {\n    try {\n      const { stdout } = await execAsync(\"git status --porcelain\");\n      return {\n        content: [{ type: \"text\", text: stdout || \"Working directory clean\" }]\n      };\n    } catch (error) {\n      throw new Error(`Git command failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-311-regex-tool","title":"Exercise 3.11: Regex Tool","text":"<p>Implement a tool for regular expression operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"regex_match\") {\n    const { pattern, text, flags = \"\" } = args;\n\n    try {\n      const regex = new RegExp(pattern, flags);\n      const matches = text.match(regex);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: matches ? `Matches found: ${matches.join(\", \")}` : \"No matches found\"\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Regex error: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-312-unit-converter-tool","title":"Exercise 3.12: Unit Converter Tool","text":"<p>Create a tool that converts between different units.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"convert_units\") {\n    const { value, from, to } = args;\n\n    // Simple conversion factors (could be expanded)\n    const conversions: Record&lt;string, Record&lt;string, number&gt;&gt; = {\n      celsius: { fahrenheit: (c) =&gt; c * 9/5 + 32, kelvin: (c) =&gt; c + 273.15 },\n      fahrenheit: { celsius: (f) =&gt; (f - 32) * 5/9, kelvin: (f) =&gt; (f - 32) * 5/9 + 273.15 },\n      meters: { feet: (m) =&gt; m * 3.28084, kilometers: (m) =&gt; m / 1000 },\n      feet: { meters: (f) =&gt; f / 3.28084, kilometers: (f) =&gt; f / 3280.84 }\n    };\n\n    if (conversions[from] &amp;&amp; conversions[from][to]) {\n      const result = conversions[from][to](value);\n      return {\n        content: [{ type: \"text\", text: `${value} ${from} = ${result.toFixed(2)} ${to}` }]\n      };\n    }\n\n    throw new Error(`Conversion from ${from} to ${to} not supported`);\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-313-csv-parser-tool","title":"Exercise 3.13: CSV Parser Tool","text":"<p>Implement a tool that parses CSV data.</p> Solution <pre><code>import { parse } from \"csv-parse/sync\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_csv\") {\n    const { csv_data } = args;\n\n    try {\n      const records = parse(csv_data, {\n        columns: true,\n        skip_empty_lines: true\n      });\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Parsed ${records.length} rows: ${JSON.stringify(records.slice(0, 5), null, 2)}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`CSV parsing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-314-password-generator-tool","title":"Exercise 3.14: Password Generator Tool","text":"<p>Create a tool that generates secure passwords.</p> Solution <pre><code>import { randomBytes } from \"crypto\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_password\") {\n    const { length = 12, include_special = true } = args;\n\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const specialChars = \"!@#$%^&amp;*\";\n\n    let charset = chars;\n    if (include_special) {\n      charset += specialChars;\n    }\n\n    let password = \"\";\n    const bytes = randomBytes(length);\n\n    for (let i = 0; i &lt; length; i++) {\n      password += charset[bytes[i] % charset.length];\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Generated password: ${password}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"02-MCP-Ollama/tasks/#exercise-315-code-formatter-tool","title":"Exercise 3.15: Code Formatter Tool","text":"<p>Implement a tool that formats code using Prettier.</p> Solution <pre><code>import prettier from \"prettier\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"format_code\") {\n    const { code, language = \"javascript\" } = args;\n\n    try {\n      const formatted = await prettier.format(code, {\n        parser: language,\n        semi: true,\n        singleQuote: true\n      });\n\n      return {\n        content: [{ type: \"text\", text: formatted }]\n      };\n    } catch (error) {\n      throw new Error(`Code formatting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Resources/resources/","title":"Resources","text":""},{"location":"Resources/001-MCP-Basics/001-MCP-Basics-py/","title":"001 MCP Basics py","text":""},{"location":"Resources/001-MCP-Basics/001-MCP-Basics-py/#mcp-basics-with-python","title":"MCP Basics with Python","text":"<pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create server instance\nmcp = FastMCP(\"kagent-mcp-server\")\n\n@mcp.tool()\ndef hello(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to K-Agent Labs.\"\n\n@mcp.tool()\ndef add(a: float, b: float) -&gt; str:\n    \"\"\"Adds two numbers together\"\"\"\n    result = a + b\n    return f\"The sum of {a} and {b} is {result}\"\n\ndef main():\n    # Initialize and run the server\n    mcp.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Resources/001-MCP-Basics/002-MCP-Basics-ts/","title":"MCP Server Example (TS)","text":"<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * K-Agent MCP Server\n * A simple Model Context Protocol server with example tools\n */\n\n// Create server instance\nconst server = new Server(\n  {\n    name: \"kagent-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\n// List available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n  return {\n    tools: [\n      {\n        name: \"hello\",\n        description: \"Returns a friendly greeting message\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            name: {\n              type: \"string\",\n              description: \"Name to greet\",\n            },\n          },\n          required: [\"name\"],\n        },\n      },\n      {\n        name: \"add\",\n        description: \"Adds two numbers together\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            a: {\n              type: \"number\",\n              description: \"First number\",\n            },\n            b: {\n              type: \"number\",\n              description: \"Second number\",\n            },\n          },\n          required: [\"a\", \"b\"],\n        },\n      },\n    ],\n  };\n});\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  switch (name) {\n    case \"hello\": {\n      const nameArg = args?.name as string;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Hello, ${nameArg}! Welcome to K-Agent Labs.`,\n          },\n        ],\n      };\n    }\n\n    case \"add\": {\n      const a = args?.a as number;\n      const b = args?.b as number;\n      const result = a + b;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `The sum of ${a} and ${b} is ${result}`,\n          },\n        ],\n      };\n    }\n\n    default:\n      throw new Error(`Unknown tool: ${name}`);\n  }\n});\n\n// Start the server\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"K-Agent MCP Server running on stdio\");\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Server error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/","title":"003 MCP Advanced py","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#mcp-basics-with-python","title":"MCP Basics with Python","text":"<pre><code>from mcp.server.fastmcp import FastMCP\nfrom starlette.responses import Response, JSONResponse, StreamingResponse\nfrom starlette.requests import Request\nimport types\nimport httpx\nimport json\nimport asyncio\nimport time\nimport inspect\nfrom typing import Any, Dict, List\n\n# Ollama configuration\nOLLAMA_BASE_URL = \"http://localhost:11434\"\nDEFAULT_MODEL = \"codestral:latest\"\n\n# Tool execution tracking\nTOOL_EXECUTIONS = {}\nEXECUTION_COUNTER = 0\n\nmcp = FastMCP(\"kagent-mcp-server\", port=8889)\n\n# Backwards-compat shim: some inspector tooling (fastmcp helpers)\n# expect a `_list_tools_mcp` coroutine on the server instance. Provide\n# a thin wrapper that forwards to the FastMCP `list_tools` implementation.\nasync def _list_tools_mcp(self):\n    return await self.list_tools()\n\n# Bind the method to the instance\n# MCP need to access it as an instance method later\n# This will return list of ToolMetadata objects\nmcp._list_tools_mcp = types.MethodType(_list_tools_mcp, mcp)\n\n# Common CORS headers used by the inspector (browser-based)\nHEADERS = {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET,POST,OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type,Authorization,X-Proxy-Token\",\n}\n\n# Helper functions for tool execution\ndef get_tool_function(tool_name: str):\n    \"\"\"Get the actual function for a tool by name\"\"\"\n    # Build a mapping of tool names to functions\n    tool_map = {\n        'hello': hello,\n        'add': add,\n        'ollama_generate': ollama_generate,\n        'ollama_chat': ollama_chat,\n        'ollama_list_models': ollama_list_models,\n        'code_review_prompt': code_review_prompt,\n        'debug_prompt': debug_prompt,\n    }\n    return tool_map.get(tool_name)\n\ndef validate_tool_arguments(tool_func, arguments: Dict[str, Any]) -&gt; tuple[bool, str]:\n    \"\"\"Validate arguments against function signature\"\"\"\n    try:\n        sig = inspect.signature(tool_func)\n        params = sig.parameters\n\n        # Check required arguments\n        for param_name, param in params.items():\n            if param.default == inspect.Parameter.empty and param_name not in arguments:\n                return False, f\"Missing required argument: {param_name}\"\n\n        # Check for unexpected arguments\n        for arg_name in arguments:\n            if arg_name not in params:\n                return False, f\"Unexpected argument: {arg_name}\"\n\n        return True, \"Valid\"\n    except Exception as e:\n        return False, f\"Validation error: {str(e)}\"\n\nasync def execute_tool(tool_name: str, arguments: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute a tool and return the result\"\"\"\n    global EXECUTION_COUNTER\n    execution_id = f\"exec_{EXECUTION_COUNTER}\"\n    EXECUTION_COUNTER += 1\n\n    start_time = time.time()\n\n    try:\n        tool_func = get_tool_function(tool_name)\n        if not tool_func:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": f\"Tool '{tool_name}' not found\",\n                \"duration_ms\": 0\n            }\n\n        # Validate arguments\n        valid, message = validate_tool_arguments(tool_func, arguments)\n        if not valid:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": message,\n                \"duration_ms\": 0\n            }\n\n        # Execute the tool\n        if inspect.iscoroutinefunction(tool_func):\n            result = await tool_func(**arguments)\n        else:\n            result = tool_func(**arguments)\n\n        duration_ms = (time.time() - start_time) * 1000\n\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": True,\n            \"result\": result,\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n\n    except Exception as e:\n        duration_ms = (time.time() - start_time) * 1000\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": False,\n            \"error\": str(e),\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n\n# Example tool definitions\n# These will be automatically registered with the MCP server\n@mcp.tool()\ndef hello(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to K-Agent Labs.\"\n\n# Example tool that adds two numbers\n# Demonstrates handling of numeric inputs and outputs\n# This will become MCP tool available at /tools\n@mcp.tool()\ndef add(a: float, b: float) -&gt; str:\n    \"\"\"Adds two numbers together\"\"\"\n    result = a + b\n    return f\"The sum of {a} and {b} is {result}\"\n\n# Ollama integration tools\n@mcp.tool()\ndef ollama_generate(prompt: str, model: str = DEFAULT_MODEL, max_tokens: int = 500) -&gt; str:\n    \"\"\"Generate text using Ollama LLM\"\"\"\n    try:\n        import requests\n        response = requests.post(\n            f\"{OLLAMA_BASE_URL}/api/generate\",\n            json={\n                \"model\": model,\n                \"prompt\": prompt,\n                \"stream\": False,\n                \"options\": {\n                    \"num_predict\": max_tokens\n                }\n            },\n            timeout=60\n        )\n        if response.status_code == 200:\n            result = response.json()\n            return result.get(\"response\", \"No response from model\")\n        else:\n            return f\"Error: {response.status_code} - {response.text}\"\n    except Exception as e:\n        return f\"Error calling Ollama: {str(e)}\"\n\n@mcp.tool()\ndef ollama_chat(message: str, model: str = DEFAULT_MODEL, system: str = \"\") -&gt; str:\n    \"\"\"Chat with Ollama LLM using chat API\"\"\"\n    try:\n        import requests\n        messages = []\n        if system:\n            messages.append({\"role\": \"system\", \"content\": system})\n        messages.append({\"role\": \"user\", \"content\": message})\n\n        response = requests.post(\n            f\"{OLLAMA_BASE_URL}/api/chat\",\n            json={\n                \"model\": model,\n                \"messages\": messages,\n                \"stream\": False\n            },\n            timeout=60\n        )\n        if response.status_code == 200:\n            result = response.json()\n            return result.get(\"message\", {}).get(\"content\", \"No response\")\n        else:\n            return f\"Error: {response.status_code} - {response.text}\"\n    except Exception as e:\n        return f\"Error calling Ollama: {str(e)}\"\n\n@mcp.tool()\ndef ollama_list_models() -&gt; str:\n    \"\"\"List available Ollama models\"\"\"\n    try:\n        import requests\n        response = requests.get(f\"{OLLAMA_BASE_URL}/api/tags\", timeout=5)\n        if response.status_code == 200:\n            data = response.json()\n            models = data.get(\"models\", [])\n            if not models:\n                return \"No models available\"\n\n            result = \"Available Ollama models:\\n\"\n            for model in models:\n                name = model.get(\"name\", \"unknown\")\n                size = model.get(\"size\", 0) // (1024**3)  # Convert to GB\n                result += f\"- {name} ({size}GB)\\n\"\n            return result\n        else:\n            return f\"Error: {response.status_code}\"\n    except Exception as e:\n        return f\"Error listing models: {str(e)}\"\n\n# Prompts - Reusable prompt templates\n@mcp.prompt()\ndef code_review_prompt(code: str, language: str = \"python\") -&gt; str:\n    \"\"\"Generate a code review prompt for the given code\"\"\"\n    return f\"\"\"Please review this {language} code and provide feedback:\n\n---{language}\n{code}\n---\n\nFocus on:\n- Code quality and best practices\n- Potential bugs or issues\n- Performance improvements\n- Security concerns\n\"\"\"\n\n@mcp.prompt()\ndef debug_prompt(error_message: str, code_context: str = \"\") -&gt; str:\n    \"\"\"Generate a debugging prompt\"\"\"\n    prompt = f\"\"\"Help me debug this error:\n\nError: {error_message}\n\"\"\"\n    if code_context:\n        prompt += f\"\\n\\nCode context:\\n---\\n{code_context}\\n---\"\n    return prompt\n\n# Resource to return the source code of this server\n# Useful for inspection and learning purposes\n@mcp.resource(\"mcp://code\")\ndef get_code() -&gt; str:\n    \"\"\"Returns the source code of this server\"\"\"\n    with open(__file__, \"r\") as f:\n        return f.read()\n\n@mcp.resource(\"mcp://server-info\")\ndef get_server_info() -&gt; str:\n    \"\"\"Returns information about this MCP server\"\"\"\n    return \"\"\"K-Agent MCP Server\n\nVersion: 0.1.0\nCapabilities:\n- Tools: hello, add\n- Prompts: code_review_prompt, debug_prompt\n- Resources: code, server-info\n- Sampling: LLM sampling support\n- Roots: File system access\n\"\"\"\n\n@mcp.custom_route(\"/\", methods=[\"GET\", \"OPTIONS\"])\nasync def root_health_check(request: Request) -&gt; Response:\n    return Response(\"MCP Server Running\", status_code=200, headers=HEADERS)\n\n# Health check endpoints\n# MCP manifest endpoint, negotiation, and tools listing\n@mcp.custom_route(\"/health\", methods=[\"GET\", \"OPTIONS\"])\nasync def health_check(request: Request) -&gt; Response:\n    return Response(\"MCP Server Running\", status_code=200, headers=HEADERS)\n\n# MCP Manifest endpoint as per MCP specification\n# Provides metadata about the MCP server\n@mcp.custom_route(\"/.well-known/mcp\", methods=[\"GET\", \"OPTIONS\"])\nasync def mcp_manifest(request: Request) -&gt; JSONResponse:\n    host = request.headers.get(\"host\", \"localhost:8889\")\n    scheme = request.url.scheme or \"http\"\n    base = f\"{scheme}://{host}\"\n    manifest = {\n        \"name\": \"kagent-mcp-server\",\n        \"version\": \"0.1.0\",\n        \"base_url\": base,\n        \"transport\": \"streamable-http\",\n        \"capabilities\": {\n            \"tools\": True,\n            \"prompts\": True,\n            \"resources\": True,\n            \"sampling\": True,\n            \"roots\": True,\n            \"logging\": True\n        },\n        \"endpoints\": {\n            \"manifest\": \"/.well-known/mcp\",\n            \"health\": \"/health\",\n            \"ping\": \"/ping\",\n            \"root\": \"/\",\n            \"negotiate\": \"/negotiate\",\n            \"metadata\": \"/metadata\",\n            \"events\": \"/mcp\",\n            \"tools\": \"/tools\",\n            \"tools_execute\": \"/tools/execute\",\n            \"tools_batch\": \"/tools/batch\",\n            \"tools_stream\": \"/tools/stream\",\n            \"tools_history\": \"/tools/history\",\n            \"prompts\": \"/prompts\",\n            \"resources\": \"/resources\",\n            \"sampling\": \"/sampling\",\n            \"roots\": \"/roots\",\n            \"ollama_status\": \"/ollama/status\",\n        },\n    }\n    return JSONResponse(manifest, headers=HEADERS)\n\n# MCP Negotiation endpoint\n# Clients use this to negotiate connection parameters\n# Supports token-based authentication\n@mcp.custom_route(\"/negotiate\", methods=[\"GET\", \"POST\", \"OPTIONS\"])\nasync def negotiate(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    host = request.headers.get(\"host\", \"localhost:8889\")\n    scheme = request.url.scheme or \"http\"\n    mcp_url = f\"{scheme}://{host}/mcp\"\n\n    # Accept proxy token from query param, X-Proxy-Token header, or Authorization bearer\n    token = request.query_params.get(\"token\") or request.headers.get(\"x-proxy-token\") or request.headers.get(\"X-Proxy-Token\")\n    auth = request.headers.get(\"authorization\") or request.headers.get(\"Authorization\")\n    if not token and auth and auth.lower().startswith(\"bearer \"):\n        token = auth.split(None, 1)[1]\n\n    response = {\n        \"transport\": \"streamable-http\",\n        \"url\": mcp_url,\n    }\n\n    # Include token in response if provided\n    if token:\n        response[\"proxy_token\"] = token\n    else:\n        # When no token is provided, explicitly indicate no auth is required\n        # This helps the Inspector understand it can connect without authentication\n        response[\"requiresAuth\"] = False\n\n    return JSONResponse(response, headers=HEADERS)\n\n# Tools listing endpoint\n# Returns metadata about all registered tools\n# Used by inspectors to discover available tools\n@mcp.custom_route(\"/tools\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def tools_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    # Use the server's list_tools implementation so the inspector sees\n    # the canonical, generated tool metadata instead of a hand-written list.\n    tools = await mcp._list_tools_mcp()\n\n    serializable = []\n    for t in tools:\n        try:\n            serializable.append(t.model_dump())\n        except Exception:\n            try:\n                serializable.append(t.dict())\n            except Exception:\n                serializable.append(str(t))\n\n    return JSONResponse({\"tools\": serializable}, headers=HEADERS)\n\n# Tool execution endpoint - Execute a single tool\n@mcp.custom_route(\"/tools/execute\", methods=[\"POST\", \"OPTIONS\"])\nasync def tool_execute(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        body = await request.json()\n        tool_name = body.get(\"tool\")\n        arguments = body.get(\"arguments\", {})\n\n        if not tool_name:\n            return JSONResponse({\n                \"success\": False,\n                \"error\": \"Missing 'tool' field\"\n            }, headers=HEADERS, status_code=400)\n\n        result = await execute_tool(tool_name, arguments)\n        return JSONResponse(result, headers=HEADERS)\n\n    except Exception as e:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": f\"Execution failed: {str(e)}\"\n        }, headers=HEADERS, status_code=500)\n\n# Batch tool execution endpoint\n@mcp.custom_route(\"/tools/batch\", methods=[\"POST\", \"OPTIONS\"])\nasync def tool_batch_execute(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        body = await request.json()\n        calls = body.get(\"calls\", [])\n\n        if not calls:\n            return JSONResponse({\n                \"success\": False,\n                \"error\": \"Missing 'calls' array\"\n            }, headers=HEADERS, status_code=400)\n\n        results = []\n        for call in calls:\n            tool_name = call.get(\"tool\")\n            arguments = call.get(\"arguments\", {})\n\n            if tool_name:\n                result = await execute_tool(tool_name, arguments)\n                results.append(result)\n            else:\n                results.append({\n                    \"success\": False,\n                    \"error\": \"Missing tool name in call\"\n                })\n\n        return JSONResponse({\n            \"success\": True,\n            \"results\": results,\n            \"total\": len(results)\n        }, headers=HEADERS)\n\n    except Exception as e:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": f\"Batch execution failed: {str(e)}\"\n        }, headers=HEADERS, status_code=500)\n\n# Tool execution history endpoint\n@mcp.custom_route(\"/tools/history\", methods=[\"GET\", \"OPTIONS\"])\nasync def tool_history(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    limit = int(request.query_params.get(\"limit\", 10))\n\n    # Get recent executions\n    executions = list(TOOL_EXECUTIONS.values())\n    executions.sort(key=lambda x: x.get(\"timestamp\", 0), reverse=True)\n\n    return JSONResponse({\n        \"executions\": executions[:limit],\n        \"total\": len(executions)\n    }, headers=HEADERS)\n\n# Get specific execution details\n@mcp.custom_route(\"/tools/execution/{execution_id}\", methods=[\"GET\", \"OPTIONS\"])\nasync def tool_execution_detail(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    execution_id = request.path_params.get(\"execution_id\")\n\n    if execution_id in TOOL_EXECUTIONS:\n        return JSONResponse(TOOL_EXECUTIONS[execution_id], headers=HEADERS)\n    else:\n        return JSONResponse({\n            \"error\": f\"Execution '{execution_id}' not found\"\n        }, headers=HEADERS, status_code=404)\n\n# Streaming tool execution\n@mcp.custom_route(\"/tools/stream\", methods=[\"POST\", \"OPTIONS\"])\nasync def tool_stream_execute(request: Request):\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        body = await request.json()\n        tool_name = body.get(\"tool\")\n        arguments = body.get(\"arguments\", {})\n\n        async def generate_stream():\n            # Send start event\n            yield json.dumps({\n                \"event\": \"start\",\n                \"tool\": tool_name,\n                \"timestamp\": time.time()\n            }) + \"\\n\"\n\n            # Execute tool\n            result = await execute_tool(tool_name, arguments)\n\n            # Send result event\n            yield json.dumps({\n                \"event\": \"result\",\n                \"data\": result\n            }) + \"\\n\"\n\n            # Send end event\n            yield json.dumps({\n                \"event\": \"end\",\n                \"timestamp\": time.time()\n            }) + \"\\n\"\n\n        return StreamingResponse(\n            generate_stream(),\n            media_type=\"application/x-ndjson\",\n            headers=HEADERS\n        )\n\n    except Exception as e:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": f\"Stream execution failed: {str(e)}\"\n        }, headers=HEADERS, status_code=500)\n\n# Prompts listing endpoint\n@mcp.custom_route(\"/prompts\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def prompts_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    prompts = [\n        {\n            \"name\": \"code_review_prompt\",\n            \"description\": \"Generate a code review prompt for the given code\",\n            \"arguments\": [\n                {\"name\": \"code\", \"description\": \"The code to review\", \"required\": True},\n                {\"name\": \"language\", \"description\": \"Programming language\", \"required\": False}\n            ]\n        },\n        {\n            \"name\": \"debug_prompt\",\n            \"description\": \"Generate a debugging prompt\",\n            \"arguments\": [\n                {\"name\": \"error_message\", \"description\": \"The error message\", \"required\": True},\n                {\"name\": \"code_context\", \"description\": \"Relevant code context\", \"required\": False}\n            ]\n        }\n    ]\n\n    return JSONResponse({\"prompts\": prompts}, headers=HEADERS)\n\n# Resources listing endpoint\n@mcp.custom_route(\"/resources\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def resources_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    resources = [\n        {\n            \"uri\": \"mcp://code\",\n            \"name\": \"Server Source Code\",\n            \"description\": \"Returns the source code of this server\",\n            \"mimeType\": \"text/plain\"\n        },\n        {\n            \"uri\": \"mcp://server-info\",\n            \"name\": \"Server Information\",\n            \"description\": \"Returns information about this MCP server\",\n            \"mimeType\": \"text/plain\"\n        }\n    ]\n\n    return JSONResponse({\"resources\": resources}, headers=HEADERS)\n\n# Ping endpoint for connection health checks\n@mcp.custom_route(\"/ping\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def ping(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    return JSONResponse({\n        \"status\": \"ok\",\n        \"timestamp\": __import__('time').time(),\n        \"server\": \"kagent-mcp-server\"\n    }, headers=HEADERS)\n\n# Sampling endpoint - LLM sampling capability using Ollama\n@mcp.custom_route(\"/sampling\", methods=[\"POST\", \"OPTIONS\"])\nasync def sampling(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    body = await request.json() if request.method == \"POST\" else {}\n    prompt = body.get(\"prompt\", \"\")\n    max_tokens = body.get(\"maxTokens\", 100)\n    model = body.get(\"model\", DEFAULT_MODEL)\n\n    try:\n        async with httpx.AsyncClient(timeout=60.0) as client:\n            response = await client.post(\n                f\"{OLLAMA_BASE_URL}/api/generate\",\n                json={\n                    \"model\": model,\n                    \"prompt\": prompt,\n                    \"stream\": False,\n                    \"options\": {\n                        \"num_predict\": max_tokens\n                    }\n                }\n            )\n\n            if response.status_code == 200:\n                result = response.json()\n                return JSONResponse({\n                    \"completion\": result.get(\"response\", \"\"),\n                    \"stopReason\": \"endTurn\" if result.get(\"done\") else \"length\",\n                    \"model\": model,\n                    \"context\": result.get(\"context\", [])\n                }, headers=HEADERS)\n            else:\n                return JSONResponse({\n                    \"error\": f\"Ollama error: {response.status_code}\",\n                    \"completion\": \"\",\n                    \"stopReason\": \"error\",\n                    \"model\": model\n                }, headers=HEADERS, status_code=500)\n    except Exception as e:\n        return JSONResponse({\n            \"error\": f\"Failed to connect to Ollama: {str(e)}\",\n            \"completion\": \"\",\n            \"stopReason\": \"error\",\n            \"model\": model\n        }, headers=HEADERS, status_code=500)\n\n# Roots endpoint - File system roots\n@mcp.custom_route(\"/roots\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def roots_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    import os\n    roots = [\n        {\n            \"uri\": f\"file://{os.getcwd()}\",\n            \"name\": \"Current Directory\"\n        }\n    ]\n\n    return JSONResponse({\"roots\": roots}, headers=HEADERS)\n\n# Ollama status endpoint\n@mcp.custom_route(\"/ollama/status\", methods=[\"GET\", \"OPTIONS\"])\nasync def ollama_status(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        async with httpx.AsyncClient(timeout=5.0) as client:\n            response = await client.get(f\"{OLLAMA_BASE_URL}/api/tags\")\n            if response.status_code == 200:\n                data = response.json()\n                models = data.get(\"models\", [])\n                return JSONResponse({\n                    \"status\": \"connected\",\n                    \"url\": OLLAMA_BASE_URL,\n                    \"models_count\": len(models),\n                    \"models\": [{\n                        \"name\": m.get(\"name\"),\n                        \"size\": m.get(\"size\"),\n                        \"modified\": m.get(\"modified_at\")\n                    } for m in models],\n                    \"default_model\": DEFAULT_MODEL\n                }, headers=HEADERS)\n            else:\n                return JSONResponse({\n                    \"status\": \"error\",\n                    \"url\": OLLAMA_BASE_URL,\n                    \"error\": f\"HTTP {response.status_code}\"\n                }, headers=HEADERS)\n    except Exception as e:\n        return JSONResponse({\n            \"status\": \"disconnected\",\n            \"url\": OLLAMA_BASE_URL,\n            \"error\": str(e)\n        }, headers=HEADERS)\n\n# Server metadata endpoint\n@mcp.custom_route(\"/metadata\", methods=[\"GET\", \"OPTIONS\"])\nasync def metadata(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    return JSONResponse({\n        \"serverInfo\": {\n            \"name\": \"kagent-mcp-server\",\n            \"version\": \"0.1.0\",\n            \"protocolVersion\": \"2024-11-05\"\n        },\n        \"capabilities\": {\n            \"tools\": {\"listChanged\": False},\n            \"prompts\": {\"listChanged\": False},\n            \"resources\": {\"subscribe\": False, \"listChanged\": False},\n            \"logging\": {},\n            \"sampling\": {},\n            \"roots\": {\"listChanged\": False}\n        }\n    }, headers=HEADERS)\n\n# Add CORS middleware to handle preflight requests for all endpoints\n@mcp.custom_route(\"/mcp\", methods=[\"OPTIONS\"])\nasync def mcp_options(request: Request) -&gt; Response:\n    \"\"\"Handle CORS preflight for the MCP endpoint\"\"\"\n    return Response(status_code=200, headers=HEADERS)\n\n# Main entry point to run the MCP server\ndef main():\n    # Start the MCP server with streamable-http transport\n    # Mounted at /mcp path\n    # This will listen on port 8889 as configured above\n    mcp.run(transport=\"streamable-http\", mount_path=\"/mcp\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step01-imports/","title":"Step01","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 1: Imports\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step02-ctor/","title":"Step02","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 1: Imports\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step03-init/","title":"Step03","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 1: Imports\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step04-tools/","title":"Step04","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 4: Register Tools\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step05-tool-handlers/","title":"Step05","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 5: Register Tool Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n    def register_tool_handlers(self):\n        \"\"\"Implement the actual logic for each tool.\"\"\"\n\n        @self.server.call_tool()\n        async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n            \"\"\"\n            Handle tool execution requests.\n            This is called when a client wants to execute a tool.\n            \"\"\"\n            if name == \"calculate\":\n                operation = arguments.get(\"operation\")\n                a = arguments.get(\"a\")\n                b = arguments.get(\"b\")\n\n                if operation == \"add\":\n                    result = a + b\n                elif operation == \"subtract\":\n                    result = a - b\n                elif operation == \"multiply\":\n                    result = a * b\n                elif operation == \"divide\":\n                    if b == 0:\n                        return [TextContent(\n                            type=\"text\",\n                            text=\"Error: Cannot divide by zero\"\n                        )]\n                    result = a / b\n                else:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Unknown operation '{operation}'\"\n                    )]\n\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Result: {a} {operation} {b} = {result}\"\n                )]\n\n            elif name == \"store_data\":\n                key = arguments.get(\"key\")\n                value = arguments.get(\"value\")\n                self.data_store[key] = value\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Stored: {key} = {value}\"\n                )]\n\n            elif name == \"retrieve_data\":\n                key = arguments.get(\"key\")\n                value = self.data_store.get(key)\n                if value is None:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Key '{key}' not found\"\n                    )]\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Retrieved: {key} = {value}\"\n                )]\n\n            elif name == \"echo\":\n                text = arguments.get(\"text\")\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\"\n                )]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown tool '{name}'\"\n                )]\n\n        print(\"Tool handlers implemented\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step06-resources/","title":"Step06","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 6: Register Resources\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n    def register_tool_handlers(self):\n        \"\"\"Implement the actual logic for each tool.\"\"\"\n\n        @self.server.call_tool()\n        async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n            \"\"\"\n            Handle tool execution requests.\n            This is called when a client wants to execute a tool.\n            \"\"\"\n            if name == \"calculate\":\n                operation = arguments.get(\"operation\")\n                a = arguments.get(\"a\")\n                b = arguments.get(\"b\")\n\n                if operation == \"add\":\n                    result = a + b\n                elif operation == \"subtract\":\n                    result = a - b\n                elif operation == \"multiply\":\n                    result = a * b\n                elif operation == \"divide\":\n                    if b == 0:\n                        return [TextContent(\n                            type=\"text\",\n                            text=\"Error: Cannot divide by zero\"\n                        )]\n                    result = a / b\n                else:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Unknown operation '{operation}'\"\n                    )]\n\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Result: {a} {operation} {b} = {result}\"\n                )]\n\n            elif name == \"store_data\":\n                key = arguments.get(\"key\")\n                value = arguments.get(\"value\")\n                self.data_store[key] = value\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Stored: {key} = {value}\"\n                )]\n\n            elif name == \"retrieve_data\":\n                key = arguments.get(\"key\")\n                value = self.data_store.get(key)\n                if value is None:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Key '{key}' not found\"\n                    )]\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Retrieved: {key} = {value}\"\n                )]\n\n            elif name == \"echo\":\n                text = arguments.get(\"text\")\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\"\n                )]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown tool '{name}'\"\n                )]\n\n        print(\"Tool handlers implemented\")\n\n    def register_resources(self):\n        \"\"\"Register resources that clients can access.\"\"\"\n\n        @self.server.list_resources()\n        async def list_resources() -&gt; list[Resource]:\n            \"\"\"\n            Return the list of available resources.\n            This is called when clients want to discover what resources are available.\n            \"\"\"\n            return [\n                Resource(\n                    uri=\"resource://server-info\",\n                    name=\"Server Information\",\n                    description=\"Information about this MCP server\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://data-store\",\n                    name=\"Data Store\",\n                    description=\"Current contents of the data store\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://welcome\",\n                    name=\"Welcome Message\",\n                    description=\"Welcome message and server capabilities\",\n                    mimeType=\"text/plain\"\n                )\n            ]\n\n        print(\"Resources registered: server-info, data-store, welcome\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step07-resource-handlers/","title":"Step07","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 7: Register Resource Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n    def register_tool_handlers(self):\n        \"\"\"Implement the actual logic for each tool.\"\"\"\n\n        @self.server.call_tool()\n        async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n            \"\"\"\n            Handle tool execution requests.\n            This is called when a client wants to execute a tool.\n            \"\"\"\n            if name == \"calculate\":\n                operation = arguments.get(\"operation\")\n                a = arguments.get(\"a\")\n                b = arguments.get(\"b\")\n\n                if operation == \"add\":\n                    result = a + b\n                elif operation == \"subtract\":\n                    result = a - b\n                elif operation == \"multiply\":\n                    result = a * b\n                elif operation == \"divide\":\n                    if b == 0:\n                        return [TextContent(\n                            type=\"text\",\n                            text=\"Error: Cannot divide by zero\"\n                        )]\n                    result = a / b\n                else:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Unknown operation '{operation}'\"\n                    )]\n\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Result: {a} {operation} {b} = {result}\"\n                )]\n\n            elif name == \"store_data\":\n                key = arguments.get(\"key\")\n                value = arguments.get(\"value\")\n                self.data_store[key] = value\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Stored: {key} = {value}\"\n                )]\n\n            elif name == \"retrieve_data\":\n                key = arguments.get(\"key\")\n                value = self.data_store.get(key)\n                if value is None:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Key '{key}' not found\"\n                    )]\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Retrieved: {key} = {value}\"\n                )]\n\n            elif name == \"echo\":\n                text = arguments.get(\"text\")\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\"\n                )]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown tool '{name}'\"\n                )]\n\n        print(\"Tool handlers implemented\")\n\n    def register_resources(self):\n        \"\"\"Register resources that clients can access.\"\"\"\n\n        @self.server.list_resources()\n        async def list_resources() -&gt; list[Resource]:\n            \"\"\"\n            Return the list of available resources.\n            This is called when clients want to discover what resources are available.\n            \"\"\"\n            return [\n                Resource(\n                    uri=\"resource://server-info\",\n                    name=\"Server Information\",\n                    description=\"Information about this MCP server\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://data-store\",\n                    name=\"Data Store\",\n                    description=\"Current contents of the data store\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://welcome\",\n                    name=\"Welcome Message\",\n                    description=\"Welcome message and server capabilities\",\n                    mimeType=\"text/plain\"\n                )\n            ]\n\n        print(\"Resources registered: server-info, data-store, welcome\")\n\n    def register_resource_handlers(self):\n        \"\"\"Implement resource retrieval logic.\"\"\"\n\n        @self.server.read_resource()\n        async def read_resource(uri: str) -&gt; str:\n            \"\"\"\n            Handle resource read requests.\n            This is called when a client wants to read a resource.\n            \"\"\"\n            if uri == \"resource://server-info\":\n                info = {\n                    \"name\": \"complete-mcp-server\",\n                    \"version\": \"1.0.0\",\n                    \"description\": \"A comprehensive MCP server implementation\",\n                    \"capabilities\": {\n                        \"tools\": 4,\n                        \"resources\": 3,\n                        \"prompts\": 2\n                    }\n                }\n                return json.dumps(info, indent=2)\n\n            elif uri == \"resource://data-store\":\n                return json.dumps(self.data_store, indent=2)\n\n            elif uri == \"resource://welcome\":\n                return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n            else:\n                raise ValueError(f\"Unknown resource: {uri}\")\n\n        print(\"Resource handlers implemented\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step08-prompts/","title":"Step08","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 8: Register Prompts\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n    def register_tool_handlers(self):\n        \"\"\"Implement the actual logic for each tool.\"\"\"\n\n        @self.server.call_tool()\n        async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n            \"\"\"\n            Handle tool execution requests.\n            This is called when a client wants to execute a tool.\n            \"\"\"\n            if name == \"calculate\":\n                operation = arguments.get(\"operation\")\n                a = arguments.get(\"a\")\n                b = arguments.get(\"b\")\n\n                if operation == \"add\":\n                    result = a + b\n                elif operation == \"subtract\":\n                    result = a - b\n                elif operation == \"multiply\":\n                    result = a * b\n                elif operation == \"divide\":\n                    if b == 0:\n                        return [TextContent(\n                            type=\"text\",\n                            text=\"Error: Cannot divide by zero\"\n                        )]\n                    result = a / b\n                else:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Unknown operation '{operation}'\"\n                    )]\n\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Result: {a} {operation} {b} = {result}\"\n                )]\n\n            elif name == \"store_data\":\n                key = arguments.get(\"key\")\n                value = arguments.get(\"value\")\n                self.data_store[key] = value\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Stored: {key} = {value}\"\n                )]\n\n            elif name == \"retrieve_data\":\n                key = arguments.get(\"key\")\n                value = self.data_store.get(key)\n                if value is None:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Key '{key}' not found\"\n                    )]\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Retrieved: {key} = {value}\"\n                )]\n\n            elif name == \"echo\":\n                text = arguments.get(\"text\")\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\"\n                )]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown tool '{name}'\"\n                )]\n\n        print(\"Tool handlers implemented\")\n\n    def register_resources(self):\n        \"\"\"Register resources that clients can access.\"\"\"\n\n        @self.server.list_resources()\n        async def list_resources() -&gt; list[Resource]:\n            \"\"\"\n            Return the list of available resources.\n            This is called when clients want to discover what resources are available.\n            \"\"\"\n            return [\n                Resource(\n                    uri=\"resource://server-info\",\n                    name=\"Server Information\",\n                    description=\"Information about this MCP server\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://data-store\",\n                    name=\"Data Store\",\n                    description=\"Current contents of the data store\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://welcome\",\n                    name=\"Welcome Message\",\n                    description=\"Welcome message and server capabilities\",\n                    mimeType=\"text/plain\"\n                )\n            ]\n\n        print(\"Resources registered: server-info, data-store, welcome\")\n\n    def register_resource_handlers(self):\n        \"\"\"Implement resource retrieval logic.\"\"\"\n\n        @self.server.read_resource()\n        async def read_resource(uri: str) -&gt; str:\n            \"\"\"\n            Handle resource read requests.\n            This is called when a client wants to read a resource.\n            \"\"\"\n            if uri == \"resource://server-info\":\n                info = {\n                    \"name\": \"complete-mcp-server\",\n                    \"version\": \"1.0.0\",\n                    \"description\": \"A comprehensive MCP server implementation\",\n                    \"capabilities\": {\n                        \"tools\": 4,\n                        \"resources\": 3,\n                        \"prompts\": 2\n                    }\n                }\n                return json.dumps(info, indent=2)\n\n            elif uri == \"resource://data-store\":\n                return json.dumps(self.data_store, indent=2)\n\n            elif uri == \"resource://welcome\":\n                return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n            else:\n                raise ValueError(f\"Unknown resource: {uri}\")\n\n        print(\"Resource handlers implemented\")\n\n    def register_prompts(self):\n        \"\"\"Register prompt templates for clients.\"\"\"\n\n        @self.server.list_prompts()\n        async def list_prompts() -&gt; list[Prompt]:\n            \"\"\"\n            Return the list of available prompts.\n            This is called when clients want to discover what prompts are available.\n            \"\"\"\n            return [\n                Prompt(\n                    name=\"analyze-data\",\n                    description=\"Analyze data stored in the server\",\n                    arguments=[\n                        {\n                            \"name\": \"key\",\n                            \"description\": \"The key of the data to analyze\",\n                            \"required\": True\n                        }\n                    ]\n                ),\n                Prompt(\n                    name=\"calculate-scenario\",\n                    description=\"Walk through a calculation scenario\",\n                    arguments=[\n                        {\n                            \"name\": \"operation\",\n                            \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n                            \"required\": True\n                        }\n                    ]\n                )\n            ]\n\n        print(\"Prompts registered: analyze-data, calculate-scenario\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step09-prompt-handlers/","title":"Step09","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 9: Register Prompt Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n    def register_tool_handlers(self):\n        \"\"\"Implement the actual logic for each tool.\"\"\"\n\n        @self.server.call_tool()\n        async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n            \"\"\"\n            Handle tool execution requests.\n            This is called when a client wants to execute a tool.\n            \"\"\"\n            if name == \"calculate\":\n                operation = arguments.get(\"operation\")\n                a = arguments.get(\"a\")\n                b = arguments.get(\"b\")\n\n                if operation == \"add\":\n                    result = a + b\n                elif operation == \"subtract\":\n                    result = a - b\n                elif operation == \"multiply\":\n                    result = a * b\n                elif operation == \"divide\":\n                    if b == 0:\n                        return [TextContent(\n                            type=\"text\",\n                            text=\"Error: Cannot divide by zero\"\n                        )]\n                    result = a / b\n                else:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Unknown operation '{operation}'\"\n                    )]\n\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Result: {a} {operation} {b} = {result}\"\n                )]\n\n            elif name == \"store_data\":\n                key = arguments.get(\"key\")\n                value = arguments.get(\"value\")\n                self.data_store[key] = value\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Stored: {key} = {value}\"\n                )]\n\n            elif name == \"retrieve_data\":\n                key = arguments.get(\"key\")\n                value = self.data_store.get(key)\n                if value is None:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Key '{key}' not found\"\n                    )]\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Retrieved: {key} = {value}\"\n                )]\n\n            elif name == \"echo\":\n                text = arguments.get(\"text\")\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\"\n                )]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown tool '{name}'\"\n                )]\n\n        print(\"Tool handlers implemented\")\n\n    def register_resources(self):\n        \"\"\"Register resources that clients can access.\"\"\"\n\n        @self.server.list_resources()\n        async def list_resources() -&gt; list[Resource]:\n            \"\"\"\n            Return the list of available resources.\n            This is called when clients want to discover what resources are available.\n            \"\"\"\n            return [\n                Resource(\n                    uri=\"resource://server-info\",\n                    name=\"Server Information\",\n                    description=\"Information about this MCP server\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://data-store\",\n                    name=\"Data Store\",\n                    description=\"Current contents of the data store\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://welcome\",\n                    name=\"Welcome Message\",\n                    description=\"Welcome message and server capabilities\",\n                    mimeType=\"text/plain\"\n                )\n            ]\n\n        print(\"Resources registered: server-info, data-store, welcome\")\n\n    def register_resource_handlers(self):\n        \"\"\"Implement resource retrieval logic.\"\"\"\n\n        @self.server.read_resource()\n        async def read_resource(uri: str) -&gt; str:\n            \"\"\"\n            Handle resource read requests.\n            This is called when a client wants to read a resource.\n            \"\"\"\n            if uri == \"resource://server-info\":\n                info = {\n                    \"name\": \"complete-mcp-server\",\n                    \"version\": \"1.0.0\",\n                    \"description\": \"A comprehensive MCP server implementation\",\n                    \"capabilities\": {\n                        \"tools\": 4,\n                        \"resources\": 3,\n                        \"prompts\": 2\n                    }\n                }\n                return json.dumps(info, indent=2)\n\n            elif uri == \"resource://data-store\":\n                return json.dumps(self.data_store, indent=2)\n\n            elif uri == \"resource://welcome\":\n                return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n            else:\n                raise ValueError(f\"Unknown resource: {uri}\")\n\n        print(\"Resource handlers implemented\")\n\n    def register_prompts(self):\n        \"\"\"Register prompt templates for clients.\"\"\"\n\n        @self.server.list_prompts()\n        async def list_prompts() -&gt; list[Prompt]:\n            \"\"\"\n            Return the list of available prompts.\n            This is called when clients want to discover what prompts are available.\n            \"\"\"\n            return [\n                Prompt(\n                    name=\"analyze-data\",\n                    description=\"Analyze data stored in the server\",\n                    arguments=[\n                        {\n                            \"name\": \"key\",\n                            \"description\": \"The key of the data to analyze\",\n                            \"required\": True\n                        }\n                    ]\n                ),\n                Prompt(\n                    name=\"calculate-scenario\",\n                    description=\"Walk through a calculation scenario\",\n                    arguments=[\n                        {\n                            \"name\": \"operation\",\n                            \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n                            \"required\": True\n                        }\n                    ]\n                )\n            ]\n\n        print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n    def register_prompt_handlers(self):\n        \"\"\"Implement prompt generation logic.\"\"\"\n\n        @self.server.get_prompt()\n        async def get_prompt(name: str, arguments: dict) -&gt; list[TextContent]:\n            \"\"\"\n            Handle prompt generation requests.\n            This is called when a client wants to get a prompt.\n            \"\"\"\n            if name == \"analyze-data\":\n                key = arguments.get(\"key\", \"unknown\")\n                value = self.data_store.get(key, \"not found\")\n\n                prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            elif name == \"calculate-scenario\":\n                operation = arguments.get(\"operation\", \"add\")\n\n                prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown prompt '{name}'\"\n                )]\n\n        print(\"Prompt handlers implemented\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step10-lifecycle/","title":"Step10","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 10: Lifecycle Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n    def register_tool_handlers(self):\n        \"\"\"Implement the actual logic for each tool.\"\"\"\n\n        @self.server.call_tool()\n        async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n            \"\"\"\n            Handle tool execution requests.\n            This is called when a client wants to execute a tool.\n            \"\"\"\n            if name == \"calculate\":\n                operation = arguments.get(\"operation\")\n                a = arguments.get(\"a\")\n                b = arguments.get(\"b\")\n\n                if operation == \"add\":\n                    result = a + b\n                elif operation == \"subtract\":\n                    result = a - b\n                elif operation == \"multiply\":\n                    result = a * b\n                elif operation == \"divide\":\n                    if b == 0:\n                        return [TextContent(\n                            type=\"text\",\n                            text=\"Error: Cannot divide by zero\"\n                        )]\n                    result = a / b\n                else:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Unknown operation '{operation}'\"\n                    )]\n\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Result: {a} {operation} {b} = {result}\"\n                )]\n\n            elif name == \"store_data\":\n                key = arguments.get(\"key\")\n                value = arguments.get(\"value\")\n                self.data_store[key] = value\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Stored: {key} = {value}\"\n                )]\n\n            elif name == \"retrieve_data\":\n                key = arguments.get(\"key\")\n                value = self.data_store.get(key)\n                if value is None:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Key '{key}' not found\"\n                    )]\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Retrieved: {key} = {value}\"\n                )]\n\n            elif name == \"echo\":\n                text = arguments.get(\"text\")\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\"\n                )]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown tool '{name}'\"\n                )]\n\n        print(\"Tool handlers implemented\")\n\n    def register_resources(self):\n        \"\"\"Register resources that clients can access.\"\"\"\n\n        @self.server.list_resources()\n        async def list_resources() -&gt; list[Resource]:\n            \"\"\"\n            Return the list of available resources.\n            This is called when clients want to discover what resources are available.\n            \"\"\"\n            return [\n                Resource(\n                    uri=\"resource://server-info\",\n                    name=\"Server Information\",\n                    description=\"Information about this MCP server\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://data-store\",\n                    name=\"Data Store\",\n                    description=\"Current contents of the data store\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://welcome\",\n                    name=\"Welcome Message\",\n                    description=\"Welcome message and server capabilities\",\n                    mimeType=\"text/plain\"\n                )\n            ]\n\n        print(\"Resources registered: server-info, data-store, welcome\")\n\n    def register_resource_handlers(self):\n        \"\"\"Implement resource retrieval logic.\"\"\"\n\n        @self.server.read_resource()\n        async def read_resource(uri: str) -&gt; str:\n            \"\"\"\n            Handle resource read requests.\n            This is called when a client wants to read a resource.\n            \"\"\"\n            if uri == \"resource://server-info\":\n                info = {\n                    \"name\": \"complete-mcp-server\",\n                    \"version\": \"1.0.0\",\n                    \"description\": \"A comprehensive MCP server implementation\",\n                    \"capabilities\": {\n                        \"tools\": 4,\n                        \"resources\": 3,\n                        \"prompts\": 2\n                    }\n                }\n                return json.dumps(info, indent=2)\n\n            elif uri == \"resource://data-store\":\n                return json.dumps(self.data_store, indent=2)\n\n            elif uri == \"resource://welcome\":\n                return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n            else:\n                raise ValueError(f\"Unknown resource: {uri}\")\n\n        print(\"Resource handlers implemented\")\n\n    def register_prompts(self):\n        \"\"\"Register prompt templates for clients.\"\"\"\n\n        @self.server.list_prompts()\n        async def list_prompts() -&gt; list[Prompt]:\n            \"\"\"\n            Return the list of available prompts.\n            This is called when clients want to discover what prompts are available.\n            \"\"\"\n            return [\n                Prompt(\n                    name=\"analyze-data\",\n                    description=\"Analyze data stored in the server\",\n                    arguments=[\n                        {\n                            \"name\": \"key\",\n                            \"description\": \"The key of the data to analyze\",\n                            \"required\": True\n                        }\n                    ]\n                ),\n                Prompt(\n                    name=\"calculate-scenario\",\n                    description=\"Walk through a calculation scenario\",\n                    arguments=[\n                        {\n                            \"name\": \"operation\",\n                            \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n                            \"required\": True\n                        }\n                    ]\n                )\n            ]\n\n        print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n    def register_prompt_handlers(self):\n        \"\"\"Implement prompt generation logic.\"\"\"\n\n        @self.server.get_prompt()\n        async def get_prompt(name: str, arguments: dict) -&gt; list[TextContent]:\n            \"\"\"\n            Handle prompt generation requests.\n            This is called when a client wants to get a prompt.\n            \"\"\"\n            if name == \"analyze-data\":\n                key = arguments.get(\"key\", \"unknown\")\n                value = self.data_store.get(key, \"not found\")\n\n                prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            elif name == \"calculate-scenario\":\n                operation = arguments.get(\"operation\", \"add\")\n\n                prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown prompt '{name}'\"\n                )]\n\n        print(\"Prompt handlers implemented\")\n\n    def setup_lifecycle_handlers(self):\n        \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n        # Note: MCP servers typically don't have explicit lifecycle hooks\n        # This is a conceptual method showing where such logic would go\n        print(\"Lifecycle management configured\")\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/step11-main/","title":"Step11","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 11: Main Execution\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Tool,\n    Resource,\n    Prompt,\n    TextContent,\n    ImageContent,\n    EmbeddedResource,\n    GetPromptResult,\n    PromptMessage,\n)\nimport sys\n\nclass CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all protocol features.\n\n    This class demonstrates:\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Request handling\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP Server instance.\"\"\"\n        self.server = Server(\"complete-mcp-server\")\n        self.data_store = {}  # Simple in-memory data storage\n        print(\"Server instance created successfully!\")\n\n    def register_tools(self):\n        \"\"\"Register all available tools with the MCP server.\"\"\"\n\n        @self.server.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            \"\"\"\n            Return the list of available tools.\n            This is called when clients want to discover what tools are available.\n            \"\"\"\n            return [\n                Tool(\n                    name=\"calculate\",\n                    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"operation\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                                \"description\": \"The operation to perform\"\n                            },\n                            \"a\": {\n                                \"type\": \"number\",\n                                \"description\": \"First number\"\n                            },\n                            \"b\": {\n                                \"type\": \"number\",\n                                \"description\": \"Second number\"\n                            }\n                        },\n                        \"required\": [\"operation\", \"a\", \"b\"]\n                    }\n                ),\n                Tool(\n                    name=\"store_data\",\n                    description=\"Store a key-value pair in the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to store\"\n                            },\n                            \"value\": {\n                                \"type\": \"string\",\n                                \"description\": \"The value to store\"\n                            }\n                        },\n                        \"required\": [\"key\", \"value\"]\n                    }\n                ),\n                Tool(\n                    name=\"retrieve_data\",\n                    description=\"Retrieve a value from the server's data store\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"key\": {\n                                \"type\": \"string\",\n                                \"description\": \"The key to retrieve\"\n                            }\n                        },\n                        \"required\": [\"key\"]\n                    }\n                ),\n                Tool(\n                    name=\"echo\",\n                    description=\"Echo back the input text\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"text\": {\n                                \"type\": \"string\",\n                                \"description\": \"Text to echo back\"\n                            }\n                        },\n                        \"required\": [\"text\"]\n                    }\n                )\n            ]\n\n        print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n    def register_tool_handlers(self):\n        \"\"\"Implement the actual logic for each tool.\"\"\"\n\n        @self.server.call_tool()\n        async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n            \"\"\"\n            Handle tool execution requests.\n            This is called when a client wants to execute a tool.\n            \"\"\"\n            if name == \"calculate\":\n                operation = arguments.get(\"operation\")\n                a = arguments.get(\"a\")\n                b = arguments.get(\"b\")\n\n                if operation == \"add\":\n                    result = a + b\n                elif operation == \"subtract\":\n                    result = a - b\n                elif operation == \"multiply\":\n                    result = a * b\n                elif operation == \"divide\":\n                    if b == 0:\n                        return [TextContent(\n                            type=\"text\",\n                            text=\"Error: Cannot divide by zero\"\n                        )]\n                    result = a / b\n                else:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Unknown operation '{operation}'\"\n                    )]\n\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Result: {a} {operation} {b} = {result}\"\n                )]\n\n            elif name == \"store_data\":\n                key = arguments.get(\"key\")\n                value = arguments.get(\"value\")\n                self.data_store[key] = value\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Stored: {key} = {value}\"\n                )]\n\n            elif name == \"retrieve_data\":\n                key = arguments.get(\"key\")\n                value = self.data_store.get(key)\n                if value is None:\n                    return [TextContent(\n                        type=\"text\",\n                        text=f\"Error: Key '{key}' not found\"\n                    )]\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Retrieved: {key} = {value}\"\n                )]\n\n            elif name == \"echo\":\n                text = arguments.get(\"text\")\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\"\n                )]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown tool '{name}'\"\n                )]\n\n        print(\"Tool handlers implemented\")\n\n    def register_resources(self):\n        \"\"\"Register resources that clients can access.\"\"\"\n\n        @self.server.list_resources()\n        async def list_resources() -&gt; list[Resource]:\n            \"\"\"\n            Return the list of available resources.\n            This is called when clients want to discover what resources are available.\n            \"\"\"\n            return [\n                Resource(\n                    uri=\"resource://server-info\",\n                    name=\"Server Information\",\n                    description=\"Information about this MCP server\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://data-store\",\n                    name=\"Data Store\",\n                    description=\"Current contents of the data store\",\n                    mimeType=\"application/json\"\n                ),\n                Resource(\n                    uri=\"resource://welcome\",\n                    name=\"Welcome Message\",\n                    description=\"Welcome message and server capabilities\",\n                    mimeType=\"text/plain\"\n                )\n            ]\n\n        print(\"Resources registered: server-info, data-store, welcome\")\n\n    def register_resource_handlers(self):\n        \"\"\"Implement resource retrieval logic.\"\"\"\n\n        @self.server.read_resource()\n        async def read_resource(uri: str) -&gt; str:\n            \"\"\"\n            Handle resource read requests.\n            This is called when a client wants to read a resource.\n            \"\"\"\n            uri = str(uri)  # Ensure uri is a string\n            if uri == \"resource://server-info\":\n                info = {\n                    \"name\": \"complete-mcp-server\",\n                    \"version\": \"1.0.0\",\n                    \"description\": \"A comprehensive MCP server implementation\",\n                    \"capabilities\": {\n                        \"tools\": 4,\n                        \"resources\": 3,\n                        \"prompts\": 2\n                    }\n                }\n                return json.dumps(info, indent=2)\n\n            elif uri == \"resource://data-store\":\n                return json.dumps(self.data_store, indent=2)\n\n            elif uri == \"resource://welcome\":\n                return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n            else:\n                raise ValueError(f\"Unknown resource: {uri}\")\n\n        print(\"Resource handlers implemented\")\n\n    def register_prompts(self):\n        \"\"\"Register prompt templates for clients.\"\"\"\n\n        @self.server.list_prompts()\n        async def list_prompts() -&gt; list[Prompt]:\n            \"\"\"\n            Return the list of available prompts.\n            This is called when clients want to discover what prompts are available.\n            \"\"\"\n            return [\n                Prompt(\n                    name=\"analyze-data\",\n                    description=\"Analyze data stored in the server\",\n                    arguments=[\n                        {\n                            \"name\": \"key\",\n                            \"description\": \"The key of the data to analyze\",\n                            \"required\": True\n                        }\n                    ]\n                ),\n                Prompt(\n                    name=\"calculate-scenario\",\n                    description=\"Walk through a calculation scenario\",\n                    arguments=[\n                        {\n                            \"name\": \"operation\",\n                            \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n                            \"required\": True\n                        }\n                    ]\n                )\n            ]\n\n        print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n    def register_prompt_handlers(self):\n        \"\"\"Implement prompt generation logic.\"\"\"\n\n        @self.server.get_prompt()\n        async def get_prompt(name: str, arguments: dict) -&gt; GetPromptResult:\n            \"\"\"\n            Handle prompt generation requests.\n            This is called when a client wants to get a prompt.\n            \"\"\"\n            if name == \"analyze-data\":\n                key = arguments.get(\"key\", \"unknown\")\n                value = self.data_store.get(key, \"not found\")\n\n                prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n                return GetPromptResult(\n                    messages=[\n                        PromptMessage(\n                            role=\"user\",\n                            content=TextContent(type=\"text\", text=prompt_text)\n                        )\n                    ]\n                )\n\n            elif name == \"calculate-scenario\":\n                operation = arguments.get(\"operation\", \"add\")\n\n                prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n                return GetPromptResult(\n                    messages=[\n                        PromptMessage(\n                            role=\"user\",\n                            content=TextContent(type=\"text\", text=prompt_text)\n                        )\n                    ]\n                )\n\n            else:\n                # Helper to create error message in correct format\n                return GetPromptResult(\n                    messages=[\n                        PromptMessage(\n                            role=\"user\",\n                            content=TextContent(\n                                type=\"text\",\n                                text=f\"Error: Unknown prompt '{name}'\"\n                            )\n                        )\n                    ]\n                )\n\n        print(\"Prompt handlers implemented\")\n\n    def setup_lifecycle_handlers(self):\n        \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n        # Note: MCP servers typically don't have explicit lifecycle hooks\n        # This is a conceptual method showing where such logic would go\n        print(\"Lifecycle management configured\")\n\n    async def run(self):\n        \"\"\"Run the MCP server.\"\"\"\n        # Initialize everything\n        self.register_tools()\n        self.register_tool_handlers()\n        self.register_resources()\n        self.register_resource_handlers()\n        self.register_prompts()\n        self.register_prompt_handlers()\n        self.setup_lifecycle_handlers()\n\n        # Connect to stdio\n        async with stdio_server() as (read_stream, write_stream):\n            print(\"Server running on stdio...\")\n            await self.server.run(\n                read_stream,\n                write_stream,\n                self.server.create_initialization_options()\n            )\n\nasync def main():\n    \"\"\"Main entry point.\"\"\"\n    server = CompleteMCPServer()\n    await server.run()\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"Server stopped by user\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"Resources/01-MCP-Workflow/test_client/","title":"Test-MCP","text":"<pre><code>#!/bin/bash\n\n# Determine the directory where this script is located\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" &amp;&amp; pwd)\"\nPROJECT_ROOT=\"$SCRIPT_DIR\" # Run from the same directory\n# Define the server script path\nSERVER_SCRIPT=\"${SCRIPT_DIR}/step11-main.md\"\nTEMP_PY=\"${SCRIPT_DIR}/temp_server.py\"\n\n# Navigate to the project root directory\ncd \"$PROJECT_ROOT\"\n\n# Check if the virtual environment exists\nif [ -d \".venv\" ]; then\n  echo \"Activating virtual environment...\"\n  source .venv/bin/activate\nelse\n  echo \"Creating virtual environment...\"\n  python3 -m venv .venv\n  source .venv/bin/activate\n  echo \"Installing requirements...\"\n  pip install -r requirements.txt\nfi\n\nif [ ! -f \"$SERVER_SCRIPT\" ]; then\n  echo \"Error: Server file $SERVER_SCRIPT not found\"\n  exit 1\nfi\n\necho \"Extracting server code from Markdown...\"\npython3 -c 'import sys; c=sys.stdin.read(); s=c.find(\"```python\"); e=c.rfind(\"```\"); print(c[s+9:e] if s!=-1 and e!=-1 else c)' &lt;\"$SERVER_SCRIPT\" &gt;\"$TEMP_PY\"\n\necho \"Starting MCP Inspector with server...\"\necho \"URL should open in your browser shortly...\"\necho \"Press Ctrl+C to stop.\"\n\n# Use the python executable from the virtual environment\nPYTHON_EXEC=\"$PROJECT_ROOT/.venv/bin/python3\"\n\n# Run the MCP Inspector with the temp file\n# Clean up temp file on exit\ntrap 'rm -f \"$TEMP_PY\"' EXIT\n\nnpx @modelcontextprotocol/inspector \"$PYTHON_EXEC\" \"$TEMP_PY\"\n</code></pre>"},{"location":"Tasks/","title":"List of tasks","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/","title":"Task: Install and Setup Roo Code","text":"<ul> <li>This guide outlines the steps to install Roo Code (formerly Cline), configure it with custom instructions and MCP (Model Context Protocol), and demonstrates a usage example with a hypothetical \u201cContext7\u201d MCP server.</li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#1-install-roo-code","title":"1. Install Roo Code","text":"<p>Roo Code is an autonomous coding agent extension for VS Code.</p> <ol> <li>Open VS Code.</li> <li>Go to the Extensions view (Click the square icon on the sidebar or press <code>Cmd+Shift+X</code>).</li> <li>Search for \u201cRoo Code\u201d.</li> <li>Look for the extension published by RooVeterinaryInc (ID: <code>RooVeterinaryInc.roo-cline</code>).</li> <li>Click Install.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#2-setup-roo-code","title":"2. Setup Roo Code","text":"<ol> <li>Once installed, you need to configure Roo Code.</li> <li>Open the Roo Code sidebar by clicking the Roo Code icon on the sidebar.</li> <li>You will see the main Roo Code interface.</li> <li>We will go over the key configuration options during the lecture.</li> <li> <p>Adding API Keys (Use exiting or create new keys as needed) https://aistudio.google.com/api-keys</p> <p></p> <p></p> </li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#3-configuring-roo-code-features","title":"3. Configuring Roo Code Features","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#create-profile","title":"Create Profile","text":"<p>Creating a Profile</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Profile icon (user icon).</li> <li>Click \u201cCreate Profile\u201d.</li> <li>Fill in your details and preferences.</li> <li>Click \u201cSave Profile\u201d.</li> <li>Your profile will help Roo Code tailor its responses to your coding style and preferences.</li> <li>You can create multiple profiles for different projects or coding styles.</li> <li>Switch between profiles as needed.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#api-keys","title":"API Keys","text":"<p>Setting Up API Keys</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Settings (gear icon).</li> <li>Scroll to \u201cAPI Keys\u201d.</li> <li>Enter your API keys for the models you want to use (e.g., OpenAI, Google Gemini).</li> <li>Click \u201cSave\u201d.</li> <li>Roo Code will use these keys to access the respective language models for code generation and assistance.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#modes","title":"Modes","text":"<p>Setting Up Modes</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Settings (gear icon).</li> <li>Scroll to \u201cDefault Mode\u201d.</li> <li>Select your preferred default mode (e.g., Code, Architect, Ask).</li> <li>Click \u201cSave\u201d.</li> <li>This setting determines how Roo Code will approach tasks by default.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#4-advanced-configuration","title":"4. Advanced Configuration","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#mcp-servers","title":"MCP Servers","text":"<ul> <li>MCP (Model Context Protocol) allows Roo Code to connect to external tools and data sources.</li> </ul> <p>Setting Up MCP Servers</p> <ol> <li>In the Roo Code sidebar, click the MCP icon (server icon) or go to Settings &gt; MCP Servers.</li> <li>Click \u201cEdit MCP Settings\u201d (Global or Project).  </li> <li>This will open a JSON file for the MCP settings.</li> <li>Add your MCP servers to the <code>mcpServers</code> object.<ul> <li>Each server configuration includes the command to start the server, arguments, and environment variables if needed.</li> </ul> </li> <li>Save the file. </li> <li>Roo Code will now be able to use these MCP servers for enhanced context and capabilities.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#additional-settings","title":"Additional Settings","text":"<ul> <li> <p>We will cover these in the lecture.</p> Setting Description Auto-Approve Automatically approve Roo Code\u2019s suggested changes. Slash Commands Enable or disable slash commands for quick actions. Context Configure how much file context Roo Code uses when generating code (Tabs, limits etc.). Prompts Customize prompt templates for different modes. </li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#4-adding-custom-instructions","title":"4. Adding Custom Instructions","text":"<ul> <li>Adding custom instructions to Roo Code is a powerful way to enforce coding standards, project context, or specific AI behaviors. </li> <li>There are three primary ways to do this: Project-specific files, the UI (Prompts Tab), and Global configuration.</li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#1-project-specific-instructions-recommended","title":"1. Project-Specific Instructions (Recommended)","text":"<ul> <li>This is the best way to ensure that any developer working on your specific project gets the same AI behavior.</li> </ul> <p>Method A: The <code>.roo/rules/</code> Directory (Modern)</p> <ul> <li> <p>Roo Code now looks for a directory in your project root to load instructions.</p> <p>Setting Up Custom Rules</p> <ul> <li>Create a folder named <code>.roo/rules/</code> in your project\u2019s root directory.  </li> <li>Roo Code will read all files in this directory and apply the instructions when working on the project.   </li> <li>Example filenames:  <pre><code>  coding-standards.md\n  project-context.md\n  api-guidelines.md\n  testing-instructions.md\n</code></pre></li> <li>Add any number of <code>.md</code> (Markdown) files in this directory. <pre><code>  your-project/\n  \u251c\u2500\u2500 .roo/\n  \u2502   \u2514\u2500\u2500 rules/\n  \u2502       \u251c\u2500\u2500 coding-standards.md\n  \u2502       \u251c\u2500\u2500 project-context.md\n  \u2502       \u2514\u2500\u2500 api-guidelines.md\n  \u2514\u2500\u2500 src/\n      \u2514\u2500\u2500 main.py\n\n  # Each file can contain specific instructions or context for Roo Code.      \n</code></pre></li> <li>Example content for <code>coding-standards.md</code>:     <pre><code># Coding Standards\n- Follow PEP 8 for Python code.\n- Use meaningful variable names.\n- Write unit tests for all new features.\n</code></pre></li> <li>This method allows for easy version control and sharing of instructions with your team.</li> <li>Roo Code will automatically pick up changes to these files.</li> </ul> </li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#2-using-the-prompts-tab-in-the-ui-globalquick-edits","title":"2. Using the Prompts Tab in the UI (Global/Quick Edits)","text":"<ul> <li>You can also add custom instructions directly through the Roo Code UI.</li> <li> <p>This method is less ideal for project-specific instructions but can be useful for quick adjustments.</p> <p>Adding Custom Prompts via UI</p> <ul> <li>Open the Roo Code sidebar.</li> <li>Click on the Prompts tab.</li> <li>Here, you can add or edit custom prompts for different modes.</li> <li>Save your changes.</li> </ul> <ul> <li>Roo Code will use these prompts when generating code.</li> </ul> </li> </ul>"}]}