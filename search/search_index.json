{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"explanations/","title":"Explanations","text":"<p>This document provides detailed explanations of key concepts in the MCP (Model Context Protocol) server implementation, including endpoints, function calls, and RAGs (Retrieval-Augmented Generation).</p>"},{"location":"explanations/#endpoints","title":"Endpoints","text":""},{"location":"explanations/#general-meaning-of-endpoints-in-this-mcp-server","title":"General Meaning of Endpoints in This MCP Server","text":"<p>In the context of this MCP (Model Context Protocol) server, the \u201cendpoints\u201d refer to the API routes (URLs) that the server exposes for clients (like MCP inspectors, AI assistants, or other tools) to interact with it. </p> <p>These endpoints are part of the server\u2019s manifest, which is a metadata document that describes the server\u2019s capabilities, transport method (e.g., \u201cstreamable-http\u201d), and available routes. </p> <p>The manifest is served at <code>/.well-known/mcp</code> and helps clients discover and connect to the server.</p> <p>The endpoints follow RESTful conventions and support HTTP methods like GET, POST, and OPTIONS (for CORS preflight). They enable core MCP functionalities such as tool execution, resource access, prompt management, and server health checks. The server uses FastMCP (a framework for building MCP servers) and runs on port 8889 by default. </p> <p>Each endpoint is implemented as a custom route in the code, often with CORS headers for browser-based clients.</p> <p>Below, you\u2019ll find explanations for each endpoint from the manifest, including its purpose, typical HTTP methods, and what it does based on the code implementation. </p> <p>They are grouped logically for clarity.</p>"},{"location":"explanations/#core-server-and-discovery-endpoints","title":"Core Server and Discovery Endpoints","text":"<p>These handle basic server operations, discovery, and connection setup.</p> <ul> <li> <p>manifest (<code>/.well-known/mcp</code>):   Serves the MCP manifest (metadata about the server, including capabilities and all endpoints). Clients use this to understand what the server supports. Handled by <code>mcp_manifest()</code> \u2013 returns JSON with server info, base URL, and endpoint list.</p> </li> <li> <p>health (<code>/health</code>):   Simple health check to confirm the server is running. Returns a plain text response like \u201cMCP Server Running\u201d. Handled by <code>health_check()</code>.</p> </li> <li> <p>ping (<code>/ping</code>):   Connection health check with more details. Returns JSON with status (\u201cok\u201d), timestamp, and server name. Handled by <code>ping()</code>.</p> </li> <li> <p>root (<code>/</code>):   Root endpoint for basic server status. Similar to health, returns \u201cMCP Server Running\u201d. Handled by <code>root_health_check()</code>.</p> </li> <li> <p>negotiate (<code>/negotiate</code>):   Used for connection negotiation (e.g., transport setup and optional authentication via tokens). Clients send tokens here; the server responds with connection details. Handled by <code>negotiate()</code> \u2013 supports proxy tokens from headers or query params.</p> </li> <li> <p>metadata (<code>/metadata</code>):   Provides detailed server metadata, including protocol version and capabilities (e.g., support for tools, prompts). Handled by <code>metadata()</code> \u2013 returns JSON with server info and feature flags.</p> </li> <li> <p>events (<code>/mcp</code>):   The main MCP event stream endpoint for streamable HTTP transport. This is where real-time communication happens (e.g., tool calls, responses). It\u2019s the core mount path for the FastMCP server. Handled by the FastMCP framework\u2019s run method.</p> </li> </ul>"},{"location":"explanations/#tool-related-endpoints","title":"Tool-Related Endpoints","text":"<p>These manage MCP tools (functions the server exposes, like \u201chello\u201d or \u201cadd\u201d).</p> <ul> <li> <p>tools (<code>/tools</code>):   Lists all available tools with metadata (names, descriptions, arguments). Clients use this to discover tools. Handled by <code>tools_list()</code> \u2013 returns JSON with tool details from the server\u2019s <code>list_tools()</code> method.</p> </li> <li> <p>tools_execute (<code>/tools/execute</code>):   Executes a single tool synchronously. Clients send the tool name and arguments; the server runs it and returns the result. Handled by <code>tool_execute()</code> \u2013 validates args, executes via <code>execute_tool()</code>, and tracks executions.</p> </li> <li> <p>tools_batch (<code>/tools/batch</code>):   Executes multiple tools in a batch (array of calls). Useful for efficiency. Handled by <code>tool_batch_execute()</code> \u2013 processes each call and returns results.</p> </li> <li> <p>tools_stream (<code>/tools/stream</code>):   Executes a tool with streaming responses (e.g., for long-running tasks). Returns NDJSON (newline-delimited JSON) events like \u201cstart\u201d, \u201cresult\u201d, and \u201cend\u201d. Handled by <code>tool_stream_execute()</code>.</p> </li> <li> <p>tools_history (<code>/tools/history</code>):   Retrieves execution history for tools (recent runs, with optional limit). Handled by <code>tool_history()</code> \u2013 returns JSON with past executions from <code>TOOL_EXECUTIONS</code>.</p> </li> </ul>"},{"location":"explanations/#prompt-and-resource-endpoints","title":"Prompt and Resource Endpoints","text":"<p>These handle reusable prompts and static resources.</p> <ul> <li> <p>prompts (<code>/prompts</code>):   Lists available prompt templates (e.g., \u201ccode_review_prompt\u201d). Clients can use these for structured interactions. Handled by <code>prompts_list()</code> \u2013 returns JSON with prompt metadata.</p> </li> <li> <p>resources (<code>/resources</code>):   Lists available resources (e.g., server source code or info). Handled by <code>resources_list()</code> \u2013 returns JSON with resource URIs and descriptions.</p> </li> </ul>"},{"location":"explanations/#sampling-and-roots-endpoints","title":"Sampling and Roots Endpoints","text":"<p>These support advanced MCP features like LLM sampling and file system access.</p> <ul> <li> <p>sampling (<code>/sampling</code>):   Provides LLM sampling (text generation) using Ollama. Clients send a prompt; the server generates a response. Handled by <code>sampling()</code> \u2013 integrates with Ollama API for completions.</p> </li> <li> <p>roots (<code>/roots</code>):   Lists file system roots (e.g., the current working directory). Used for file-based operations. Handled by <code>roots_list()</code> \u2013 returns JSON with root URIs.</p> </li> </ul>"},{"location":"explanations/#customollama-specific-endpoint","title":"Custom/Ollama-Specific Endpoint","text":"<ul> <li>ollama_status (<code>/ollama/status</code>):   Checks the status of the connected Ollama instance (local LLM server). Returns model info, connection status, and available models. Handled by <code>ollama_status()</code> \u2013 queries Ollama\u2019s <code>/api/tags</code> endpoint.</li> </ul> <p>All endpoints include CORS headers for cross-origin requests and handle OPTIONS preflights. The server tracks tool executions globally for history/debugging.</p>"},{"location":"explanations/#function-calls","title":"Function Calls","text":""},{"location":"explanations/#what-are-function-calls","title":"What Are Function Calls?","text":"<p>In the context of MCP (Model Context Protocol) and AI systems, function calls (often referred to as \u201ctools\u201d in MCP terminology) are mechanisms that allow AI models or clients to invoke external functions or services dynamically. </p> <p>Instead of generating plain text responses, the AI can decide to call a predefined function with specific arguments, execute it on the server, and incorporate the results into its response. </p> <p>This enables more interactive, tool-augmented AI behaviors, such as performing calculations, querying databases, or interacting with APIs.</p> <p>In this MCP server, tools are essentially function calls exposed via the <code>/tools</code> endpoints. For example, the <code>hello</code> tool is a function that takes a <code>name</code> argument and returns a greeting string.</p>"},{"location":"explanations/#what-do-they-do","title":"What Do They Do?","text":"<p>Function calls allow the AI to extend its capabilities beyond static knowledge. </p> <p>They enable:</p> <ul> <li>Dynamic Execution: The AI can perform real-time actions, like adding numbers or generating text via Ollama.</li> <li>Structured Interactions: Clients (e.g., an AI assistant) can call functions to retrieve data or perform tasks, then use the output in conversations.</li> <li>Modularity: Developers can add new functions without retraining the AI model.</li> <li>Safety and Control: Arguments are validated, and executions are tracked for auditing.</li> </ul> <p>In MCP, tools are registered with decorators like <code>@mcp.tool()</code>, and clients discover them via the <code>/tools</code> endpoint.</p>"},{"location":"explanations/#how-to-set-them-up","title":"How to Set Them Up","text":"<ol> <li> <p>Define the Function: Write a Python function with type hints and a docstring. For example:    <pre><code>@mcp.tool()\ndef my_tool(arg1: str, arg2: int = 0) -&gt; str:\n    \"\"\"Description of what the tool does.\"\"\"\n    # Implementation here\n    return f\"Result: {arg1} and {arg2}\"\n</code></pre></p> <ul> <li>Use <code>@mcp.tool()</code> to register it with FastMCP.</li> <li>Arguments should have types; defaults are optional.</li> </ul> </li> <li> <p>Validation and Execution: The server automatically validates arguments against the function signature (via <code>validate_tool_arguments</code>) and executes it (via <code>execute_tool</code>). Results are tracked in <code>TOOL_EXECUTIONS</code>.</p> </li> <li> <p>Expose via Endpoints: Tools are listed at <code>/tools</code>, executed at <code>/tools/execute</code>, etc. No additional setup needed beyond registration.</p> </li> <li> <p>Testing: Use the <code>/tools/history</code> endpoint to debug executions. Ensure the function handles errors gracefully.</p> </li> <li> <p>Integration with AI: Clients (e.g., via MCP inspectors) can call these functions. For LLM integration, the AI might be prompted to output function call JSON, which the client then executes.</p> </li> </ol> <p>Function calls are asynchronous if the function is a coroutine (<code>async def</code>).</p>"},{"location":"explanations/#rags-retrieval-augmented-generation","title":"RAGs (Retrieval-Augmented Generation)","text":""},{"location":"explanations/#what-are-rags","title":"What Are RAGs?","text":"<p>RAGs stand for Retrieval-Augmented Generation, a technique in AI where an LLM (Large Language Model) retrieves relevant information from external data sources before generating a response. </p> <p>This improves accuracy, reduces hallucinations, and allows the model to access up-to-date or domain-specific knowledge not in its training data. </p> <p>Instead of relying solely on pre-trained knowledge, RAGs \u201caugment\u201d generation with retrieved context.</p> <p>In this MCP server context, RAGs can be implemented using resources (static data) or sampling (dynamic retrieval via Ollama). </p> <p>For example, retrieving code snippets or server info to inform responses.</p>"},{"location":"explanations/#how-do-they-work","title":"How Do They Work?","text":"<ol> <li>Retrieval Phase: When a query is made, the system searches a knowledge base (e.g., documents, databases) for relevant chunks of data.</li> <li>Augmentation: Retrieved data is fed into the LLM\u2019s prompt as context.</li> <li>Generation: The LLM generates a response based on both the query and retrieved data.</li> </ol> <ul> <li> <p>Key components:</p> <ul> <li>Data Sources: Could be files, APIs, or databases.</li> <li>Retriever: Searches and ranks relevant data (e.g., via embeddings or keywords).</li> <li>Generator: The LLM that produces the final output.</li> </ul> </li> </ul> <p>In MCP, resources at <code>/resources</code> can serve as static data sources, while sampling at <code>/sampling</code> can generate augmented responses.</p>"},{"location":"explanations/#how-to-set-them-up_1","title":"How to Set Them Up","text":"<ol> <li> <p>Define Data Sources: Use MCP resources for static data. For example:    <pre><code>@mcp.resource(\"mcp://my-data\")\ndef get_data() -&gt; str:\n    \"\"\"Returns relevant data.\"\"\"\n    return \"Retrieved information here.\"\n</code></pre></p> <ul> <li>Resources are listed at <code>/resources</code> and can be queried by URI.</li> </ul> </li> <li> <p>Implement Retrieval: For dynamic retrieval, integrate with tools or sampling. For instance, use a tool to query a database or API, then pass results to Ollama via <code>/sampling</code>.</p> </li> <li> <p>Augment with Sampling: At <code>/sampling</code>, send a prompt that includes retrieved context:    <pre><code>{\n  \"prompt\": \"Using this data: [retrieved info]. Answer: [query]\",\n  \"model\": \"llama3.2:latest\"\n}\n</code></pre></p> <ul> <li>Ollama generates the response with augmentation.</li> </ul> </li> <li> <p>Full RAG Pipeline:</p> <ul> <li>Client queries the server.</li> <li>Server retrieves data (e.g., via a tool or resource).</li> <li>Data is injected into a prompt.</li> <li>Sampling generates the augmented response.</li> </ul> </li> <li> <p>Tools for RAG: Add tools like <code>search_documents</code> that retrieve data. Combine with prompts for structured queries.</p> </li> <li> <p>Best Practices: Use embeddings (e.g., via Ollama or external services) for semantic search. Cache retrieved data for efficiency. Ensure data sources are secure and up-to-date.</p> </li> </ol> <p>RAGs enhance MCP servers by making them knowledge-aware, useful for applications like chatbots with custom data or code assistants.</p>"},{"location":"explanations/#additional-mcp-inspector-tabs-and-configuration","title":"Additional MCP Inspector Tabs and Configuration","text":"<p>The MCP Inspector provides various tabs that correspond to different capabilities and endpoints in your MCP server. </p> <p>These tabs allow you to test and interact with the server\u2019s features. Below, you\u2019ll find explanations for each tab mentioned (resources, prompts, tools, ping, sampling, elicitations, roots, auth, metadata) and how to configure them in the JSON manifest within <code>mcp02.py</code>.</p> <p>The manifest is defined in the <code>mcp_manifest()</code> function. It includes a <code>\"capabilities\"</code> object (boolean flags indicating support) and an <code>\"endpoints\"</code> object (URL paths). To enable or configure a feature, update these sections accordingly.</p>"},{"location":"explanations/#resources-tab","title":"Resources Tab","text":"<ul> <li>Purpose: Displays static data sources (e.g., files, server info) that clients can access.</li> <li>Configuration: <ul> <li>Set <code>\"resources\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"resources\": \"/resources\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/resources</code> endpoint to list available resources (e.g., URIs like <code>mcp://code</code>).</li> <li>Register resources with <code>@mcp.resource(\"uri\")</code> decorators.</li> </ul> </li> <li>Example: In <code>mcp02.py</code>, resources like <code>get_code()</code> and <code>get_server_info()</code> are registered and listed via <code>/resources</code>.</li> </ul>"},{"location":"explanations/#prompts-tab","title":"Prompts Tab","text":"<ul> <li>Purpose: Shows reusable prompt templates for structured interactions (e.g., code review prompts).</li> <li>Configuration:<ul> <li>Set <code>\"prompts\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"prompts\": \"/prompts\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/prompts</code> endpoint to return a list of prompt metadata.</li> <li>Register prompts with <code>@mcp.prompt()</code> decorators.</li> </ul> </li> <li>Example: Prompts like <code>code_review_prompt()</code> are defined and exposed via <code>/prompts</code>.</li> </ul>"},{"location":"explanations/#tools-tab","title":"Tools Tab","text":"<ul> <li>Purpose: Lists executable functions (tools) that clients can invoke (e.g., <code>hello</code>, <code>add</code>).</li> <li>Configuration:<ul> <li>Set <code>\"tools\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"tools\": \"/tools\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/tools</code> to return tool metadata from <code>mcp.list_tools()</code>.</li> <li>Register tools with <code>@mcp.tool()</code> decorators.</li> </ul> </li> <li>Example: Tools like <code>hello()</code> and <code>add()</code> are registered and discoverable via <code>/tools</code>.</li> </ul>"},{"location":"explanations/#ping-tab","title":"Ping Tab","text":"<ul> <li>Purpose: Tests server connectivity and health with a simple ping.</li> <li>Configuration:<ul> <li>Add <code>\"ping\": \"/ping\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/ping</code> endpoint to return JSON with status, timestamp, and server name.</li> </ul> </li> <li>Example: The <code>ping()</code> function returns <code>{\"status\": \"ok\", ...}</code>.</li> </ul>"},{"location":"explanations/#sampling-tab","title":"Sampling Tab","text":"<ul> <li>Purpose: Allows LLM text generation (e.g., via Ollama) for completions.</li> <li>Configuration:<ul> <li>Set <code>\"sampling\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"sampling\": \"/sampling\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/sampling</code> to accept prompts and return generated text.</li> </ul> </li> <li>Example: Uses Ollama API to generate responses based on input prompts.</li> </ul>"},{"location":"explanations/#elicitations-tab","title":"Elicitations Tab","text":"<ul> <li>Purpose: Likely refers to logging or event elicitation (capturing server events/logs). In MCP, this may map to <code>\"logging\"</code> capability for debugging.</li> <li>Configuration:<ul> <li>Set <code>\"logging\": true</code> in <code>\"capabilities\"</code>.</li> <li>No specific endpoint needed, but ensure logging is enabled in the server framework.</li> </ul> </li> <li>Note: If this refers to \u201cevents,\u201d use the <code>/mcp</code> endpoint for streamable HTTP events.</li> </ul>"},{"location":"explanations/#roots-tab","title":"Roots Tab","text":"<ul> <li>Purpose: Lists file system roots for file-based operations.</li> <li>Configuration:<ul> <li>Set <code>\"roots\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"roots\": \"/roots\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/roots</code> to return root URIs (e.g., current directory).</li> </ul> </li> <li>Example: Returns <code>[{\"uri\": \"file://current/dir\", \"name\": \"Current Directory\"}]</code>.</li> </ul>"},{"location":"explanations/#auth-tab","title":"Auth Tab","text":"<ul> <li>Purpose: Handles authentication (e.g., token-based access).</li> <li>Configuration:<ul> <li>Use the <code>/negotiate</code> endpoint for auth negotiation.</li> <li>Accept tokens via headers (e.g., <code>Authorization: Bearer &lt;token&gt;</code>).</li> <li>In the manifest, no direct flag, but ensure <code>/negotiate</code> supports auth.</li> </ul> </li> <li>Example: The <code>negotiate()</code> function checks for tokens and includes them in responses.</li> </ul>"},{"location":"explanations/#metadata-tab","title":"Metadata Tab","text":"<ul> <li>Purpose: Provides server metadata (version, capabilities, protocol info).</li> <li>Configuration:<ul> <li>Add <code>\"metadata\": \"/metadata\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/metadata</code> to return detailed server info.</li> </ul> </li> <li>Example: Returns JSON with <code>serverInfo</code> and <code>capabilities</code>.</li> </ul> <p>To update the manifest in <code>mcp02.py</code>, edit the <code>manifest</code> dictionary in <code>mcp_manifest()</code>. For instance, to add a new capability, include it in <code>\"capabilities\"</code> and its endpoint in <code>\"endpoints\"</code>. Restart the server after changes.</p>"},{"location":"explanations/#creating-a-personal-custom-rag","title":"Creating a Personal Custom RAG","text":"<p>Retrieval-Augmented Generation (RAG) allows you to build a custom knowledge system by combining data retrieval with LLM generation. </p> <p>Here\u2019s how to create one in your MCP server context:</p>"},{"location":"explanations/#step-1-define-data-sources","title":"Step 1: Define Data Sources","text":"<ul> <li>Static Data: Use MCP resources for fixed content (e.g., documents, code).<ul> <li>Register with <code>@mcp.resource(\"mcp://my-data\")</code>.</li> <li>Store data in files, databases, or variables.</li> </ul> </li> <li>Dynamic Data: Integrate APIs or databases for real-time retrieval.<ul> <li>Create tools to query external sources (e.g., a tool that searches a vector database).</li> </ul> </li> </ul>"},{"location":"explanations/#step-2-implement-retrieval","title":"Step 2: Implement Retrieval","text":"<ul> <li>Simple Retrieval: Use keyword search or basic queries.<ul> <li>Example: A tool that reads from a JSON file or API.</li> </ul> </li> <li>Advanced Retrieval: Use embeddings for semantic search.<ul> <li>Install libraries like <code>sentence-transformers</code> or <code>faiss</code>.</li> <li>Embed your data and queries, then find similar vectors.</li> <li>Example: Store document chunks in a vector DB, retrieve top matches for a query.</li> </ul> </li> </ul>"},{"location":"explanations/#step-3-augment-with-llm","title":"Step 3: Augment with LLM","text":"<ul> <li>Integration: Pass retrieved data into prompts.<ul> <li>Use the <code>/sampling</code> endpoint or a tool like <code>ollama_generate()</code>.</li> <li>Example Prompt: <code>\"Using this data: {retrieved_info}. Answer: {user_query}\"</code>.</li> </ul> </li> <li>Pipeline:<ol> <li>User queries the server.</li> <li>Retrieve relevant data (via tool or resource).</li> <li>Inject data into LLM prompt.</li> <li>Generate response via sampling.</li> </ol> </li> </ul>"},{"location":"explanations/#step-4-set-up-in-mcp-server","title":"Step 4: Set Up in MCP Server","text":"<ul> <li>Add Tools/Resources: Register retrieval functions as tools (e.g., <code>@mcp.tool() def search_docs(query: str)</code>).</li> <li>Configure Endpoints: Ensure <code>/resources</code>, <code>/tools</code>, and <code>/sampling</code> are enabled.</li> <li>Testing: Use the Inspector to test retrieval and generation.</li> </ul>"},{"location":"explanations/#best-practices","title":"Best Practices","text":"<ul> <li>Data Management: Keep data secure and up-to-date.</li> <li>Performance: Cache embeddings; use efficient search.</li> <li>Scalability: For large datasets, use external vector DBs like Pinecone or Weaviate.</li> <li> <p>Example Code Snippet:</p> <pre><code>@mcp.tool()\ndef rag_query(query: str) -&gt; str:\n    # Retrieve data (simplified)\n    retrieved = \"Relevant info from your data source.\"\n    # Augment and generate\n    prompt = f\"Data: {retrieved}. Query: {query}\"\n    return ollama_generate(prompt)\n</code></pre> </li> </ul> <p>This creates a personal RAG tailored to your data, enhancing AI responses with custom knowledge.</p>"},{"location":"explanations/#adding-clients-internal-llm","title":"Adding Clients (Internal LLM)","text":"<p>To integrate an internal Large Language Model (LLM) as a client with your MCP server, you need to set up a client that can connect to the MCP server, discover its capabilities, and invoke tools, resources, or prompts. </p> <p>This allows the LLM to augment its responses using the server\u2019s functionalities, such as executing custom tools or retrieving data.</p>"},{"location":"explanations/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>MCP Server Running: Ensure your MCP server is running and accessible (e.g., at <code>http://localhost:8889</code>).</p> </li> <li> <p>Client Library: Use an MCP-compatible client library. For Python, you can use libraries like <code>mcp-client</code> or integrate with frameworks like LangChain or LlamaIndex that support MCP. For other languages, check for MCP SDKs (e.g., Node.js MCP clients).</p> </li> <li> <p>LLM Setup: Have an internal LLM ready, such as Ollama running locally, or another model that supports tool calling (e.g., via function calling APIs).</p> </li> <li> <p>Information Needed:</p> <ul> <li>Server Base URL: The full URL where the MCP server is hosted (e.g., <code>http://localhost:8889</code>).</li> <li>Manifest URL: The URL to the manifest endpoint (e.g., <code>http://localhost:8889/.well-known/mcp</code>). This provides metadata about the server\u2019s capabilities and endpoints.</li> <li>Authentication Token (optional): If the server requires authentication, obtain a token (e.g., via the <code>/negotiate</code> endpoint). Pass it in headers like <code>Authorization: Bearer &lt;token&gt;</code>.</li> <li>Transport Method: Confirm the server uses \u201cstreamable-http\u201d transport, as indicated in the manifest.</li> </ul> </li> </ul>"},{"location":"explanations/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Install Required Libraries:</p> <ul> <li>For Python: Install the MCP client library if available (e.g., <code>pip install mcp-client</code> or similar). If using LangChain, install <code>langchain</code> and MCP integrations.</li> <li>For other setups: Ensure your LLM framework supports MCP (e.g., LlamaIndex has MCP connectors).</li> </ul> </li> <li> <p>Fetch the Server Manifest:</p> <ul> <li>Make a GET request to the manifest URL to retrieve the server\u2019s metadata.</li> <li>Example (using curl): <code>curl http://localhost:8889/.well-known/mcp</code></li> <li>Parse the JSON response to understand available endpoints (e.g., <code>/tools</code>, <code>/resources</code>, <code>/sampling</code>) and capabilities (e.g., <code>tools: true</code>).</li> </ul> </li> <li> <p>Initialize the MCP Client:</p> <ul> <li>In your client code, create an MCP client instance and connect to the server.</li> <li>Provide the base URL and any authentication details.</li> <li> <p>Example in Python (pseudo-code):</p> <pre><code>from mcp_client import MCPClient  # Assuming a library exists\n\nclient = MCPClient(base_url=\"http://localhost:8889\", auth_token=\"your_token_if_needed\")\nclient.connect()\n</code></pre> </li> </ul> </li> <li> <p>Discover Capabilities:</p> <ul> <li>Use the client to list available tools, resources, or prompts.</li> <li>Example: Call <code>client.list_tools()</code> to get tool metadata, which includes names, descriptions, and argument schemas.</li> </ul> </li> <li> <p>Integrate with the Internal LLM:</p> <ul> <li>Configure the LLM to use the MCP client for tool calling.</li> <li>For LLMs that support function calling (e.g., GPT models or local models via libraries), map MCP tools to callable functions.</li> <li>Example workflow:<ul> <li>When the LLM generates a response, check if it needs to call a tool (e.g., based on a prompt or decision).</li> <li>Use the MCP client to execute the tool: <code>result = client.call_tool(\"tool_name\", args={\"arg1\": \"value\"})</code>.</li> <li>Feed the result back into the LLM\u2019s context for the final response.</li> </ul> </li> <li>For Ollama or similar local LLMs, you may need a wrapper script that handles the tool calling logic.</li> </ul> </li> <li> <p>Handle Sampling or Generation:</p> <ul> <li>If the LLM needs to generate text augmented by the server, use the <code>/sampling</code> endpoint via the client.</li> <li>Example: <code>response = client.sample(prompt=\"Your prompt here\", model=\"llama3.2:latest\")</code>.</li> </ul> </li> <li> <p>Test the Integration:</p> <ul> <li>Run a test query where the LLM invokes a tool (e.g., the \u201chello\u201d tool).</li> <li>Verify that the client connects, executes the tool, and the LLM incorporates the result.</li> <li>Check logs on the server side (e.g., via <code>/tools/history</code>) for executions.</li> </ul> </li> <li> <p>Handle Errors and Authentication:</p> <ul> <li>Implement error handling for failed connections or tool executions.</li> <li>If authentication fails, renegotiate tokens via <code>/negotiate</code>.</li> <li>Ensure CORS and security settings allow the client to connect.</li> </ul> </li> <li> <p>Advanced Setup:</p> <ul> <li>For streaming: Use the <code>/tools/stream</code> endpoint for real-time tool execution.</li> <li>For batch operations: Call multiple tools at once via <code>/tools/batch</code>.</li> <li>Integrate with prompts: Use <code>/prompts</code> to retrieve structured prompts for the LLM.</li> </ul> </li> </ol> <p>By following these steps, your internal LLM can act as an MCP client, leveraging the server\u2019s tools and resources to provide more capable and context-aware responses. </p> <p>If using a specific LLM framework, refer to its documentation for MCP integration details.</p>"},{"location":"labs/","title":"MCP Labs - Learning Series","text":"<ul> <li>Welcome to the Model Context Protocol (MCP) hands-on learning series! </li> <li>This comprehensive set of labs will take you from MCP fundamentals to building production-ready MCP servers.</li> <li>Here you\u2019ll Learn and Build Model Context Protocol (MCP) from Scratch</li> <li>Whether you\u2019re new to MCP or looking to deepen your understanding, this learning series will take you from fundamentals to building production-ready MCP servers.</li> </ul>"},{"location":"labs/#what-youll-learn","title":"What You\u2019ll Learn","text":"<p>Through these 6 progressive labs, you\u2019ll master:</p> Topic Description MCP Architecture Understanding and mastering the client-server model and core concepts Server Development Building MCP servers from scratch with TypeScript using the official SDK Tools Implementation Creating sophisticated tools that interact with external systems and developing functions that LLMs can call to perform actions Resource Management Exposing contextual data through MCP resources that LLMs can read and reference Prompt Engineering Building reusable prompt templates for common tasks Production Deployment Applying best practices for real-world applications"},{"location":"labs/#labs-overview","title":"Labs Overview","text":""},{"location":"labs/#lab-1-mcp-fundamentals","title":"Lab 1: MCP Fundamentals","text":"<p>Get started with the basics! Learn what MCP is, why it exists, and understand its architecture and core components.</p> <p>Topics:</p> <ul> <li>What is MCP and the problem it solves</li> <li>Client-server architecture</li> <li>Core capabilities: Tools, Resources, and Prompts</li> <li>MCP communication model and lifecycle</li> <li>Common use cases</li> </ul>"},{"location":"labs/#lab-2-building-your-first-mcp-server","title":"Lab 2: Building Your First MCP Server","text":"<p>Build a complete, working MCP server from the ground up.</p> <p>Topics:</p> <ul> <li>Project setup with Node.js and TypeScript</li> <li>Implementing the MCP protocol</li> <li>Creating your first tool</li> <li>Testing with MCP Inspector</li> <li>Connecting to Claude Desktop</li> </ul>"},{"location":"labs/#lab-3-implementing-mcp-tools","title":"Lab 3: Implementing MCP Tools","text":"<p>Master the art of creating sophisticated, production-ready tools.</p> <p>Topics:</p> <ul> <li>Advanced input validation with JSON Schema</li> <li>Real-world tool examples (Weather API, File operations, Database queries)</li> <li>Returning rich content types</li> <li>Error handling patterns</li> <li>Performance optimization and caching</li> </ul>"},{"location":"labs/#lab-4-working-with-mcp-resources","title":"Lab 4: Working with MCP Resources","text":"<p>Learn to expose contextual data that LLMs can read and reference.</p> <p>Topics:</p> <ul> <li>Understanding tools vs. resources</li> <li>Implementing different resource types</li> <li>Resource URI schemes and templates</li> <li>Resource subscriptions for live updates</li> <li>Combining tools and resources</li> </ul>"},{"location":"labs/#lab-5-mcp-prompts-and-complete-integration","title":"Lab 5: MCP Prompts and Complete Integration","text":"<p>Complete your MCP education with prompts and production best practices.</p> <p>Topics:</p> <ul> <li>Creating reusable prompt templates</li> <li>Embedding resources in prompts</li> <li>Building a complete server with all capabilities</li> <li>Production deployment and configuration</li> <li>Debugging and troubleshooting</li> </ul>"},{"location":"labs/#lab-6-k-agent-integration","title":"Lab 6: K-Agent Integration","text":"<p>Implement a specialized MCP server (K-Agent) that interacts with Kubernetes clusters to provide AI-driven log collection and analysis.</p> <p>Topics:</p> <ul> <li>MCP server architecture for Kubernetes</li> <li>Secure communication with Kubernetes API</li> <li>Implementing tools for pod discovery and log retrieval</li> <li>Collecting and structuring logs for LLM consumption</li> <li>Containerizing and deploying the K-Agent server</li> </ul>"},{"location":"labs/#ready-to-begin","title":"Ready to Begin?","text":"<p>Start with Lab 1: MCP Fundamentals \u2192</p> <p>Let\u2019s build something amazing with MCP!</p>"},{"location":"resources/","title":"MCP Server Examples","text":"<p>This section provides complete, working examples of MCP servers in both TypeScript and Python. These examples demonstrate the core concepts of MCP server development and can be used as starting points for your own implementations.</p>"},{"location":"resources/#typescript-mcp-server-example","title":"TypeScript MCP Server Example","text":""},{"location":"resources/#complete-mcp-server-with-tools-resources-and-prompts","title":"Complete MCP Server with Tools, Resources, and Prompts","text":"<pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { readFileSync } from \"fs\";\nimport fetch from \"node-fetch\";\n\nclass MCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"example-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // Tools handlers\n    this.server.setRequestHandler(\"tools/list\", async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"calculate\",\n            description: \"Perform basic arithmetic operations\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                operation: {\n                  type: \"string\",\n                  enum: [\"add\", \"subtract\", \"multiply\", \"divide\"]\n                },\n                a: { type: \"number\" },\n                b: { type: \"number\" }\n              },\n              required: [\"operation\", \"a\", \"b\"]\n            }\n          },\n          {\n            name: \"get_weather\",\n            description: \"Get current weather for a city\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: { type: \"string\" }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"read_file\",\n            description: \"Read contents of a file\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                path: { type: \"string\" }\n              },\n              required: [\"path\"]\n            }\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"calculate\":\n          return this.handleCalculate(args);\n        case \"get_weather\":\n          return this.handleWeather(args);\n        case \"read_file\":\n          return this.handleReadFile(args);\n        default:\n          throw new Error(`Unknown tool: ${name}`);\n      }\n    });\n\n    // Resources handlers\n    this.server.setRequestHandler(\"resources/list\", async () =&gt; {\n      return {\n        resources: [\n          {\n            uri: \"file://server-info\",\n            name: \"Server Information\",\n            description: \"Information about this MCP server\",\n            mimeType: \"application/json\"\n          },\n          {\n            uri: \"file://system-status\",\n            name: \"System Status\",\n            description: \"Current system status and metrics\",\n            mimeType: \"application/json\"\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n      const { uri } = request.params;\n\n      switch (uri) {\n        case \"file://server-info\":\n          return {\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                name: \"Example MCP Server\",\n                version: \"1.0.0\",\n                capabilities: [\"tools\", \"resources\", \"prompts\"],\n                uptime: process.uptime()\n              }, null, 2)\n            }]\n          };\n        case \"file://system-status\":\n          return {\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                platform: process.platform,\n                nodeVersion: process.version,\n                memory: process.memoryUsage(),\n                cpuUsage: process.cpuUsage()\n              }, null, 2)\n            }]\n          };\n        default:\n          throw new Error(`Resource not found: ${uri}`);\n      }\n    });\n\n    // Prompts handlers\n    this.server.setRequestHandler(\"prompts/list\", async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"code_review\",\n            description: \"Review code for best practices and improvements\",\n            arguments: [\n              {\n                name: \"code\",\n                description: \"The code to review\",\n                required: true\n              },\n              {\n                name: \"language\",\n                description: \"Programming language\",\n                required: false\n              }\n            ]\n          },\n          {\n            name: \"debug_help\",\n            description: \"Get help debugging an issue\",\n            arguments: [\n              {\n                name: \"problem\",\n                description: \"Description of the problem\",\n                required: true\n              },\n              {\n                name: \"code\",\n                description: \"Relevant code snippet\",\n                required: false\n              }\n            ]\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"code_review\":\n          return {\n            description: \"Code Review Assistant\",\n            messages: [\n              {\n                role: \"user\",\n                content: {\n                  type: \"text\",\n                  text: `Please review the following ${args.language || 'code'} for best practices, potential bugs, and improvements:\\n\\n${args.code}\\n\\nPlease provide:\\n1. Code quality assessment\\n2. Potential issues or bugs\\n3. Suggestions for improvement\\n4. Best practices recommendations`\n                }\n              }\n            ]\n          };\n        case \"debug_help\":\n          return {\n            description: \"Debugging Assistant\",\n            messages: [\n              {\n                role: \"user\",\n                content: {\n                  type: \"text\",\n                  text: `I'm experiencing this problem: ${args.problem}\\n\\n${args.code ? `Here's the relevant code:\\n${args.code}\\n` : ''}\\n\\nPlease help me:\\n1. Understand what might be causing this issue\\n2. Suggest debugging steps\\n3. Provide potential solutions\\n4. Recommend best practices to avoid similar issues`\n                }\n              }\n            ]\n          };\n        default:\n          throw new Error(`Unknown prompt: ${name}`);\n      }\n    });\n  }\n\n  private handleCalculate(args: any) {\n    const { operation, a, b } = args;\n    let result: number;\n\n    switch (operation) {\n      case \"add\":\n        result = a + b;\n        break;\n      case \"subtract\":\n        result = a - b;\n        break;\n      case \"multiply\":\n        result = a * b;\n        break;\n      case \"divide\":\n        if (b === 0) throw new Error(\"Division by zero\");\n        result = a / b;\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Result: ${result}`\n      }]\n    };\n  }\n\n  private async handleWeather(args: any) {\n    const { city } = args;\n    const apiKey = process.env.WEATHER_API_KEY;\n\n    if (!apiKey) {\n      throw new Error(\"Weather API key not configured\");\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${city}&amp;appid=${apiKey}&amp;units=metric`\n      );\n\n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Weather in ${city}: ${data.weather[0].description}, ${data.main.temp}\u00b0C`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Weather fetch failed: ${error.message}`);\n    }\n  }\n\n  private handleReadFile(args: any) {\n    const { path } = args;\n\n    try {\n      const content = readFileSync(path, \"utf-8\");\n      return {\n        content: [{\n          type: \"text\",\n          text: content\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n\n  async start() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"MCP Server started\");\n  }\n}\n\n// Start the server\nconst server = new MCPServer();\nserver.start().catch(console.error);\n</code></pre>"},{"location":"resources/#packagejson-for-typescript-mcp-server","title":"package.json for TypeScript MCP Server","text":"<pre><code>{\n  \"name\": \"example-mcp-server-ts\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Example MCP server in TypeScript\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\",\n    \"node-fetch\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre>"},{"location":"resources/#tsconfigjson","title":"tsconfig.json","text":"<pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre>"},{"location":"resources/#python-mcp-server-example","title":"Python MCP Server Example","text":""},{"location":"resources/#complete-mcp-server-with-tools-resources-and-prompts_1","title":"Complete MCP Server with Tools, Resources, and Prompts","text":"<pre><code>#!/usr/bin/env python3\n\nimport asyncio\nimport json\nimport os\nimport sys\nfrom typing import Any, Dict, List\nimport httpx\nfrom mcp import Tool, types\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\n\nserver = Server(\"example-mcp-server\")\n\n@server.list_tools()\nasync def list_tools() -&gt; List[Tool]:\n    \"\"\"List available tools.\"\"\"\n    return [\n        Tool(\n            name=\"calculate\",\n            description=\"Perform basic arithmetic operations\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"operation\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"]\n                    },\n                    \"a\": {\"type\": \"number\"},\n                    \"b\": {\"type\": \"number\"}\n                },\n                \"required\": [\"operation\", \"a\", \"b\"]\n            }\n        ),\n        Tool(\n            name=\"get_weather\",\n            description=\"Get current weather for a city\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"city\": {\"type\": \"string\"}\n                },\n                \"required\": [\"city\"]\n            }\n        ),\n        Tool(\n            name=\"read_file\",\n            description=\"Read contents of a file\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\"type\": \"string\"}\n                },\n                \"required\": [\"path\"]\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    if name == \"calculate\":\n        return await handle_calculate(arguments)\n    elif name == \"get_weather\":\n        return await handle_weather(arguments)\n    elif name == \"read_file\":\n        return await handle_read_file(arguments)\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n\nasync def handle_calculate(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle calculator tool.\"\"\"\n    operation = args[\"operation\"]\n    a = args[\"a\"]\n    b = args[\"b\"]\n\n    if operation == \"add\":\n        result = a + b\n    elif operation == \"subtract\":\n        result = a - b\n    elif operation == \"multiply\":\n        result = a * b\n    elif operation == \"divide\":\n        if b == 0:\n            raise ValueError(\"Division by zero\")\n        result = a / b\n    else:\n        raise ValueError(f\"Unknown operation: {operation}\")\n\n    return [types.TextContent(type=\"text\", text=f\"Result: {result}\")]\n\nasync def handle_weather(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle weather tool.\"\"\"\n    city = args[\"city\"]\n    api_key = os.getenv(\"WEATHER_API_KEY\")\n\n    if not api_key:\n        raise ValueError(\"Weather API key not configured\")\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            f\"https://api.openweathermap.org/data/2.5/weather?q={city}&amp;appid={api_key}&amp;units=metric\"\n        )\n\n        if response.status_code != 200:\n            raise ValueError(f\"Weather API error: {response.status_code}\")\n\n        data = response.json()\n        weather_desc = data[\"weather\"][0][\"description\"]\n        temp = data[\"main\"][\"temp\"]\n\n        return [types.TextContent(\n            type=\"text\",\n            text=f\"Weather in {city}: {weather_desc}, {temp}\u00b0C\"\n        )]\n\nasync def handle_read_file(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle file reading tool.\"\"\"\n    path = args[\"path\"]\n\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        return [types.TextContent(type=\"text\", text=content)]\n    except Exception as e:\n        raise ValueError(f\"Failed to read file: {e}\")\n\n@server.list_resources()\nasync def list_resources() -&gt; List[types.Resource]:\n    \"\"\"List available resources.\"\"\"\n    return [\n        types.Resource(\n            uri=\"file://server-info\",\n            name=\"Server Information\",\n            description=\"Information about this MCP server\",\n            mimeType=\"application/json\"\n        ),\n        types.Resource(\n            uri=\"file://system-status\",\n            name=\"System Status\",\n            description=\"Current system status and metrics\",\n            mimeType=\"application/json\"\n        )\n    ]\n\n@server.read_resource()\nasync def read_resource(uri: str) -&gt; str:\n    \"\"\"Read resource content.\"\"\"\n    if uri == \"file://server-info\":\n        import psutil\n        import time\n\n        info = {\n            \"name\": \"Example MCP Server\",\n            \"version\": \"1.0.0\",\n            \"capabilities\": [\"tools\", \"resources\", \"prompts\"],\n            \"uptime\": time.time() - psutil.boot_time()\n        }\n        return json.dumps(info, indent=2)\n\n    elif uri == \"file://system-status\":\n        import psutil\n\n        status = {\n            \"cpu_percent\": psutil.cpu_percent(interval=1),\n            \"memory\": {\n                \"total\": psutil.virtual_memory().total,\n                \"available\": psutil.virtual_memory().available,\n                \"percent\": psutil.virtual_memory().percent\n            },\n            \"disk\": {\n                \"total\": psutil.disk_usage('/').total,\n                \"free\": psutil.disk_usage('/').free,\n                \"percent\": psutil.disk_usage('/').percent\n            }\n        }\n        return json.dumps(status, indent=2)\n\n    else:\n        raise ValueError(f\"Resource not found: {uri}\")\n\n@server.list_prompts()\nasync def list_prompts() -&gt; List[types.Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        types.Prompt(\n            name=\"code_review\",\n            description=\"Review code for best practices and improvements\",\n            arguments=[\n                types.PromptArgument(\n                    name=\"code\",\n                    description=\"The code to review\",\n                    required=True\n                ),\n                types.PromptArgument(\n                    name=\"language\",\n                    description=\"Programming language\",\n                    required=False\n                )\n            ]\n        ),\n        types.Prompt(\n            name=\"debug_help\",\n            description=\"Get help debugging an issue\",\n            arguments=[\n                types.PromptArgument(\n                    name=\"problem\",\n                    description=\"Description of the problem\",\n                    required=True\n                ),\n                types.PromptArgument(\n                    name=\"code\",\n                    description=\"Relevant code snippet\",\n                    required=False\n                )\n            ]\n        )\n    ]\n\n@server.get_prompt()\nasync def get_prompt(name: str, arguments: Dict[str, Any]) -&gt; types.GetPromptResult:\n    \"\"\"Get prompt content.\"\"\"\n    if name == \"code_review\":\n        code = arguments.get(\"code\", \"\")\n        language = arguments.get(\"language\", \"\")\n\n        return types.GetPromptResult(\n            description=\"Code Review Assistant\",\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(\n                        type=\"text\",\n                        text=f\"\"\"Please review the following {language or 'code'} for best practices, potential bugs, and improvements:\n\n{code}\n\nPlease provide:\n1. Code quality assessment\n2. Potential issues or bugs\n3. Suggestions for improvement\n4. Best practices recommendations\"\"\"\n                    )\n                )\n            ]\n        )\n\n    elif name == \"debug_help\":\n        problem = arguments.get(\"problem\", \"\")\n        code = arguments.get(\"code\", \"\")\n\n        content = f\"I'm experiencing this problem: {problem}\\n\\n\"\n        if code:\n            content += f\"Here's the relevant code:\\n{code}\\n\\n\"\n\n        content += \"\"\"Please help me:\n1. Understand what might be causing this issue\n2. Suggest debugging steps\n3. Provide potential solutions\n4. Recommend best practices to avoid similar issues\"\"\"\n\n        return types.GetPromptResult(\n            description=\"Debugging Assistant\",\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(type=\"text\", text=content)\n                )\n            ]\n        )\n\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\nasync def main():\n    \"\"\"Main server function.\"\"\"\n    async with stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            server.create_initialization_options()\n        )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"resources/#requirementstxt-for-python-mcp-server","title":"requirements.txt for Python MCP Server","text":"<pre><code>mcp&gt;=0.1.0\nhttpx&gt;=0.25.0\npsutil&gt;=5.9.0\n</code></pre>"},{"location":"resources/#pyprojecttoml-alternative-to-requirementstxt","title":"pyproject.toml (Alternative to requirements.txt)","text":"<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"example-mcp-server-py\"\nversion = \"1.0.0\"\ndescription = \"Example MCP server in Python\"\ndependencies = [\n    \"mcp&gt;=0.1.0\",\n    \"httpx&gt;=0.25.0\",\n    \"psutil&gt;=5.9.0\"\n]\n\n[project.scripts]\nmcp-server = \"main:main\"\n\n[tool.setuptools]\npackages = [\".\"]\n</code></pre>"},{"location":"resources/#running-the-examples","title":"Running the Examples","text":""},{"location":"resources/#typescript-server","title":"TypeScript Server","text":"<pre><code># Install dependencies\nnpm install\n\n# Build the server\nnpm run build\n\n# Run the server\nnpm start\n</code></pre>"},{"location":"resources/#python-server","title":"Python Server","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Run the server\npython server.py\n</code></pre>"},{"location":"resources/#configuration-for-roo-code","title":"Configuration for Roo Code","text":"<p>To use these servers with Roo Code, add them to your MCP configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"typescript-server\": {\n      \"command\": \"node\",\n      \"args\": [\"/path/to/typescript-server/dist/index.js\"]\n    },\n    \"python-server\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/python-server/server.py\"]\n    }\n  }\n}\n</code></pre>"},{"location":"resources/#key-differences-typescript-vs-python","title":"Key Differences: TypeScript vs Python","text":""},{"location":"resources/#typescript-advantages","title":"TypeScript Advantages:","text":"<ul> <li>Strong typing and compile-time error checking</li> <li>Rich ecosystem and tooling</li> <li>Better IDE support</li> <li>More mature MCP SDK</li> </ul>"},{"location":"resources/#python-advantages","title":"Python Advantages:","text":"<ul> <li>Simpler syntax and faster development</li> <li>Great for data processing and AI/ML integration</li> <li>Extensive scientific computing libraries</li> <li>Easier deployment in some environments</li> </ul> <p>Both implementations provide the same MCP functionality and can be used interchangeably based on your project requirements and preferences.</p>"},{"location":"welcome/","title":"Welcome","text":"<p>Getting Started Tip</p> <ul> <li>Choose the preferred way to run the labs. </li> <li>If you encounter any issues, please check the documentation or ask for assistance.</li> </ul> <p></p>"},{"location":"welcome/#k8s-mcp-k-agent-workshop","title":"K8S - MCP (K-Agent Workshop)","text":""},{"location":"welcome/#intro","title":"Intro","text":"<ul> <li>This tutorial is a custom made workshop for teaching AI In focus on MCP development.</li> <li>The lab is based upon K-Agent framework through hands-on labs designed as practical exercises.</li> <li>Each lab is packaged in its own folder and includes the files, manifests, and assets required to complete the lab.</li> <li>Every lab folder includes a <code>README</code> that describes the lab\u2019s objectives, tasks, and how to verify the solution.</li> <li>The K-Agent Labs are a series of Kubernetes and MCP automation exercises designed to teach Model Context Protocol skills &amp; features.</li> <li>The inspiration for this project is to provide practical learning experiences for K-Agent and MCP.</li> </ul>"},{"location":"welcome/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TD\n    A[K-Agent Labs] --&gt; B[MCP Server]\n    B --&gt; C[Kubernetes Cluster]\n    C --&gt; D[Pods &amp; Services]\n    B --&gt; E[AI Models]</code></pre>"},{"location":"welcome/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>This tutorial will test your <code>Kubernetes</code>, <code>MCP</code>, and <code>Python</code> skills.</li> <li>You should be familiar with the following topics:<ul> <li>Basic Docker and container concepts</li> <li>Kubernetes fundamentals (pods, deployments, services)</li> <li>Basic knowledge of YAML</li> <li>Node.js or Python programming basics</li> </ul> </li> <li>For advanced Labs: <ul> <li><code>MCP</code> protocol basics</li> <li><code>Kubernetes</code> advanced concepts (RBAC, ConfigMaps, Secrets)</li> <li><code>GCP</code> (Google Cloud Platform) basics</li> </ul> </li> </ul>"},{"location":"welcome/#required-tools","title":"Required Tools","text":"<p>Before You Begin</p> <ul> <li>Ensure you have the the above tools, permissions to run <code>Docker</code> commands &amp;&amp; <code>Kubernetes</code>  on your system.</li> <li>Enjoy, and don\u2019t forget to star the project on GitHub!</li> </ul>"},{"location":"welcome/#visual-studio-code","title":"Visual Studio Code","text":"<p>An integrated development environment (IDE) for coding, debugging, and version control.</p>"},{"location":"welcome/#python-3","title":"Python 3","text":"<p>A versatile programming language essential for scripting and building MCP servers.</p>"},{"location":"welcome/#nodejs","title":"Node.js","text":"<p>A JavaScript runtime for building scalable network applications and MCP tools.</p>"},{"location":"welcome/#git","title":"Git","text":"<p>A version control system for tracking changes in source code during development.</p>"},{"location":"welcome/#docker","title":"Docker","text":"<p>A platform for developing, shipping, and running applications in containers.</p>"},{"location":"welcome/#kubernetes-kubectl","title":"Kubernetes (kubectl)","text":"<p>A command-line tool for deploying and managing containerized applications on Kubernetes clusters.</p>"},{"location":"welcome/#ollama","title":"Ollama","text":"<p>A tool for running large language models locally for AI assistance.</p>"},{"location":"welcome/#mcp-inspector","title":"MCP Inspector","text":"<p>A utility for inspecting and debugging MCP protocol interactions.</p>"},{"location":"welcome/#preface","title":"Preface","text":""},{"location":"welcome/#what-is-k-agent","title":"What is K-Agent?","text":"<ul> <li><code>K-Agent</code> is a Kubernetes-native tool to write <code>Model Context Protocol</code> (<code>MCP</code>) server(s), tool(s) and more.</li> <li><code>K-Agent</code> enables AI assistants to interact with Kubernetes clusters and cloud services through standardized tools.</li> <li><code>K-Agent</code> provides a set of MCP tools for cluster management, monitoring, and operations.</li> <li><code>K-Agent</code> framework supports multiple transport protocols: stdio, HTTP, and WebSocket.</li> <li><code>K-Agent</code> can be deployed as a containerized service in Kubernetes or run locally for development.</li> </ul>"},{"location":"welcome/#what-is-mcp","title":"What is MCP","text":"<ul> <li><code>MCP</code> - Model Context Protocol</li> <li><code>MCP</code> is an open standard protocol for connecting AI assistants to external tools and data sources.</li> <li><code>MCP</code> defines a standard way for AI models to discover, invoke, and interact with tools.</li> <li><code>MCP</code> uses JSON-RPC 2.0 protocol over various transports (stdio, HTTP, WebSocket).</li> <li><code>MCP</code> enables AI assistants to perform actions beyond text generation, such as API calls, database queries, and system operations.</li> </ul>"},{"location":"welcome/#how-does-k-agent-work","title":"How Does <code>K-Agent</code> Work","text":"<ul> <li><code>K-Agent</code> acts as an <code>MCP server</code> that exposes <code>Kubernetes</code> and <code>cloud management capabilities</code> as tools.</li> <li>AI assistants connect to <code>K-Agent</code> using the <code>MCP protocol</code>.</li> <li><code>K-Agent</code> translates MCP tool invocations into <code>Kubernetes API</code> calls or <code>cloud service</code> operations.</li> <li>Results are returned to the AI assistant in a structured format.</li> </ul>"},{"location":"welcome/#k-agent-architecture-flow","title":"K-Agent Architecture Flow","text":"<pre><code>flowchart TD\n    assistant[AI Assistant] --&gt;|MCP tool request| kagent[K-Agent MCP Server]\n    kagent --&gt; toolRouter[K-Agent Tool Router]\n    toolRouter --&gt;|kubeclient| k8s[Kubernetes API]\n    toolRouter --&gt;|cloud sdk| clouds[Cloud Providers]\n    kagent --&gt;|context updates| datastore[State &amp; Context Store]\n    datastore --&gt;|observability| observ[Logs &amp; Metrics]\n    k8s --&gt;|responses| kagent\n    clouds --&gt;|responses| kagent\n    kagent --&gt;|MCP response| assistant\n    subgraph cluster [Kubernetes Cluster]\n        direction LR\n        k8s\n        datastore\n        observ\n    end</code></pre>"},{"location":"welcome/#how-tdo-we-use-this-k-agent-labs","title":"How tDo we use this K-Agent Labs","text":"<ul> <li>Here\u2019s a brief overview of how this <code>K-Agent Labs</code> work:</li> </ul> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <ul> <li>The K-Agent Labs are designed for practical learning with a focus on hands-on experience.</li> <li>They guide you from MCP basics to production-ready deployments.</li> <li>Labs can be completed in any supported environment (Docker Desktop, Minikube, Kind, GKE).</li> </ul>"},{"location":"welcome/#lab-structure","title":"Lab Structure","text":"<ul> <li>Each <code>lab</code> is a self-contained learning module with README, demo scripts, and resources.</li> <li>Labs build upon each other (piled), starting with MCP basics and progressing to production deployments.</li> <li>Each lab includes hands-on exercises and verification steps.</li> </ul>"},{"location":"welcome/#environment","title":"Environment","text":"<ul> <li>Refer to the \u201cEnvironment Setup\u201d section for detailed instructions.</li> <li>The environment is consistent across all platforms (macOS, Linux, Windows).</li> <li>Automated scripts initialize clusters and deploy resources.</li> </ul>"},{"location":"welcome/#progressive-learning","title":"Progressive Learning","text":"<ul> <li> <p>Start with MCP fundamentals and simple tools.</p> </li> <li> <p>Progress through TypeScript and Python MCP server development.</p> </li> <li> <p>Learn Kubernetes deployment and management.</p> </li> </ul>"},{"location":"welcome/#hands-on-practice","title":"Hands-On Practice","text":"<ul> <li> <p>Each lab includes executable demo scripts for automation.</p> </li> <li> <p>Verify your work with provided test scripts.</p> </li> <li> <p>Build real-world MCP tools that interact with Kubernetes.</p> </li> </ul>"},{"location":"001-mcp-basics/","title":"Lab 001 - MCP Basics","text":"<ul> <li>In this lab, you\u2019ll learn about the Model Context Protocol (MCP), the communication standard that enables AI assistants to interact with external tools and services. </li> <li>You\u2019ll explore MCP concepts, test simple tools, and understand the protocol structure.</li> <li> <p>This lab uses the MCP server included in the K-Agent labs environment.</p> <p>Prerequisites</p> <ul> <li>Make sure you have completed Lab 000 - Environment Setup before starting this lab.</li> </ul> </li> </ul>"},{"location":"001-mcp-basics/#what-youll-learn","title":"What you\u2019ll learn:","text":"<ul> <li>Understanding Model Context Protocol (MCP) architecture</li> <li>MCP server and client communication</li> <li>Tool definitions and JSON schemas</li> <li>Testing MCP tools with stdio transport</li> </ul>"},{"location":"001-mcp-basics/#01-what-is-mcp","title":"01. What is MCP?","text":"<ul> <li>The Model Context Protocol (MCP) is an open protocol that standardizes how AI applications interact with external data sources and tools. </li> <li>It defines a structured way for AI assistants (clients) to discover, call, and receive responses from tools (servers) using JSON-RPC over various transport layers.</li> <li>MCP is designed to be flexible and extensible, allowing developers to create custom tools that can be easily integrated with different AI models.</li> </ul>"},{"location":"001-mcp-basics/#what-does-mcp-offer","title":"What does MCP offer?","text":""},{"location":"001-mcp-basics/#standardized-communication","title":"Standardized Communication","text":"<p>AI assistants can work with any MCP-compatible tool</p>"},{"location":"001-mcp-basics/#tool-discovery","title":"Tool Discovery","text":"<p>Clients can discover available tools from servers</p>"},{"location":"001-mcp-basics/#structured-interaction","title":"Structured Interaction","text":"<p>Well-defined input/output schemas using JSON</p>"},{"location":"001-mcp-basics/#standardized-communication_1","title":"Standardized Communication","text":"<p>AI assistants can work with any MCP-compatible tool</p>"},{"location":"001-mcp-basics/#tool-discovery_1","title":"Tool Discovery","text":"<p>Clients can discover available tools from servers</p>"},{"location":"001-mcp-basics/#structured-interaction_1","title":"Structured Interaction","text":"<p>Well-defined input/output schemas using JSON</p>"},{"location":"001-mcp-basics/#multiple-transports","title":"Multiple Transports","text":"<p>Supports stdio, HTTP, WebSocket</p>"},{"location":"001-mcp-basics/#k-agent-architecture-flow","title":"K-Agent Architecture Flow","text":"<pre><code>flowchart TD\n    assistant[AI Assistant] --&gt;|MCP tool request| kagent[K-Agent MCP Server]\n    kagent --&gt; toolRouter[K-Agent Tool Router]\n    toolRouter --&gt;|kubeclient| k8s[Kubernetes API]\n    toolRouter --&gt;|cloud sdk| clouds[Cloud Providers]\n    kagent --&gt;|context updates| datastore[State &amp; Context Store]\n    datastore --&gt;|observability| observ[Logs &amp; Metrics]\n    k8s --&gt;|responses| kagent\n    clouds --&gt;|responses| kagent\n    kagent --&gt;|MCP response| assistant\n    subgraph cluster [Kubernetes Cluster]\n        direction LR\n        k8s\n        datastore\n        observ\n    end</code></pre>"},{"location":"001-mcp-basics/#02-mcp-components","title":"02. MCP Components","text":""},{"location":"001-mcp-basics/#mcp-server","title":"MCP Server","text":""},{"location":"001-mcp-basics/#exposes-toolsresources-to-clients","title":"Exposes tools/resources to clients","text":"<ul> <li>Provides a standardized interface for tool interaction</li> <li>Allows AI assistants to discover and call tools</li> <li>Manages tool lifecycle and execution</li> <li>Handles tool errors and retries</li> </ul>"},{"location":"001-mcp-basics/#implements-the-mcp-protocol","title":"Implements the MCP protocol","text":"<ul> <li>Follows JSON-RPC 2.0 specification</li> <li>Supports multiple transport layers (stdio, HTTP, WebSocket)</li> <li>Manages tool schemas and validation</li> <li>Supports tool discovery and listing</li> <li>Provides structured responses</li> </ul>"},{"location":"001-mcp-basics/#typical-mcp-server-features","title":"Typical MCP Server Features","text":"<ul> <li>Runs as a standalone process or service</li> <li>Can be deployed locally or in the cloud</li> <li>Can run in containers or serverless environments</li> <li>Scales based on demand</li> <li>Monitors tool usage and performance</li> <li>Logs tool interactions for auditing</li> <li>Supports authentication and authorization</li> <li>Integrates with AI assistants and applications</li> <li>Defines tool schemas (inputs/outputs)</li> <li>Handles tool execution</li> </ul>"},{"location":"001-mcp-basics/#mcp-server-notes","title":"MCP Server Notes","text":"<ul> <li>Communicates via transport layer (stdio, HTTP, WebSocket)</li> <li>Typically runs as a local process or container</li> <li>In K-Agent, the MCP server exposes Kubernetes and cloud management tools.</li> <li>The server listens for incoming MCP requests from AI assistants and executes the requested tools.</li> <li>In our lab The server translates MCP tool calls into Kubernetes API calls or cloud service operations.</li> <li>The server returns structured responses back to the AI assistant.</li> <li>The server can also update context/state in a datastore for persistent information.</li> <li>The server is implemented using the MCP SDK, which simplifies tool definition and communication handling.</li> <li>The server supports multiple transport layers, allowing it to communicate with different types of AI assistants.</li> </ul>"},{"location":"001-mcp-basics/#mcp-client","title":"MCP Client","text":""},{"location":"001-mcp-basics/#general-mcp-client-features","title":"General MCP Client Features","text":"<ul> <li>Discovers available tools from MCP servers</li> <li>Sends tool call requests with parameters</li> <li>Receives and processes tool responses</li> <li>Manages tool invocation lifecycle</li> <li>Handles errors and retries</li> <li>Typically embedded in remote AI assistants (Claude, ChatGPT, etc.) or local models (Ollama, etc.)</li> </ul>"},{"location":"001-mcp-basics/#the-host-application","title":"The Host Application","text":"<ul> <li>The <code>Client</code> is often part of a Host Application (like VS Code, Claude Desktop, or a CLI).</li> <li>The Host manages the connection to the MCP Server.</li> <li>It provides the user interface for interacting with the AI.</li> <li>It handles permissions (asking the user before running a tool).</li> </ul>"},{"location":"001-mcp-basics/#client-capabilities","title":"Client Capabilities","text":"Capability Description Sampling The server can request the client to sample an LLM (generate text). Roots The client can tell the server which files/folders are accessible. Notifications The client can receive notifications from the server (e.g. logs, progress). Context Updates The client can send context/state updates to the server. Authentication The client can provide authentication tokens/credentials to the server. Transport The client supports multiple transport layers (stdio, HTTP, WebSocket). Error Handling The client manages errors and retries for tool calls. Tool Discovery The client can list available tools from the server. Tool Invocation The client can call tools with parameters and receive structured responses. Logging The client can log tool interactions for auditing and debugging."},{"location":"001-mcp-basics/#transport-layer-mcp-communication","title":"Transport Layer - MCP Communication","text":"<ul> <li>MCP supports multiple transport mechanisms:</li> </ul> Protocol Description <code>stdio</code> Standard input/output (used in K-Agent) <code>HTTP</code> RESTful API communication <code>WebSocket</code> Real-time bidirectional communication <code>gRPC</code> High-performance RPC framework <code>MQTT</code> Lightweight messaging protocol <code>Custom</code> Any custom transport implementation"},{"location":"001-mcp-basics/#mcp-communication-flow","title":"MCP Communication Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant S as Server\n\n    C-&gt;&gt;S: 1. Discover available tools\n    C-&gt;&gt;S: 2. Send tool call request (parameters)\n    Note over S: 3. Validate request against schema\n    Note over S: 4. Execute tool logic\n    S--&gt;&gt;C: 5. Return structured response\n    Note over C: 6. Process response &amp; continue interaction</code></pre>"},{"location":"001-mcp-basics/#03-mcp-tool-structure","title":"03. MCP Tool Structure","text":"<ul> <li>An MCP tool consists of:</li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul>"},{"location":"001-mcp-basics/#tool-definition","title":"Tool Definition","text":"<ul> <li>Metadata about the tool (name, description)</li> <li>Input schema defining parameters</li> <li>Output schema defining response structure</li> <li>Versioning information</li> <li>Dependencies and requirements</li> <li>Authentication requirements</li> <li>Rate limiting information</li> <li>Error handling strategies</li> </ul>"},{"location":"001-mcp-basics/#tool-handler","title":"Tool Handler","text":"<ul> <li>Function that implements the tool\u2019s logic</li> <li>Receives input parameters</li> <li>Performs the tool\u2019s operation</li> <li>Returns structured output</li> <li>Handles errors and exceptions</li> <li>Logs execution details</li> <li>Manages state/context if needed</li> </ul>"},{"location":"001-mcp-basics/#tool-execution-flow","title":"Tool Execution Flow","text":"<ul> <li>Client discovers tool from server</li> <li>Client sends tool call request with parameters</li> <li>Server validates request against tool schema</li> <li>Server invokes tool handler with parameters</li> <li>Tool handler executes logic and returns response</li> <li>Server sends structured response back to client</li> </ul>"},{"location":"001-mcp-basics/#input-schema","title":"Input Schema","text":"<ul> <li>Defines expected parameters for the tool</li> <li>Uses JSON Schema format</li> <li>Specifies data types, required fields, and descriptions</li> <li>Enables validation of incoming requests</li> <li>Facilitates client-side form generation</li> <li>Supports complex nested structures</li> <li>Allows default values and constraints</li> <li>Enhances interoperability between clients and servers</li> </ul>"},{"location":"001-mcp-basics/#examples","title":"Examples:","text":"<ul> <li> <p>Tool Definition:</p> <pre><code>{\n  name: \"hello\",\n  description: \"Returns a greeting message\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      name: {\n        type: \"string\",\n        description: \"Name to greet\"\n      }\n    },\n    required: [\"name\"]\n  }\n}\n</code></pre> </li> <li> <p>Tool Handler:</p> <pre><code>async function handleHello(args: { name: string }) {\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Hello, ${args.name}!`\n      }\n    ]\n  };\n}\n</code></pre> </li> </ul>"},{"location":"001-mcp-basics/#04-k-agent-mcp-server-overview","title":"04. K-Agent MCP Server Overview","text":"<ul> <li>Let\u2019s examine the MCP server included in the labs environment.</li> <li>We will use all the tools locally, but we also have the option to use Docker.</li> <li>The Example MCP server is implemented in TypeScript using the MCP SDK.</li> <li> <p>It listens for MCP requests over stdio.</p> </li> <li> <p>The server implements two simple tools:</p> </li> <li> <p>hello: Greets a user by name</p> </li> <li>add: Adds two numbers</li> </ul>"},{"location":"001-mcp-basics/#05-testing-mcp-tools-ts","title":"05. Testing MCP Tools (TS)","text":""},{"location":"001-mcp-basics/#using-mcp-inspector","title":"Using MCP Inspector","text":"<ul> <li>MCP Inspector is a tool for testing MCP servers interactively.</li> </ul> <pre><code># Install mcp-inspector (if not already installed)\nnpm install -g @modelcontextprotocol/inspector\n\n# Start the MCP Inspector with the TS code\nnpx @modelcontextprotocol/inspector node ./build/index.js\n</code></pre> <p>MCP Inspector UI</p> <ul> <li>MCP Inspector will start a web interface at <code>http://localhost:6274</code></li> <li>You can also test tools programmatically using the examples below.</li> </ul> <p>Step-by-step MCP Inspector Testing:</p> <ol> <li> <p>Get the Authentication Token    When you start MCP Inspector, the terminal displays:</p> <pre><code>\ud83d\udd11 Session token: [long-token-string]\n\n\ud83d\udd17 Open inspector with token pre-filled:\n    http://localhost:6274/?MCP_PROXY_AUTH_TOKEN=[token]\n</code></pre> </li> <li> <p>Copy the Authentication URL    Copy the complete URL with the token (the second line starting with <code>http://</code>)</p> </li> <li> <p>Open MCP Inspector in Your Browser    Paste the complete URL from step 2 into your browser. You\u2019ll be authenticated immediately.</p> </li> <li> <p>Configure the Server Connection    In the MCP Inspector interface:</p> <ul> <li>Verify the \u201cTransport\u201d is set to <code>stdio</code> (NOT http or streamable-http)</li> <li>You\u2019ll see a \u201cCommand\u201d field - it should already show: <code>node</code></li> <li>look for the \u201cArgument\u201d field - it should show: <code>/app/build/index.js</code></li> <li>Click the \u201cConnect\u201d button</li> <li>Wait for the status to show \u201cConnected\u201d with a green indicator</li> </ul> </li> <li> <p>Explore Available Tools:</p> <ul> <li>Once connected, click on the \u201cTools\u201d tab at the top of the interface, and the on \u201cList Tools\u201d button</li> <li>You\u2019ll see a list of available tools from your MCP server:<ul> <li><code>hello</code>: Returns a friendly greeting message</li> <li><code>add</code>: Adds two numbers together</li> </ul> </li> </ul> </li> <li> <p>Test the Hello Tool </p> <ul> <li>Click the <code>hello</code> tool from the list</li> <li>You\u2019ll see an input form for the tool\u2019s parameters</li> <li>In the name field, enter: <code>K-Agent User</code></li> <li>Click \u201cRun Tool\u201d</li> <li>Expected Result - You should see:<ul> <li>Tool Result: Success</li> <li>Message: <code>Hello, K-Agent User! Welcome to K-Agent Labs.</code></li> </ul> </li> </ul> </li> <li> <p>Test the Add Tool  </p> <ul> <li>In the Tools tab, find and click the <code>add</code> tool</li> <li>You\u2019ll see input fields for two parameters:<ul> <li>a: Enter <code>5</code></li> <li>b: Enter <code>3</code></li> </ul> </li> <li>Click \u201cRun Tool\u201d</li> <li>Expected Result: You should see:<ul> <li>Tool Result: Success</li> <li>Message: <code>The sum of 5 and 3 is 8</code></li> </ul> </li> </ul> </li> </ol> <p>Authentication Required</p> <ul> <li>The MCP Inspector requires authentication by default. </li> <li>Always use the URL with the token (shown in the terminal when you start the inspector), or manually enter the token in the Configuration settings. </li> <li>If you forget the token, restart the MCP Inspector to generate a new one.</li> </ul> <p>Disabling Authentication (Development Only)</p> <p>Y* ou can disable authentication by setting the <code>DANGEROUSLY_OMIT_AUTH=true</code> environment variable: <pre><code>DANGEROUSLY_OMIT_AUTH=true npx @modelcontextprotocol/inspector node /app/build/index.js\n</code></pre> \u26a0\ufe0f WARNING: This is dangerous and should ONLY be used in isolated development environments, never in production or when exposed to the internet.</p> <p>Keep MCP Inspector Running</p> <ul> <li>Make sure the MCP Inspector command (<code>npx @modelcontextprotocol/inspector node /app/build/index.js</code>) is still running in your terminal. </li> <li>If the connection fails or you see errors, restart the command in the container.</li> </ul> <p>Interactive Testing</p> <ul> <li>The MCP Inspector provides a user-friendly web interface to test your MCP server without writing code. </li> <li>This is perfect for debugging and understanding how MCP tools work before integrating them with AI assistants.</li> </ul> <p>Understanding MCP Inspector Output</p> <ul> <li>The Inspector displays tool results in a readable format. </li> <li>Internally, MCP uses JSON-RPC 2.0 protocol with structured responses, but the UI shows you the human-readable content. </li> <li>For JSON view, see the \u201cHistory\u201d section below the UI</li> </ul>"},{"location":"001-mcp-basics/#testing-tools-via-command-line","title":"Testing Tools via Command Line","text":"<p>Let\u2019s test the MCP tools using a simple Node.js script.</p> <p>Running Multiple Sessions</p> <p>You can run this command-line test while keeping the MCP Inspector running. The script creates its own MCP server process, so it won\u2019t interfere with the Inspector.</p> <p>Create test script:</p> <pre><code># Open a new terminal and connect to the container\ndocker exec -it kagent-controller bash\n\n# Inside the container, create and run the test script\ncat &gt; /labs-scripts/test-index.js &lt;&lt; 'EOF'\nconst { spawn } = require('child_process');\n\n// Start MCP server process\nconst mcpServer = spawn('node', ['/app/build/index.js']);\n\nlet responseData = '';\n\n// Send ListTools request\nconst listToolsRequest = {\n  jsonrpc: \"2.0\",\n  id: 1,\n  method: \"tools/list\",\n  params: {}\n};\n\n// Send request to server\nmcpServer.stdin.write(JSON.stringify(listToolsRequest) + '\\n');\n\n// Collect response\nmcpServer.stdout.on('data', (data) =&gt; {\n  responseData += data.toString();\n  console.log('Server response:', data.toString());\n});\n\n// Wait and send tool call\nsetTimeout(() =&gt; {\n  const toolCallRequest = {\n    jsonrpc: \"2.0\",\n    id: 2,\n    method: \"tools/call\",\n    params: {\n      name: \"hello\",\n      arguments: {\n        name: \"K-Agent User\"\n      }\n    }\n  };\n\n  mcpServer.stdin.write(JSON.stringify(toolCallRequest) + '\\n');\n}, 1000);\n\n// Cleanup after 3 seconds\nsetTimeout(() =&gt; {\n  mcpServer.kill();\n  process.exit(0);\n}, 3000);\nEOF\n\n# Run the test\nnode /labs-scripts/test-index.js\n</code></pre> <p>Expected Output</p> <p>When you run this script, you should see JSON-RPC responses from the MCP server, showing the raw protocol communication that happens behind the scenes in MCP Inspector.</p>"},{"location":"001-mcp-basics/#06-understanding-json-rpc-protocol","title":"06. Understanding JSON-RPC Protocol","text":"<ul> <li>MCP uses JSON-RPC 2.0 for communication. </li> <li>Every request/response follows this structure:</li> </ul>"},{"location":"001-mcp-basics/#request-format","title":"Request Format","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"hello\",\n    \"arguments\": {\n      \"name\": \"Alice\"\n    }\n  }\n}\n</code></pre>"},{"location":"001-mcp-basics/#response-format","title":"Response Format","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Hello, Alice!\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"001-mcp-basics/#07-hands-on-exercise","title":"07. Hands-on Exercise","text":"<p>Hands-on JSON-RPC Testing</p> <ul> <li>These exercises provide direct interaction with the MCP server using JSON-RPC protocol over stdio. </li> <li>This gives you a deeper understanding of how MCP communication works at the protocol level.</li> </ul>"},{"location":"001-mcp-basics/#exercise-1-list-available-tools","title":"Exercise 1: List Available Tools","text":"<p>Test listing tools from the MCP server using direct JSON-RPC communication:</p> <pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Inside the container, create a test script\ncat &gt; /labs-scripts/test-list-tools.js &lt;&lt; 'EOF'\nconst { spawn } = require(\"child_process\");\n\nconsole.log(\"Starting MCP server test...\");\n\ntry {\n  // Start MCP server\n  const server = spawn(\"node\", [\"/app/build/index.js\"], {\n    stdio: [\"pipe\", \"pipe\", \"pipe\"]\n  });\n\n  console.log(\"Server spawned, PID:\", server.pid);\n\n  server.stdout.on(\"data\", (data) =&gt; {\n    console.log(\"RESPONSE:\", data.toString().trim());\n  });\n\n  server.stderr.on(\"data\", (data) =&gt; {\n    console.log(\"SERVER:\", data.toString().trim());\n  });\n\n  // Send tools/list request\n  const listRequest = {\n    jsonrpc: \"2.0\",\n    id: 1,\n    method: \"tools/list\",\n    params: {}\n  };\n\n  setTimeout(() =&gt; {\n    console.log(\"Sending:\", JSON.stringify(listRequest));\n    server.stdin.write(JSON.stringify(listRequest) + \"\\n\");\n  }, 1000);\n\n  // Exit after 5 seconds\n  setTimeout(() =&gt; {\n    server.kill();\n    process.exit(0);\n  }, 5000);\n\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\nEOF\n\n# Run the test\nnode /labs-scripts/test-list-tools.js\n</code></pre> <p>Expected Output: <pre><code>Starting MCP server test...\nServer spawned, PID: 18211\nSERVER: K-Agent MCP Server running on stdio\nSending: {\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/list\",\"params\":{}}\nRESPONSE: {\"result\":{\"tools\":[{\"name\":\"hello\",\"description\":\"Returns a friendly greeting message\",\"inputSchema\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Name to greet\"}},\"required\":[\"name\"]}},{\"name\":\"add\",\"description\":\"Adds two numbers together\",\"inputSchema\":{\"type\":\"object\",\"properties\":{\"a\":{\"type\":\"number\",\"description\":\"First number\"},\"b\":{\"type\":\"number\",\"description\":\"Second number\"}},\"required\":[\"a\",\"b\"]}}]},\"jsonrpc\":\"2.0\",\"id\":1}\n</code></pre></p>"},{"location":"001-mcp-basics/#exercise-2-call-the-hello-tool","title":"Exercise 2: Call the Hello Tool","text":"<ul> <li>Test calling the hello tool using direct JSON-RPC communication:</li> </ul> <pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Inside the container, create a test script\ncat &gt; /labs-scripts/test-hello-tool.js &lt;&lt; 'EOF'\nconst { spawn } = require(\"child_process\");\n\nconsole.log(\"Testing hello tool...\");\n\ntry {\n  const server = spawn(\"node\", [\"/app/build/index.js\"], {\n    stdio: [\"pipe\", \"pipe\", \"pipe\"]\n  });\n\n  console.log(\"Server spawned, PID:\", server.pid);\n\n  server.stdout.on(\"data\", (data) =&gt; {\n    console.log(\"RESPONSE:\", data.toString().trim());\n  });\n\n  server.stderr.on(\"data\", (data) =&gt; {\n    console.log(\"SERVER:\", data.toString().trim());\n  });\n\n  const helloRequest = {\n    jsonrpc: \"2.0\",\n    id: 2,\n    method: \"tools/call\",\n    params: {\n      name: \"hello\",\n      arguments: {\n        name: \"K-Agent Lab User\"\n      }\n    }\n  };\n\n  setTimeout(() =&gt; {\n    console.log(\"Sending:\", JSON.stringify(helloRequest));\n    server.stdin.write(JSON.stringify(helloRequest) + \"\\n\");\n  }, 1000);\n\n  setTimeout(() =&gt; {\n    server.kill();\n    process.exit(0);\n  }, 5000);\n\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\nEOF\n\n# Run the test\nnode /labs-scripts/test-hello-tool.js\n</code></pre> <p>Expected Output: <pre><code>Testing hello tool...\nServer spawned, PID: 18237\nSERVER: K-Agent MCP Server running on stdio\nSending: {\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"hello\",\"arguments\":{\"name\":\"K-Agent Lab User\"}}}\nRESPONSE: {\"result\":{\"content\":[{\"type\":\"text\",\"text\":\"Hello, K-Agent Lab User! Welcome to K-Agent Labs.\"}]},\"jsonrpc\":\"2.0\",\"id\":2}\n</code></pre></p>"},{"location":"001-mcp-basics/#exercise-3-call-the-add-tool","title":"Exercise 3: Call the Add Tool","text":"<p>Test calling the add tool using direct JSON-RPC communication:</p> <pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Inside the container, create a test script\ncat &gt; /labs-scripts/test-add-tool.js &lt;&lt; 'EOF'\nconst { spawn } = require(\"child_process\");\n\nconsole.log(\"Testing add tool...\");\n\ntry {\n  const server = spawn(\"node\", [\"/app/build/index.js\"], {\n    stdio: [\"pipe\", \"pipe\", \"pipe\"]\n  });\n\n  console.log(\"Server spawned, PID:\", server.pid);\n\n  server.stdout.on(\"data\", (data) =&gt; {\n    console.log(\"RESPONSE:\", data.toString().trim());\n  });\n\n  server.stderr.on(\"data\", (data) =&gt; {\n    console.log(\"SERVER:\", data.toString().trim());\n  });\n\n  const addRequest = {\n    jsonrpc: \"2.0\",\n    id: 3,\n    method: \"tools/call\",\n    params: {\n      name: \"add\",\n      arguments: {\n        a: 5,\n        b: 3\n      }\n    }\n  };\n\n  setTimeout(() =&gt; {\n    console.log(\"Sending:\", JSON.stringify(addRequest));\n    server.stdin.write(JSON.stringify(addRequest) + \"\\n\");\n  }, 1000);\n\n  setTimeout(() =&gt; {\n    server.kill();\n    process.exit(0);\n  }, 5000);\n\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\nEOF\n\n# Run the test\nnode /labs-scripts/test-add-tool.js\n</code></pre> <p>Expected Output: <pre><code>Testing add tool...\nServer spawned, PID: 18263\nSERVER: K-Agent MCP Server running on stdio\nSending: {\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"tools/call\",\"params\":{\"name\":\"add\",\"arguments\":{\"a\":5,\"b\":3}}}\nRESPONSE: {\"result\":{\"content\":[{\"type\":\"text\",\"text\":\"The sum of 5 and 3 is 8\"}]},\"jsonrpc\":\"2.0\",\"id\":3}\n</code></pre></p>"},{"location":"001-mcp-basics/#08-key-takeaways","title":"08. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 MCP is a standardized protocol for AI-tool communication</li> <li>\u2713 MCP servers expose tools with defined schemas</li> <li>\u2713 Tools have names, descriptions, input schemas, and handlers</li> <li>\u2713 JSON-RPC 2.0 is the communication format</li> <li>\u2713 Transport can be stdio, HTTP, or WebSocket</li> </ul> <p>MCP in Practice</p> <p>MCP servers are typically used by AI assistants like Claude, ChatGPT with plugins, or custom AI applications. The stdio transport allows them to run as local processes.</p>"},{"location":"001-mcp-basics/#09-additional-resources","title":"09. Additional Resources","text":"<ul> <li>MCP Specification</li> <li>MCP SDK Documentation</li> <li>JSON-RPC 2.0 Specification</li> </ul>"},{"location":"001-mcp-basics/#10-next-steps","title":"10. Next Steps","text":"<p>Now that you understand MCP basics, you\u2019ll learn how to build your own MCP server with Python.</p> <p>What\u2019s next:</p> <ul> <li>Lab 002 - Python MCP Server - Build a custom MCP server</li> <li>Creating custom tools with Python</li> <li>Implementing tool handlers</li> </ul>"},{"location":"002-typescript-server/","title":"Lab 002 - TypeScript MCP Server","text":"<p>In this lab, you\u2019ll build your own Model Context Protocol server using TypeScript. You\u2019ll create custom tools, define input schemas, and implement tool handlers from scratch.</p> <p>What you\u2019ll learn: - Create a TypeScript MCP server project - Define custom tools with JSON Schema - Implement tool handlers - Test your MCP server</p> <p>Estimated time: 15 minutes</p>"},{"location":"002-typescript-server/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 001 - MCP Basics</li> <li>Understanding of TypeScript basics</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"002-typescript-server/#01-project-structure","title":"01. Project Structure","text":"<p>A TypeScript MCP server project typically has this structure:</p> <pre><code>my-mcp-server/\n\u251c\u2500\u2500 package.json          # Project dependencies\n\u251c\u2500\u2500 tsconfig.json         # TypeScript configuration\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 mcp.ts         # Main server code\n\u2514\u2500\u2500 build/               # Compiled JavaScript (generated)\n</code></pre>"},{"location":"002-typescript-server/#02-initialize-project","title":"02. Initialize Project","text":"<p>Let\u2019s create a new MCP server from scratch.</p> <pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Create project directory\nmkdir -p /labs-scripts/my-mcp-server\ncd /labs-scripts/my-mcp-server\n\n# Initialize npm project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk\n\n# Install dev dependencies\nnpm install --save-dev typescript @types/node ts-node\n</code></pre>"},{"location":"002-typescript-server/#03-configure-typescript","title":"03. Configure TypeScript","text":"<p>Create <code>tsconfig.json</code>:</p> <pre><code>cat &gt; tsconfig.json &lt;&lt; 'EOF'\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\"],\n    \"outDir\": \"./build\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"build\"]\n}\nEOF\n</code></pre>"},{"location":"002-typescript-server/#04-create-mcp-server","title":"04. Create MCP Server","text":"<p>Create <code>src/indmcpex.ts</code> with custom tools:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n// Create server instance\nconst server = new Server(\n  {\n    name: \"my-custom-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\n// Define available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n  return {\n    tools: [\n      {\n        name: \"calculate\",\n        description: \"Performs basic mathematical operations\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            operation: {\n              type: \"string\",\n              enum: [\"add\", \"subtract\", \"multiply\", \"divide\"],\n              description: \"Mathematical operation to perform\",\n            },\n            a: {\n              type: \"number\",\n              description: \"First number\",\n            },\n            b: {\n              type: \"number\",\n              description: \"Second number\",\n            },\n          },\n          required: [\"operation\", \"a\", \"b\"],\n        },\n      },\n      {\n        name: \"reverse_string\",\n        description: \"Reverses a string\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            text: {\n              type: \"string\",\n              description: \"Text to reverse\",\n            },\n          },\n          required: [\"text\"],\n        },\n      },\n      {\n        name: \"get_timestamp\",\n        description: \"Returns current timestamp in ISO format\",\n        inputSchema: {\n          type: \"object\",\n          properties: {},\n        },\n      },\n    ],\n  };\n});\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  switch (name) {\n    case \"calculate\": {\n      const { operation, a, b } = args as {\n        operation: string;\n        a: number;\n        b: number;\n      };\n\n      let result: number;\n      switch (operation) {\n        case \"add\":\n          result = a + b;\n          break;\n        case \"subtract\":\n          result = a - b;\n          break;\n        case \"multiply\":\n          result = a * b;\n          break;\n        case \"divide\":\n          if (b === 0) {\n            throw new Error(\"Division by zero\");\n          }\n          result = a / b;\n          break;\n        default:\n          throw new Error(`Unknown operation: ${operation}`);\n      }\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Result: ${a} ${operation} ${b} = ${result}`,\n          },\n        ],\n      };\n    }\n\n    case \"reverse_string\": {\n      const { text } = args as { text: string };\n      const reversed = text.split(\"\").reverse().join(\"\");\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Original: \"${text}\"\\nReversed: \"${reversed}\"`,\n          },\n        ],\n      };\n    }\n\n    case \"get_timestamp\": {\n      const timestamp = new Date().toISOString();\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Current timestamp: ${timestamp}`,\n          },\n        ],\n      };\n    }\n\n    default:\n      throw new Error(`Unknown tool: ${name}`);\n  }\n});\n\n// Start the server\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"Custom MCP Server running on stdio\");\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Server error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"002-typescript-server/#05-update-packagejson","title":"05. Update package.json","text":"<p>Add build and start scripts:</p> <pre><code>cat &gt; package.json &lt;&lt; 'EOF'\n{\n  \"name\": \"my-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Custom MCP Server\",\n  \"main\": \"build/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node build/index.js\",\n    \"dev\": \"ts-node src/mcp.ts\"\n  },\n  \"keywords\": [\"mcp\", \"model-context-protocol\"],\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.10.0\",\n    \"ts-node\": \"^10.9.2\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\nEOF\n</code></pre>"},{"location":"002-typescript-server/#06-build-the-server","title":"06. Build the Server","text":"<pre><code># Install dependencies\nnpm install\n\n# Compile TypeScript\nnpm run build\n\n# Verify build\nls -la build/\n</code></pre> <p>You should see <code>index.js</code> in the <code>build/</code> directory.</p>"},{"location":"002-typescript-server/#07-test-the-server","title":"07. Test the Server","text":"<p>Create a test script:</p> <pre><code>cat &gt; test-server.js &lt;&lt; 'EOF'\nconst { spawn } = require('child_process');\n\nconsole.log(\"Testing Custom MCP Server\\n\");\n\n// Start the server\nconst server = spawn('node', ['build/index.js']);\n\nserver.stderr.on('data', (data) =&gt; {\n  console.log('[Server]', data.toString().trim());\n});\n\n// Test 1: List tools\nconsole.log(\"Test 1: Listing tools...\\n\");\nconst listRequest = {\n  jsonrpc: \"2.0\",\n  id: 1,\n  method: \"tools/list\"\n};\n\nserver.stdin.write(JSON.stringify(listRequest) + '\\n');\n\n// Test 2: Calculate (add)\nsetTimeout(() =&gt; {\n  console.log(\"\\nTest 2: Calculate 15 + 27...\\n\");\n  const calculateRequest = {\n    jsonrpc: \"2.0\",\n    id: 2,\n    method: \"tools/call\",\n    params: {\n      name: \"calculate\",\n      arguments: {\n        operation: \"add\",\n        a: 15,\n        b: 27\n      }\n    }\n  };\n  server.stdin.write(JSON.stringify(calculateRequest) + '\\n');\n}, 500);\n\n// Test 3: Reverse string\nsetTimeout(() =&gt; {\n  console.log(\"\\nTest 3: Reverse string 'Hello K-Agent'...\\n\");\n  const reverseRequest = {\n    jsonrpc: \"2.0\",\n    id: 3,\n    method: \"tools/call\",\n    params: {\n      name: \"reverse_string\",\n      arguments: {\n        text: \"Hello K-Agent\"\n      }\n    }\n  };\n  server.stdin.write(JSON.stringify(reverseRequest) + '\\n');\n}, 1000);\n\n// Test 4: Get timestamp\nsetTimeout(() =&gt; {\n  console.log(\"\\nTest 4: Get current timestamp...\\n\");\n  const timestampRequest = {\n    jsonrpc: \"2.0\",\n    id: 4,\n    method: \"tools/call\",\n    params: {\n      name: \"get_timestamp\",\n      arguments: {}\n    }\n  };\n  server.stdin.write(JSON.stringify(timestampRequest) + '\\n');\n}, 1500);\n\n// Capture responses\nserver.stdout.on('data', (data) =&gt; {\n  console.log('[Response]', data.toString());\n});\n\n// Cleanup\nsetTimeout(() =&gt; {\n  server.kill();\n  console.log(\"\\n\u2713 All tests completed!\");\n  process.exit(0);\n}, 3000);\nEOF\n\n# Run tests\nnode test-server.js\n</code></pre>"},{"location":"002-typescript-server/#08-hands-on-exercise","title":"08. Hands-on Exercise","text":""},{"location":"002-typescript-server/#exercise-1-add-a-new-tool","title":"Exercise 1: Add a New Tool","text":"<p>Add a <code>to_uppercase</code> tool that converts text to uppercase.</p> <p>Steps:</p> <ol> <li>Add tool definition in <code>ListToolsRequestSchema</code> handler:</li> </ol> <pre><code>{\n  name: \"to_uppercase\",\n  description: \"Converts text to uppercase\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      text: {\n        type: \"string\",\n        description: \"Text to convert\"\n      }\n    },\n    required: [\"text\"]\n  }\n}\n</code></pre> <ol> <li>Add tool handler in <code>CallToolRequestSchema</code>:</li> </ol> <pre><code>case \"to_uppercase\": {\n  const { text } = args as { text: string };\n  const upper = text.toUpperCase();\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Uppercase: ${upper}`\n      }\n    ]\n  };\n}\n</code></pre> <ol> <li>Rebuild and test:</li> </ol> <pre><code>npm run build\n# Test with your test script\n</code></pre>"},{"location":"002-typescript-server/#exercise-2-add-input-validation","title":"Exercise 2: Add Input Validation","text":"<p>Enhance the <code>calculate</code> tool to validate inputs:</p> <pre><code>case \"calculate\": {\n  const { operation, a, b } = args as {\n    operation: string;\n    a: number;\n    b: number;\n  };\n\n  // Validate inputs\n  if (typeof a !== 'number' || typeof b !== 'number') {\n    throw new Error(\"Invalid input: a and b must be numbers\");\n  }\n\n  if (!['add', 'subtract', 'multiply', 'divide'].includes(operation)) {\n    throw new Error(`Invalid operation: ${operation}`);\n  }\n\n  // ... rest of the code\n}\n</code></pre>"},{"location":"002-typescript-server/#exercise-3-add-error-handling","title":"Exercise 3: Add Error Handling","text":"<p>Create a test that triggers an error (division by zero):</p> <pre><code>cat &gt; test-error.js &lt;&lt; 'EOF'\nconst { spawn } = require('child_process');\n\nconst server = spawn('node', ['build/index.js']);\n\n// Test division by zero\nconst request = {\n  jsonrpc: \"2.0\",\n  id: 1,\n  method: \"tools/call\",\n  params: {\n    name: \"calculate\",\n    arguments: {\n      operation: \"divide\",\n      a: 10,\n      b: 0\n    }\n  }\n};\n\nserver.stdin.write(JSON.stringify(request) + '\\n');\n\nserver.stdout.on('data', (data) =&gt; {\n  console.log('Response:', data.toString());\n});\n\nsetTimeout(() =&gt; {\n  server.kill();\n  process.exit(0);\n}, 1000);\nEOF\n\nnode test-error.js\n</code></pre> <p>Expected: Error message about division by zero.</p>"},{"location":"002-typescript-server/#09-key-takeaways","title":"09. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Created a TypeScript MCP server from scratch</li> <li>\u2713 Defined custom tools with JSON Schema validation</li> <li>\u2713 Implemented tool handlers with logic</li> <li>\u2713 Built and tested the server</li> <li>\u2713 Added error handling and validation</li> </ul> <p>Best Practices</p> <ul> <li>Always validate tool inputs</li> <li>Provide clear error messages</li> <li>Use TypeScript for type safety</li> <li>Test each tool thoroughly</li> <li>Document tool descriptions clearly</li> </ul>"},{"location":"002-typescript-server/#10-next-steps","title":"10. Next Steps","text":"<p>Now that you can build TypeScript MCP servers, you\u2019ll learn about deploying MCP servers to Kubernetes.</p>"},{"location":"003-python-server/","title":"Lab 003 - Python MCP Server with FastMCP","text":"<ul> <li>In this lab, you\u2019ll build MCP servers using Python and the <code>FastMCP</code> framework. </li> <li><code>FastMCP</code> is a high-level Python framework that simplifies the creating of MCP servers with minimal boilerplate code. </li> <li>You\u2019ll learn how to define tools using decorators, handle parameters, and integrate with Python\u2019s ecosystem.</li> </ul> <p>What you\u2019ll learn:</p> <ul> <li>Building MCP servers with Python and <code>FastMCP</code></li> <li>Using decorators to define tools</li> <li>Working with tool parameters and validation</li> <li>Testing Python MCP servers</li> <li>Best practices for Python MCP development</li> </ul> <p>Estimated time: 15-20 minutes</p>"},{"location":"003-python-server/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 000 - K-Agent Labs Setup and Lab 001 - MCP Basics</li> <li>K-Agent labs environment running</li> <li>Basic Python knowledge</li> </ul>"},{"location":"003-python-server/#01-what-is-fastmcp","title":"01. What is FastMCP?","text":"<p><code>FastMCP</code> is a Python framework that makes it easy to build MCP servers. It provides:</p> <ul> <li>Simple Decorator API: Define tools with <code>@mcp.tool()</code> decorators</li> <li>Automatic Schema Generation: Generates JSON schemas from Python type hints</li> <li>Built-in Validation: Validates inputs based on type annotations</li> <li>Minimal Boilerplate: Focus on tool logic, not protocol details</li> <li>Python Ecosystem: Leverage any Python library in your tools</li> </ul>"},{"location":"003-python-server/#fastmcp-vs-mcp-sdk","title":"FastMCP vs MCP SDK","text":"Feature FastMCP MCP SDK (TypeScript) Language Python TypeScript/JavaScript API Style Decorator-based Class-based Typing Type hints TypeScript types Best for Python developers, rapid prototyping Type safety, large projects"},{"location":"003-python-server/#02-fastmcp-server-structure","title":"02. FastMCP Server Structure","text":"<p>A basic FastMCP server looks like this:</p> <pre><code>#!/usr/bin/env python3\nfrom fastmcp import FastMCP\n\n# Create server instance\nmcp = FastMCP(\"My Server Name\")\n\n# Define tools using decorators\n@mcp.tool()\ndef my_tool(param: str) -&gt; str:\n    \"\"\"Tool description here\"\"\"\n    return f\"Result: {param}\"\n\n# Run the server\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre> <p>Key Components:</p> <ol> <li>Import FastMCP: <code>from fastmcp import FastMCP</code></li> <li>Create Server: <code>mcp = FastMCP(\"Server Name\")</code></li> <li>Define Tools: Use <code>@mcp.tool()</code> decorator</li> <li>Run Server: Call <code>mcp.run()</code> to start</li> </ol>"},{"location":"003-python-server/#03-tool-definition-with-decorators","title":"03. Tool Definition with Decorators","text":"<p><code>FastMCP</code> uses Python decorators to define tools. The framework automatically:</p> <ul> <li>Extracts the tool name from the function name</li> <li>Uses the docstring as the tool description</li> <li>Generates input schema from type hints</li> <li>Validates inputs against the schema</li> </ul> <p>Example:</p> <pre><code>@mcp.tool()\ndef greet(name: str, greeting: str = \"Hello\") -&gt; str:\n    \"\"\"Greet a person with a custom greeting\"\"\"\n    return f\"{greeting}, {name}!\"\n</code></pre> <p>This creates a tool with:</p> <ul> <li>Name: <code>greet</code></li> <li>Description: \u201cGreet a person with a custom greeting\u201d</li> <li>Parameters: <ul> <li><code>name</code> (string, required)</li> <li><code>greeting</code> (string, optional, default=\u201dHello\u201d)</li> </ul> </li> <li>Return Type: string</li> </ul>"},{"location":"003-python-server/#04-type-hints-and-validation","title":"04. Type Hints and Validation","text":"<p><code>FastMCP</code> uses Python\u2019s type hints for automatic validation:</p> <pre><code>from typing import List, Optional\n\n@mcp.tool()\ndef calculate_average(numbers: List[float]) -&gt; float:\n    \"\"\"Calculate the average of a list of numbers\"\"\"\n    if not numbers:\n        return 0.0\n    return sum(numbers) / len(numbers)\n\n@mcp.tool()\ndef find_user(user_id: int, include_details: Optional[bool] = False) -&gt; str:\n    \"\"\"Find a user by ID\"\"\"\n    details = \" with details\" if include_details else \"\"\n    return f\"User {user_id}{details}\"\n</code></pre> <p>Supported Types:</p> <ul> <li>Basic: <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code></li> <li>Collections: <code>List</code>, <code>Dict</code>, <code>Tuple</code></li> <li>Optional: <code>Optional[T]</code> or <code>T | None</code></li> <li>Complex: Custom data classes</li> </ul>"},{"location":"003-python-server/#05-hands-on-exercise","title":"05. Hands-on Exercise","text":""},{"location":"003-python-server/#exercise-1-create-a-simple-calculator-server","title":"Exercise 1: Create a Simple Calculator Server","text":"<p>Let\u2019s build a calculator MCP server with multiple tools.</p> <pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Create a new Python file for our calculator server\ncat &gt; /labs-scripts/calculator_server.py &lt;&lt; 'EOF'\n#!/usr/bin/env python3\nfrom fastmcp import FastMCP\n\n# Create the calculator MCP server\nmcp = FastMCP(\"Calculator Server\")\n\n@mcp.tool()\ndef add(a: float, b: float) -&gt; float:\n    \"\"\"Add two numbers together\"\"\"\n    return a + b\n\n@mcp.tool()\ndef subtract(a: float, b: float) -&gt; float:\n    \"\"\"Subtract b from a\"\"\"\n    return a - b\n\n@mcp.tool()\ndef multiply(a: float, b: float) -&gt; float:\n    \"\"\"Multiply two numbers\"\"\"\n    return a * b\n\n@mcp.tool()\ndef divide(a: float, b: float) -&gt; str:\n    \"\"\"Divide a by b\"\"\"\n    if b == 0:\n        return \"Error: Division by zero\"\n    result = a / b\n    return f\"The result is {result}\"\n\n@mcp.tool()\ndef power(base: float, exponent: float) -&gt; float:\n    \"\"\"Raise base to the power of exponent\"\"\"\n    return base ** exponent\n\nif __name__ == \"__main__\":\n    mcp.run()\nEOF\n\n# Make it executable\nchmod +x /labs-scripts/calculator_server.py\n</code></pre>"},{"location":"003-python-server/#exercise-2-test-with-mcp-inspector","title":"Exercise 2: Test with MCP Inspector","text":"<p>Now let\u2019s test our calculator server:</p> <pre><code># Inside the container, start MCP Inspector with our calculator server\nnpx @modelcontextprotocol/inspector python3 /labs-scripts/calculator_server.py\n</code></pre> <p>Port Already in Use?</p> <p>If you see <code>\u274c Proxy Server PORT IS IN USE at port 6277 \u274c</code>, there\u2019s already an MCP Inspector running. </p> <p>Solution: Kill the existing process <pre><code># Find and kill any running inspector processes\npkill -f \"inspector\" || true\n\n# Wait a moment for the port to be released\nsleep 2\n\n# Now try again\nnpx @modelcontextprotocol/inspector python3 /labs-scripts/calculator_server.py\n</code></pre></p> <p>Alternative: Kill specific port <pre><code># Kill process on port 6277\nlsof -ti:6277 | xargs kill -9 2&gt;/dev/null || true\n\n# Also check port 6274 (sometimes used)\nlsof -ti:6274 | xargs kill -9 2&gt;/dev/null || true\n\n# Try again\nnpx @modelcontextprotocol/inspector python3 /labs-scripts/calculator_server.py\n</code></pre></p> <p>Testing Steps</p> <ol> <li>Copy the authentication URL from the terminal</li> <li>Open it in your browser</li> <li>Verify transport is set to stdio</li> <li>Command should show: <code>python3</code></li> <li>Argument should show: <code>/labs-scripts/calculator_server.py</code></li> <li>Click Connect</li> <li>Go to Tools tab and click List Tools</li> <li>You should see 5 tools: add, subtract, multiply, divide, power</li> </ol> <p>Test the tools:</p> <ol> <li> <p>Test Add Tool:</p> <ul> <li>Click <code>add</code></li> <li>Enter <code>a</code>: <code>15</code></li> <li>Enter <code>b</code>: <code>7</code></li> <li>Click Run Tool</li> <li>Expected: <code>22.0</code></li> </ul> </li> <li> <p>Test Divide Tool:</p> <ul> <li>Click <code>divide</code></li> <li>Enter <code>a</code>: <code>100</code></li> <li>Enter <code>b</code>: <code>4</code></li> <li>Click Run Tool</li> <li>Expected: \u201cThe result is 25.0\u201d</li> </ul> </li> <li> <p>Test Power Tool:</p> <ul> <li>Click <code>power</code></li> <li>Enter <code>base</code>: <code>2</code></li> <li>Enter <code>exponent</code>: <code>8</code></li> <li>Click Run Tool</li> <li>Expected: <code>256.0</code></li> </ul> </li> <li> <p>Test Error Handling:</p> <ul> <li>Click <code>divide</code></li> <li>Enter <code>a</code>: <code>10</code></li> <li>Enter <code>b</code>: <code>0</code></li> <li>Click Run Tool</li> <li>Expected: \u201cError: Division by zero\u201d</li> </ul> </li> </ol>"},{"location":"003-python-server/#exercise-3-build-a-text-processing-server","title":"Exercise 3: Build a Text Processing Server","text":"<p>Create a more advanced server with string manipulation tools:</p> <pre><code># Inside the container\ncat &gt; /labs-scripts/text_server.py &lt;&lt; 'EOF'\n#!/usr/bin/env python3\nfrom fastmcp import FastMCP\nfrom typing import List\n\nmcp = FastMCP(\"Text Processing Server\")\n\n@mcp.tool()\ndef to_uppercase(text: str) -&gt; str:\n    \"\"\"Convert text to uppercase\"\"\"\n    return text.upper()\n\n@mcp.tool()\ndef to_lowercase(text: str) -&gt; str:\n    \"\"\"Convert text to lowercase\"\"\"\n    return text.lower()\n\n@mcp.tool()\ndef reverse_text(text: str) -&gt; str:\n    \"\"\"Reverse the input text\"\"\"\n    return text[::-1]\n\n@mcp.tool()\ndef count_words(text: str) -&gt; int:\n    \"\"\"Count the number of words in text\"\"\"\n    return len(text.split())\n\n@mcp.tool()\ndef count_characters(text: str, include_spaces: bool = True) -&gt; int:\n    \"\"\"Count characters in text, optionally excluding spaces\"\"\"\n    if include_spaces:\n        return len(text)\n    return len(text.replace(\" \", \"\"))\n\n@mcp.tool()\ndef find_substring(text: str, substring: str) -&gt; str:\n    \"\"\"Find if substring exists in text and return its position\"\"\"\n    index = text.find(substring)\n    if index == -1:\n        return f\"Substring '{substring}' not found in text\"\n    return f\"Substring '{substring}' found at position {index}\"\n\n@mcp.tool()\ndef split_by_delimiter(text: str, delimiter: str = \",\") -&gt; List[str]:\n    \"\"\"Split text by a delimiter\"\"\"\n    return text.split(delimiter)\n\nif __name__ == \"__main__\":\n    mcp.run()\nEOF\n\nchmod +x /labs-scripts/text_server.py\n</code></pre> <p>Test the text processing server:</p> <pre><code># Start MCP Inspector\nnpx @modelcontextprotocol/inspector python3 /labs-scripts/text_server.py\n</code></pre> <p>Testing Steps</p> <ol> <li>Copy the authentication URL from the terminal</li> <li>Open it in your browser</li> <li>Verify transport is set to stdio</li> <li>Command should show: <code>python3</code></li> <li>Argument should show: <code>/labs-scripts/text_server.py</code></li> <li>Click Connect</li> <li>Go to Tools tab and click List Tools</li> <li>You should see 7 tools: to_uppercase, to_lowercase, reverse_text, count_words, count_characters, find_substring, split_by_delimiter</li> </ol> <p>Try these tests:</p> <ol> <li> <p>to_uppercase:</p> <ul> <li>Input: \u201chello world\u201d</li> <li>Expected: \u201cHELLO WORLD\u201d</li> </ul> </li> <li> <p>count_words:</p> <ul> <li>Input: \u201cThe quick brown fox jumps\u201d</li> <li>Expected: <code>5</code></li> </ul> </li> <li> <p>find_substring:</p> <ul> <li>text: \u201cPython MCP Server\u201d</li> <li>substring: \u201cMCP\u201d</li> <li>Expected: \u201cSubstring \u2018MCP\u2019 found at position 7\u201d</li> </ul> </li> <li> <p>split_by_delimiter:</p> <ul> <li>text: \u201capple,banana,orange\u201d</li> <li>delimiter: \u201c,\u201d</li> <li>Expected: <code>[\"apple\", \"banana\", \"orange\"]</code></li> </ul> </li> </ol>"},{"location":"003-python-server/#exercise-4-command-line-testing","title":"Exercise 4: Command-Line Testing","text":"<p>Test tools programmatically using Python:</p> <pre><code># Inside the container, create a test script\ncat &gt; /labs-scripts/test_calculator.py &lt;&lt; 'EOF'\n#!/usr/bin/env python3\nimport subprocess\nimport json\nimport time\n\ndef test_mcp_tool(server_path, tool_name, arguments):\n    \"\"\"Test an MCP tool by spawning the server and sending requests\"\"\"\n\n    # Start the server process\n    process = subprocess.Popen(\n        ['python3', server_path],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True,\n        bufsize=1\n    )\n\n    time.sleep(0.5)  # Give server time to start\n\n    # Create the tool call request\n    request = {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"tools/call\",\n        \"params\": {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }\n    }\n\n    # Send request\n    process.stdin.write(json.dumps(request) + \"\\n\")\n    process.stdin.flush()\n\n    # Read response\n    time.sleep(0.5)\n    response_line = process.stdout.readline()\n\n    # Clean up\n    process.terminate()\n    process.wait(timeout=2)\n\n    try:\n        response = json.loads(response_line)\n        return response\n    except:\n        return {\"error\": \"Failed to parse response\", \"raw\": response_line}\n\n# Test calculator operations\nprint(\"Testing Calculator Server...\")\nprint(\"-\" * 50)\n\n# Test addition\nresult = test_mcp_tool('/labs-scripts/calculator_server.py', 'add', {'a': 10, 'b': 20})\nprint(f\"add(10, 20) = {result}\")\n\n# Test division\nresult = test_mcp_tool('/labs-scripts/calculator_server.py', 'divide', {'a': 100, 'b': 5})\nprint(f\"divide(100, 5) = {result}\")\n\n# Test power\nresult = test_mcp_tool('/labs-scripts/calculator_server.py', 'power', {'base': 3, 'exponent': 4})\nprint(f\"power(3, 4) = {result}\")\n\nprint(\"-\" * 50)\nprint(\"Tests complete!\")\nEOF\n\nchmod +x /labs-scripts/test_calculator.py\n\n# Run the tests\npython3 /labs-scripts/test_calculator.py\n</code></pre>"},{"location":"003-python-server/#06-advanced-features","title":"06. Advanced Features","text":""},{"location":"003-python-server/#error-handling","title":"Error Handling","text":"<p>Add proper error handling to your tools:</p> <pre><code>@mcp.tool()\ndef safe_divide(a: float, b: float) -&gt; str:\n    \"\"\"Safely divide two numbers with error handling\"\"\"\n    try:\n        if b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        result = a / b\n        return f\"Result: {result}\"\n    except Exception as e:\n        return f\"Error: {str(e)}\"\n</code></pre>"},{"location":"003-python-server/#using-python-libraries","title":"Using Python Libraries","text":"<p><code>FastMCP</code> integrates seamlessly with Python\u2019s ecosystem:</p> <pre><code>import math\nfrom datetime import datetime\n\n@mcp.tool()\ndef calculate_sqrt(number: float) -&gt; float:\n    \"\"\"Calculate square root using math library\"\"\"\n    return math.sqrt(number)\n\n@mcp.tool()\ndef get_current_time() -&gt; str:\n    \"\"\"Get current timestamp\"\"\"\n    return datetime.now().isoformat()\n</code></pre>"},{"location":"003-python-server/#complex-return-types","title":"Complex Return Types","text":"<p>Return structured data:</p> <pre><code>from typing import Dict, List\n\n@mcp.tool()\ndef analyze_text(text: str) -&gt; Dict[str, int]:\n    \"\"\"Analyze text and return statistics\"\"\"\n    return {\n        \"characters\": len(text),\n        \"words\": len(text.split()),\n        \"lines\": text.count('\\n') + 1,\n        \"vowels\": sum(1 for c in text.lower() if c in 'aeiou')\n    }\n</code></pre>"},{"location":"003-python-server/#07-best-practices","title":"07. Best Practices","text":"<p>FastMCP Best Practices</p> <p>1. Use Type Hints <pre><code># Good\n@mcp.tool()\ndef process(data: str, count: int) -&gt; List[str]:\n    pass\n\n# Avoid (no type hints)\n@mcp.tool()\ndef process(data, count):\n    pass\n</code></pre></p> <p>2. Write Clear Docstrings <pre><code># Good\n@mcp.tool()\ndef calculate_tax(amount: float, rate: float) -&gt; float:\n    \"\"\"Calculate tax on an amount using the given rate.\n\n    Args:\n        amount: The base amount\n        rate: Tax rate as a decimal (e.g., 0.15 for 15%)\n    \"\"\"\n    return amount * rate\n</code></pre></p> <p>3. Handle Errors Gracefully <pre><code>@mcp.tool()\ndef safe_operation(value: int) -&gt; str:\n    \"\"\"Perform operation with error handling\"\"\"\n    try:\n        result = 100 / value\n        return f\"Success: {result}\"\n    except ZeroDivisionError:\n        return \"Error: Cannot divide by zero\"\n    except Exception as e:\n        return f\"Error: {str(e)}\"\n</code></pre></p> <p>4. Validate Inputs <pre><code>@mcp.tool()\ndef process_positive(number: int) -&gt; str:\n    \"\"\"Process only positive numbers\"\"\"\n    if number &lt;= 0:\n        return \"Error: Number must be positive\"\n    return f\"Processing {number}\"\n</code></pre></p> <p>5. Use Meaningful Names <pre><code># Good\n@mcp.tool()\ndef calculate_monthly_payment(principal: float, rate: float, months: int) -&gt; float:\n    pass\n\n# Avoid\n@mcp.tool()\ndef calc(p: float, r: float, m: int) -&gt; float:\n    pass\n</code></pre></p>"},{"location":"003-python-server/#08-key-takeaways","title":"08. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Building MCP servers with Python and FastMCP</li> <li>\u2713 Using <code>@mcp.tool()</code> decorator for tool definition</li> <li>\u2713 Leveraging type hints for automatic schema generation</li> <li>\u2713 Testing Python MCP servers with MCP Inspector</li> <li>\u2713 Implementing error handling and validation</li> <li>\u2713 Integrating Python libraries with MCP tools</li> <li>\u2713 Command-line testing with subprocess</li> </ul> <p>FastMCP Advantages</p> <ul> <li>Rapid Development: Minimal boilerplate, quick prototyping</li> <li>Python Ecosystem: Access to thousands of Python libraries</li> <li>Type Safety: Automatic validation from type hints</li> <li>Easy Testing: Simple to test with Python scripts</li> <li>Readable Code: Decorator pattern is clean and intuitive</li> </ul>"},{"location":"003-python-server/#09-additional-resources","title":"09. Additional Resources","text":"<ul> <li>FastMCP Documentation</li> <li>Python Type Hints Guide</li> <li>MCP Specification</li> <li>Python Decorators Tutorial</li> </ul>"},{"location":"003-python-server/#10-next-steps","title":"10. Next Steps","text":"<p>Now that you can build Python MCP servers with FastMCP, you\u2019ll learn how to create TypeScript-based MCP servers for type-safe, production-grade implementations.</p>"},{"location":"004-k8s-deploy/","title":"Index","text":""},{"location":"004-k8s-deploy/#lab-004-deploy-mcp-to-kubernetes","title":"Lab 004 - Deploy MCP to Kubernetes","text":"<p>What you\u2019ll learn: - Deploy MCP to Kubernetes concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"004-k8s-deploy/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 003</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"004-k8s-deploy/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on deploy mcp to kubernetes.</p>"},{"location":"004-k8s-deploy/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"004-k8s-deploy/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"004-k8s-deploy/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"004-k8s-deploy/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"004-k8s-deploy/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Deploy MCP to Kubernetes implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"004-k8s-deploy/#06-next-steps","title":"06. Next Steps","text":"<p>Continue to Lab 005 to build on these concepts.</p>"},{"location":"005-kubectl-tool/","title":"Index","text":""},{"location":"005-kubectl-tool/#lab-005-kubectl-integration-tool","title":"Lab 005 - Kubectl Integration Tool","text":"<p>What you\u2019ll learn: - Kubectl Integration Tool concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"005-kubectl-tool/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 004</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"005-kubectl-tool/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on kubectl integration tool.</p>"},{"location":"005-kubectl-tool/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"005-kubectl-tool/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"005-kubectl-tool/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"005-kubectl-tool/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"005-kubectl-tool/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Kubectl Integration Tool implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"006-cluster-inspector/","title":"Index","text":""},{"location":"006-cluster-inspector/#lab-006-cluster-health-inspector","title":"Lab 006 - Cluster Health Inspector","text":"<p>What you\u2019ll learn: - Cluster Health Inspector concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"006-cluster-inspector/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 005</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"006-cluster-inspector/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on cluster health inspector.</p>"},{"location":"006-cluster-inspector/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"006-cluster-inspector/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"006-cluster-inspector/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"006-cluster-inspector/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"006-cluster-inspector/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Cluster Health Inspector implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"007-helm-tool/","title":"Index","text":""},{"location":"007-helm-tool/#lab-007-helm-package-management","title":"Lab 007 - Helm Package Management","text":"<p>What you\u2019ll learn: - Helm Package Management concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"007-helm-tool/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 006</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"007-helm-tool/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on helm package management.</p>"},{"location":"007-helm-tool/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"007-helm-tool/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"007-helm-tool/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"007-helm-tool/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"007-helm-tool/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Helm Package Management implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"008-postgres-tool/","title":"Index","text":""},{"location":"008-postgres-tool/#lab-008-postgresql-database-tool","title":"Lab 008 - PostgreSQL Database Tool","text":"<p>What you\u2019ll learn: - PostgreSQL Database Tool concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"008-postgres-tool/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 007</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"008-postgres-tool/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on postgresql database tool.</p>"},{"location":"008-postgres-tool/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"008-postgres-tool/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"008-postgres-tool/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"008-postgres-tool/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"008-postgres-tool/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 PostgreSQL Database Tool implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"009-configmap-secrets/","title":"Index","text":""},{"location":"009-configmap-secrets/#lab-009-configmaps-and-secrets","title":"Lab 009 - ConfigMaps and Secrets","text":"<p>What you\u2019ll learn: - ConfigMaps and Secrets concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"009-configmap-secrets/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 008</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"009-configmap-secrets/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on configmaps and secrets.</p>"},{"location":"009-configmap-secrets/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"009-configmap-secrets/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"009-configmap-secrets/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"009-configmap-secrets/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"009-configmap-secrets/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 ConfigMaps and Secrets implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"010-mcp-remote/","title":"Index","text":""},{"location":"010-mcp-remote/#lab-010-remote-mcp-server","title":"Lab 010 - Remote MCP Server","text":"<p>What you\u2019ll learn: - Remote MCP Server concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"010-mcp-remote/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 009</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"010-mcp-remote/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on remote mcp server.</p>"},{"location":"010-mcp-remote/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"010-mcp-remote/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"010-mcp-remote/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"010-mcp-remote/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"010-mcp-remote/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Remote MCP Server implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"011-gcp-gke/","title":"Index","text":""},{"location":"011-gcp-gke/#lab-011-google-kubernetes-engine","title":"Lab 011 - Google Kubernetes Engine","text":"<p>What you\u2019ll learn: - Google Kubernetes Engine concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"011-gcp-gke/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 010</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"011-gcp-gke/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on google kubernetes engine.</p>"},{"location":"011-gcp-gke/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"011-gcp-gke/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"011-gcp-gke/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"011-gcp-gke/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"011-gcp-gke/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Google Kubernetes Engine implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"012-gcp-tools/","title":"Index","text":""},{"location":"012-gcp-tools/#lab-012-google-cloud-sdk-tools","title":"Lab 012 - Google Cloud SDK Tools","text":"<p>What you\u2019ll learn: - Google Cloud SDK Tools concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"012-gcp-tools/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 011</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"012-gcp-tools/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on google cloud sdk tools.</p>"},{"location":"012-gcp-tools/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"012-gcp-tools/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"012-gcp-tools/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"012-gcp-tools/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"012-gcp-tools/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Google Cloud SDK Tools implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"013-security-rbac/","title":"Index","text":""},{"location":"013-security-rbac/#lab-013-security-and-rbac","title":"Lab 013 - Security and RBAC","text":"<p>What you\u2019ll learn: - Security and RBAC concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"013-security-rbac/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 012</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"013-security-rbac/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on security and rbac.</p>"},{"location":"013-security-rbac/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"013-security-rbac/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"013-security-rbac/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"013-security-rbac/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"013-security-rbac/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Security and RBAC implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"013-security-rbac/#06-next-steps","title":"06. Next Steps","text":"<p>Continue to Lab 014 to build on these concepts.</p>"},{"location":"014-production-ready/","title":"Index","text":""},{"location":"014-production-ready/#lab-014-production-deployment","title":"Lab 014 - Production Deployment","text":"<p>What you\u2019ll learn: - Production Deployment concepts and implementation - Hands-on exercises with K-Agent - Best practices and patterns</p> <p>Estimated time: 10-15 minutes</p>"},{"location":"014-production-ready/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Completed Lab 013</li> <li>K-Agent labs environment running</li> </ul>"},{"location":"014-production-ready/#01-introduction","title":"01. Introduction","text":"<p>This lab focuses on production deployment.</p>"},{"location":"014-production-ready/#02-setup","title":"02. Setup","text":"<pre><code># Connect to container\ndocker exec -it kagent-controller bash\n\n# Navigate to labs directory\ncd /labs-scripts\n</code></pre>"},{"location":"014-production-ready/#03-hands-on-exercise","title":"03. Hands-on Exercise","text":""},{"location":"014-production-ready/#exercise-1-core-implementation","title":"Exercise 1: Core Implementation","text":"<p>[Lab-specific content]</p>"},{"location":"014-production-ready/#04-verification","title":"04. Verification","text":"<pre><code># Verify your implementation\n</code></pre>"},{"location":"014-production-ready/#05-key-takeaways","title":"05. Key Takeaways","text":"<p>What You Learned</p> <ul> <li>\u2713 Production Deployment implementation</li> <li>\u2713 Practical hands-on experience</li> <li>\u2713 Testing and validation</li> </ul>"},{"location":"014-production-ready/#06-next-steps","title":"06. Next Steps","text":"<p>Continue to Lab 015 to build on these concepts.</p>"},{"location":"Lab00-Setup/","title":"Lab 000 - Environment Setup","text":"<ul> <li>Welcome to <code>K-Agent</code> Labs! </li> <li>In this first lab, you\u2019ll set up your development environment with all the tools needed for the <code>K-Agent</code> infrastructure. </li> <li>This lab covers <code>Docker</code>, <code>Kubernetes</code>, and the <code>K-Agent</code> labs environment container.</li> </ul>"},{"location":"Lab00-Setup/#what-youll-learn-in-this-workshop","title":"What you\u2019ll learn in this workshop:","text":"<ul> <li>Install and configure required tools (Docker, kubectl, Helm, Ollama, MCP Inspector, K-Agent etc.)</li> <li>Build and run the K-Agent labs environment (Docker container or locally)</li> <li>Verify Kubernetes cluster connectivity </li> <li>Prepare the MCP server setup</li> </ul>"},{"location":"Lab00-Setup/#01-prerequisites-installation","title":"01. Prerequisites Installation","text":""},{"location":"Lab00-Setup/#docker-installation","title":"\ud83d\udc33 Docker Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code># Install Docker Desktop\nbrew install --cask docker\n\n# Start Docker Desktop from Applications\n# Or use command line:\nopen /Applications/Docker.app\n</code></pre> <pre><code># Update package index\nsudo apt-get update\n\n# Install Docker\ncurl -fsSL https://get.docker.com | sh\n\n# Add user to docker group\nsudo usermod -aG docker $USER\n\n# Restart session or run:\nnewgrp docker\n</code></pre> <pre><code># Set up the repository\nsudo yum install -y yum-utils\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n# Install Docker\nsudo yum install -y docker-ce docker-ce-cli containerd.io\n# Start Docker\nsudo systemctl start docker\n# Add user to docker group\nsudo usermod -aG docker $USER\n# Restart session or run:\nnewgrp docker\n</code></pre> <pre><code># Docker is pre-installed in Cloud Shell\ndocker --version\n</code></pre>"},{"location":"Lab00-Setup/#kubectl-installation","title":"\u2638\ufe0f kubectl Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install kubectl\n</code></pre> <pre><code>curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n</code></pre> <pre><code>curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" \nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n</code></pre> <pre><code># kubectl is pre-installed\nkubectl version --client\n</code></pre>"},{"location":"Lab00-Setup/#helm-installation","title":"\u2693 Helm Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install helm\n</code></pre> <pre><code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre> <pre><code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre> <pre><code># Helm is pre-installed\nhelm version\n</code></pre>"},{"location":"Lab00-Setup/#git-installation","title":"\ud83d\udc19 Git Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install git\n</code></pre> <pre><code>sudo apt-get install -y git\n</code></pre> <pre><code>sudo yum install -y git\n</code></pre> <pre><code># Git is pre-installed\ngit --version\n</code></pre>"},{"location":"Lab00-Setup/#python3-installation","title":"\ud83d\udc0d Python3 Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install python\n</code></pre> <pre><code>sudo apt-get install -y python3 python3-pip\n</code></pre> <pre><code>sudo yum install -y python3 python3-pip\n</code></pre> <pre><code># Python3 is pre-installed\npython3 --version\n</code></pre>"},{"location":"Lab00-Setup/#nodejs-installation","title":"\ud83d\udce6 Node.js Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install node\n</code></pre> <pre><code>sudo apt-get install -y nodejs npm\n</code></pre> <pre><code>sudo yum install -y nodejs npm\n</code></pre> <pre><code># Node.js is pre-installed\nnode --version\n</code></pre>"},{"location":"Lab00-Setup/#ollama-installation","title":"\ud83e\udd16 Ollama Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install ollama\n\n# Start Ollama service\nollama serve\n</code></pre> <pre><code>curl -fsSL https://ollama.ai/install.sh | sh\n\n# Start Ollama service\nollama serve\n</code></pre> <pre><code>curl -fsSL https://ollama.ai/install.sh | sh\n\n# Start Ollama service\nollama serve\n</code></pre> <pre><code># Ollama is not supported in Cloud Shell\necho \"Ollama is not supported in Cloud Shell\"\n</code></pre>"},{"location":"Lab00-Setup/#mcp-inspector-installation","title":"\ud83d\udd0d MCP Inspector Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre> <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre> <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre> <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre>"},{"location":"Lab00-Setup/#kubernetes-cluster-setup-minikube","title":"Kubernetes Cluster Setup (minikube)","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install minikube\n</code></pre> <pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\n</code></pre> <pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\n</code></pre> <pre><code># Minikube is already installed in Cloud Shell\nminikube version\n</code></pre>"},{"location":"Lab00-Setup/#kubernetes-cluster-setup-kind","title":"Kubernetes Cluster Setup (kind)","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install kind\n</code></pre> <pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64\nchmod +x ./kind\nsudo mv ./kind /usr/local/bin/kind\n</code></pre> <pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64\nchmod +x ./kind\nsudo mv ./kind /usr/local/bin/kind\n</code></pre> <pre><code>Kind is not supported in Cloud Shell - Use minikube instead\n</code></pre>"},{"location":"Lab00-Setup/#02-verify-tools-installation","title":"02. Verify Tools Installation","text":"<ul> <li>Verify that all the tools are installed <pre><code># Verify Docker\ndocker --version\n# Verify kubectl\nkubectl version --client\n# Verify Helm\nhelm version\n# Verify Git\ngit --version\n# Verify Python3\npython3 --version\n# Verify Node.js\nnode --version\n# Verify Ollama (if installed)\nollama --version\n# Verify MCP Inspector\nmcp-inspector --version \n# Verify Kind (if installed)\nkind --version\n# Verify Minikube (if installed)\nminikube version\n# Verify Cluster Info (if cluster is running)\nkubectl cluster-info\n</code></pre></li> </ul>"},{"location":"Lab00-Setup/#03-install-the-k-agent","title":"03. Install the K-Agent","text":"<ul> <li>The <code>K-Agent</code> labs environment is the fundamental building block for all labs.</li> <li>Its an Open Source framework to write MCP tools and interact with Kubernetes clusters.</li> </ul> \uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install kagent\n</code></pre> <p>```bash curl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash</p> <pre><code>curl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash\n</code></pre> <pre><code>curl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash\n</code></pre>"},{"location":"Lab00-Setup/#verifty-k-agent-installation","title":"Verifty K-Agent Installation","text":"<pre><code>kagent version\n</code></pre>"},{"location":"Lab00-Setup/#04-ollama-setup","title":"04. Ollama Setup","text":"<ul> <li>Ollama will be used as our LLLM model for the labs.</li> <li>Ollama is a local LLM server that allows you to run large language models on your machine.</li> <li>Ollama supports various models, for example: Qwen and Llama.</li> <li>We will ise the <code>qwen3-coder</code> model which is optimized for coding tasks or the <code>gpt-oos</code> model.  </li> </ul> <p>Pulling Models (Ollama)</p> <ul> <li>Pulling models can take a while depending on your internet speed and system performance.</li> <li>You can skip this step and return to it later when needed.</li> </ul>"},{"location":"Lab00-Setup/#setup-ollama-models","title":"Setup Ollama models","text":"<pre><code># Start Ollama service\nollama serve\n\n# In a new terminal, pull the qwen3-coder model (optimized for coding tasks)\nollama pull qwen3-coder:30b\n\n# Alternatively, pull the gpt-oos model\nollama pull gpt-oos:7b\n\n# Verify\nollama list\n</code></pre>"},{"location":"Lab00-Setup/#pull-a-model","title":"Pull a Model","text":"<pre><code># In a new terminal, pull the qwen3-coder model (optimized for coding tasks)\nollama pull qwen3-coder:30b\n\n# Verify\nollama list\n</code></pre>"},{"location":"Lab00-Setup/#07-verify-setup","title":"07. Verify Setup","text":"<ul> <li>Let\u2019s verify your setup by running a simple test.</li> </ul>"},{"location":"Lab00-Setup/#task-01-check-cluster-information","title":"Task 01: Check Cluster Information","text":"<pre><code># Check cluster info\nkubectl cluster-info\nkubectl get nodes\nkubectl get namespaces\n</code></pre> <p>Exercise 2: Test Container Environment</p> <pre><code># Start labs environment if not running\ncd labs-environment\ndocker compose up -d\n\n# Execute commands in container\ndocker exec kagent-controller bash -c \"\necho '=== Environment Check ==='\necho 'Node.js:' \\$(node --version)\necho 'Python:' \\$(python --version)\necho 'kubectl:' \\$(kubectl version --client --short)\necho 'Helm:' \\$(helm version --short)\necho '========================='\n\"\n</code></pre> <p>Expected Output: <pre><code>=== Environment Check ===\nNode.js: v18.x.x\nPython: Python 3.10.x\nkubectl: Client Version: v1.28.x\nHelm: v3.13.x\n=========================\n</code></pre></p>"},{"location":"Lab00-Setup/#08-troubleshooting","title":"08. Troubleshooting","text":"<p>Container Won\u2019t Start</p> <p>If the container fails to start, check: <pre><code>docker compose logs\ndocker images | grep kagent\ndocker ps -a\n</code></pre></p> <p>Kubectl Not Working in Container</p> <p>If kubectl commands fail in the container: <pre><code># Verify kubeconfig is mounted correctly\ndocker exec kagent-controller ls -la /root/.kube/\n\n# Try copying kubeconfig again\ncp ~/.kube/config $(git rev-parse --show-toplevel)//runtime/.kube/config\n\n# Restart container\ncd labs-environment\ndocker compose restart\n</code></pre></p> <p>Platform Issues (M1/M2 Mac)</p> <p>If you encounter platform errors: <pre><code># Verify platform in .env file\ncat labs-environment/.env\n\n# Should show: TARGET_PLATFORM=linux/arm64\n# If not, update it manually\n</code></pre></p>"},{"location":"Lab01-MCP-Fundamentals/","title":"Lab 1 - MCP Fundamentals","text":""},{"location":"Lab01-MCP-Fundamentals/#overview","title":"Overview","text":"<ul> <li><code>MCP</code> is a game-changer for AI application development .</li> <li>In this lab, you\u2019ll learn about the Model Context Protocol (<code>MCP</code>), the communication standard that enables AI assistants to interact with external tools and services. </li> <li>You\u2019ll explore MCP concepts, test simple tools, and understand the protocol structure.</li> <li> <p>This lab uses the MCP server included in the K-Agent labs environment.</p> <p>Prerequisites</p> <ul> <li>Make sure you have completed Lab 000 - Environment Setup before starting this lab.</li> </ul> </li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand what <code>MCP</code> is and why it was created</li> <li>Learn the core architecture and components of <code>MCP</code></li> <li>Identify the key capabilities <code>MCP</code> provides</li> <li>Understand the client-server model in <code>MCP</code></li> <li>Recognize common use cases for <code>MCP</code></li> <li>Learn MCP server and client communication</li> <li>Testing MCP tools with stdio transport</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#what-is-mcp","title":"What is MCP?","text":"<ul> <li>The Model Context Protocol (MCP) is an open protocol that standardizes how AI applications interact with external data sources and tools. </li> <li>It defines a structured way for AI assistants (clients) to discover, call, and receive responses from tools (servers) using JSON-RPC over various transport layers.</li> <li>MCP is designed to be flexible and extensible, allowing developers to create custom tools that can be easily integrated with different AI models.</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#what-does-mcp-offer","title":"What does MCP offer?","text":""},{"location":"Lab01-MCP-Fundamentals/#standardized-communication","title":"Standardized Communication","text":"<p>AI assistants can work with any MCP-compatible tool</p>"},{"location":"Lab01-MCP-Fundamentals/#tool-discovery","title":"Tool Discovery","text":"<p>Clients can discover available tools from servers</p>"},{"location":"Lab01-MCP-Fundamentals/#structured-interaction","title":"Structured Interaction","text":"<p>Well-defined input/output schemas using JSON</p>"},{"location":"Lab01-MCP-Fundamentals/#standardized-communication_1","title":"Standardized Communication","text":"<p>AI assistants can work with any MCP-compatible tool</p>"},{"location":"Lab01-MCP-Fundamentals/#tool-discovery_1","title":"Tool Discovery","text":"<p>Clients can discover available tools from servers</p>"},{"location":"Lab01-MCP-Fundamentals/#structured-interaction_1","title":"Structured Interaction","text":"<p>Well-defined input/output schemas using JSON</p>"},{"location":"Lab01-MCP-Fundamentals/#multiple-transports","title":"Multiple Transports","text":"<p>Supports stdio, HTTP, WebSocket</p>"},{"location":"Lab01-MCP-Fundamentals/#the-problem-mcp-solves","title":"The Problem MCP Solves","text":"<p>Before <code>MCP</code>, every AI application had to build custom integrations for each data source or tool it wanted to use. This led to:</p> <ul> <li>Fragmentation: Each app using different methods to connect to the same services</li> <li>Duplication: Developers rebuilding the same integrations repeatedly</li> <li>Limited scalability: Adding new integrations was time-consuming and error-prone</li> <li>Inconsistent experiences: No standard way for LLMs to interact with external systems</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#the-mcp-solution","title":"The MCP Solution","text":"<p><code>MCP</code> provides a standardized protocol that:</p> <ul> <li>Enables universal connectivity between LLMs and data sources</li> <li>Allows one integration to work across all MCP-compatible applications</li> <li>Provides a consistent interface for accessing tools, resources, and prompts</li> <li>Supports secure, controlled access to external systems</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#mcp-architecture-overview","title":"MCP Architecture Overview","text":"<p><code>MCP</code> follows a client-server architecture with clear separation of concerns:</p> <pre><code>graph TD\n    A[MCP Client] --&gt; B[Ollama Module]\n    A --&gt; C[IDEs &amp; Apps]\n    A --&gt; D[AI Tools]\n    B --&gt; E[MCP Protocol]\n    C --&gt; E\n    D --&gt; E\n    E --&gt; F[MCP Server]\n    F --&gt; G[Exposes: Tools, Resources &amp; Prompts]\n    F --&gt; H[Connects to: APIs, Databases, Files, etc.]</code></pre>"},{"location":"Lab01-MCP-Fundamentals/#k-agent-architecture-flow","title":"K-Agent Architecture Flow","text":"<pre><code>flowchart TD\n    assistant[AI Assistant] --&gt;|MCP tool request| kagent[K-Agent MCP Server]\n    kagent --&gt; toolRouter[K-Agent Tool Router]\n    toolRouter --&gt;|kubeclient| k8s[Kubernetes API]\n    toolRouter --&gt;|cloud sdk| clouds[Cloud Providers]\n    kagent --&gt;|context updates| datastore[State &amp; Context Store]\n    datastore --&gt;|observability| observ[Logs &amp; Metrics]\n    k8s --&gt;|responses| kagent\n    clouds --&gt;|responses| kagent\n    kagent --&gt;|MCP response| assistant\n    subgraph cluster [Kubernetes Cluster]\n        direction LR\n        k8s\n        datastore\n        observ\n    end</code></pre>"},{"location":"Lab01-MCP-Fundamentals/#mcp-components","title":"MCP Components","text":""},{"location":"Lab01-MCP-Fundamentals/#mcp-server","title":"MCP Server","text":""},{"location":"Lab01-MCP-Fundamentals/#exposes-toolsresources-to-clients","title":"Exposes tools/resources to clients","text":"<ul> <li>Provides a standardized interface for tool interaction</li> <li>Allows AI assistants to discover and call tools</li> <li>Manages tool lifecycle and execution</li> <li>Handles tool errors and retries</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#implements-the-mcp-protocol","title":"Implements the MCP protocol","text":"<ul> <li>Follows JSON-RPC 2.0 specification</li> <li>Supports multiple transport layers (stdio, HTTP, WebSocket)</li> <li>Manages tool schemas and validation</li> <li>Supports tool discovery and listing</li> <li>Provides structured responses</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#typical-mcp-server-features","title":"Typical MCP Server Features","text":"<ul> <li>Runs as a standalone process or service</li> <li>Can be deployed locally or in the cloud</li> <li>Can run in containers or serverless environments</li> <li>Scales based on demand</li> <li>Monitors tool usage and performance</li> <li>Logs tool interactions for auditing</li> <li>Supports authentication and authorization</li> <li>Integrates with AI assistants and applications</li> <li>Defines tool schemas (inputs/outputs)</li> <li>Handles tool execution</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#mcp-server-notes","title":"MCP Server Notes","text":"<ul> <li>Communicates via transport layer (stdio, HTTP, WebSocket)</li> <li>Typically runs as a local process or container</li> <li>In K-Agent, the MCP server exposes Kubernetes and cloud management tools.</li> <li>The server listens for incoming MCP requests from AI assistants and executes the requested tools.</li> <li>In our lab The server translates MCP tool calls into Kubernetes API calls or cloud service operations.</li> <li>The server returns structured responses back to the AI assistant.</li> <li>The server can also update context/state in a datastore for persistent information.</li> <li>The server is implemented using the MCP SDK, which simplifies tool definition and communication handling.</li> <li>The server supports multiple transport layers, allowing it to communicate with different types of AI assistants.</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#mcp-client","title":"MCP Client","text":""},{"location":"Lab01-MCP-Fundamentals/#general-mcp-client-features","title":"General MCP Client Features","text":"<ul> <li>The application that hosts the LLM (e.g., Roo Code, VS Code, Visual Studio, etc.)</li> <li>Discovers available tools from MCP servers</li> <li>Sends tool call requests with parameters</li> <li>Receives and processes tool responses</li> <li>Manages tool invocation lifecycle</li> <li>Handles errors and retries</li> <li>Typically embedded in remote AI assistants (Claude, ChatGPT, etc.) or local models (Ollama, etc.)</li> <li>Presents server capabilities to the user/LLM</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#the-host-application","title":"The Host Application","text":"<ul> <li>The <code>Client</code> is often part of a Host Application (like VS Code, Claude Desktop, or a CLI).</li> <li>The Host manages the connection to the MCP Server.</li> <li>It provides the user interface for interacting with the AI.</li> <li>It handles permissions (asking the user before running a tool).</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#client-capabilities","title":"Client Capabilities","text":"Capability Description Sampling The server can request the client to sample an LLM (generate text). Roots The client can tell the server which files/folders are accessible. Notifications The client can receive notifications from the server (e.g. logs, progress). Context Updates The client can send context/state updates to the server. Authentication The client can provide authentication tokens/credentials to the server. Transport The client supports multiple transport layers (stdio, HTTP, WebSocket). Error Handling The client manages errors and retries for tool calls. Tool Discovery The client can list available tools from the server. Tool Invocation The client can call tools with parameters and receive structured responses. Logging The client can log tool interactions for auditing and debugging."},{"location":"Lab01-MCP-Fundamentals/#transport-layer-mcp-communication","title":"Transport Layer - MCP Communication","text":"<ul> <li>MCP supports multiple transport mechanisms:</li> </ul> Protocol Description <code>stdio</code> Standard input/output (used in K-Agent) <code>HTTP</code> RESTful API communication <code>WebSocket</code> Real-time bidirectional communication <code>gRPC</code> High-performance RPC framework <code>MQTT</code> Lightweight messaging protocol <code>Custom</code> Any custom transport implementation"},{"location":"Lab01-MCP-Fundamentals/#mcp-communication-flow","title":"MCP Communication Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant S as Server\n\n    C-&gt;&gt;S: 1. Discover available tools\n    C-&gt;&gt;S: 2. Send tool call request (parameters)\n    Note over S: 3. Validate request against schema\n    Note over S: 4. Execute tool logic\n    S--&gt;&gt;C: 5. Return structured response\n    Note over C: 6. Process response &amp; continue interaction</code></pre>"},{"location":"Lab01-MCP-Fundamentals/#mcp-tool-structure","title":"MCP Tool Structure","text":"<ul> <li>An MCP tool consists of:</li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#tool-definition","title":"Tool Definition","text":"<ul> <li>Metadata about the tool (name, description)</li> <li>Input schema defining parameters</li> <li>Output schema defining response structure</li> <li>Versioning information</li> <li>Dependencies and requirements</li> <li>Authentication requirements</li> <li>Rate limiting information</li> <li>Error handling strategies</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#tool-handler","title":"Tool Handler","text":"<ul> <li>Function that implements the tool\u2019s logic</li> <li>Receives input parameters</li> <li>Performs the tool\u2019s operation</li> <li>Returns structured output</li> <li>Handles errors and exceptions</li> <li>Logs execution details</li> <li>Manages state/context if needed</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#tool-execution-flow","title":"Tool Execution Flow","text":"<ul> <li>Client discovers tool from server</li> <li>Client sends tool call request with parameters</li> <li>Server validates request against tool schema</li> <li>Server invokes tool handler with parameters</li> <li>Tool handler executes logic and returns response</li> <li>Server sends structured response back to client</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#input-schema","title":"Input Schema","text":"<ul> <li>Defines expected parameters for the tool</li> <li>Uses JSON Schema format</li> <li>Specifies data types, required fields, and descriptions</li> <li>Enables validation of incoming requests</li> <li>Facilitates client-side form generation</li> <li>Supports complex nested structures</li> <li>Allows default values and constraints</li> <li>Enhances interoperability between clients and servers</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#core-mcp-capabilities","title":"Core MCP Capabilities","text":"<p><code>MCP</code> servers can expose three main types of capabilities:</p>"},{"location":"Lab01-MCP-Fundamentals/#1-tools","title":"1. Tools","text":"<p>Functions that the LLM can call to perform actions or retrieve information.</p> <p>Examples:</p> <ul> <li>Search a database</li> <li>Make an API call</li> <li>Perform calculations</li> <li>Execute system commands</li> </ul> <p>Characteristics:</p> <ul> <li>Defined with JSON Schema for input validation</li> <li>Return structured results</li> <li>Can have side effects (create, update, delete operations)</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#examples","title":"Examples:","text":"<ul> <li> <p>Tool Definition:</p> <pre><code>{\n  name: \"hello\",\n  description: \"Returns a greeting message\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      name: {\n        type: \"string\",\n        description: \"Name to greet\"\n      }\n    },\n    required: [\"name\"]\n  }\n}\n</code></pre> </li> <li> <p>Tool Handler:</p> <pre><code>async function handleHello(args: { name: string }) {\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Hello, ${args.name}!`\n      }\n    ]\n  };\n}\n</code></pre> </li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#2-resources","title":"2. Resources","text":"<p>Contextual data that can be read by the LLM.</p> <p>Examples:</p> <ul> <li>File contents</li> <li>Database records</li> <li>API responses</li> <li>Documentation</li> </ul> <p>Characteristics:</p> <ul> <li>Identified by URI (Uniform Resource Identifier)</li> <li>Can be text, binary, or structured data</li> <li>Typically read-only</li> <li>Support for templates and subscriptions</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#3-prompts","title":"3. Prompts","text":"<p>Pre-built prompt templates that users can invoke.</p> <p>Examples:</p> <ul> <li>Code review templates</li> <li>Documentation generation prompts</li> <li>Analysis frameworks</li> <li>Interaction patterns</li> </ul> <p>Characteristics:</p> <ul> <li>Can include embedded resources</li> <li>Support arguments for customization</li> <li>Help standardize common tasks</li> <li>Improve consistency and quality</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#the-mcp-lifecycle","title":"The MCP Lifecycle","text":"<p>Understanding how <code>MCP</code> clients and servers interact:</p>"},{"location":"Lab01-MCP-Fundamentals/#1-initialization","title":"1. Initialization","text":"<ul> <li>Client connects to server via transport layer</li> <li>Handshake to establish protocol version and capabilities</li> <li>Server sends initial tool/resource/prompt listings</li> <li>Client acknowledges and prepares for interaction</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#2-capability-discovery","title":"2. Capability Discovery","text":"<ul> <li>Client requests list of available tools, resources, or prompts</li> <li>Server responds with detailed descriptions</li> <li>Client presents these to the user/LLM</li> <li>Client selects tools/resources/prompts to use</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#3-execution","title":"3. Execution","text":"<ul> <li>Client sends requests to invoke tools, read resources, or render prompts</li> <li>Server processes the request</li> <li>Server returns results in standardized format</li> <li>Client handles the response and continues interaction</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#4-cleanup","title":"4. Cleanup","text":"<ul> <li>Either party can close the connection</li> <li>Graceful shutdown with notifications</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#mcp-communication-model","title":"MCP Communication Model","text":"<p><code>MCP</code> uses three types of messages:</p>"},{"location":"Lab01-MCP-Fundamentals/#1-requests","title":"1. Requests","text":"<ul> <li>Require a response</li> <li>Include a unique request ID</li> <li>Examples: <code>tools/list</code>, <code>resources/read</code>, <code>tools/call</code></li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#2-responses","title":"2. Responses","text":"<ul> <li>Match to requests by ID</li> <li>Contain either results or errors</li> <li>Must be sent for every request</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#3-notifications","title":"3. Notifications","text":"<ul> <li>One-way messages</li> <li>Don\u2019t require responses</li> <li>Examples: <code>notifications/initialized</code>, <code>notifications/cancelled</code></li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#security-considerations","title":"Security Considerations","text":"<p>When working with <code>MCP</code>, keep these best practices in mind:</p> <ol> <li> <p>Authentication &amp; Authorization</p> <ul> <li>Servers should validate requests</li> <li>Use appropriate credentials management</li> <li>Implement least-privilege access</li> </ul> </li> <li> <p>Data Privacy</p> <ul> <li>Be mindful of what data is exposed</li> <li>Implement proper access controls</li> <li>Consider encryption for sensitive data</li> </ul> </li> <li> <p>Rate Limiting</p> <ul> <li>Protect against abuse</li> <li>Implement appropriate throttling</li> <li>Monitor usage patterns</li> </ul> </li> <li> <p>Input Validation</p> <ul> <li>Always validate tool inputs</li> <li>Sanitize user-provided data</li> <li>Prevent injection attacks</li> </ul> </li> </ol>"},{"location":"Lab01-MCP-Fundamentals/#common-use-cases","title":"Common Use Cases","text":"<p><code>MCP</code> is ideal for:</p>"},{"location":"Lab01-MCP-Fundamentals/#enterprise-integration","title":"Enterprise Integration","text":"<ul> <li>Connect LLMs to internal databases</li> <li>Access corporate knowledge bases</li> <li>Integrate with business tools (CRM, ERP, etc.)</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#developer-tools","title":"Developer Tools","text":"<ul> <li>File system access</li> <li>Git operations</li> <li>Database queries</li> <li>API testing and documentation</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#data-analysis","title":"Data Analysis","text":"<ul> <li>Query and visualize data</li> <li>Generate reports</li> <li>Perform statistical analysis</li> <li>Access multiple data sources</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#productivity","title":"Productivity","text":"<ul> <li>Calendar and email management</li> <li>Task and project tracking</li> <li>Document processing</li> <li>Automated workflows</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/#mcp-vs-other-approaches","title":"MCP vs. Other Approaches","text":"Approach Pros Cons Function Calling Simple, direct Requires custom implementation per app API Integration Flexible No standard, duplicated effort MCP Universal standard, reusable, scalable Requires initial setup"},{"location":"Lab01-MCP-Fundamentals/#hands-on-exercise","title":"Hands-On Exercise","text":""},{"location":"Lab01-MCP-Fundamentals/#explore-an-mcp-server-configuration","title":"Explore an MCP Server Configuration","text":"<p>Look at how an <code>MCP</code> server is configured in a client application (like Roo Code):</p> <pre><code>{\n  \"mcpServers\": {\n    \"example-server\": {\n      \"command\": \"node\",\n      \"args\": [\"/path/to/server/index.js\"],\n      \"env\": {\n        \"API_KEY\": \"your-api-key\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Lab01-MCP-Fundamentals/#testing-mcp-tools-ts","title":"Testing MCP Tools (TS)","text":""},{"location":"Lab01-MCP-Fundamentals/#using-mcp-inspector","title":"Using MCP Inspector","text":"<p><code>MCP Inspector</code> is a tool for testing MCP servers interactively.</p> <pre><code># Install mcp-inspector (if not already installed)\nnpm install -g @modelcontextprotocol/inspector\n\n# Start the MCP Inspector with the TS code\nnpx @modelcontextprotocol/inspector node ./build/index.js\n</code></pre> <p>MCP Inspector UI</p> <ul> <li>MCP Inspector will start a web interface at <code>http://localhost:6274</code></li> <li>You can also test tools programmatically using the examples below.</li> </ul> <p>Step-by-step MCP Inspector Testing:</p> <ol> <li> <p>Get the Authentication Token    When you start MCP Inspector, the terminal displays:</p> <pre><code>\ud83d\udd11 Session token: [long-token-string]\n\n\ud83d\udd17 Open inspector with token pre-filled:\n    http://localhost:6274/?MCP_PROXY_AUTH_TOKEN=[token]\n</code></pre> </li> <li> <p>Copy the Authentication URL    Copy the complete URL with the token (the second line starting with <code>http://</code>)</p> </li> <li> <p>Open MCP Inspector in Your Browser    Paste the complete URL from step 2 into your browser. You\u2019ll be authenticated immediately.</p> </li> <li> <p>Configure the Server Connection    In the MCP Inspector interface:</p> <ul> <li>Verify the \u201cTransport\u201d is set to <code>stdio</code> (NOT http or streamable-http)</li> <li>You\u2019ll see a \u201cCommand\u201d field - it should already show: <code>node</code></li> <li>look for the \u201cArgument\u201d field - it should show: <code>/app/build/index.js</code></li> <li>Click the \u201cConnect\u201d button</li> <li>Wait for the status to show \u201cConnected\u201d with a green indicator</li> </ul> </li> <li> <p>Explore Available Tools:</p> <ul> <li>Once connected, click on the \u201cTools\u201d tab at the top of the interface, and the on \u201cList Tools\u201d button</li> <li>You\u2019ll see a list of available tools from your MCP server</li> </ul> </li> </ol> <p>Authentication Required</p> <ul> <li>The MCP Inspector requires authentication by default. </li> <li>Always use the URL with the token (shown in the terminal when you start the inspector), or manually enter the token in the Configuration settings. </li> <li>If you forget the token, restart the MCP Inspector to generate a new one.</li> </ul> <p>Disabling Authentication (Development Only)</p> <p>Y* ou can disable authentication by setting the <code>DANGEROUSLY_OMIT_AUTH=true</code> environment variable: <pre><code>DANGEROUSLY_OMIT_AUTH=true npx @modelcontextprotocol/inspector node /app/build/index.js\n</code></pre> \u26a0\ufe0f WARNING: This is dangerous and should ONLY be used in isolated development environments, never in production or when exposed to the internet.</p> <p>Keep MCP Inspector Running</p> <ul> <li>Make sure the MCP Inspector command (<code>npx @modelcontextprotocol/inspector node /app/build/index.js</code>) is still running in your terminal. </li> <li>If the connection fails or you see errors, restart the command in the container.</li> </ul> <p>Interactive Testing</p> <ul> <li>The MCP Inspector provides a user-friendly web interface to test your MCP server without writing code. </li> <li>This is perfect for debugging and understanding how MCP tools work before integrating them with AI assistants.</li> </ul> <p>Understanding MCP Inspector Output</p> <ul> <li>The Inspector displays tool results in a readable format. </li> <li>Internally, MCP uses JSON-RPC 2.0 protocol with structured responses, but the UI shows you the human-readable content. </li> <li>For JSON view, see the \u201cHistory\u201d section below the UI</li> </ul> <p>Ready to build your first MCP server? Continue to Lab 2!</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/","title":"MCP Fundementals Tasks - Lab 1","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-11-identify-mcp-components","title":"Exercise 1.1: Identify MCP Components","text":"<p>Identify the three main components of the MCP architecture and explain their roles.</p> Solution <p>The three main components are:</p> <ol> <li>MCP Client: Applications that host LLMs (like Roo Code, Claude Desktop)</li> <li>MCP Server: Exposes capabilities to clients (tools, resources, prompts)</li> <li>MCP Protocol: JSON-RPC 2.0 based communication standard</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-12-mcp-vs-traditional-apis","title":"Exercise 1.2: MCP vs Traditional APIs","text":"<p>Explain how MCP differs from traditional REST APIs in terms of LLM integration.</p> Solution <p>MCP provides a standardized protocol specifically designed for LLM integration, while traditional APIs require custom integration code for each application. MCP enables universal connectivity across all MCP-compatible clients.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-13-transport-layers","title":"Exercise 1.3: Transport Layers","text":"<p>List the three main transport mechanisms supported by MCP and their use cases.</p> Solution <ol> <li>STDIO: Most common, for local subprocess communication</li> <li>SSE (Server-Sent Events): HTTP-based for remote servers</li> <li>Streamable HTTP: Modern standard for remote MCP servers</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-14-mcp-capabilities","title":"Exercise 1.4: MCP Capabilities","text":"<p>Name the three types of capabilities MCP servers can expose.</p> Solution <ol> <li>Tools: Functions for performing actions</li> <li>Resources: Contextual data for reading</li> <li>Prompts: Pre-built prompt templates</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-15-json-rpc-message-types","title":"Exercise 1.5: JSON-RPC Message Types","text":"<p>Identify the three types of messages used in MCP communication.</p> Solution <ol> <li>Requests: Require responses (tools/list, resources/read)</li> <li>Responses: Match to requests with results or errors</li> <li>Notifications: One-way messages (initialized, cancelled)</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-16-mcp-initialization-flow","title":"Exercise 1.6: MCP Initialization Flow","text":"<p>Describe the sequence of messages during MCP server initialization.</p> Solution <ol> <li>Client sends <code>initialize</code> request</li> <li>Server processes and responds with <code>initialize</code> response</li> <li>Client sends <code>initialized</code> notification</li> <li>Connection is established</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-17-tool-definition-schema","title":"Exercise 1.7: Tool Definition Schema","text":"<p>What information must be included when defining an MCP tool?</p> Solution <ul> <li>Tool name</li> <li>Description</li> <li>Input parameters (JSON Schema)</li> <li>Whether it has side effects</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-18-resource-identifiers","title":"Exercise 1.8: Resource Identifiers","text":"<p>How are MCP resources identified and what types of data can they contain?</p> Solution <p>Resources are identified by URIs and can contain text, binary data, or structured data. They are typically read-only.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-19-prompt-templates","title":"Exercise 1.9: Prompt Templates","text":"<p>Explain the purpose of MCP prompts and how they differ from regular prompts.</p> Solution <p>MCP prompts are pre-built, reusable prompt templates that can include embedded resources and support arguments for customization, ensuring consistency across applications.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-110-security-considerations","title":"Exercise 1.10: Security Considerations","text":"<p>List three security best practices for MCP implementations.</p> Solution <ol> <li>Authentication &amp; Authorization: Validate requests and use least-privilege access</li> <li>Data Privacy: Control what data is exposed</li> <li>Input Validation: Sanitize user inputs to prevent injection attacks</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-111-mcp-client-examples","title":"Exercise 1.11: MCP Client Examples","text":"<p>Name three popular MCP client applications.</p> Solution <ol> <li>Roo Code (VS Code extension)</li> <li>Claude Desktop</li> <li>Continue.dev</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-112-protocol-versioning","title":"Exercise 1.12: Protocol Versioning","text":"<p>How does MCP handle protocol versioning and backward compatibility?</p> Solution <p>MCP uses capability negotiation during initialization, allowing clients and servers to agree on supported features and maintain backward compatibility.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-113-error-handling","title":"Exercise 1.13: Error Handling","text":"<p>How are errors communicated in MCP?</p> Solution <p>Errors are communicated through JSON-RPC error responses with error codes, messages, and optional data fields.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-114-connection-lifecycle","title":"Exercise 1.14: Connection Lifecycle","text":"<p>Describe the complete MCP connection lifecycle from start to finish.</p> Solution <ol> <li>Initialization handshake</li> <li>Capability discovery</li> <li>Normal operation (tool calls, resource access)</li> <li>Cleanup and graceful shutdown</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-115-mcp-ecosystem-benefits","title":"Exercise 1.15: MCP Ecosystem Benefits","text":"<p>Explain three key benefits of the MCP ecosystem approach.</p> Solution <ol> <li>Universal Integration: One server works with all MCP clients</li> <li>Standardized Communication: Consistent interface across applications</li> <li>Rapid Development: Reduced integration time and duplication</li> </ol>"},{"location":"Lab02-First-MCP-Server/","title":"Lab 2: Building Your First MCP Server","text":""},{"location":"Lab02-First-MCP-Server/#overview","title":"Overview","text":"<ul> <li>Now that you understand the fundamentals of <code>MCP</code>, it\u2019s time to get hands-on! </li> <li>In this lab, you\u2019ll build a complete, working <code>MCP</code> server from scratch. </li> <li>You\u2019ll learn how to set up the project, implement the core protocol, and connect it to an <code>MCP</code> client.</li> </ul>"},{"location":"Lab02-First-MCP-Server/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Set up a <code>Node.js / TypeScript / Python</code> project for <code>MCP</code> development</li> <li>Implement the <code>MCP</code> initialization handshake</li> <li>Create a basic server structure using the <code>MCP</code> SDK</li> <li>Test your server with a real <code>MCP</code> client</li> <li>Understand the request/response lifecycle</li> <li>Debug and troubleshoot common issues</li> </ul>"},{"location":"Lab02-First-MCP-Server/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Node.js (v18 or later) installed</li> <li>Python (v3.8 or later) installed</li> <li>npm or yarn package manager</li> <li>A code editor (VS Code recommended)</li> <li>Basic understanding of JavaScript / TypeScript / Python</li> <li>Familiarity with JSON and HTTP</li> <li>Basic knowledge of MCP concepts from Lab 1</li> </ul> <p>To verify your prerequisites are installed correctly, run the following commands:</p> <pre><code># Check Node.js version\nnode --version\n\n# Check npm version\nnpm --version\n\n# Check Python version\npython3 --version\npython --version\n</code></pre>"},{"location":"Lab02-First-MCP-Server/#project-setup","title":"Project Setup","text":""},{"location":"Lab02-First-MCP-Server/#step-1-initialize-your-project","title":"Step 1: Initialize Your Project","text":"<ul> <li> <p>Create a new directory for your <code>MCP</code> server, navigate into it, and initialize a new <code>Node.js</code> / <code>Python</code> project:</p> <pre><code>mkdir my-first-mcp-server\ncd my-first-mcp-server\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"Node.js / TypeScriptPython <ul> <li> <p>Install the MCP SDK and TypeScript dependencies using npm and build tool:   <pre><code># Core MCP SDK\nnpm install @modelcontextprotocol/sdk\n\n# TypeScript and type definitions\nnpm install -D typescript @types/node\n\n# Build tool\nnpm install -D tsx\n</code></pre></p> </li> <li> <p>To verify TypeScript installation:   <pre><code>tsc --version\n</code></pre></p> </li> </ul> <ul> <li> <p>For this lab, we\u2019ll use FastMCP which simplifies MCP server development with a Flask-like decorator syntax.</p> </li> <li> <p>Create a <code>requirements.txt</code> file:   <pre><code>mcp\nfastmcp\nuvicorn\nhttpx\nstarlette\n</code></pre></p> </li> <li> <p>Install uv (fast Python package installer) if not already installed:   <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre></p> </li> <li> <p>Create and activate a virtual environment, then install dependencies:   <pre><code># Create virtual environment using uv\nuv venv\n\n# Activate virtual environment\nsource .venv/bin/activate  # On Windows use `.venv\\Scripts\\activate`\n\n# Install dependencies\nuv pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>To verify installation:   <pre><code>python -c \"import mcp; print('MCP installed successfully')\"\npython -c \"from mcp.server.fastmcp import FastMCP; print('FastMCP ready')\"\n</code></pre></p> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#step-3-configure-your-project","title":"Step 3: Configure Your Project","text":"Node.js / TypeScriptPython <ul> <li>Create a <code>tsconfig.json</code> file:     <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre></li> <li>Replace (copy / paste) the entire content of the file <code>package.json</code>, located inside the previously created <code>my-first-mcp-server</code> directory with this:     <pre><code>{\n  \"name\": \"my-first-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"description\": \"My first MCP server\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx src/index.ts\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\"mcp\", \"server\"],\n  \"author\": \"Your Name\"\n}\n</code></pre></li> </ul> <ul> <li>Create a <code>requirements.txt</code> file with the necessary dependencies (if not created in Step 2):   <pre><code>mcp\nfastmcp\nuvicorn\nhttpx\nstarlette\n</code></pre></li> </ul>"},{"location":"Lab02-First-MCP-Server/#step-4-create-the-mcp-server","title":"Step 4: Create the MCP Server","text":"Node.js / TypeScriptPython <ul> <li>Create a directory named <code>src</code> inside <code>my-first-mcp-server</code>.</li> <li> <p>Create a file named <code>index.ts</code> inside the <code>src</code> directory and fill it with the following basic server skeleton code (copy / paste inside the file):</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n* Create an MCP server with core capabilities\n*/\nclass MyFirstMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"my-first-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          {\n            name: \"hello_world\",\n            description: \"Returns a friendly greeting message\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                name: {\n                  type: \"string\",\n                  description: \"The name to greet\",\n                },\n              },\n              required: [\"name\"],\n            },\n          },\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        if (name === \"hello_world\") {\n          const userName = args?.name as string;\n\n          if (!userName) {\n            throw new Error(\"Name parameter is required\");\n          }\n\n          return {\n            content: [\n              {\n                type: \"text\",\n                text: `Hello, ${userName}! Welcome to your first MCP server! \ud83c\udf89`,\n              },\n            ],\n          };\n        }\n\n        throw new Error(`Unknown tool: ${name}`);\n      }\n    );\n  }\n\n  /**\n  * Set up error handling\n  */\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  /**\n  * Start the server\n  */\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n\n    console.error(\"My First MCP Server running on stdio\");\n  }\n}\n\n/**\n* Main entry point\n*/\nasync function main() {\n  const server = new MyFirstMCPServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre> </li> </ul> <ul> <li> <p>Create a file named <code>mcp.py</code> in the root of <code>my-first-mcp-server</code> directory and add the following code:</p> <pre><code>#!/usr/bin/env python3\nfrom mcp.server.fastmcp import FastMCP\nfrom starlette.responses import JSONResponse\nfrom starlette.requests import Request\n\n# Create FastMCP server instance\n# This will listen on port 8889\nmcp = FastMCP(\"my-first-mcp-server\", port=8889)\n\n# CORS headers for browser-based inspector\nHEADERS = {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET,POST,OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type,Authorization,X-Proxy-Token\",\n}\n\n# Define a simple hello tool using @mcp.tool() decorator\n@mcp.tool()\ndef hello_world(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to your first MCP server! \ud83c\udf89\"\n\n# Health check endpoint\n@mcp.custom_route(\"/health\", methods=[\"GET\", \"OPTIONS\"])\nasync def health_check(request: Request) -&gt; JSONResponse:\n    return JSONResponse({\"status\": \"healthy\"}, headers=HEADERS)\n\n# MCP Manifest endpoint\n@mcp.custom_route(\"/.well-known/mcp\", methods=[\"GET\", \"OPTIONS\"])\nasync def mcp_manifest(request: Request) -&gt; JSONResponse:\n    host = request.headers.get(\"host\", \"localhost:8889\")\n    scheme = request.url.scheme or \"http\"\n    base = f\"{scheme}://{host}\"\n\n    manifest = {\n        \"name\": \"my-first-mcp-server\",\n        \"version\": \"1.0.0\",\n        \"base_url\": base,\n        \"transport\": \"streamable-http\",\n        \"capabilities\": {\n            \"tools\": True,\n            \"prompts\": False,\n            \"resources\": False,\n        },\n        \"endpoints\": {\n            \"manifest\": \"/.well-known/mcp\",\n            \"health\": \"/health\",\n            \"events\": \"/mcp\",\n        },\n    }\n    return JSONResponse(manifest, headers=HEADERS)\n\n# Server metadata endpoint\n@mcp.custom_route(\"/metadata\", methods=[\"GET\", \"OPTIONS\"])\nasync def metadata(request: Request) -&gt; JSONResponse:\n    return JSONResponse({\n        \"serverInfo\": {\n            \"name\": \"my-first-mcp-server\",\n            \"version\": \"1.0.0\",\n            \"protocolVersion\": \"2024-11-05\"\n        },\n        \"capabilities\": {\n            \"tools\": {\"listChanged\": False},\n        }\n    }, headers=HEADERS)\n\n# Main entry point\ndef main():\n    # Start the MCP server with streamable-http transport\n    # Mounted at /mcp path\n    mcp.run(transport=\"streamable-http\", mount_path=\"/mcp\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#understanding-the-code","title":"Understanding the Code","text":"<p>Let\u2019s break down the key components:</p> Node.js / TypeScriptPython"},{"location":"Lab02-First-MCP-Server/#1-server-initialization","title":"1. Server Initialization","text":"<pre><code>this.server = new Server(\n  {\n    name: \"my-first-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n</code></pre> <ul> <li>Defines server metadata (name and version)</li> <li>Declares capabilities (in this case, the server supports tools)</li> <li>This information is sent during the initialization handshake</li> </ul>"},{"location":"Lab02-First-MCP-Server/#2-list-tools-handler","title":"2. List Tools Handler","text":"<pre><code>this.server.setRequestHandler(\n  ListToolsRequestSchema,\n  async () =&gt; ({\n    tools: [...],\n  })\n);\n</code></pre> <ul> <li>Responds to <code>tools/list</code> requests from clients</li> <li>Returns an array of tool definitions</li> <li>Each tool has: name, description and inputSchema (JSON Schema)</li> </ul>"},{"location":"Lab02-First-MCP-Server/#3-call-tool-handler","title":"3. Call Tool Handler","text":"<pre><code>this.server.setRequestHandler(\n  CallToolRequestSchema,\n  async (request) =&gt; {\n    // Tool execution logic\n  }\n);\n</code></pre> <ul> <li>Responds to <code>tools/call</code> requests</li> <li>Receives tool name and arguments</li> <li>Returns tool results in a standardized format</li> </ul>"},{"location":"Lab02-First-MCP-Server/#4-transport-layer","title":"4. Transport Layer","text":"<pre><code>const transport = new StdioServerTransport();\nawait this.server.connect(transport);\n</code></pre> <ul> <li>Uses stdio (standard input/output) for communication</li> <li>Server runs as a subprocess of the client</li> <li>All <code>MCP</code> messages flow through stdin/stdout</li> </ul>"},{"location":"Lab02-First-MCP-Server/#1-server-initialization-with-fastmcp","title":"1. Server Initialization with FastMCP","text":"<pre><code>mcp = FastMCP(\"my-first-mcp-server\", port=8889)\n</code></pre> <ul> <li>Creates a FastMCP server instance with a name and port</li> <li>FastMCP uses a Flask-like decorator syntax for simplicity</li> <li>The server will listen on port 8889 for HTTP connections</li> </ul>"},{"location":"Lab02-First-MCP-Server/#2-tool-definition-with-decorators","title":"2. Tool Definition with Decorators","text":"<pre><code>@mcp.tool()\ndef hello_world(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to your first MCP server! \ud83c\udf89\"\n</code></pre> <ul> <li>The <code>@mcp.tool()</code> decorator automatically registers the function as an MCP tool</li> <li>Function signature defines the input parameters (with type hints)</li> <li>Docstring becomes the tool description</li> <li>Return value is automatically formatted as MCP response</li> </ul>"},{"location":"Lab02-First-MCP-Server/#3-custom-routes-for-mcp-protocol","title":"3. Custom Routes for MCP Protocol","text":"<pre><code>@mcp.custom_route(\"/health\", methods=[\"GET\", \"OPTIONS\"])\nasync def health_check(request: Request) -&gt; JSONResponse:\n    return JSONResponse({\"status\": \"healthy\"}, headers=HEADERS)\n</code></pre> <ul> <li>Custom routes handle MCP protocol endpoints</li> <li>Support for CORS headers enables browser-based inspector access</li> <li>Returns JSON responses following MCP specification</li> </ul>"},{"location":"Lab02-First-MCP-Server/#4-transport-layer_1","title":"4. Transport Layer","text":"<pre><code>mcp.run(transport=\"streamable-http\", mount_path=\"/mcp\")\n</code></pre> <ul> <li>Uses streamable-http transport for bi-directional communication</li> <li>Mounts the MCP protocol handler at <code>/mcp</code> path</li> <li>Server runs with uvicorn ASGI server automatically</li> </ul>"},{"location":"Lab02-First-MCP-Server/#5-tool-execution-helper-why-get_tool_function","title":"5. Tool Execution Helper - Why <code>get_tool_function</code>?","text":"<p>In more advanced MCP servers (like the full example in <code>mcp.py</code>), you\u2019ll see a helper function called <code>get_tool_function</code>:</p> <pre><code>def get_tool_function(tool_name: str):\n    \"\"\"Get the actual function for a tool by name\"\"\"\n    tool_map = {\n        'hello_world': hello_world,\n        'calculate': calculate,\n        'echo': echo,\n    }\n    return tool_map.get(tool_name)\n</code></pre> <p>Why do we need this?</p> <ol> <li> <p>Dynamic Tool Execution: When the MCP Inspector or client sends a tool call request with just the tool name as a string (e.g., <code>\"hello_world\"</code>), we need to map that string to the actual Python function.</p> </li> <li> <p>Decoupling Tool Registration from Execution: While <code>@mcp.tool()</code> decorator handles registration, for custom execution workflows (like tracking execution history, adding middleware, or batch execution), we need direct access to the tool functions.</p> </li> <li> <p>Tool Validation: Before executing a tool, we can verify it exists in our tool map, providing better error messages if a non-existent tool is called.</p> </li> <li> <p>Execution Tracking: In the full <code>mcp.py</code> example, we use this helper to:</p> </li> <li>Track tool execution history</li> <li>Measure execution time</li> <li>Log tool calls</li> <li>Handle errors consistently</li> </ol> <p>Example usage in execution flow:</p> <pre><code>async def execute_tool(tool_name: str, arguments: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute a tool and return the result\"\"\"\n    # Get the actual function by name\n    tool_func = get_tool_function(tool_name)\n\n    if not tool_func:\n        return {\"error\": f\"Tool '{tool_name}' not found\"}\n\n    # Validate arguments against function signature\n    valid, message = validate_tool_arguments(tool_func, arguments)\n    if not valid:\n        return {\"error\": message}\n\n    # Execute the tool\n    result = await tool_func(**arguments) if inspect.iscoroutinefunction(tool_func) else tool_func(**arguments)\n\n    return {\"success\": True, \"result\": result}\n</code></pre> <p>When to use it:</p> <ul> <li>Building custom execution endpoints (<code>/tools/execute</code>, <code>/tools/batch</code>)</li> <li>Adding execution middleware (logging, timing, caching)</li> <li>Implementing tool execution history</li> <li>Creating custom validation or error handling</li> <li>Not needed for basic MCP servers where <code>@mcp.tool()</code> handles everything</li> </ul> <p>Simplified vs Advanced Approach</p> <p>For this lab\u2019s basic server, <code>@mcp.tool()</code> decorator is sufficient. The <code>get_tool_function</code> pattern is useful when you need more control over tool execution, which you\u2019ll see in advanced labs.</p>"},{"location":"Lab02-First-MCP-Server/#6-the-execute_tool-function-complete-tool-execution-pipeline","title":"6. The <code>execute_tool</code> Function - Complete Tool Execution Pipeline","text":"<p>The <code>execute_tool</code> function is the heart of custom tool execution. It orchestrates the entire lifecycle of a tool call:</p> <pre><code>async def execute_tool(tool_name: str, arguments: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute a tool and return the result\"\"\"\n    global EXECUTION_COUNTER\n    execution_id = f\"exec_{EXECUTION_COUNTER}\"\n    EXECUTION_COUNTER += 1\n\n    start_time = time.time()\n\n    try:\n        # 1. Lookup the tool function\n        tool_func = get_tool_function(tool_name)\n        if not tool_func:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": f\"Tool '{tool_name}' not found\",\n                \"duration_ms\": 0\n            }\n\n        # 2. Validate arguments\n        valid, message = validate_tool_arguments(tool_func, arguments)\n        if not valid:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": message,\n                \"duration_ms\": 0\n            }\n\n        # 3. Execute the tool (handle both sync and async)\n        if inspect.iscoroutinefunction(tool_func):\n            result = await tool_func(**arguments)\n        else:\n            result = tool_func(**arguments)\n\n        # 4. Record successful execution\n        duration_ms = (time.time() - start_time) * 1000\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": True,\n            \"result\": result,\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n\n    except Exception as e:\n        # 5. Record failed execution\n        duration_ms = (time.time() - start_time) * 1000\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": False,\n            \"error\": str(e),\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n</code></pre> <p>What does <code>execute_tool</code> do?</p> <ol> <li> <p>Generates Execution ID: Creates a unique identifier for tracking this specific tool execution    <pre><code>execution_id = f\"exec_{EXECUTION_COUNTER}\"\n</code></pre></p> </li> <li> <p>Tool Lookup: Uses <code>get_tool_function()</code> to find the actual Python function</p> </li> <li>Returns error immediately if tool doesn\u2019t exist</li> <li> <p>Avoids crashes from undefined tools</p> </li> <li> <p>Argument Validation: Validates parameters against the function signature</p> </li> <li>Checks for required parameters</li> <li>Detects unexpected parameters</li> <li> <p>Provides clear error messages</p> </li> <li> <p>Async/Sync Execution: Handles both synchronous and asynchronous tools    <pre><code>if inspect.iscoroutinefunction(tool_func):\n    result = await tool_func(**arguments)\nelse:\n    result = tool_func(**arguments)\n</code></pre></p> </li> <li> <p>Performance Tracking: Measures execution time in milliseconds    <pre><code>duration_ms = (time.time() - start_time) * 1000\n</code></pre></p> </li> <li> <p>Execution History: Stores all executions (success and failure) in <code>TOOL_EXECUTIONS</code> dictionary</p> </li> <li>Enables debugging</li> <li>Supports execution history endpoint (<code>/tools/history</code>)</li> <li> <p>Helps track tool usage patterns</p> </li> <li> <p>Structured Responses: Returns consistent response format:    <pre><code>{\n    \"execution_id\": \"exec_0\",\n    \"tool\": \"hello_world\",\n    \"arguments\": {\"name\": \"Alice\"},\n    \"success\": True,\n    \"result\": \"Hello, Alice!\",\n    \"duration_ms\": 1.23,\n    \"timestamp\": 1704931200.0\n}\n</code></pre></p> </li> </ol> <p>Why use <code>execute_tool</code> instead of calling tools directly?</p> Direct Call Through <code>execute_tool</code> <code>result = hello_world(name=\"Alice\")</code> <code>result = await execute_tool(\"hello_world\", {\"name\": \"Alice\"})</code> No validation Argument validation No error tracking Error records No timing data Performance metrics No execution history Complete audit trail Manual async handling Automatic async detection <p>Where is <code>execute_tool</code> used?</p> <ol> <li> <p>Custom Execution Endpoint (<code>/tools/execute</code>):    <pre><code>@mcp.custom_route(\"/tools/execute\", methods=[\"POST\"])\nasync def tool_execute(request: Request):\n    body = await request.json()\n    result = await execute_tool(body[\"tool\"], body.get(\"arguments\", {}))\n    return JSONResponse(result)\n</code></pre></p> </li> <li> <p>Batch Execution (<code>/tools/batch</code>):    <pre><code>results = []\nfor call in calls:\n    result = await execute_tool(call[\"tool\"], call.get(\"arguments\", {}))\n    results.append(result)\n</code></pre></p> </li> <li> <p>Streaming Execution (<code>/tools/stream</code>):    <pre><code>result = await execute_tool(tool_name, arguments)\nyield json.dumps({\"event\": \"result\", \"data\": result})\n</code></pre></p> </li> </ol> <p>Production Benefits</p> <ul> <li>Observability: Track which tools are used most, their success rates, and performance</li> <li>Debugging: View execution history with <code>/tools/history</code> endpoint</li> <li>Error Analysis: See all failures with context and timing</li> <li>API Consistency: All execution endpoints return the same structure</li> <li>Audit Trail: Complete log of all tool invocations</li> </ul>"},{"location":"Lab02-First-MCP-Server/#testing-your-server","title":"Testing Your Server","text":"Node.js / TypeScriptPython"},{"location":"Lab02-First-MCP-Server/#testing-with-the-mcp-inspector","title":"Testing with the MCP Inspector","text":"<ul> <li> <p>The MCP Inspector is a web-based tool for testing MCP servers. Run these commands from your <code>my-first-mcp-server</code> directory:</p> <pre><code># Install the inspector globally\nnpm install -g @modelcontextprotocol/inspector\n\n# Run your server with the inspector\nnpx @modelcontextprotocol/inspector --transport stdio tsx src/index.ts\n</code></pre> </li> <li> <p>This will open a web interface where you can:</p> <ul> <li>See the server\u2019s capabilities</li> <li>List available tools</li> <li>Call tools with test inputs</li> <li>View request/response messages</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#testing-with-the-mcp-inspector_1","title":"Testing with the MCP Inspector","text":"<ul> <li> <p>The MCP Inspector can test Python MCP servers over HTTP. Run these commands from your <code>my-first-mcp-server</code> directory:</p> <pre><code># Make sure your virtual environment is activated\nsource .venv/bin/activate\n\n# Run the Python MCP server\npython mcp.py\n</code></pre> </li> <li> <p>The server will start on <code>http://localhost:8889</code></p> </li> <li> <p>In a new terminal, install and run the MCP Inspector:</p> <pre><code># Install the inspector globally (if not already installed)\nnpm install -g @modelcontextprotocol/inspector\n\n# Run the inspector pointing to your Python server\n# Disable auth for easier testing\nDANGEROUSLY_OMIT_AUTH=true npx @modelcontextprotocol/inspector \\\n  \"http://localhost:8889/mcp\"\n</code></pre> </li> <li> <p>This will open a web interface where you can:</p> <ul> <li>See the server\u2019s capabilities</li> <li>List available tools</li> <li>Call tools with test inputs</li> <li>View request/response messages</li> <li>Test health endpoints</li> </ul> </li> </ul> <p>#### Testing with curl:</p> <p>You can also test the server directly with curl commands:</p> <pre><code># Test health endpoint\ncurl http://localhost:8889/health\n\n# Test metadata endpoint\ncurl http://localhost:8889/metadata\n\n# Test manifest endpoint\ncurl http://localhost:8889/.well-known/mcp\n</code></pre>"},{"location":"Lab02-First-MCP-Server/#the-request-response-lifecycle","title":"The Request - Response Lifecycle","text":"<p>Here\u2019s what happens when a tool is called:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Client-&gt;&gt;Server: tools/list request\n    Note over Server: Process request:&lt;br/&gt;- Match handler&lt;br/&gt;- Execute handler function\n    Server--&gt;&gt;Client: tools/list response&lt;br/&gt;(list of available tools)\n\n    Client-&gt;&gt;Server: tools/call request&lt;br/&gt;{ name: \"hello_world\",&lt;br/&gt;arguments: { name: \"Alice\" } }\n    Note over Server: Process request:&lt;br/&gt;- Validate tool name&lt;br/&gt;- Validate arguments&lt;br/&gt;- Execute tool logic&lt;br/&gt;- Format response\n    Server--&gt;&gt;Client: tools/call response&lt;br/&gt;{ content: [...] }</code></pre>"},{"location":"Lab02-First-MCP-Server/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<p>Proper error handling is crucial for <code>MCP</code> servers! </p> Node.js / TypeScriptPython <p>Here\u2019s how to implement robust error handling, step by step:</p> <p>Here\u2019s how to implement robust error handling in Python:</p>"},{"location":"Lab02-First-MCP-Server/#1-validate-inputs","title":"1. Validate Inputs","text":"<p>Why: Always validate input parameters before processing to prevent runtime errors and provide clear feedback to clients.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Check for required parameters:    <pre><code>if (!userName) {\n  throw new Error(\"Name parameter is required\");\n}\n</code></pre></p> </li> <li> <p>Validate parameter types:    <pre><code>if (typeof userName !== 'string') {\n  throw new Error(\"Name parameter must be a string\");\n}\n</code></pre></p> </li> <li> <p>Combine validation checks:    <pre><code>if (!userName || typeof userName !== 'string') {\n  throw new Error(\"Name parameter is required and must be a string\");\n}\n</code></pre></p> </li> <li> <p>Validate against schema constraints:    <pre><code>if (userName.length === 0) {\n  throw new Error(\"Name parameter cannot be empty\");\n}\nif (userName.length &gt; 100) {\n  throw new Error(\"Name parameter cannot exceed 100 characters\");\n}\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/#2-provide-helpful-error-messages","title":"2. Provide Helpful Error Messages","text":"<p>Why: Clear error messages help developers understand what went wrong and how to fix it.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Include the problematic value in the error:    <pre><code>throw new Error(`Unknown tool: ${name}`);\n</code></pre></p> </li> <li> <p>Suggest available alternatives:    <pre><code>throw new Error(`Unknown tool: ${name}. Available tools: hello_world`);\n</code></pre></p> </li> <li> <p>Provide context about what was expected:    <pre><code>throw new Error(`Invalid operation: ${operation}. Expected: add, subtract, multiply, or divide`);\n</code></pre></p> </li> <li> <p>Include parameter names for clarity:    <pre><code>throw new Error(`Parameter 'count' must be a positive number, got: ${count}`);\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/#3-handle-async-errors","title":"3. Handle Async Errors","text":"<p>Why: Asynchronous operations can fail, and these errors need to be caught and handled properly.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Wrap async operations in try-catch:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  // Handle the error\n}\n</code></pre></p> </li> <li> <p>Extract error information safely:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n  throw new Error(`Operation failed: ${errorMessage}`);\n}\n</code></pre></p> </li> <li> <p>Preserve original error context:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  console.error('Async operation failed:', error);\n  throw new Error(`Operation failed: ${error.message}`);\n}\n</code></pre></p> </li> <li> <p>Handle different error types appropriately:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  if (error.code === 'ENOTFOUND') {\n    throw new Error('Network connection failed. Please check your internet connection.');\n  } else if (error.code === 'ETIMEDOUT') {\n    throw new Error('Operation timed out. Please try again.');\n  } else {\n    throw new Error(`Operation failed: ${error.message}`);\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/#4-log-to-stderr","title":"4. Log to stderr","text":"<p>Why: <code>MCP</code> protocol uses <code>stdout</code> for communication. Logging to <code>stdout</code> can break the protocol.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Use console.error() for all logging:    <pre><code>console.error(\"[DEBUG] Tool called:\", name);\nconsole.error(\"[DEBUG] Arguments:\", args);\n</code></pre></p> </li> <li> <p>Structure your log messages:    <pre><code>console.error(`[INFO] Processing tool: ${name}`);\nconsole.error(`[DEBUG] Input validation passed`);\nconsole.error(`[ERROR] Tool execution failed:`, error.message);\n</code></pre></p> </li> <li> <p>Log at appropriate levels:    <pre><code>// Debug information\nconsole.error(\"[DEBUG] Server initialized with capabilities:\", capabilities);\n\n// Info for normal operations\nconsole.error(\"[INFO] Tool executed successfully\");\n\n// Warnings for potential issues\nconsole.error(\"[WARN] Using default value for optional parameter\");\n\n// Errors for failures\nconsole.error(\"[ERROR] Tool execution failed:\", error);\n</code></pre></p> </li> <li> <p>Include timestamps for debugging:    <pre><code>const timestamp = new Date().toISOString();\nconsole.error(`[${timestamp}] [INFO] Server started`);\n</code></pre></p> </li> </ol> <p>Important</p> <p>Use <code>console.error()</code> for logging, not <code>console.log()</code>. Your MCP server must not write to <code>stdout</code> for logging purposes, as stdout is reserved for MCP protocol messages!</p>"},{"location":"Lab02-First-MCP-Server/#1-validate-inputs-with-type-hints","title":"1. Validate Inputs with Type Hints","text":"<p>Why: Python type hints combined with runtime validation prevent errors and provide clear feedback.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Use type hints in function signatures:    <pre><code>@mcp.tool()\ndef hello_world(name: str) -&gt; str:\n    if not name:\n        raise ValueError(\"Name parameter is required\")\n    return f\"Hello, {name}!\"\n</code></pre></p> </li> <li> <p>Validate parameter types at runtime:    <pre><code>@mcp.tool()\ndef hello_world(name: str) -&gt; str:\n    if not isinstance(name, str):\n        raise TypeError(\"Name parameter must be a string\")\n    if not name or not name.strip():\n        raise ValueError(\"Name parameter cannot be empty\")\n    return f\"Hello, {name}!\"\n</code></pre></p> </li> <li> <p>Validate against constraints:    <pre><code>@mcp.tool()\ndef hello_world(name: str) -&gt; str:\n    if len(name) &gt; 100:\n        raise ValueError(\"Name parameter cannot exceed 100 characters\")\n    if len(name) &lt; 1:\n        raise ValueError(\"Name parameter must be at least 1 character\")\n    return f\"Hello, {name}!\"\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/#2-provide-helpful-error-messages_1","title":"2. Provide Helpful Error Messages","text":"<p>Why: Clear error messages help developers understand and fix issues quickly.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Include problematic values:    <pre><code>@mcp.tool()\ndef calculate(operation: str, a: float, b: float) -&gt; str:\n    valid_ops = [\"add\", \"subtract\", \"multiply\", \"divide\"]\n    if operation not in valid_ops:\n        raise ValueError(\n            f\"Unknown operation: {operation}. \"\n            f\"Available operations: {', '.join(valid_ops)}\"\n        )\n</code></pre></p> </li> <li> <p>Provide context in exceptions:    <pre><code>@mcp.tool()\ndef process_data(count: int) -&gt; str:\n    if count &lt; 0:\n        raise ValueError(\n            f\"Parameter 'count' must be a positive number, got: {count}\"\n        )\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/#3-handle-async-errors_1","title":"3. Handle Async Errors","text":"<p>Why: Async operations can fail and need proper error handling.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Wrap async operations in try-except:    <pre><code>@mcp.tool()\nasync def fetch_data(url: str) -&gt; str:\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url)\n            return response.text\n    except httpx.HTTPError as e:\n        raise RuntimeError(f\"Failed to fetch data: {str(e)}\")\n</code></pre></p> </li> <li> <p>Handle specific exception types:    <pre><code>@mcp.tool()\nasync def fetch_data(url: str) -&gt; str:\n    try:\n        async with httpx.AsyncClient(timeout=5.0) as client:\n            response = await client.get(url)\n            return response.text\n    except httpx.TimeoutException:\n        raise RuntimeError(\"Request timed out. Please try again.\")\n    except httpx.NetworkError:\n        raise RuntimeError(\"Network connection failed.\")\n    except Exception as e:\n        raise RuntimeError(f\"Unexpected error: {str(e)}\")\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/#4-use-pythons-logging-module","title":"4. Use Python\u2019s Logging Module","text":"<p>Why: Proper logging helps debug issues without interfering with MCP protocol.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Configure logging at the start of your script:    <pre><code>import logging\nimport sys\n\n# Configure logging to stderr\nlogging.basicConfig(\n    level=logging.INFO,\n    format='[%(asctime)s] %(levelname)s: %(message)s',\n    stream=sys.stderr\n)\nlogger = logging.getLogger(__name__)\n</code></pre></p> </li> <li> <p>Log at appropriate levels:    <pre><code>@mcp.tool()\ndef hello_world(name: str) -&gt; str:\n    logger.debug(f\"hello_world called with name: {name}\")\n\n    if not name:\n        logger.warning(\"hello_world called with empty name\")\n        raise ValueError(\"Name parameter is required\")\n\n    logger.info(f\"Successfully greeted: {name}\")\n    return f\"Hello, {name}!\"\n</code></pre></p> </li> <li> <p>Log errors with full context:    <pre><code>@mcp.tool()\nasync def process_request(data: str) -&gt; str:\n    try:\n        result = await some_async_operation(data)\n        logger.info(\"Request processed successfully\")\n        return result\n    except Exception as e:\n        logger.error(f\"Failed to process request: {str(e)}\", exc_info=True)\n        raise\n</code></pre></p> </li> </ol> <p>Important</p> <p>Use <code>logging</code> module with <code>stream=sys.stderr</code> for all logging. Never use <code>print()</code> for logging in production MCP servers, as it can interfere with protocol communication in stdio transport mode.</p>"},{"location":"Lab02-First-MCP-Server/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"Lab02-First-MCP-Server/#issue-1-server-not-connecting","title":"Issue 1: Server Not Connecting","text":"<ul> <li> <p>Symptoms: Client doesn\u2019t see the server or times out</p> </li> <li> <p>Solutions:</p> <ul> <li>Check that the command path is absolute</li> <li>Verify Node.js is in the PATH</li> <li>Look at client logs for connection errors</li> <li>Ensure the server starts without crashing</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#issue-2-tools-not-appearing","title":"Issue 2: Tools Not Appearing","text":"<ul> <li> <p>Symptoms: Server connects but no tools are listed</p> </li> <li> <p>Solutions:</p> <ul> <li>Verify <code>capabilities.tools</code> is declared in server initialization</li> <li>Check that <code>ListToolsRequestSchema</code> handler is registered</li> <li>Ensure the handler returns the correct format</li> <li>Restart the client after code changes</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#issue-3-tool-execution-fails","title":"Issue 3: Tool Execution Fails","text":"<ul> <li> <p>Symptoms: Tool appears but fails when called</p> </li> <li> <p>Solutions:</p> <ul> <li>Validate input arguments match the schema</li> <li>Check for typos in tool names</li> <li>Add debug logging to see what\u2019s received</li> <li>Ensure return format matches <code>MCP</code> specification</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#issue-4-server-crashes","title":"Issue 4: Server Crashes","text":"<ul> <li> <p>Symptoms: Server exits unexpectedly</p> </li> <li> <p>Solutions:</p> <ul> <li>Add try-catch blocks around async code</li> <li>Check for unhandled promise rejections</li> <li>Validate all external data</li> <li>Add process error handlers</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#extending-your-server-hands-on-exercises","title":"Extending Your Server: Hands-On Exercises","text":"<p>Now that you have a working server, try these exercises:</p> Node.js / TypeScriptPython"},{"location":"Lab02-First-MCP-Server/#exercise-1-add-a-calculator-tool","title":"Exercise 1: Add a Calculator Tool","text":"<ul> <li> <p>Create a tool that performs basic math operations:</p> <pre><code>{\n  name: \"calculate\",\n  description: \"Performs basic math operations\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      operation: {\n        type: \"string\",\n        enum: [\"add\", \"subtract\", \"multiply\", \"divide\"],\n        description: \"The operation to perform\"\n      },\n      a: {\n        type: \"number\",\n        description: \"First number\"\n      },\n      b: {\n        type: \"number\",\n        description: \"Second number\"\n      }\n    },\n    required: [\"operation\", \"a\", \"b\"]\n  }\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#exercise-2-add-an-echo-tool","title":"Exercise 2: Add an Echo Tool","text":"<ul> <li> <p>Create a tool that returns whatever text it receives:</p> <pre><code>{\n  name: \"echo\",\n  description: \"Echoes back the input text\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      message: {\n        type: \"string\",\n        description: \"The message to echo\"\n      },\n      repeat: {\n        type: \"number\",\n        description: \"Number of times to repeat (default: 1)\",\n        default: 1\n      }\n    },\n    required: [\"message\"]\n  }\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#exercise-3-add-logging","title":"Exercise 3: Add Logging","text":"<ul> <li> <p>Enhance your server with structured logging:</p> <pre><code>private log(level: string, message: string, data?: any): void {\n  const timestamp = new Date().toISOString();\n  const logEntry = { timestamp, level, message, data };\n  console.error(JSON.stringify(logEntry));\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#exercise-1-add-a-calculator-tool_1","title":"Exercise 1: Add a Calculator Tool","text":"<ul> <li> <p>Add a calculator tool to your <code>mcp.py</code> file:</p> <pre><code>@mcp.tool()\ndef calculate(operation: str, a: float, b: float) -&gt; str:\n    \"\"\"Performs basic math operations\"\"\"\n    if operation == \"add\":\n        result = a + b\n    elif operation == \"subtract\":\n        result = a - b\n    elif operation == \"multiply\":\n        result = a * b\n    elif operation == \"divide\":\n        if b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        result = a / b\n    else:\n        raise ValueError(\n            f\"Unknown operation: {operation}. \"\n            f\"Use: add, subtract, multiply, or divide\"\n        )\n\n    return f\"The result of {a} {operation} {b} is {result}\"\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#exercise-2-add-an-echo-tool_1","title":"Exercise 2: Add an Echo Tool","text":"<ul> <li> <p>Add an echo tool that repeats messages:</p> <pre><code>@mcp.tool()\ndef echo(message: str, repeat: int = 1) -&gt; str:\n    \"\"\"Echoes back the input text, optionally repeated\"\"\"\n    if repeat &lt; 1:\n        raise ValueError(\"Repeat count must be at least 1\")\n    if repeat &gt; 10:\n        raise ValueError(\"Repeat count cannot exceed 10\")\n\n    return (message + \"\\\\n\") * repeat\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#exercise-3-add-logging_1","title":"Exercise 3: Add Logging","text":"<ul> <li> <p>Add structured logging to your server:</p> <pre><code>import logging\nimport sys\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='[%(asctime)s] %(levelname)s: %(message)s',\n    stream=sys.stderr\n)\nlogger = logging.getLogger(__name__)\n\n# Add logging to your tools\n@mcp.tool()\ndef hello_world(name: str) -&gt; str:\n    \\\"\\\"\\\"Returns a friendly greeting message\\\"\\\"\\\"\n    start_time = time.time()\n    logger.info(f\"Processing hello_world for: {name}\")\n\n    try:\n        result = f\"Hello, {name}! Welcome to your first MCP server! \ud83c\udf89\"\n        duration = (time.time() - start_time) * 1000\n        logger.info(f\"hello_world completed in {duration:.2f}ms\")\n        return result\n    except Exception as e:\n        logger.error(f\"hello_world failed: {str(e)}\", exc_info=True)\n        raise\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#exercise-4-add-a-resource","title":"Exercise 4: Add a Resource","text":"<ul> <li> <p>Add a resource that returns server statistics:</p> <pre><code>@mcp.resource(\"mcp://stats\")\ndef get_server_stats() -&gt; str:\n    \\\"\\\"\\\"Returns server statistics\\\"\\\"\\\"\n    import psutil\n    import os\n\n    stats = {\n        \"server\": \"my-first-mcp-server\",\n        \"version\": \"1.0.0\",\n        \"uptime_seconds\": time.time() - start_time,\n        \"process_id\": os.getpid(),\n        \"memory_mb\": psutil.Process().memory_info().rss / 1024 / 1024,\n    }\n\n    return json.dumps(stats, indent=2)\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>MCP servers are built up using the <code>sdk</code> package</li> <li>The SDK handles protocol details, letting you focus on business logic</li> <li>Servers communicate via stdio, HTTP, or custom transports</li> <li>Tools are defined with JSON Schema for type safety      </li> <li>Error handling and validation are critical for reliability</li> <li>The MCP Inspector is invaluable for development and testing</li> <li>Always log to stderr, never stdout (reserved for protocol)</li> </ul>"},{"location":"Lab02-First-MCP-Server/#troubleshooting-checklist","title":"Troubleshooting Checklist","text":"<ul> <li> <p>Before moving on, verify:</p> <ul> <li> Your server builds without TypeScript errors</li> <li> The server starts and logs \u201crunning on stdio\u201d</li> <li> The MCP Inspector can connect to your server</li> <li> Tools appear in the inspector\u2019s tool list</li> <li> You can successfully call the <code>hello_world</code> tool</li> <li> Error messages are helpful and informative</li> </ul> </li> </ul> <p>Congratulations! You\u2019ve built your first MCP server! Ready for more? Continue to Lab 3!</p>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/","title":"MCP Lab Tasks - Lab 2","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-21-basic-server-structure","title":"Exercise 2.1: Basic Server Structure","text":"<p>Create the basic file structure for a new MCP server project.</p> Solution <pre><code>my-mcp-server/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 index.ts\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-22-packagejson-dependencies","title":"Exercise 2.2: Package.json Dependencies","text":"<p>What are the essential dependencies for an MCP server?</p> Solution <pre><code>{\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-23-server-initialization","title":"Exercise 2.3: Server Initialization","text":"<p>Write the basic server initialization code.</p> Solution <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nconst server = new Server(\n  {\n    name: \"my-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-24-tool-registration","title":"Exercise 2.4: Tool Registration","text":"<p>How do you register a tool with the MCP server?</p> Solution <pre><code>server.setRequestHandler(\"tools/list\", async () =&gt; {\n  return {\n    tools: [\n      {\n        name: \"example_tool\",\n        description: \"An example tool\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            message: { type: \"string\" }\n          }\n        }\n      }\n    ]\n  };\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-25-tool-implementation","title":"Exercise 2.5: Tool Implementation","text":"<p>Implement a simple tool that echoes back the input message.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"echo\") {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Echo: ${args.message}`\n        }\n      ]\n    };\n  }\n\n  throw new Error(`Unknown tool: ${name}`);\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-26-error-handling","title":"Exercise 2.6: Error Handling","text":"<p>Add proper error handling to the tool implementation.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  try {\n    const { name, arguments: args } = request.params;\n\n    if (name === \"echo\") {\n      if (!args || !args.message) {\n        throw new Error(\"Message parameter is required\");\n      }\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Echo: ${args.message}`\n          }\n        ]\n      };\n    }\n\n    throw new Error(`Unknown tool: ${name}`);\n  } catch (error) {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Error: ${error.message}`\n        }\n      ],\n      isError: true\n    };\n  }\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-27-server-logging","title":"Exercise 2.7: Server Logging","text":"<p>Add logging to track server operations.</p> Solution <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\n\nconst server = new Server(\n  {\n    name: \"my-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\nserver.setRequestHandler(\"tools/list\", async () =&gt; {\n  console.log(\"Listing available tools\");\n  return { tools: [] };\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-28-typescript-configuration","title":"Exercise 2.8: TypeScript Configuration","text":"<p>Create a proper tsconfig.json for an MCP server.</p> Solution <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-29-build-script","title":"Exercise 2.9: Build Script","text":"<p>Add build and start scripts to package.json.</p> Solution <pre><code>{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\"\n  }\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-210-input-validation","title":"Exercise 2.10: Input Validation","text":"<p>Implement input validation for tool parameters.</p> Solution <pre><code>function validateEchoInput(args: any): { message: string } {\n  if (!args || typeof args.message !== 'string') {\n    throw new Error(\"message parameter must be a string\");\n  }\n  if (args.message.length &gt; 1000) {\n    throw new Error(\"message too long (max 1000 characters)\");\n  }\n  return args;\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-211-server-capabilities","title":"Exercise 2.11: Server Capabilities","text":"<p>Configure server capabilities in the initialization.</p> Solution <pre><code>const server = new Server(\n  {\n    name: \"my-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n      resources: {},\n      prompts: {}\n    },\n  }\n);\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-212-graceful-shutdown","title":"Exercise 2.12: Graceful Shutdown","text":"<p>Implement graceful shutdown handling.</p> Solution <pre><code>process.on('SIGINT', async () =&gt; {\n  console.log('Shutting down MCP server...');\n  await server.close();\n  process.exit(0);\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-213-environment-variables","title":"Exercise 2.13: Environment Variables","text":"<p>Use environment variables for server configuration.</p> Solution <pre><code>const PORT = process.env.PORT || 3000;\nconst API_KEY = process.env.API_KEY;\n\nif (!API_KEY) {\n  throw new Error(\"API_KEY environment variable is required\");\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-214-testing-setup","title":"Exercise 2.14: Testing Setup","text":"<p>Create a basic test structure for the MCP server.</p> Solution <pre><code>// test/server.test.ts\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\n\ndescribe(\"MCP Server\", () =&gt; {\n  let server: Server;\n\n  beforeEach(() =&gt; {\n    server = new Server(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: { tools: {} } }\n    );\n  });\n\n  it(\"should initialize correctly\", () =&gt; {\n    expect(server).toBeDefined();\n  });\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-215-documentation","title":"Exercise 2.15: Documentation","text":"<p>Create a README.md for the MCP server project.</p> Solution <pre><code># My MCP Server\n\nA Model Context Protocol server that provides useful tools.\n\n## Installation\n\n```bash\nnpm install\nnpm run build\n</code></pre> <p>Usage</p> <pre><code>npm start\n</code></pre> <p>Configuration</p> <p>Set the following environment variables: - <code>API_KEY</code>: Your API key - <code>PORT</code>: Server port (optional, defaults to 3000) ```</p>"},{"location":"Lab03-MCP-Tools/","title":"Lab 3: Implementing MCP Tools","text":""},{"location":"Lab03-MCP-Tools/#overview","title":"Overview","text":"<p>In Lab 2, you created a basic <code>MCP</code> server with a simple \u201chello world\u201d tool. Now it\u2019s time to level up! </p> <p>In this lab, you\u2019ll master the art of creating sophisticated, production-ready <code>MCP</code> tools that can handle complex inputs, perform real-world operations, and return rich content types.</p>"},{"location":"Lab03-MCP-Tools/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Design robust tool schemas with advanced validation</li> <li>Implement tools that interact with external systems (APIs, databases, file systems)</li> <li>Return multiple content types (text, images, resources)</li> <li>Handle errors gracefully with detailed feedback</li> <li>Implement async operations and streaming responses</li> <li>Apply best practices for tool composition</li> <li>Test tools thoroughly with various edge cases</li> </ul>"},{"location":"Lab03-MCP-Tools/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 2 - Building Your First MCP Server</li> <li>Understanding of async/await in JavaScript/TypeScript</li> <li>Basic knowledge of REST APIs and JSON</li> <li>Node.js development environment set up</li> </ul>"},{"location":"Lab03-MCP-Tools/#understanding-tool-design","title":"Understanding Tool Design","text":""},{"location":"Lab03-MCP-Tools/#what-makes-a-great-mcp-tool","title":"What Makes a Great <code>MCP</code> Tool?","text":"<p>A well-designed tool should be:</p> <ol> <li>Single Purpose: Does one thing well</li> <li>Self-Descriptive: Clear name and description</li> <li>Well-Validated: Comprehensive input schema</li> <li>Error-Resilient: Handles failures gracefully</li> <li>Efficient: Returns results quickly</li> <li>Composable: Can work with other tools</li> </ol>"},{"location":"Lab03-MCP-Tools/#tool-anatomy","title":"Tool Anatomy","text":"<p>Every <code>MCP</code> tool consists of the following key components:</p> <pre><code>{\n  name: \"tool_name\",              // Unique identifier\n  description: \"What it does\",    // Clear explanation for LLM\n  inputSchema: {                  // JSON Schema for validation\n    type: \"object\",\n    properties: { ... },\n    required: [ ... ]\n  }\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/#advanced-input-schema-design","title":"Advanced Input Schema Design","text":""},{"location":"Lab03-MCP-Tools/#example-1-file-search-tool","title":"Example 1: File Search Tool","text":"<p>Key Features:</p> <ul> <li>Pattern validation using <code>regex</code></li> <li>Default values for optional parameters</li> <li>Min/max constraints for numbers</li> <li>Clear descriptions for the LLM </li> </ul> <pre><code>{\n  name: \"search_files\",\n  description: \"Search for files in a directory using glob patterns\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      path: {\n        type: \"string\",\n        description: \"Directory path to search in\",\n        pattern: \"^(/|\\\\./|\\\\.\\\\./).*\"  // Must be absolute or relative path\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Glob pattern (e.g., '*.ts', '**/*.json')\",\n        default: \"*\"\n      },\n      recursive: {\n        type: \"boolean\",\n        description: \"Search subdirectories\",\n        default: false\n      },\n      maxResults: {\n        type: \"number\",\n        description: \"Maximum number of results to return\",\n        minimum: 1,\n        maximum: 1000,\n        default: 100\n      }\n    },\n    required: [\"path\"]\n  }\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/#example-2-api-request-tool","title":"Example 2: API Request Tool","text":"<p>Key Features:</p> <ul> <li>Format validation (<code>uri</code>)</li> <li>Enum constraints</li> <li>Nested objects with additional properties</li> <li>Practical defaults</li> </ul> <pre><code>{\n  name: \"make_api_request\",\n  description: \"Make HTTP requests to REST APIs\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      url: {\n        type: \"string\",\n        description: \"Full URL to request\",\n        format: \"uri\"\n      },\n      method: {\n        type: \"string\",\n        description: \"HTTP method\",\n        enum: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\"],\n        default: \"GET\"\n      },\n      headers: {\n        type: \"object\",\n        description: \"HTTP headers as key-value pairs\",\n        additionalProperties: {\n          type: \"string\"\n        }\n      },\n      body: {\n        type: \"string\",\n        description: \"Request body (JSON string for POST/PUT)\"\n      },\n      timeout: {\n        type: \"number\",\n        description: \"Request timeout in milliseconds\",\n        minimum: 100,\n        maximum: 30000,\n        default: 5000\n      }\n    },\n    required: [\"url\", \"method\"]\n  }\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/#implementing-real-world-tools","title":"Implementing Real-World Tools","text":""},{"location":"Lab03-MCP-Tools/#tool-1-weather-information-with-ollama","title":"Tool 1: Weather Information with Ollama","text":"<p>Goal: Create a production-ready weather tool that uses Ollama (local AI) to generate weather information, handles errors gracefully, and returns formatted information.</p>"},{"location":"Lab03-MCP-Tools/#complete-weather-tool-implementation-with-ollama","title":"Complete Weather Tool Implementation with Ollama","text":"<ul> <li>Here is the complete <code>src/index.ts</code> file with the Ollama-based weather tool added. </li> <li>Copy this entire code and overwrite your existing <code>src/index.ts</code> file:</li> </ul> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n* Create an MCP server with core capabilities\n*/\nclass MyFirstMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"my-first-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          {\n            name: \"get_weather\",\n            description: \"Get current weather information for a city using AI\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: {\n                  type: \"string\",\n                  description: \"City name (e.g., 'London', 'New York')\"\n                },\n                units: {\n                  type: \"string\",\n                  description: \"Temperature units\",\n                  enum: [\"celsius\", \"fahrenheit\"],\n                  default: \"celsius\"\n                }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"hello_world\",\n            description: \"Returns a friendly greeting message\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                name: {\n                  type: \"string\",\n                  description: \"The name to greet\",\n                },\n              },\n              required: [\"name\"],\n            },\n          },\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        if (name === \"get_weather\") {\n          try {\n            // Extract and validate parameters\n            const city = args.city as string;\n            const units = (args.units as string) || \"celsius\";\n\n            if (!city || city.trim().length === 0) {\n              throw new Error(\"City name cannot be empty\");\n            }\n\n            // Use Ollama to generate weather information\n            const prompt = `Generate realistic current weather information for ${city}.\n            Return ONLY a JSON object with this exact structure:\n            {\n              \"name\": \"${city}\",\n              \"sys\": {\"country\": \"XX\"},\n              \"main\": {\"temp\": 20.5, \"feels_like\": 22.1, \"humidity\": 65},\n              \"weather\": [{\"description\": \"clear sky\"}],\n              \"wind\": {\"speed\": 3.2}\n            }\n\n            Use realistic weather data appropriate for the location. Temperature should be in Celsius. Choose an appropriate 2-letter country code for the city. Make the weather description realistic for the location and season.`;\n\n            // Call Ollama API\n            const response = await fetch('http://localhost:11434/api/generate', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                model: 'gpt-oss:20b',\n                prompt: prompt,\n                stream: false,\n                format: 'json'\n              }),\n            });\n\n            if (!response.ok) {\n              throw new Error(`Ollama API error: ${response.status} ${response.statusText}. Make sure Ollama is running with 'ollama serve'.`);\n            }\n\n            const ollamaResult = await response.json();\n            let data;\n\n            try {\n              // Parse the JSON response from Ollama\n              data = JSON.parse(ollamaResult.response);\n            } catch (parseError) {\n              // Fallback to mock data if parsing fails\n              console.warn('Failed to parse Ollama response, using fallback data');\n              const fallbackData: Record&lt;string, any&gt; = {\n                \"london\": {\n                  name: \"London\",\n                  sys: { country: \"GB\" },\n                  main: { temp: 15.2, feels_like: 14.8, humidity: 82 },\n                  weather: [{ description: \"light rain\" }],\n                  wind: { speed: 3.6 }\n                },\n                \"new york\": {\n                  name: \"New York\",\n                  sys: { country: \"US\" },\n                  main: { temp: 22.5, feels_like: 24.1, humidity: 65 },\n                  weather: [{ description: \"clear sky\" }],\n                  wind: { speed: 2.1 }\n                },\n                \"tokyo\": {\n                  name: \"Tokyo\",\n                  sys: { country: \"JP\" },\n                  main: { temp: 18.7, feels_like: 18.2, humidity: 78 },\n                  weather: [{ description: \"few clouds\" }],\n                  wind: { speed: 1.8 }\n                },\n                \"paris\": {\n                  name: \"Paris\",\n                  sys: { country: \"FR\" },\n                  main: { temp: 12.8, feels_like: 11.9, humidity: 71 },\n                  weather: [{ description: \"overcast clouds\" }],\n                  wind: { speed: 4.2 }\n                },\n                \"sydney\": {\n                  name: \"Sydney\",\n                  sys: { country: \"AU\" },\n                  main: { temp: 24.3, feels_like: 25.1, humidity: 73 },\n                  weather: [{ description: \"sunny\" }],\n                  wind: { speed: 2.8 }\n                }\n              };\n              data = fallbackData[city.toLowerCase().trim()] || fallbackData[\"london\"];\n            }\n\n            // Format response\n            const tempUnit = units === \"fahrenheit\" ? \"\u00b0F\" : \"\u00b0C\";\n            const weatherText = `\nWeather in ${data.name}, ${data.sys.country}:\n- Temperature: ${data.main.temp}${tempUnit}\n- Feels like: ${data.main.feels_like}${tempUnit}\n- Conditions: ${data.weather[0].description}\n- Humidity: ${data.main.humidity}%\n- Wind Speed: ${data.wind.speed} m/s\n\n*Generated by Ollama AI*\n`.trim();\n\n            // Return MCP response\n            return {\n              content: [\n                {\n                  type: \"text\",\n                  text: weatherText\n                }\n              ]\n            };\n\n          } catch (error) {\n            // Handle errors\n            throw new Error(\n              `Failed to get weather: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n        }\n\n        if (name === \"hello_world\") {\n          const userName = args?.name as string;\n\n          if (!userName) {\n            throw new Error(\"Name parameter is required\");\n          }\n\n          return {\n            content: [\n              {\n                type: \"text\",\n                text: `Hello, ${userName}! Welcome to your first MCP server! \ud83c\udf89`,\n              },\n            ],\n          };\n        }\n\n        throw new Error(`Unknown tool: ${name}`);\n      }\n    );\n  }\n\n  /**\n  * Set up error handling\n  */\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  /**\n  * Start the server\n  */\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n\n    console.error(\"My First MCP Server running on stdio\");\n  }\n}\n\n/**\n* Main entry point\n*/\nasync function main() {\n  const server = new MyFirstMCPServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/#testing-the-weather-tool-with-ollama","title":"Testing the Weather Tool with Ollama:","text":"<p>Step 1: Install Ollama</p> <pre><code># On macOS (using Homebrew)\nbrew install ollama\n\n# Or download from the official website: https://ollama.ai/download\n</code></pre> <p>Step 2: Download a Model</p> <pre><code># Pull the recommended model for this lab\nollama pull gpt-oss:20b\n\n# List available models to verify the download completed successfully\nollama list\n</code></pre> <p>Step 3: Start Ollama Server</p> <pre><code># Start the Ollama server (keep this running in a terminal)\nollama serve\n\n# Check which models are currently running locally:\ncurl http://localhost:11434/api/tags | jq .\n</code></pre> <p>The server will run on http://localhost:11434 by default.</p> <p>Step 4: Test the Weather Tool</p> <ol> <li> <p>Start the MCP Inspector (in a new terminal):    <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre></p> </li> <li> <p>In the MCP Inspector interface:</p> <ul> <li>You should see both <code>get_weather</code> and <code>hello_world</code> tools listed</li> <li>Click on <code>get_weather</code> tool</li> <li>Enter a city name like \u201cLondon\u201d, \u201cNew York\u201d, \u201cTokyo\u201d, \u201cParis\u201d, or \u201cSydney\u201d</li> <li>Optionally set units to \u201cfahrenheit\u201d for Fahrenheit temperatures</li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test different scenarios:</p> <ul> <li>Valid cities: \u201cLondon\u201d, \u201cNew York\u201d, \u201cTokyo\u201d, \u201cParis\u201d, \u201cSydney\u201d</li> <li>Invalid cities: \u201cInvalidCity123\u201d (will use fallback data)</li> <li>Different units: Try both \u201ccelsius\u201d and \u201cfahrenheit\u201d</li> <li>Empty city: Try with empty string (should show validation error)</li> </ul> </li> <li> <p>Test error cases:</p> <ul> <li>Stop Ollama server and try calling the tool (should show API error)</li> <li>Try with invalid model name in the code (should show error)</li> </ul> </li> </ol> <p>Step 5: Verify Everything Works</p> <ul> <li> <p>You should see AI-generated weather information formatted like this:</p> <pre><code>Weather in London, GB:\n- Temperature: 15.2\u00b0C\n- Feels like: 14.8\u00b0C\n- Conditions: light rain\n- Humidity: 82%\n- Wind Speed: 3.6 m/s\n\n*Generated by Ollama AI*\n</code></pre> </li> </ul> <p>Troubleshooting:</p> <ul> <li>If you get \u201cOllama API error\u201d, make sure <code>ollama serve</code> is running</li> <li>If you see fallback data, Ollama might not be responding properly</li> <li>Check that the model is downloaded with <code>ollama list</code></li> <li>Try a different model if gpt-oss:20b doesn\u2019t work well</li> <li>Make sure you\u2019re in the correct directory when running commands</li> </ul>"},{"location":"Lab03-MCP-Tools/#key-learning-points","title":"Key Learning Points:","text":"<ul> <li>Local AI integration using Ollama for generating content</li> <li>Fallback handling when AI services are unavailable</li> <li>JSON parsing from AI-generated responses</li> <li>Error handling for external service dependencies</li> <li>Input validation and data formatting</li> <li>API communication with local services</li> </ul>"},{"location":"Lab03-MCP-Tools/#tool-2-file-operations","title":"Tool 2: File Operations","text":"<p>Goal: Create a secure file reading tool that can handle various file types, validate paths, and return formatted content with metadata.</p>"},{"location":"Lab03-MCP-Tools/#complete-file-operations-tool-implementation","title":"Complete File Operations Tool Implementation","text":"<p>Important: Do NOT copy the entire code block below. Instead, add the <code>read_file</code> tool to your existing <code>src/index.ts</code> file by following these specific steps:</p> <ol> <li> <p>Add the import at the top of your file (after existing imports):    <pre><code>import * as fs from 'fs/promises';\nimport * as path from 'path';\n</code></pre></p> </li> <li> <p>Add the <code>read_file</code> tool to your tools array in the <code>ListToolsRequestSchema</code> handler:    <pre><code>{\n  name: \"read_file\",\n  description: \"Read contents of a text file with security validation\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      filepath: {\n        type: \"string\",\n        description: \"Absolute path to the file\"\n      },\n      encoding: {\n        type: \"string\",\n        description: \"File encoding\",\n        enum: [\"utf8\", \"ascii\", \"base64\"],\n        default: \"utf8\"\n      },\n      maxSize: {\n        type: \"number\",\n        description: \"Maximum file size in bytes\",\n        minimum: 1,\n        maximum: 10485760,\n        default: 1048576\n      }\n    },\n    required: [\"filepath\"]\n  }\n}\n</code></pre></p> </li> <li> <p>Add the <code>read_file</code> handler in the <code>CallToolRequestSchema</code> handler (before the final <code>throw new Error</code>):    <pre><code>if (name === \"read_file\") {\n  try {\n    const filepath = args.filepath as string;\n    const encoding = (args.encoding as BufferEncoding) || \"utf8\";\n    const maxSize = (args.maxSize as number) || 1048576;\n\n    // Security: Validate input\n    if (!filepath || typeof filepath !== 'string' || filepath.trim().length === 0) {\n      throw new Error(\"filepath must be a non-empty string\");\n    }\n\n    // Security: Resolve and validate path\n    const resolvedPath = path.resolve(filepath);\n\n    // Prevent directory traversal attacks\n    if (!resolvedPath.startsWith(process.cwd())) {\n      throw new Error(\"Access denied: file path outside allowed directory\");\n    }\n\n    // Check if file exists and is readable\n    try {\n      await fs.access(resolvedPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(`File not found or not readable: ${filepath}`);\n    }\n\n    // Get file stats\n    const stats = await fs.stat(resolvedPath);\n\n    // Check if it's actually a file (not a directory)\n    if (!stats.isFile()) {\n      throw new Error(`Path is not a file: ${filepath}`);\n    }\n\n    // Check file size\n    if (stats.size &gt; maxSize) {\n      throw new Error(\n        `File too large: ${stats.size} bytes (max: ${maxSize})`\n      );\n    }\n\n    // Read file content\n    const content = await fs.readFile(resolvedPath, encoding);\n\n    // Format response with metadata\n    const fileInfo = {\n      path: resolvedPath,\n      size: stats.size,\n      modified: stats.mtime.toISOString(),\n      encoding: encoding\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `File Information:\\n${JSON.stringify(fileInfo, null, 2)}\\n\\nContent:\\n${content}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(\n      `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n</code></pre></p> </li> </ol> <p>The code block below is for reference only - it shows what your complete file should look like after adding the tool. Do not copy-paste the entire block:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\n/**\n* Create an MCP server with core capabilities\n*/\nclass MyFirstMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"my-first-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          {\n            name: \"get_weather\",\n            description: \"Get current weather information for a city using AI\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: {\n                  type: \"string\",\n                  description: \"City name (e.g., 'London', 'New York')\"\n                },\n                units: {\n                  type: \"string\",\n                  description: \"Temperature units\",\n                  enum: [\"celsius\", \"fahrenheit\"],\n                  default: \"celsius\"\n                }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"read_file\",\n            description: \"Read contents of a text file with security validation\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                filepath: {\n                  type: \"string\",\n                  description: \"Absolute path to the file\"\n                },\n                encoding: {\n                  type: \"string\",\n                  description: \"File encoding\",\n                  enum: [\"utf8\", \"ascii\", \"base64\"],\n                  default: \"utf8\"\n                },\n                maxSize: {\n                  type: \"number\",\n                  description: \"Maximum file size in bytes\",\n                  minimum: 1,\n                  maximum: 10485760,\n                  default: 1048576\n                }\n              },\n              required: [\"filepath\"]\n            }\n          },\n          {\n            name: \"hello_world\",\n            description: \"Returns a friendly greeting message\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                name: {\n                  type: \"string\",\n                  description: \"The name to greet\",\n                },\n              },\n              required: [\"name\"],\n            },\n          },\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        if (name === \"get_weather\") {\n          // ... existing weather tool code ...\n        }\n\n        if (name === \"read_file\") {\n          try {\n            const filepath = args.filepath as string;\n            const encoding = (args.encoding as BufferEncoding) || \"utf8\";\n            const maxSize = (args.maxSize as number) || 1048576;\n\n            // Security: Validate input\n            if (!filepath || typeof filepath !== 'string' || filepath.trim().length === 0) {\n              throw new Error(\"filepath must be a non-empty string\");\n            }\n\n            // Security: Resolve and validate path\n            const resolvedPath = path.resolve(filepath);\n\n            // Prevent directory traversal attacks\n            if (!resolvedPath.startsWith(process.cwd())) {\n              throw new Error(\"Access denied: file path outside allowed directory\");\n            }\n\n            // Check if file exists and is readable\n            try {\n              await fs.access(resolvedPath, fs.constants.R_OK);\n            } catch {\n              throw new Error(`File not found or not readable: ${filepath}`);\n            }\n\n            // Get file stats\n            const stats = await fs.stat(resolvedPath);\n\n            // Check if it's actually a file (not a directory)\n            if (!stats.isFile()) {\n              throw new Error(`Path is not a file: ${filepath}`);\n            }\n\n            // Check file size\n            if (stats.size &gt; maxSize) {\n              throw new Error(\n                `File too large: ${stats.size} bytes (max: ${maxSize})`\n              );\n            }\n\n            // Read file content\n            const content = await fs.readFile(resolvedPath, encoding);\n\n            // Format response with metadata\n            const fileInfo = {\n              path: resolvedPath,\n              size: stats.size,\n              modified: stats.mtime.toISOString(),\n              encoding: encoding\n            };\n\n            return {\n              content: [\n                {\n                  type: \"text\",\n                  text: `File Information:\\n${JSON.stringify(fileInfo, null, 2)}\\n\\nContent:\\n${content}`\n                }\n              ]\n            };\n\n          } catch (error) {\n            throw new Error(\n              `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n        }\n\n        if (name === \"hello_world\") {\n          // ... existing hello world code ...\n        }\n\n        throw new Error(`Unknown tool: ${name}`);\n      }\n    );\n  }\n\n  // ... rest of the class remains the same ...\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/#testing-the-file-operations-tool","title":"Testing the File Operations Tool","text":"<p>Step 1: Create Test Files</p> <pre><code># Create a test directory and files\nmkdir -p test-files\necho \"Hello, this is a test file!\" &gt; test-files/hello.txt\necho '{\"name\": \"test\", \"value\": 123}' &gt; test-files/data.json\necho \"Line 1\\nLine 2\\nLine 3\" &gt; test-files/lines.txt\n</code></pre> <p>Step 2: Start the MCP Inspector</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>Step 3: Test File Reading</p> <ol> <li> <p>Test with a simple text file:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/hello.txt</code> (use the full absolute path)</li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test with JSON file:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/data.json</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test with different encoding:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/hello.txt</code></li> <li>encoding: <code>base64</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test file size limit:</p> <ul> <li>Create a large file: <code>dd if=/dev/zero of=test-files/large.txt bs=1M count=2</code></li> <li>Try reading it with default maxSize (1MB)</li> <li>Try with maxSize: <code>2097152</code> (2MB)</li> </ul> </li> </ol> <p>Step 4: Test Error Cases</p> <ol> <li> <p>Non-existent file:</p> <ul> <li>filepath: <code>/absolute/path/to/test-files/nonexistent.txt</code></li> </ul> </li> <li> <p>Directory instead of file:</p> <ul> <li>filepath: <code>/absolute/path/to/test-files</code> (the directory itself)</li> </ul> </li> <li> <p>Empty filepath:</p> <ul> <li>filepath: <code>\"\"</code></li> </ul> </li> <li> <p>Path traversal attempt:</p> <ul> <li>filepath: <code>/absolute/path/../../../etc/passwd</code></li> </ul> </li> </ol> <p>Step 5: Verify Output</p> <ul> <li> <p>You should see output like:</p> <pre><code>File Information:\n{\n  \"path\": \"/Users/username/project/test-files/hello.txt\",\n  \"size\": 27,\n  \"modified\": \"2024-01-06T10:30:00.000Z\",\n  \"encoding\": \"utf8\"\n}\n\nContent:\nHello, this is a test file!\n</code></pre> </li> </ul>"},{"location":"Lab03-MCP-Tools/#troubleshooting","title":"Troubleshooting:","text":"<ul> <li>\u201cFile not found\u201d: Make sure you\u2019re using the absolute path</li> <li>\u201cAccess denied\u201d: The file path is outside your project directory</li> <li>\u201cPath is not a file\u201d: You tried to read a directory</li> <li>\u201cFile too large\u201d: Increase the maxSize parameter</li> </ul>"},{"location":"Lab03-MCP-Tools/#key-learning-points_1","title":"Key Learning Points:","text":"<ul> <li>Path security and preventing directory traversal attacks</li> <li>File system operations with Node.js fs/promises</li> <li>Input validation beyond JSON Schema</li> <li>File metadata extraction and formatting</li> <li>Error handling for various file system scenarios</li> <li>Resource limits to prevent abuse</li> </ul>"},{"location":"Lab03-MCP-Tools/#tool-3-database-query","title":"Tool 3: Database Query","text":"<p>Goal: Create a secure database query tool that can execute SELECT statements on a SQLite database with proper validation and safety measures.</p>"},{"location":"Lab03-MCP-Tools/#complete-database-query-tool-implementation","title":"Complete Database Query Tool Implementation","text":"<ul> <li> <p>First, install the SQLite dependency:</p> <pre><code>npm install better-sqlite3\nnpm install --save-dev @types/better-sqlite3\n</code></pre> </li> </ul> <p>Important: Do NOT copy the entire code block below. Instead, add the <code>query_database</code> tool to your existing <code>src/index.ts</code> file by following these specific steps:</p> <ol> <li> <p>Add the imports at the top of your file (after existing imports):    <pre><code>import Database from 'better-sqlite3';\n</code></pre></p> </li> <li> <p>Add the <code>query_database</code> tool to your tools array in the <code>ListToolsRequestSchema</code> handler:    <pre><code>{\n  name: \"query_database\",\n  description: \"Execute SELECT queries on a SQLite database\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"SQL SELECT query to execute\"\n      },\n      parameters: {\n        type: \"array\",\n        description: \"Query parameters for prepared statement\",\n        items: {\n          type: [\"string\", \"number\", \"boolean\", \"null\"]\n        },\n        default: []\n      },\n      limit: {\n        type: \"number\",\n        description: \"Maximum number of rows to return\",\n        minimum: 1,\n        maximum: 1000,\n        default: 100\n      }\n    },\n    required: [\"query\"]\n  }\n}\n</code></pre></p> </li> <li> <p>Add the <code>query_database</code> handler in the <code>CallToolRequestSchema</code> handler (before the final <code>throw new Error</code>):    <pre><code>if (name === \"query_database\") {\n  try {\n    const query = args.query as string;\n    const parameters = (args.parameters as any[]) || [];\n    const limit = (args.limit as number) || 100;\n\n    // Security: Validate input\n    if (!query || typeof query !== 'string' || query.trim().length === 0) {\n      throw new Error(\"query must be a non-empty string\");\n    }\n\n    // Security: Only allow SELECT queries\n    const trimmedQuery = query.trim().toUpperCase();\n    if (!trimmedQuery.startsWith('SELECT')) {\n      throw new Error(\"Only SELECT queries are allowed for security\");\n    }\n\n    // Check if database file exists\n    const dbPath = './data.db';\n    try {\n      await fs.access(dbPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(\"Database file 'data.db' not found in project root\");\n    }\n\n    // Open database in read-only mode\n    const db = new Database(dbPath, { readonly: true });\n\n    try {\n      // Prepare statement\n      const stmt = db.prepare(query + ' LIMIT ?');\n\n      // Execute query\n      const rows = stmt.all(...parameters, limit);\n\n      // Format results\n      const resultText = rows.length &gt; 0\n        ? JSON.stringify(rows, null, 2)\n        : \"No results found\";\n\n      // Get query info\n      const info = stmt.columns();\n      const columnNames = info.map(col =&gt; col.name);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Query executed successfully.\\nDatabase: ${dbPath}\\nColumns: ${columnNames.join(', ')}\\nRows returned: ${rows.length}\\n\\nResults:\\n${resultText}`\n          }\n        ]\n      };\n\n    } finally {\n      db.close();\n    }\n\n  } catch (error) {\n    throw new Error(\n      `Database query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n</code></pre></p> </li> </ol> <p></p> <ul> <li> <p>The code block below is for reference only - it shows what your complete file should look like after adding the tool. Do not copy-paste the entire block:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport Database from 'better-sqlite3';\n\n// ... existing imports and class definition ...\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          // ... existing tools ...\n          {\n            name: \"query_database\",\n            description: \"Execute SELECT queries on a SQLite database\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                query: {\n                  type: \"string\",\n                  description: \"SQL SELECT query to execute\"\n                },\n                parameters: {\n                  type: \"array\",\n                  description: \"Query parameters for prepared statement\",\n                  items: {\n                    type: [\"string\", \"number\", \"boolean\", \"null\"]\n                  },\n                  default: []\n                },\n                limit: {\n                  type: \"number\",\n                  description: \"Maximum number of rows to return\",\n                  minimum: 1,\n                  maximum: 1000,\n                  default: 100\n                }\n              },\n              required: [\"query\"]\n            }\n          },\n          // ... existing tools ...\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        // ... existing tool handlers ...\n\n        if (name === \"query_database\") {\n          try {\n            const query = args.query as string;\n            const parameters = (args.parameters as any[]) || [];\n            const limit = (args.limit as number) || 100;\n\n            // Security: Validate input\n            if (!query || typeof query !== 'string' || query.trim().length === 0) {\n              throw new Error(\"query must be a non-empty string\");\n            }\n\n            // Security: Only allow SELECT queries\n            const trimmedQuery = query.trim().toUpperCase();\n            if (!trimmedQuery.startsWith('SELECT')) {\n              throw new Error(\"Only SELECT queries are allowed for security\");\n            }\n\n            // Check if database file exists\n            const dbPath = './data.db';\n            try {\n              await fs.access(dbPath, fs.constants.R_OK);\n            } catch {\n              throw new Error(\"Database file 'data.db' not found in project root\");\n            }\n\n            // Open database in read-only mode\n            const db = new Database(dbPath, { readonly: true });\n\n            try {\n              // Prepare statement\n              const stmt = db.prepare(query + ' LIMIT ?');\n\n              // Execute query\n              const rows = stmt.all(...parameters, limit);\n\n              // Format results\n              const resultText = rows.length &gt; 0\n                ? JSON.stringify(rows, null, 2)\n                : \"No results found\";\n\n              // Get query info\n              const info = stmt.columns();\n              const columnNames = info.map(col =&gt; col.name);\n\n              return {\n                content: [\n                  {\n                    type: \"text\",\n                    text: `Query executed successfully.\\nDatabase: ${dbPath}\\nColumns: ${columnNames.join(', ')}\\nRows returned: ${rows.length}\\n\\nResults:\\n${resultText}`\n                  }\n                ]\n              };\n\n            } finally {\n              db.close();\n            }\n\n          } catch (error) {\n            throw new Error(\n              `Database query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n        }\n\n        // ... existing tool handlers ...\n      }\n    );\n  }\n\n  // ... rest of the class remains the same ...\n</code></pre> </li> </ul>"},{"location":"Lab03-MCP-Tools/#testing-the-database-query-tool","title":"Testing the Database Query Tool","text":"<p>Step 1: Install SQLite</p> <pre><code># Install sqlite3 command-line tool (if not already installed)\n\n# On macOS:\nbrew install sqlite3\n\n# On Linux (Ubuntu/Debian):\nsudo apt-get update &amp;&amp; sudo apt-get install sqlite3\n\n# On Linux (CentOS/RHEL/Fedora):\nsudo yum install sqlite3    # or sudo dnf install sqlite3\n\n# On Windows (using Chocolatey):\nchoco install sqlite\n\n# On Windows (manual download):\n# Download from: https://www.sqlite.org/download.html\n# Extract sqlite3.exe to a folder in your PATH\n\n# Verify installation:\nsqlite3 --version\n</code></pre> <p></p> <p>Step 2: Create a Sample Database</p> <p>Navigate to your MCP server directory</p> <pre><code>cd /Users/orni/Code-Wizard/MCP_Lab/MCP_Lab/lab_solution/my-first-mcp-server\n</code></pre> <p>Run the database creation command</p> <pre><code>sqlite3 data.db &lt;&lt; 'EOF'\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  email TEXT UNIQUE,\n  age INTEGER,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  price REAL,\n  category TEXT,\n  in_stock BOOLEAN DEFAULT 1\n);\n\nINSERT INTO users (name, email, age) VALUES \n  ('Alice Johnson', 'alice@example.com', 28),\n  ('Bob Smith', 'bob@example.com', 34),\n  ('Charlie Brown', 'charlie@example.com', 22);\n\nINSERT INTO products (name, price, category, in_stock) VALUES \n  ('Laptop', 999.99, 'Electronics', 1),\n  ('Book', 19.99, 'Education', 1),\n  ('Coffee Mug', 12.50, 'Kitchen', 0);\n\n.quit\nEOF\n</code></pre> <p>Verify the database was created</p> <pre><code>sqlite3 data.db \"SELECT name FROM sqlite_master WHERE type='table';\"\n</code></pre> <ul> <li> <p>You should see output like:</p> <pre><code>users\nproducts\n</code></pre> </li> </ul> <p>What this does:</p> <ul> <li>Creates a SQLite database file called <code>data.db</code> in your project directory</li> <li>Creates two tables: <code>users</code> and <code>products</code></li> <li>Inserts sample data into both tables</li> <li>This gives you test data to query with your <code>query_database</code> tool</li> </ul> <p></p> <p>Step 2: Start the MCP Inspector</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p></p> <p>Step 3: Test Database Queries</p> <ol> <li> <p>Simple SELECT query:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM users</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with WHERE clause:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT name, email FROM users WHERE age &gt; 25</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with parameters:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM products WHERE category = ?</code></li> <li>parameters: <code>[\"Electronics\"]</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with LIMIT:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM users</code></li> <li>limit: <code>2</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>JOIN query:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT u.name, p.name as product FROM users u CROSS JOIN products p LIMIT 5</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> </ol> <p></p> <p>Step 4: Test Error Cases</p> <ol> <li> <p>Non-SELECT query:</p> <ul> <li>query: <code>DELETE FROM users WHERE id = 1</code></li> </ul> </li> <li> <p>Invalid SQL syntax:</p> <ul> <li>query: <code>SELECT * FROM nonexistent_table</code></li> </ul> </li> <li> <p>Missing database file:</p> <ul> <li>Rename <code>data.db</code> to <code>data.db.backup</code> and try a query</li> </ul> </li> <li> <p>Empty query:</p> <ul> <li>query: <code>\"\"</code></li> </ul> </li> </ol> <p></p> <p>Step 5: Verify Output</p> <ul> <li> <p>You should see output like:</p> <pre><code>Query executed successfully.\nDatabase: ./data.db\nColumns: id, name, email, age, created_at\nRows returned: 3\n\nResults:\n[\n  {\n    \"id\": 1,\n    \"name\": \"Alice Johnson\",\n    \"email\": \"alice@example.com\",\n    \"age\": 28,\n    \"created_at\": \"2024-01-06 10:30:00\"\n  },\n  ...\n]\n</code></pre> </li> </ul> <p>Troubleshooting:</p> <ul> <li>\u201cDatabase file not found\u201d: Make sure <code>data.db</code> exists in your project root</li> <li>\u201cOnly SELECT queries are allowed\u201d: The tool only allows SELECT statements for security</li> <li>\u201cno such table\u201d: Check your table names in the database</li> <li>\u201csqlite3: command not found\u201d: Install sqlite3 CLI tool</li> </ul>"},{"location":"Lab03-MCP-Tools/#key-learning-points_2","title":"Key Learning Points:","text":"<ul> <li>SQL injection prevention using prepared statements</li> <li>Database security with read-only access and query restrictions</li> <li>SQLite operations with better-sqlite3</li> <li>Query parameterization for safe dynamic queries</li> <li>Result formatting and metadata extraction</li> <li>Resource management with proper database connection handling</li> </ul>"},{"location":"Lab03-MCP-Tools/#returning-rich-content","title":"Returning Rich Content","text":"<p>MCP supports multiple content types in tool responses, allowing you to return not just text but also images, resources, and combinations of different content types. This enables richer, more interactive responses that can include visual data, file references, and structured information.</p>"},{"location":"Lab03-MCP-Tools/#1-text-content","title":"1. Text Content","text":"<p>Text content is the most common and basic type of response. Use it for any string-based information like analysis results, status messages, or formatted data.</p> <pre><code>return {\n  content: [\n    {\n      type: \"text\",\n      text: \"Simple text response\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Most tool responses will use text content. It\u2019s perfect for:</p> <ul> <li>Status messages and confirmations</li> <li>Formatted data output (JSON, tables, lists)</li> <li>Error messages and explanations</li> <li>Analysis results and summaries</li> </ul>"},{"location":"Lab03-MCP-Tools/#2-image-content","title":"2. Image Content","text":"<p>Image content allows you to return visual data directly in the response. The image data must be base64-encoded and include the appropriate MIME type.</p> <pre><code>return {\n  content: [\n    {\n      type: \"image\",\n      data: base64ImageData,\n      mimeType: \"image/png\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Ideal for tools that generate or process visual content:</p> <ul> <li>Charts and graphs from data analysis</li> <li>Screenshots or visual captures</li> <li>Generated diagrams or illustrations</li> <li>Image processing results</li> </ul> <p>Important: Always specify the correct MIME type (image/png, image/jpeg, image/svg+xml, etc.) and ensure the base64 data is properly encoded.</p>"},{"location":"Lab03-MCP-Tools/#3-resource-content","title":"3. Resource Content","text":"<p>Resource content references external resources rather than including their data directly. This is useful for large files or when you want to provide access to resources without embedding them.</p> <pre><code>return {\n  content: [\n    {\n      type: \"resource\",\n      resource: {\n        uri: \"file:///path/to/file.txt\",\n        mimeType: \"text/plain\",\n        text: \"File contents...\"\n      }\n    }\n  ]\n};\n</code></pre> <p>When to use - Best for:</p> <ul> <li>Large files that would make responses too bulky</li> <li>References to external files or URLs</li> <li>When the client should handle the resource directly</li> <li>Providing access to generated files</li> </ul> <p>Note: The <code>text</code> field is optional - you can omit it if the resource content is too large or if you just want to provide a reference.</p>"},{"location":"Lab03-MCP-Tools/#4-multiple-content-items","title":"4. Multiple Content Items","text":"<p>Multiple content items allow you to combine different types of content in a single response. This creates rich, multi-part responses that can include text explanations alongside visual data.</p> <pre><code>return {\n  content: [\n    {\n      type: \"text\",\n      text: \"Analysis complete:\"\n    },\n    {\n      type: \"text\",\n      text: \"Details:\\n- Item 1\\n- Item 2\"\n    },\n    {\n      type: \"image\",\n      data: chartImage,\n      mimeType: \"image/png\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Perfect for comprehensive responses that need multiple components:</p> <ul> <li>Analysis reports with both text summaries and visual charts</li> <li>File processing results with metadata and content preview</li> <li>Multi-step operations with status updates and final results</li> <li>Complex data with both tabular and graphical representations</li> </ul> <p>Tip: Order your content logically - start with text explanations, then show supporting images or resources.</p>"},{"location":"Lab03-MCP-Tools/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Error handling is crucial for robust MCP tools. Different situations require different approaches to handle failures gracefully while providing useful feedback to users. Here are three essential patterns for handling errors effectively.</p>"},{"location":"Lab03-MCP-Tools/#pattern-1-input-validation","title":"Pattern 1: Input Validation","text":"<p>Input validation ensures that tool arguments meet your requirements before processing begins. This prevents runtime errors and provides clear feedback when users provide invalid data.</p> <pre><code>function validateInput(args: any): void {\n  if (!args.filepath || typeof args.filepath !== 'string') {\n    throw new Error(\"filepath must be a non-empty string\");\n  }\n\n  if (args.maxSize &amp;&amp; (args.maxSize &lt; 1 || args.maxSize &gt; 10485760)) {\n    throw new Error(\"maxSize must be between 1 and 10485760 bytes\");\n  }\n}\n</code></pre> <p>When to use - Always validate inputs before processing, even when using JSON Schema validation. This pattern is essential for:</p> <ul> <li>Type checking beyond JSON Schema capabilities</li> <li>Business logic validation (file size limits, path security)</li> <li>Preventing runtime errors from malformed data</li> <li>Providing specific, actionable error messages</li> </ul> <p>Why it matters: Early validation fails fast and gives users clear guidance on how to fix their input.</p>"},{"location":"Lab03-MCP-Tools/#pattern-2-graceful-degradation","title":"Pattern 2: Graceful Degradation","text":"<p>Graceful degradation provides partial functionality when full operation isn\u2019t possible. Instead of failing completely, the tool returns useful information or falls back to alternative approaches.</p> <pre><code>try {\n  const data = await fetchFromAPI(url);\n  return formatSuccess(data);\n} catch (error) {\n  // Log error but return partial results if possible\n  console.error(\"API call failed:\", error);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: \"\u26a0\ufe0f Could not fetch live data. Using cached results...\"\n      }\n    ]\n  };\n}\n</code></pre> <p>When to use - For external dependencies that might be unreliable:</p> <ul> <li>API calls that could timeout or fail</li> <li>Network-dependent operations</li> <li>Services with occasional downtime</li> <li>When partial results are better than no results</li> </ul> <p>Why it matters: Users get some value even when systems are partially broken, improving overall reliability and user experience.</p>"},{"location":"Lab03-MCP-Tools/#pattern-3-detailed-error-context","title":"Pattern 3: Detailed Error Context","text":"<p>Detailed error context provides comprehensive information for debugging while keeping user-facing messages clean. Log full details internally but expose only safe, helpful information to users.</p> <pre><code>catch (error) {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  const errorContext = {\n    tool: name,\n    arguments: args,\n    timestamp: new Date().toISOString(),\n    error: errorMessage\n  };\n\n  console.error(\"[Tool Error]\", JSON.stringify(errorContext));\n\n  throw new Error(\n    `Tool '${name}' failed: ${errorMessage}. Check server logs for details.`\n  );\n}\n</code></pre> <p>When to use - For complex operations where debugging might be needed:</p> <ul> <li>Multi-step processes with potential failure points</li> <li>Operations involving external systems</li> <li>When you need to track error patterns over time</li> <li>Production environments where detailed logging is crucial</li> </ul> <p>Why it matters: Developers can diagnose issues effectively while users get clear, non-technical error messages.</p> <p></p>"},{"location":"Lab03-MCP-Tools/#best-practices-for-error-handling","title":"Best Practices for Error Handling:","text":"<ul> <li>Fail Fast: Validate inputs early and stop processing on critical errors</li> <li>Log Internally: Use <code>console.error()</code> for detailed logging (goes to stderr, not stdout)</li> <li>User-Friendly Messages: Keep error messages clear and actionable</li> <li>Don\u2019t Leak Sensitive Data: Never expose file paths, credentials, or internal details</li> <li>Consistent Format: Use similar error message patterns across tools</li> <li>Recovery Options: When possible, suggest how users can resolve the issue</li> </ul>"},{"location":"Lab03-MCP-Tools/#async-operations-and-performance","title":"Async Operations and Performance","text":"<p>MCP tools often need to handle asynchronous operations and optimize performance. Long-running tasks require special handling to prevent timeouts and provide feedback, while expensive operations benefit from caching to improve response times and reduce resource usage.</p>"},{"location":"Lab03-MCP-Tools/#long-running-operations","title":"Long-Running Operations","text":"<p>Long-running operations need monitoring and progress feedback to prevent timeouts and keep users informed. Use logging and timing to track operation progress and provide completion status.</p> <pre><code>if (name === \"analyze_large_file\") {\n  const filepath = args.filepath as string;\n\n  // For very long operations, consider streaming or progress updates\n  console.error(`[INFO] Starting analysis of ${filepath}...`);\n\n  try {\n    const startTime = Date.now();\n\n    // Perform analysis\n    const result = await performLongAnalysis(filepath);\n\n    const duration = Date.now() - startTime;\n    console.error(`[INFO] Analysis completed in ${duration}ms`);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Analysis Results (completed in ${duration}ms):\\n\\n${result}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    console.error(`[ERROR] Analysis failed after ${Date.now() - startTime}ms`);\n    throw error;\n  }\n}\n</code></pre> <p>When to use - For operations that take more than a few seconds:</p> <ul> <li>Large file processing or analysis</li> <li>Complex computations</li> <li>External API calls with potential delays</li> <li>Batch operations on multiple items</li> </ul> <p>Why it matters: Prevents timeouts, provides user feedback, enables monitoring and debugging of slow operations.</p>"},{"location":"Lab03-MCP-Tools/#caching-results","title":"Caching Results","text":"<p>Caching results stores expensive operation results to avoid redundant computation. Use time-based expiration and proper cache keys for efficient reuse of results.</p> <pre><code>class CachedMCPServer {\n  private cache: Map&lt;string, { data: any; timestamp: number }&gt;;\n  private cacheTTL: number = 60000; // 1 minute\n\n  constructor() {\n    this.cache = new Map();\n  }\n\n  private getCacheKey(toolName: string, args: any): string {\n    return `${toolName}:${JSON.stringify(args)}`;\n  }\n\n  private getCached(key: string): any | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n\n    if (Date.now() - cached.timestamp &gt; this.cacheTTL) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return cached.data;\n  }\n\n  private setCache(key: string, data: any): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n}\n</code></pre> <p>When to use - For expensive operations that return consistent results:</p> <ul> <li>API calls to external services</li> <li>Complex calculations or data processing</li> <li>Database queries with static data</li> <li>File analysis that doesn\u2019t change frequently</li> </ul> <p>Why it matters: Dramatically improves response times, reduces resource usage, and provides better user experience for repeated requests.</p>"},{"location":"Lab03-MCP-Tools/#best-practices-for-async-operations-and-performance","title":"Best Practices for Async Operations and Performance:","text":"<ul> <li>Monitor Execution Time: Log start/end times for operations over 1 second</li> <li>Set Reasonable Timeouts: Use appropriate timeouts for external calls (5-30 seconds)</li> <li>Cache Strategically: Cache expensive operations but consider data freshness</li> <li>Use Streaming: For very large responses, consider streaming or pagination</li> <li>Resource Cleanup: Always clean up connections, file handles, and memory</li> <li>Progress Feedback: For long operations, provide progress updates via logging</li> <li>Memory Management: Be mindful of memory usage in long-running processes</li> </ul>"},{"location":"Lab03-MCP-Tools/#tool-composition","title":"Tool Composition","text":"<p>Tool composition is the art of designing MCP tools that work seamlessly together, allowing LLMs to chain multiple tools to accomplish complex tasks. Well-composed tools create a powerful ecosystem where each tool handles a specific responsibility while enabling sophisticated workflows through intelligent combination.</p>"},{"location":"Lab03-MCP-Tools/#example-multi-step-analysis","title":"Example: Multi-Step Analysis","text":"<p>Multi-step analysis demonstrates how simple, focused tools can be combined to perform complex data processing workflows. Each tool has a clear responsibility and can be used independently or as part of larger operations.</p> <pre><code>// Tool 1: List files\n{\n  name: \"list_files\",\n  description: \"List files in a directory\",\n  inputSchema: { ... }\n}\n\n// Tool 2: Read file\n{\n  name: \"read_file\",\n  description: \"Read a specific file\",\n  inputSchema: { ... }\n}\n\n// Tool 3: Analyze content\n{\n  name: \"analyze_text\",\n  description: \"Analyze text content\",\n  inputSchema: { ... }\n}\n</code></pre> <p>When to use - For workflows that require multiple processing steps:</p> <ul> <li>Data analysis pipelines</li> <li>File processing workflows</li> <li>Multi-stage computations</li> <li>Complex research tasks</li> </ul> <p>Why it matters: Breaks down complex problems into manageable, reusable components that can be combined in flexible ways.</p>"},{"location":"Lab03-MCP-Tools/#llm-tool-chaining","title":"LLM Tool Chaining","text":"<p>LLM tool chaining allows AI models to automatically sequence tool calls based on intermediate results. The LLM analyzes outputs from one tool and determines which tool to call next, creating intelligent workflows without explicit programming.</p> <p>The LLM can chain these tools:</p> <ol> <li>List files in directory - Discover available files</li> <li>Read interesting files - Access content based on filenames</li> <li>Analyze their content - Process and extract insights</li> </ol> <p>When to use - When tasks naturally break down into sequential steps:</p> <ul> <li>Research and analysis workflows</li> <li>Data processing pipelines</li> <li>Content generation chains</li> <li>Problem-solving sequences</li> </ul> <p>Why it matters: Enables complex, multi-step reasoning and problem-solving that would be difficult to implement in single tools.</p>"},{"location":"Lab03-MCP-Tools/#testing-composed-tools","title":"Testing Composed Tools","text":"<p>Testing composed tools ensures that individual tools work correctly both in isolation and when chained together. Use comprehensive test suites that cover single-tool usage and multi-tool workflows.</p> <pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Weather Tool', () =&gt; {\n  it('should validate city name', async () =&gt; {\n    await expect(\n      callTool('get_weather', { city: '' })\n    ).rejects.toThrow('City name cannot be empty');\n  });\n\n  it('should handle invalid city', async () =&gt; {\n    await expect(\n      callTool('get_weather', { city: 'InvalidCity12345' })\n    ).rejects.toThrow('not found');\n  });\n\n  it('should return weather data', async () =&gt; {\n    const result = await callTool('get_weather', {\n      city: 'London',\n      units: 'celsius'\n    });\n\n    expect(result.content).toHaveLength(1);\n    expect(result.content[0].text).toContain('Temperature');\n  });\n});\n</code></pre> <p>When to use - For validating tool behavior in different scenarios:</p> <ul> <li>Unit testing individual tools</li> <li>Integration testing tool chains</li> <li>Regression testing after changes</li> <li>Edge case validation</li> </ul> <p>Why it matters: Ensures reliability and predictability when tools are used individually or in combination.</p>"},{"location":"Lab03-MCP-Tools/#best-practices-for-tool-composition","title":"Best Practices for Tool Composition:","text":"<ul> <li>Single Responsibility: Each tool should do one thing well</li> <li>Consistent Interfaces: Use similar parameter patterns across tools</li> <li>Clear Dependencies: Document which tools work well together</li> <li>Error Propagation: Handle failures gracefully in tool chains</li> <li>State Management: Avoid tools that require complex state between calls</li> <li>Flexible Outputs: Design tool outputs to be usable as inputs for other tools</li> <li>Documentation: Clearly explain how tools can be combined</li> <li>Version Compatibility: Ensure tool interfaces remain stable</li> </ul>"},{"location":"Lab03-MCP-Tools/#best-practices-checklist","title":"Best Practices Checklist","text":"<p>\u2705 Schema Design</p> <ul> <li>Use descriptive names and descriptions</li> <li>Add examples in descriptions</li> <li>Set reasonable defaults</li> <li>Use enums for constrained values</li> <li>Add min/max for numbers</li> </ul> <p>\u2705 Implementation</p> <ul> <li>Validate all inputs, even with schemas</li> <li>Handle errors gracefully</li> <li>Log to stderr, not stdout</li> <li>Use async/await properly</li> <li>Clean up resources (file handles, connections)</li> </ul> <p>\u2705 Security</p> <ul> <li>Validate and sanitize file paths</li> <li>Use prepared statements for SQL</li> <li>Limit resource usage (file sizes, API calls)</li> <li>Don\u2019t expose sensitive data in errors</li> <li>Implement rate limiting</li> </ul> <p>\u2705 Performance</p> <ul> <li>Cache expensive operations</li> <li>Set reasonable timeouts</li> <li>Limit result sizes</li> <li>Use streaming for large data</li> <li>Monitor execution time</li> </ul> <p>\u2705 User Experience</p> <ul> <li>Provide clear error messages</li> <li>Return structured data when possible</li> <li>Include relevant context in responses</li> <li>Handle edge cases gracefully</li> <li>Document expected behavior</li> </ul>"},{"location":"Lab03-MCP-Tools/#hands-on-exercises","title":"Hands-On Exercises","text":""},{"location":"Lab03-MCP-Tools/#exercise-1-text-processing-tool","title":"Exercise 1: Text Processing Tool","text":"<p>Create a tool that:</p> <ul> <li>Counts words, characters, lines</li> <li>Finds specific patterns</li> <li>Calculates reading time</li> <li>Detects language</li> </ul> \ud83d\udca1 Solution: Text Processing Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"process_text\",\n  description: \"Analyze and process text content with various metrics and operations\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      text: {\n        type: \"string\",\n        description: \"The text content to process\"\n      },\n      operations: {\n        type: \"array\",\n        description: \"Operations to perform\",\n        items: {\n          type: \"string\",\n          enum: [\"count\", \"find_pattern\", \"reading_time\", \"detect_language\"]\n        },\n        default: [\"count\"]\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Regex pattern for find_pattern operation\"\n      }\n    },\n    required: [\"text\"]\n  }\n}\n</code></pre>  Implementation - Add this handler in your \"CallToolRequestSchema\" handler:  <pre><code>if (name === \"process_text\") {\n  try {\n    const text = args.text as string;\n    const operations = (args.operations as string[]) || [\"count\"];\n    const pattern = args.pattern as string;\n\n    let results: string[] = [];\n\n    for (const op of operations) {\n      switch (op) {\n        case \"count\":\n          const lines = text.split('\\n').length;\n          const words = text.split(/\\s+/).filter(w =&gt; w.length &gt; 0).length;\n          const chars = text.length;\n          results.push(`\ud83d\udcca Text Statistics:\\n- Lines: ${lines}\\n- Words: ${words}\\n- Characters: ${chars}`);\n          break;\n\n        case \"find_pattern\":\n          if (!pattern) {\n            results.push(\"\u274c Pattern required for find_pattern operation\");\n            break;\n          }\n          try {\n            const regex = new RegExp(pattern, 'g');\n            const matches = text.match(regex);\n            results.push(`\ud83d\udd0d Pattern Matches (${pattern}):\\nFound ${matches ? matches.length : 0} matches:\\n${matches ? matches.slice(0, 10).join('\\n') : 'None'}`);\n          } catch (e) {\n            results.push(`\u274c Invalid regex pattern: ${pattern}`);\n          }\n          break;\n\n        case \"reading_time\":\n          // Average reading speed: 200 words per minute\n          const wordCount = text.split(/\\s+/).filter(w =&gt; w.length &gt; 0).length;\n          const readingTime = Math.ceil(wordCount / 200);\n          results.push(`\u23f1\ufe0f Reading Time: Approximately ${readingTime} minute${readingTime !== 1 ? 's' : ''} (${wordCount} words at 200 WPM)`);\n          break;\n\n        case \"detect_language\":\n          // Simple language detection based on common words\n          const englishWords = /\\b(the|and|or|but|in|on|at|to|for|of|with|by)\\b/gi;\n          const spanishWords = /\\b(el|la|los|las|y|o|pero|en|sobre|a|para|de|con|por)\\b/gi;\n          const frenchWords = /\\b(le|la|les|et|ou|mais|dans|sur|\u00e0|pour|de|avec|par)\\b/gi;\n\n          const englishMatches = (text.match(englishWords) || []).length;\n          const spanishMatches = (text.match(spanishWords) || []).length;\n          const frenchMatches = (text.match(frenchWords) || []).length;\n\n          const maxMatches = Math.max(englishMatches, spanishMatches, frenchMatches);\n          let detectedLang = \"Unknown\";\n\n          if (maxMatches &gt; 0) {\n            if (englishMatches === maxMatches) detectedLang = \"English\";\n            else if (spanishMatches === maxMatches) detectedLang = \"Spanish\";\n            else if (frenchMatches === maxMatches) detectedLang = \"French\";\n          }\n\n          results.push(`\ud83c\udf0d Detected Language: ${detectedLang} (confidence: ${maxMatches} common words)`);\n          break;\n      }\n    }\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: results.join('\\n\\n')\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(`Text processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n</code></pre>  Testing - Test with different inputs:  <pre><code>// Basic counting\n{ text: \"Hello world\\nThis is a test\", operations: [\"count\"] }\n\n// Pattern matching\n{ text: \"The quick brown fox jumps over the lazy dog\", operations: [\"find_pattern\"], pattern: \"\\\\b\\\\w{4}\\\\b\" }\n\n// Multiple operations\n{ text: \"This is a longer piece of text to analyze for various metrics and patterns.\", operations: [\"count\", \"reading_time\", \"detect_language\"] }\n</code></pre>"},{"location":"Lab03-MCP-Tools/#exercise-2-json-validator-tool","title":"Exercise 2: JSON Validator Tool","text":"<p>Create a tool that:</p> <ul> <li>Validates JSON syntax</li> <li>Validates against JSON Schema</li> <li>Formats/pretty-prints JSON</li> <li>Compares two JSON objects</li> </ul> \ud83d\udca1 Solution: JSON Validator Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"validate_json\",\n  description: \"Validate, format, and compare JSON data\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      json: {\n        type: \"string\",\n        description: \"JSON string to validate or format\"\n      },\n      operation: {\n        type: \"string\",\n        description: \"Operation to perform\",\n        enum: [\"validate\", \"format\", \"schema_validate\", \"compare\"],\n        default: \"validate\"\n      },\n      schema: {\n        type: \"string\",\n        description: \"JSON Schema for schema validation (as JSON string)\"\n      },\n      json2: {\n        type: \"string\",\n        description: \"Second JSON string for comparison\"\n      }\n    },\n    required: [\"json\", \"operation\"]\n  }\n}\n</code></pre>  Implementation - First, install the required dependency:  <pre><code>npm install ajv\n</code></pre>  Add the import:  <pre><code>import Ajv from 'ajv';\n</code></pre>  Add this handler in your \"CallToolRequestSchema\" handler:  <pre><code>if (name === \"validate_json\") {\n  try {\n    const json = args.json as string;\n    const operation = args.operation as string;\n    const schema = args.schema as string;\n    const json2 = args.json2 as string;\n\n    let result = \"\";\n\n    switch (operation) {\n      case \"validate\":\n        try {\n          JSON.parse(json);\n          result = \"\u2705 Valid JSON syntax\";\n        } catch (e) {\n          result = `\u274c Invalid JSON: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"format\":\n        try {\n          const parsed = JSON.parse(json);\n          result = `\ud83d\udcc4 Formatted JSON:\\n\\`\\`\\`json\\n${JSON.stringify(parsed, null, 2)}\\n\\`\\`\\``;\n        } catch (e) {\n          result = `\u274c Cannot format invalid JSON: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"schema_validate\":\n        if (!schema) {\n          result = \"\u274c Schema required for schema validation\";\n          break;\n        }\n        try {\n          const ajv = new Ajv();\n          const parsedJson = JSON.parse(json);\n          const parsedSchema = JSON.parse(schema);\n\n          const validate = ajv.compile(parsedSchema);\n          const valid = validate(parsedJson);\n\n          if (valid) {\n            result = \"\u2705 JSON validates against schema\";\n          } else {\n            result = `\u274c Schema validation failed:\\n${JSON.stringify(validate.errors, null, 2)}`;\n          }\n        } catch (e) {\n          result = `\u274c Schema validation error: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"compare\":\n        if (!json2) {\n          result = \"\u274c Second JSON required for comparison\";\n          break;\n        }\n        try {\n          const obj1 = JSON.parse(json);\n          const obj2 = JSON.parse(json2);\n\n          const differences: string[] = [];\n\n          // Simple comparison - check if objects are equal\n          if (JSON.stringify(obj1) === JSON.stringify(obj2)) {\n            result = \"\u2705 JSON objects are identical\";\n          } else {\n            // Find differences\n            const keys1 = Object.keys(obj1);\n            const keys2 = Object.keys(obj2);\n\n            const added = keys2.filter(k =&gt; !keys1.includes(k));\n            const removed = keys1.filter(k =&gt; !keys2.includes(k));\n            const modified = keys1.filter(k =&gt; keys2.includes(k) &amp;&amp; JSON.stringify(obj1[k]) !== JSON.stringify(obj2[k]));\n\n            if (added.length &gt; 0) differences.push(`Added keys: ${added.join(', ')}`);\n            if (removed.length &gt; 0) differences.push(`Removed keys: ${removed.join(', ')}`);\n            if (modified.length &gt; 0) differences.push(`Modified keys: ${modified.join(', ')}`);\n\n            result = `\u26a0\ufe0f JSON objects differ:\\n${differences.join('\\n')}`;\n          }\n        } catch (e) {\n          result = `\u274c Comparison error: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n    }\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: result\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(`JSON validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n</code></pre>  Testing - Test different operations:  <pre><code>// Validate syntax\n{ json: '{\"name\": \"test\", \"value\": 123}', operation: \"validate\" }\n\n// Format JSON\n{ json: '{\"name\":\"test\",\"value\":123}', operation: \"format\" }\n\n// Schema validation\n{ \n  json: '{\"name\": \"John\", \"age\": 30}', \n  operation: \"schema_validate\",\n  schema: '{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}, \"age\": {\"type\": \"number\"}}}'\n}\n\n// Compare JSON\n{\n  json: '{\"a\": 1, \"b\": 2}',\n  json2: '{\"a\": 1, \"c\": 3}',\n  operation: \"compare\"\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/#exercise-3-web-scraper-tool","title":"Exercise 3: Web Scraper Tool","text":"<p>Create a tool that:</p> <ul> <li>Fetches web page content</li> <li>Extracts specific elements</li> <li>Returns clean text</li> <li>Handles errors gracefully</li> </ul> \ud83d\udca1 Solution: Web Scraper Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"scrape_web\",\n  description: \"Fetch and extract content from web pages\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      url: {\n        type: \"string\",\n        description: \"URL to scrape\",\n        format: \"uri\"\n      },\n      selector: {\n        type: \"string\",\n        description: \"CSS selector to extract specific elements (optional)\",\n        default: \"body\"\n      },\n      includeText: {\n        type: \"boolean\",\n        description: \"Extract only text content (remove HTML)\",\n        default: true\n      },\n      maxLength: {\n        type: \"number\",\n        description: \"Maximum length of extracted content\",\n        minimum: 100,\n        maximum: 10000,\n        default: 2000\n      },\n      timeout: {\n        type: \"number\",\n        description: \"Request timeout in milliseconds\",\n        minimum: 1000,\n        maximum: 30000,\n        default: 10000\n      }\n    },\n    required: [\"url\"]\n  }\n}\n</code></pre>  Implementation - First, install the required dependencies:  <pre><code>npm install axios cheerio\n</code></pre>  Add the imports:  <pre><code>import axios from 'axios';\nimport * as cheerio from 'cheerio';\n</code></pre>  Add this handler in your `CallToolRequestSchema` handler:  <pre><code>if (name === \"scrape_web\") {\n  try {\n    const url = args.url as string;\n    const selector = (args.selector as string) || \"body\";\n    const includeText = (args.includeText !== false); // default true\n    const maxLength = (args.maxLength as number) || 2000;\n    const timeout = (args.timeout as number) || 10000;\n\n    // Validate URL\n    try {\n      new URL(url);\n    } catch {\n      throw new Error(\"Invalid URL format\");\n    }\n\n    // Fetch the webpage\n    const response = await axios.get(url, {\n      timeout: timeout,\n      headers: {\n        'User-Agent': 'MCP-Web-Scraper/1.0 (Educational Tool)'\n      },\n      maxContentLength: 5 * 1024 * 1024, // 5MB limit\n    });\n\n    // Load HTML into cheerio\n    const $ = cheerio.load(response.data);\n\n    // Extract content based on selector\n    let extractedContent = \"\";\n\n    if (selector === \"body\") {\n      extractedContent = includeText ? $('body').text() : $('body').html() || \"\";\n    } else {\n      const elements = $(selector);\n      if (elements.length === 0) {\n        throw new Error(`No elements found matching selector: ${selector}`);\n      }\n\n      if (includeText) {\n        extractedContent = elements.map((_, el) =&gt; $(el).text()).get().join('\\n\\n');\n      } else {\n        extractedContent = elements.map((_, el) =&gt; $.html(el)).get().join('\\n\\n');\n      }\n    }\n\n    // Clean up the content\n    extractedContent = extractedContent\n      .replace(/\\s+/g, ' ')  // Replace multiple whitespace with single space\n      .replace(/\\n\\s*\\n/g, '\\n')  // Remove empty lines\n      .trim();\n\n    // Truncate if too long\n    if (extractedContent.length &gt; maxLength) {\n      extractedContent = extractedContent.substring(0, maxLength - 3) + \"...\";\n    }\n\n    // Prepare metadata\n    const metadata = {\n      url: url,\n      statusCode: response.status,\n      contentType: response.headers['content-type'],\n      contentLength: response.data.length,\n      extractedLength: extractedContent.length,\n      selector: selector,\n      elementsFound: selector === \"body\" ? 1 : $(selector).length\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `\ud83c\udf10 Web Scraping Results\\n\\n\ud83d\udcca Metadata:\\n${Object.entries(metadata).map(([k, v]) =&gt; `- ${k}: ${v}`).join('\\n')}\\n\\n\ud83d\udcc4 Extracted Content:\\n${extractedContent}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    if (axios.isAxiosError(error)) {\n      if (error.code === 'ENOTFOUND') {\n        throw new Error(`Could not resolve hostname: ${args.url}`);\n      } else if (error.code === 'ECONNREFUSED') {\n        throw new Error(`Connection refused: ${args.url}`);\n      } else if (error.response) {\n        throw new Error(`HTTP ${error.response.status}: ${error.response.statusText}`);\n      } else if (error.code === 'ETIMEDOUT') {\n        throw new Error(`Request timeout after ${args.timeout || 10000}ms`);\n      } else {\n        throw new Error(`Network error: ${error.message}`);\n      }\n    } else {\n      throw new Error(`Web scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n}\n</code></pre>  Testing - Test with different websites and selectors:  <pre><code>// Basic page scraping\n{ url: \"https://httpbin.org/html\" }\n\n// Extract specific elements\n{ url: \"https://httpbin.org/html\", selector: \"h1\" }\n\n// Get HTML instead of text\n{ url: \"https://httpbin.org/html\", selector: \"p\", includeText: false }\n\n// Test error handling\n{ url: \"https://nonexistent-domain-12345.com\" }\n{ url: \"https://httpbin.org/status/404\" }\n</code></pre>  #### Security Notes  - This tool includes basic security measures but should not be used for production scraping - Always respect robots.txt and terms of service - Consider rate limiting to avoid being blocked - Some websites may block requests without proper headers"},{"location":"Lab03-MCP-Tools/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Well-designed tools have clear schemas with validation</p> <p>\u2705 Always validate inputs, even with JSON Schema</p> <p>\u2705 Return rich content types when appropriate</p> <p>\u2705 Handle errors gracefully with helpful messages</p> <p>\u2705 Consider performance and caching for expensive operations</p> <p>\u2705 Design tools to be composable with others</p> <p>\u2705 Test thoroughly with edge cases</p> <p>\u2705 Security is paramount - validate and sanitize everything</p>"},{"location":"Lab03-MCP-Tools/#next-steps","title":"Next Steps","text":"<p>In Lab 4, you\u2019ll explore MCP Resources. You\u2019ll learn:</p> <ul> <li>What resources are and how they differ from tools</li> <li>Implementing resource URIs and templates</li> <li>Supporting resource subscriptions for live updates</li> <li>Best practices for resource organization</li> <li>Combining tools and resources effectively</li> </ul> <p>You\u2019re becoming an MCP expert! Continue to Lab 4.</p>"},{"location":"Lab03-MCP-Tools/lab3-tasks/","title":"MCP Lab Tasks - Lab 3","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-31-calculator-tool","title":"Exercise 3.1: Calculator Tool","text":"<p>Implement a calculator tool that supports basic arithmetic operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"calculate\") {\n    const { operation, a, b } = args;\n    let result: number;\n\n    switch (operation) {\n      case \"add\":\n        result = a + b;\n        break;\n      case \"subtract\":\n        result = a - b;\n        break;\n      case \"multiply\":\n        result = a * b;\n        break;\n      case \"divide\":\n        if (b === 0) throw new Error(\"Division by zero\");\n        result = a / b;\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-32-file-reader-tool","title":"Exercise 3.2: File Reader Tool","text":"<p>Create a tool that reads and returns file contents.</p> Solution <pre><code>import { readFileSync } from \"fs\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"read_file\") {\n    const { path } = args;\n    try {\n      const content = readFileSync(path, \"utf-8\");\n      return {\n        content: [{ type: \"text\", text: content }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-33-http-request-tool","title":"Exercise 3.3: HTTP Request Tool","text":"<p>Implement a tool that makes HTTP requests.</p> Solution <pre><code>import fetch from \"node-fetch\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"http_request\") {\n    const { url, method = \"GET\", headers = {} } = args;\n\n    try {\n      const response = await fetch(url, { method, headers });\n      const data = await response.text();\n\n      return {\n        content: [\n          { type: \"text\", text: `Status: ${response.status}` },\n          { type: \"text\", text: `Body: ${data}` }\n        ]\n      };\n    } catch (error) {\n      throw new Error(`HTTP request failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-34-json-parser-tool","title":"Exercise 3.4: JSON Parser Tool","text":"<p>Create a tool that parses and validates JSON data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_json\") {\n    const { json_string } = args;\n\n    try {\n      const parsed = JSON.parse(json_string);\n      return {\n        content: [\n          { type: \"text\", text: \"JSON is valid\" },\n          { type: \"text\", text: `Parsed: ${JSON.stringify(parsed, null, 2)}` }\n        ]\n      };\n    } catch (error) {\n      return {\n        content: [{ type: \"text\", text: `Invalid JSON: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-35-string-manipulation-tool","title":"Exercise 3.5: String Manipulation Tool","text":"<p>Implement a tool for common string operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"string_ops\") {\n    const { operation, text } = args;\n    let result: string;\n\n    switch (operation) {\n      case \"uppercase\":\n        result = text.toUpperCase();\n        break;\n      case \"lowercase\":\n        result = text.toLowerCase();\n        break;\n      case \"reverse\":\n        result = text.split('').reverse().join('');\n        break;\n      case \"length\":\n        result = text.length.toString();\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-36-database-query-tool","title":"Exercise 3.6: Database Query Tool","text":"<p>Create a tool that executes simple database queries.</p> Solution <pre><code>import sqlite3 from \"sqlite3\";\n\nconst db = new sqlite3.Database(':memory:');\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"db_query\") {\n    const { query } = args;\n\n    return new Promise((resolve, reject) =&gt; {\n      db.all(query, [], (err, rows) =&gt; {\n        if (err) {\n          reject(new Error(`Database error: ${err.message}`));\n        } else {\n          resolve({\n            content: [{ type: \"text\", text: JSON.stringify(rows, null, 2) }]\n          });\n        }\n      });\n    });\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-37-image-processing-tool","title":"Exercise 3.7: Image Processing Tool","text":"<p>Implement a tool that gets image metadata.</p> Solution <pre><code>import sharp from \"sharp\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"image_info\") {\n    const { image_path } = args;\n\n    try {\n      const metadata = await sharp(image_path).metadata();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Width: ${metadata.width}, Height: ${metadata.height}, Format: ${metadata.format}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Image processing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-38-code-linter-tool","title":"Exercise 3.8: Code Linter Tool","text":"<p>Create a tool that lints JavaScript/TypeScript code.</p> Solution <pre><code>import { ESLint } from \"eslint\";\n\nconst eslint = new ESLint();\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"lint_code\") {\n    const { code, filename = \"temp.js\" } = args;\n\n    try {\n      const results = await eslint.lintText(code, { filePath: filename });\n      const formatter = await eslint.loadFormatter(\"stylish\");\n      const resultText = formatter.format(results);\n\n      return {\n        content: [{ type: \"text\", text: resultText || \"No linting issues found\" }]\n      };\n    } catch (error) {\n      throw new Error(`Linting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-39-weather-api-tool","title":"Exercise 3.9: Weather API Tool","text":"<p>Implement a tool that fetches weather data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"get_weather\") {\n    const { city } = args;\n    const apiKey = process.env.WEATHER_API_KEY;\n\n    if (!apiKey) {\n      throw new Error(\"Weather API key not configured\");\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${city}&amp;appid=${apiKey}&amp;units=metric`\n      );\n\n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Weather in ${city}: ${data.weather[0].description}, ${data.main.temp}\u00b0C`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Weather fetch failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-310-git-operations-tool","title":"Exercise 3.10: Git Operations Tool","text":"<p>Create a tool for basic Git operations.</p> Solution <pre><code>import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"git_status\") {\n    try {\n      const { stdout } = await execAsync(\"git status --porcelain\");\n      return {\n        content: [{ type: \"text\", text: stdout || \"Working directory clean\" }]\n      };\n    } catch (error) {\n      throw new Error(`Git command failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-311-regex-tool","title":"Exercise 3.11: Regex Tool","text":"<p>Implement a tool for regular expression operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"regex_match\") {\n    const { pattern, text, flags = \"\" } = args;\n\n    try {\n      const regex = new RegExp(pattern, flags);\n      const matches = text.match(regex);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: matches ? `Matches found: ${matches.join(\", \")}` : \"No matches found\"\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Regex error: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-312-unit-converter-tool","title":"Exercise 3.12: Unit Converter Tool","text":"<p>Create a tool that converts between different units.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"convert_units\") {\n    const { value, from, to } = args;\n\n    // Simple conversion factors (could be expanded)\n    const conversions: Record&lt;string, Record&lt;string, number&gt;&gt; = {\n      celsius: { fahrenheit: (c) =&gt; c * 9/5 + 32, kelvin: (c) =&gt; c + 273.15 },\n      fahrenheit: { celsius: (f) =&gt; (f - 32) * 5/9, kelvin: (f) =&gt; (f - 32) * 5/9 + 273.15 },\n      meters: { feet: (m) =&gt; m * 3.28084, kilometers: (m) =&gt; m / 1000 },\n      feet: { meters: (f) =&gt; f / 3.28084, kilometers: (f) =&gt; f / 3280.84 }\n    };\n\n    if (conversions[from] &amp;&amp; conversions[from][to]) {\n      const result = conversions[from][to](value);\n      return {\n        content: [{ type: \"text\", text: `${value} ${from} = ${result.toFixed(2)} ${to}` }]\n      };\n    }\n\n    throw new Error(`Conversion from ${from} to ${to} not supported`);\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-313-csv-parser-tool","title":"Exercise 3.13: CSV Parser Tool","text":"<p>Implement a tool that parses CSV data.</p> Solution <pre><code>import { parse } from \"csv-parse/sync\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_csv\") {\n    const { csv_data } = args;\n\n    try {\n      const records = parse(csv_data, {\n        columns: true,\n        skip_empty_lines: true\n      });\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Parsed ${records.length} rows: ${JSON.stringify(records.slice(0, 5), null, 2)}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`CSV parsing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-314-password-generator-tool","title":"Exercise 3.14: Password Generator Tool","text":"<p>Create a tool that generates secure passwords.</p> Solution <pre><code>import { randomBytes } from \"crypto\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_password\") {\n    const { length = 12, include_special = true } = args;\n\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const specialChars = \"!@#$%^&amp;*\";\n\n    let charset = chars;\n    if (include_special) {\n      charset += specialChars;\n    }\n\n    let password = \"\";\n    const bytes = randomBytes(length);\n\n    for (let i = 0; i &lt; length; i++) {\n      password += charset[bytes[i] % charset.length];\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Generated password: ${password}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-315-code-formatter-tool","title":"Exercise 3.15: Code Formatter Tool","text":"<p>Implement a tool that formats code using Prettier.</p> Solution <pre><code>import prettier from \"prettier\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"format_code\") {\n    const { code, language = \"javascript\" } = args;\n\n    try {\n      const formatted = await prettier.format(code, {\n        parser: language,\n        semi: true,\n        singleQuote: true\n      });\n\n      return {\n        content: [{ type: \"text\", text: formatted }]\n      };\n    } catch (error) {\n      throw new Error(`Code formatting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/","title":"Lab 4: Implementing MCP Resources","text":""},{"location":"Lab04-MCP-Resources/#overview","title":"Overview","text":"<p>In Lab 3, you mastered the art of creating sophisticated MCP tools that perform actions and return rich content. Now it\u2019s time to explore MCP Resources - the passive counterpart to tools that provides contextual data for LLMs to read and reference.</p> <p>Resources are the foundation for giving LLMs access to your knowledge bases, files, databases, and other data sources. Unlike tools that do things, resources are things - they represent the data itself that LLMs can access for context and reasoning.</p>"},{"location":"Lab04-MCP-Resources/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand the fundamental difference between tools and resources</li> <li>Design effective resource URI schemes for different data types</li> <li>Implement static and dynamic resources with proper metadata</li> <li>Create resource templates for parameterized access</li> <li>Build resource subscriptions for real-time updates</li> <li>Apply security best practices for resource access</li> <li>Combine resources with tools for comprehensive MCP servers</li> <li>Test resource implementations thoroughly</li> </ul>"},{"location":"Lab04-MCP-Resources/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 3 - Implementing MCP Tools</li> <li>Understanding of URI / URL patterns and RESTful design</li> <li>Familiarity with file systems and data structures</li> <li>Basic knowledge of caching and performance optimization</li> </ul>"},{"location":"Lab04-MCP-Resources/#tools-vs-resources","title":"Tools vs. Resources","text":""},{"location":"Lab04-MCP-Resources/#the-fundamental-difference","title":"The Fundamental Difference","text":"<p>Before diving into implementation, it\u2019s crucial to understand when to use tools versus resources. They serve different purposes in the MCP ecosystem.</p>"},{"location":"Lab04-MCP-Resources/#tools-active-operations","title":"Tools: Active Operations","text":"<p>Tools perform actions and return results based on parameters.</p> <pre><code>// Tool: Active, parameterized, can have side effects\n{\n  name: \"search_database\",\n  description: \"Search database with custom query\",\n  inputSchema: {\n    properties: {\n      query: { type: \"string\" },\n      limit: { type: \"number\", default: 100 }\n    }\n  }\n}\n</code></pre> <p>When to use tools:</p> <ul> <li>Data changes frequently or needs computation</li> <li>Operations require parameters or user input</li> <li>Actions have side effects (create, update, delete)</li> <li>Results need processing or transformation</li> </ul>"},{"location":"Lab04-MCP-Resources/#resources-passive-data","title":"Resources: Passive Data","text":"<p>Resources expose existing data that can be read and referenced.</p> <pre><code>// Resource: Passive, addressable, read-only\n{\n  uri: \"db://users/123/profile\",\n  name: \"User Profile\",\n  description: \"User profile data for ID 123\",\n  mimeType: \"application/json\"\n}\n</code></pre> <p>When to use resources:</p> <ul> <li>Data is relatively static or changes predictably</li> <li>Direct access to structured data is needed</li> <li>Content should be cached or bookmarked</li> <li>Data serves as context for LLM reasoning</li> </ul>"},{"location":"Lab04-MCP-Resources/#decision-framework","title":"Decision Framework","text":"Scenario Use Tool Use Resource Why Current weather \u2705 Tool \u274c Resource Data changes constantly API documentation \u274c Tool \u2705 Resource Static reference material Database search \u2705 Tool \u274c Resource Requires query parameters User profile \u274c Tool \u2705 Resource Direct data access needed File contents \u274c Tool \u2705 Resource Static file data Generate report \u2705 Tool \u274c Resource Computation required"},{"location":"Lab04-MCP-Resources/#resource-fundamentals","title":"Resource Fundamentals","text":""},{"location":"Lab04-MCP-Resources/#resource-structure","title":"Resource Structure","text":"<p>Every MCP resource has a consistent structure with metadata that helps LLMs understand what they\u2019re accessing:</p> <pre><code>interface Resource {\n  uri: string;           // Unique identifier (like a URL)\n  name: string;          // Human-readable title\n  description: string;   // What the resource contains\n  mimeType?: string;     // Content type (optional but recommended)\n}\n</code></pre>"},{"location":"Lab04-MCP-Resources/#resource-content","title":"Resource Content","text":"<p>When a resource is read, it returns structured content:</p> <pre><code>interface ResourceContent {\n  contents: Array&lt;{\n    uri: string;\n    mimeType?: string;\n    text?: string;       // For text content\n    blob?: string;       // For binary content (base64)\n  }&gt;;\n}\n</code></pre> <p>Key Points:</p> <ul> <li>Resources are read-only by convention</li> <li>Content can be text or binary (base64 encoded)</li> <li>Multiple content items can be returned for complex resources</li> <li><code>MIME (Multipurpose Internet Mail Extensions) types</code> help clients handle content appropriately</li> </ul>"},{"location":"Lab04-MCP-Resources/#designing-resource-uri-schemes","title":"Designing Resource URI Schemes","text":"<p>Effective URI design is crucial for resource organization and discoverability. A good URI scheme should be:</p> <ul> <li>Hierarchical: Reflects data organization</li> <li>Descriptive: Self-documenting structure</li> <li>Consistent: Follows patterns across similar resources</li> <li>Extensible: Allows for future additions</li> </ul>"},{"location":"Lab04-MCP-Resources/#common-uri-patterns","title":"Common URI Patterns","text":""},{"location":"Lab04-MCP-Resources/#file-system-resources","title":"File System Resources","text":"<pre><code>file:///project/src/index.ts\nfile:///docs/api-reference.md\nfile:///config/database.json\n</code></pre>"},{"location":"Lab04-MCP-Resources/#database-resources","title":"Database Resources","text":"<pre><code>db://users/123/profile\ndb://products/category/electronics\ndb://orders/recent?limit=10\n</code></pre>"},{"location":"Lab04-MCP-Resources/#api-documentation","title":"API Documentation","text":"<pre><code>api://petstore/v1/swagger.json\napi://github/repos/microsoft/vscode/issues\napi://weather/current/london\n</code></pre>"},{"location":"Lab04-MCP-Resources/#configuration-resources","title":"Configuration Resources","text":"<pre><code>config://app/settings\nconfig://database/connection\nconfig://logging/level\n</code></pre>"},{"location":"Lab04-MCP-Resources/#uri-design-best-practices","title":"URI Design Best Practices","text":"<ol> <li>Use descriptive paths: <code>users/active</code> vs <code>u/a</code></li> <li>Include identifiers: <code>orders/123</code> vs <code>current-order</code></li> <li>Support hierarchies: <code>docs/api/v1/endpoints</code></li> <li>Use query parameters moderately: Prefer path segments</li> <li>Be consistent: Same patterns for similar resources</li> </ol>"},{"location":"Lab04-MCP-Resources/#implementing-static-resources","title":"Implementing Static Resources","text":"<p>Static resources represent fixed data that doesn\u2019t change or changes infrequently. They\u2019re perfect for documentation, configuration files, and reference data.</p>"},{"location":"Lab04-MCP-Resources/#complete-static-resource-server","title":"Complete Static Resource Server","text":"<p>Here\u2019s a complete MCP server that exposes static resources:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\n/**\n * MCP Server exposing static file resources\n */\nclass StaticResourceServer {\n  private server: Server;\n  private resourceRoot: string;\n\n  constructor(resourceRoot: string = './resources') {\n    this.resourceRoot = path.resolve(resourceRoot);\n\n    this.server = new Server(\n      {\n        name: \"static-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List available resources\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = await this.discoverResources();\n      return { resources };\n    });\n\n    // Read specific resource\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readResource(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async discoverResources(): Promise&lt;any[]&gt; {\n    const resources: any[] = [];\n\n    try {\n      const files = await this.walkDirectory(this.resourceRoot);\n\n      for (const file of files) {\n        const relativePath = path.relative(this.resourceRoot, file);\n        const uri = `file:///${relativePath.replace(/\\\\/g, '/')}`;\n        const mimeType = this.getMimeType(file);\n\n        resources.push({\n          uri,\n          name: path.basename(file),\n          description: `Static file: ${relativePath}`,\n          mimeType,\n        });\n      }\n    } catch (error) {\n      console.error('Error discovering resources:', error);\n    }\n\n    return resources;\n  }\n\n  private async readResource(uri: string): Promise&lt;any&gt; {\n    // Validate URI format\n    if (!uri.startsWith('file:///')) {\n      throw new Error(`Invalid URI format: ${uri}`);\n    }\n\n    const relativePath = uri.substring('file:///'.length);\n    const filePath = path.join(this.resourceRoot, relativePath);\n\n    // Security: Prevent directory traversal\n    const resolvedPath = path.resolve(filePath);\n    if (!resolvedPath.startsWith(this.resourceRoot)) {\n      throw new Error('Access denied: path outside resource root');\n    }\n\n    try {\n      const content = await fs.readFile(filePath, 'utf8');\n      const mimeType = this.getMimeType(filePath);\n\n      return {\n        uri,\n        mimeType,\n        text: content,\n      };\n    } catch (error) {\n      throw new Error(`Failed to read resource: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private async walkDirectory(dir: string): Promise&lt;string[]&gt; {\n    const files: string[] = [];\n\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (entry.isDirectory()) {\n          // Skip hidden directories and node_modules\n          if (!entry.name.startsWith('.') &amp;&amp; entry.name !== 'node_modules') {\n            files.push(...await this.walkDirectory(fullPath));\n          }\n        } else if (entry.isFile()) {\n          // Only include certain file types\n          const ext = path.extname(entry.name).toLowerCase();\n          if (['.md', '.txt', '.json', '.yaml', '.yml', '.js', '.ts', '.css', '.html'].includes(ext)) {\n            files.push(fullPath);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error walking directory ${dir}:`, error);\n    }\n\n    return files;\n  }\n\n  private getMimeType(filePath: string): string {\n    const ext = path.extname(filePath).toLowerCase();\n\n    const mimeTypes: { [key: string]: string } = {\n      '.md': 'text/markdown',\n      '.txt': 'text/plain',\n      '.json': 'application/json',\n      '.yaml': 'application/yaml',\n      '.yml': 'application/yaml',\n      '.js': 'application/javascript',\n      '.ts': 'application/typescript',\n      '.css': 'text/css',\n      '.html': 'text/html',\n    };\n\n    return mimeTypes[ext] || 'text/plain';\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`Static Resource Server running on stdio (root: ${this.resourceRoot})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new StaticResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/#testing-static-resources","title":"Testing Static Resources","text":"<p>Step 1: Create Test Resources</p> <p>First, let\u2019s create some test files that our static resource server can expose. These files will simulate a typical project structure with documentation, configuration, and general project files.</p> <pre><code># Create the directory structure\nmkdir -p resources/docs resources/config\n\n# Create a markdown documentation file\necho \"# API Documentation\\n\\nThis is the API docs.\" &gt; resources/docs/api.md\n\n# Create a JSON configuration file\necho '{\"version\": \"1.0.0\", \"env\": \"development\"}' &gt; resources/config/settings.json\n\n# Create a plain text README file\necho \"Welcome to our project!\" &gt; resources/README.txt\n</code></pre> <p>What this creates:</p> <ul> <li><code>resources/docs/api.md</code> - A markdown file with API documentation</li> <li><code>resources/config/settings.json</code> - A JSON configuration file with version and environment info</li> <li><code>resources/README.txt</code> - A plain text file with project information</li> </ul> <p></p> <p>Step 2: Start the Server</p> <p>Now start your MCP server using the MCP Inspector. </p> <p>This will launch both your server and the testing interface:</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>What to expect:</p> <ul> <li>The MCP Inspector window should open in your browser</li> <li>Your server will start and connect via <code>stdio</code> transport</li> <li>You should see connection confirmation in the terminal</li> <li>The inspector interface will show tabs for Resources, Tools, etc.</li> </ul> <p></p> <p>Step 3: Test Resource Discovery</p> <p>In the MCP Inspector, navigate to the Resources tab to see what resources your server is exposing.</p> <ul> <li> <p>The MCP Inspector should show resources like:</p> <ul> <li><code>file:///docs/api.md</code> - Your API documentation file</li> <li><code>file:///config/settings.json</code> - Your configuration file</li> <li><code>file:///README.txt</code> - Your project README</li> </ul> </li> </ul> <p>What to verify:</p> <ul> <li>All three resources should be listed</li> <li>Each resource should have a descriptive name and description</li> <li>MIME types should be correctly detected (text/markdown, application/json, text/plain)</li> <li>URIs should follow the <code>file://</code> scheme with proper paths</li> </ul> <p></p> <p>Step 4: Test Resource Reading</p> <p>Click on each resource in the list to read its content and verify proper handling.</p> <ul> <li> <p>Click on <code>file:///docs/api.md</code>:</p> <ul> <li>Should display: \u201c# API Documentation\\n\\nThis is the API docs.\u201d</li> <li>MIME type should be: text/markdown</li> </ul> </li> <li> <p>Click on <code>file:///config/settings.json</code>:</p> <ul> <li>Should display: {\u201cversion\u201d: \u201c1.0.0\u201d, \u201cenv\u201d: \u201cdevelopment\u201d}</li> <li>MIME type should be: application/json</li> </ul> </li> <li> <p>Click on <code>file:///README.txt</code>:</p> <ul> <li>Should display: \u201cWelcome to our project!\u201d</li> <li>MIME type should be: text/plain</li> </ul> </li> </ul> <p>Error Testing:</p> <ul> <li>Try reading a non-existent resource like <code>file:///does-not-exist.txt</code></li> <li>Should show an appropriate error message</li> <li>Verify the server handles invalid URIs gracefully</li> </ul> <p>What to learn:</p> <ul> <li>Resources provide direct access to file content</li> <li>MIME types help clients handle different content types</li> <li>Error handling is important for robust resource servers</li> <li>The inspector provides a complete testing environment</li> </ul>"},{"location":"Lab04-MCP-Resources/#implementing-dynamic-resources","title":"Implementing Dynamic Resources","text":"<p>Dynamic resources generate content on-demand based on parameters or current state. They\u2019re useful for live data, computed views, and parameterized access.</p>"},{"location":"Lab04-MCP-Resources/#resource-templates","title":"Resource Templates","text":"<p>Resource templates allow parameterized URIs using <code>{parameter}</code> syntax:</p> <pre><code>// Template definition\n{\n  uriTemplate: \"db://users/{userId}/profile\",\n  name: \"User Profile\",\n  description: \"Profile data for a specific user\",\n  mimeType: \"application/json\"\n}\n\n// Generated URIs\n\"db://users/123/profile\"\n\"db://users/456/profile\"\n</code></pre>"},{"location":"Lab04-MCP-Resources/#complete-dynamic-resource-server","title":"Complete Dynamic Resource Server","text":"<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * MCP Server with dynamic resources and templates\n */\nclass DynamicResourceServer {\n  private server: Server;\n\n  // Mock data store\n  private users = [\n    { id: 1, name: \"Alice Johnson\", email: \"alice@example.com\", role: \"admin\" },\n    { id: 2, name: \"Bob Smith\", email: \"bob@example.com\", role: \"user\" },\n    { id: 3, name: \"Charlie Brown\", email: \"charlie@example.com\", role: \"user\" },\n  ];\n\n  private products = [\n    { id: 1, name: \"Laptop\", price: 999.99, category: \"Electronics\" },\n    { id: 2, name: \"Book\", price: 19.99, category: \"Education\" },\n    { id: 3, name: \"Coffee Mug\", price: 12.50, category: \"Kitchen\" },\n  ];\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"dynamic-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List resource templates\n    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () =&gt; {\n      const templates: ResourceTemplate[] = [\n        {\n          uriTemplate: \"db://users/{userId}/profile\",\n          name: \"User Profile\",\n          description: \"Profile information for a specific user\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://products/{productId}/details\",\n          name: \"Product Details\",\n          description: \"Detailed information about a product\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://stats/{category}/summary\",\n          name: \"Category Statistics\",\n          description: \"Statistical summary for a product category\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resourceTemplates: templates };\n    });\n\n    // List available resources (dynamic)\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources: any[] = [];\n\n      // Add user resources\n      for (const user of this.users) {\n        resources.push({\n          uri: `db://users/${user.id}/profile`,\n          name: `User: ${user.name}`,\n          description: `Profile for ${user.name}`,\n          mimeType: \"application/json\",\n        });\n      }\n\n      // Add product resources\n      for (const product of this.products) {\n        resources.push({\n          uri: `db://products/${product.id}/details`,\n          name: `Product: ${product.name}`,\n          description: `${product.category} - $${product.price}`,\n          mimeType: \"application/json\",\n        });\n      }\n\n      // Add category stats\n      const categories = [...new Set(this.products.map(p =&gt; p.category))];\n      for (const category of categories) {\n        resources.push({\n          uri: `db://stats/${category}/summary`,\n          name: `${category} Statistics`,\n          description: `Summary statistics for ${category}`,\n          mimeType: \"application/json\",\n        });\n      }\n\n      return { resources };\n    });\n\n    // Read specific resource\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.generateResourceContent(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async generateResourceContent(uri: string): Promise&lt;any&gt; {\n    const parts = uri.split('/');\n\n    if (parts[0] === 'db:' &amp;&amp; parts[1] === '') {\n      const type = parts[2];\n      const id = parts[3];\n      const action = parts[4];\n\n      switch (type) {\n        case 'users':\n          if (action === 'profile') {\n            const user = this.users.find(u =&gt; u.id === parseInt(id));\n            if (!user) throw new Error(`User ${id} not found`);\n\n            return {\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                user,\n                metadata: {\n                  lastUpdated: new Date().toISOString(),\n                  source: \"dynamic-resource-server\"\n                }\n              }, null, 2),\n            };\n          }\n          break;\n\n        case 'products':\n          if (action === 'details') {\n            const product = this.products.find(p =&gt; p.id === parseInt(id));\n            if (!product) throw new Error(`Product ${id} not found`);\n\n            return {\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                product,\n                metadata: {\n                  lastUpdated: new Date().toISOString(),\n                  inStock: Math.random() &gt; 0.3 // Simulate stock status\n                }\n              }, null, 2),\n            };\n          }\n          break;\n\n        case 'stats':\n          if (action === 'summary') {\n            const category = id;\n            const categoryProducts = this.products.filter(p =&gt; p.category === category);\n\n            if (categoryProducts.length === 0) {\n              throw new Error(`Category '${category}' not found`);\n            }\n\n            const stats = {\n              category,\n              totalProducts: categoryProducts.length,\n              averagePrice: categoryProducts.reduce((sum, p) =&gt; sum + p.price, 0) / categoryProducts.length,\n              priceRange: {\n                min: Math.min(...categoryProducts.map(p =&gt; p.price)),\n                max: Math.max(...categoryProducts.map(p =&gt; p.price)),\n              },\n              generatedAt: new Date().toISOString(),\n            };\n\n            return {\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify(stats, null, 2),\n            };\n          }\n          break;\n      }\n    }\n\n    throw new Error(`Unknown resource URI: ${uri}`);\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Dynamic Resource Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new DynamicResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/#testing-dynamic-resources","title":"Testing Dynamic Resources","text":"<p>Step 1: Start the Server</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>Step 2: Test Resource Templates</p> <ul> <li>Check that templates are listed: <code>db://users/{userId}/profile</code>, etc.</li> </ul> <p>Step 3: Test Resource Discovery</p> <ul> <li>Should show individual resources for users, products, and categories</li> </ul> <p>Step 4: Test Resource Reading</p> <ul> <li>Try <code>db://users/1/profile</code> - should return user data</li> <li>Try <code>db://products/2/details</code> - should return product data</li> <li>Try <code>db://stats/Electronics/summary</code> - should return category stats</li> <li>Test invalid URIs to verify error handling</li> </ul>"},{"location":"Lab04-MCP-Resources/#resource-subscriptions-for-live-updates","title":"Resource Subscriptions for Live Updates","text":"<p>Resource subscriptions enable real-time updates when resource content changes. This is essential for live data, monitoring dashboards, and collaborative environments.</p>"},{"location":"Lab04-MCP-Resources/#subscription-implementation","title":"Subscription Implementation","text":"<pre><code>// Enable subscriptions in server capabilities\n{\n  capabilities: {\n    resources: {\n      subscribe: true  // Enable subscription support\n    },\n  },\n}\n</code></pre>"},{"location":"Lab04-MCP-Resources/#complete-subscription-server","title":"Complete Subscription Server","text":"<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  SubscribeRequestSchema,\n  UnsubscribeRequestSchema,\n  ResourceUpdatedNotificationSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * MCP Server with resource subscriptions for live updates\n */\nclass SubscriptionResourceServer {\n  private server: Server;\n  private subscribers: Map&lt;string, Set&lt;string&gt;&gt; = new Map(); // uri -&gt; sessionIds\n  private updateInterval: NodeJS.Timeout | null = null;\n\n  // Simulated live data\n  private metrics = {\n    activeUsers: 42,\n    serverLoad: 0.65,\n    responseTime: 120,\n    errorRate: 0.02,\n  };\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"subscription-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {\n            subscribe: true,\n          },\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n    this.startMetricsSimulation();\n  }\n\n  private setupHandlers(): void {\n    // List resources\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      return {\n        resources: [\n          {\n            uri: \"metrics://server/active-users\",\n            name: \"Active Users\",\n            description: \"Current number of active users\",\n            mimeType: \"application/json\",\n          },\n          {\n            uri: \"metrics://server/load\",\n            name: \"Server Load\",\n            description: \"Current server load percentage\",\n            mimeType: \"application/json\",\n          },\n          {\n            uri: \"metrics://server/response-time\",\n            name: \"Response Time\",\n            description: \"Average response time in milliseconds\",\n            mimeType: \"application/json\",\n          },\n          {\n            uri: \"metrics://server/error-rate\",\n            name: \"Error Rate\",\n            description: \"Current error rate percentage\",\n            mimeType: \"application/json\",\n          },\n        ],\n      };\n    });\n\n    // Read resource\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = this.getMetricContent(uri);\n      return { contents: [content] };\n    });\n\n    // Subscribe to resource updates\n    this.server.setRequestHandler(SubscribeRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n\n      if (!this.subscribers.has(uri)) {\n        this.subscribers.set(uri, new Set());\n      }\n\n      // In a real implementation, you'd get the session ID from the request\n      // For this example, we'll use a mock session ID\n      const sessionId = \"mock-session\";\n      this.subscribers.get(uri)!.add(sessionId);\n\n      console.error(`Subscribed to ${uri} (session: ${sessionId})`);\n\n      return {};\n    });\n\n    // Unsubscribe from resource updates\n    this.server.setRequestHandler(UnsubscribeRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const sessionId = \"mock-session\"; // Would come from request in real implementation\n\n      if (this.subscribers.has(uri)) {\n        this.subscribers.get(uri)!.delete(sessionId);\n\n        if (this.subscribers.get(uri)!.size === 0) {\n          this.subscribers.delete(uri);\n        }\n      }\n\n      console.error(`Unsubscribed from ${uri} (session: ${sessionId})`);\n\n      return {};\n    });\n  }\n\n  private getMetricContent(uri: string): any {\n    const metricName = uri.split('/').pop();\n\n    if (!metricName || !(metricName in this.metrics)) {\n      throw new Error(`Unknown metric: ${metricName}`);\n    }\n\n    const value = (this.metrics as any)[metricName];\n\n    return {\n      uri,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        metric: metricName,\n        value,\n        timestamp: new Date().toISOString(),\n        unit: this.getMetricUnit(metricName),\n      }, null, 2),\n    };\n  }\n\n  private getMetricUnit(metricName: string): string {\n    const units: { [key: string]: string } = {\n      activeUsers: \"users\",\n      serverLoad: \"percentage\",\n      responseTime: \"milliseconds\",\n      errorRate: \"percentage\",\n    };\n    return units[metricName] || \"unit\";\n  }\n\n  private startMetricsSimulation(): void {\n    // Simulate changing metrics every 5 seconds\n    this.updateInterval = setInterval(() =&gt; {\n      // Randomly update metrics\n      this.metrics.activeUsers += Math.floor(Math.random() * 10) - 5;\n      this.metrics.activeUsers = Math.max(0, this.metrics.activeUsers);\n\n      this.metrics.serverLoad = Math.random() * 0.5 + 0.3; // 0.3 to 0.8\n      this.metrics.responseTime = 100 + Math.random() * 100; // 100-200ms\n      this.metrics.errorRate = Math.random() * 0.05; // 0-5%\n\n      // Notify subscribers of updates\n      this.notifySubscribers();\n    }, 5000);\n  }\n\n  private notifySubscribers(): void {\n    for (const [uri, sessionIds] of this.subscribers) {\n      if (sessionIds.size &gt; 0) {\n        // Send notification to all subscribers of this resource\n        this.server.notification(ResourceUpdatedNotificationSchema, {\n          uri,\n        });\n\n        console.error(`Notified ${sessionIds.size} subscribers of ${uri} update`);\n      }\n    }\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      if (this.updateInterval) {\n        clearInterval(this.updateInterval);\n      }\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Subscription Resource Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new SubscriptionResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/#testing-subscriptions","title":"Testing Subscriptions","text":"<p>Step 1: Start the Server</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>Step 2: Test Basic Resource Reading</p> <ul> <li>Read metrics like <code>metrics://server/active-users</code></li> <li>Verify they return current values</li> </ul> <p>Step 3: Test Subscriptions</p> <ul> <li> <p>Subscribe to a metric resource:</p> <ul> <li>In the MCP Inspector Resources tab, find a metric resource (e.g., <code>metrics://server/active-users</code>)</li> <li>Click the \u201cSubscribe\u201d button next to the resource</li> <li>You should see a confirmation that subscription was successful</li> </ul> </li> <li> <p>Watch the MCP Inspector for update notifications every 5 seconds:</p> <ul> <li>Keep the Resources tab open</li> <li>Look for notification messages in the inspector interface</li> <li>The metric values should update automatically every 5 seconds</li> <li>You can also check the console/logs for subscription update messages</li> </ul> </li> <li> <p>Unsubscribe and verify notifications stop:</p> <ul> <li>Click the \u201cUnsubscribe\u201d button for the same resource</li> <li>Confirm that update notifications cease</li> <li>The metric values should stop updating in the interface</li> </ul> </li> </ul>"},{"location":"Lab04-MCP-Resources/#security-and-access-control","title":"Security and Access Control","text":"<p>Resource security is critical, especially when exposing sensitive data or system information.</p>"},{"location":"Lab04-MCP-Resources/#access-control-patterns","title":"Access Control Patterns","text":""},{"location":"Lab04-MCP-Resources/#1-path-based-authorization","title":"1. Path-Based Authorization","text":"<pre><code>private checkResourceAccess(uri: string, userId?: string): boolean {\n  // Allow access to own profile\n  if (uri.startsWith(`users/${userId}/`)) {\n    return true;\n  }\n\n  // Restrict admin resources\n  if (uri.startsWith('admin/') &amp;&amp; !this.isAdmin(userId)) {\n    return false;\n  }\n\n  // Public resources\n  if (uri.startsWith('public/')) {\n    return true;\n  }\n\n  return false;\n}\n</code></pre> <p>How it works: This method checks if a user has permission to access a resource based on the URI path. It grants access to user-specific resources (like their own profile), restricts admin-only resources unless the user has admin privileges, allows public resources for everyone, and denies access by default for any other paths.</p> <p></p>"},{"location":"Lab04-MCP-Resources/#2-content-filtering","title":"2. Content Filtering","text":"<pre><code>private filterSensitiveContent(content: any, userRole: string): any {\n  if (userRole !== 'admin') {\n    // Remove sensitive fields for non-admin users\n    const { password, ssn, ...filtered } = content;\n    return filtered;\n  }\n  return content;\n}\n</code></pre> <p>How it works: This function removes sensitive information from resource content based on user roles. For non-admin users, it uses object destructuring to exclude sensitive fields like passwords and social security numbers, returning a filtered version of the data. Admin users see the complete, unfiltered content.</p> <p></p>"},{"location":"Lab04-MCP-Resources/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code>private rateLimiter = new Map&lt;string, { count: number; resetTime: number }&gt;();\n\nprivate checkRateLimit(identifier: string, maxRequests: number = 100): boolean {\n  const now = Date.now();\n  const windowMs = 60000; // 1 minute\n\n  const record = this.rateLimiter.get(identifier);\n\n  if (!record || now &gt; record.resetTime) {\n    this.rateLimiter.set(identifier, { count: 1, resetTime: now + windowMs });\n    return true;\n  }\n\n  if (record.count &gt;= maxRequests) {\n    return false;\n  }\n\n  record.count++;\n  return true;\n}\n</code></pre> <p>How it works: This implements a sliding window rate limiter using a Map to track request counts per identifier (like user ID or IP address). It allows up to <code>maxRequests</code> (default 100) within a 1-minute window. When the limit is exceeded, it returns false to block the request. The window resets automatically after the time period expires.</p>"},{"location":"Lab04-MCP-Resources/#combining-resources-with-tools","title":"Combining Resources with Tools","text":"<p>The most powerful MCP servers combine resources and tools to provide a comprehensive functionality!</p>"},{"location":"Lab04-MCP-Resources/#complete-hybrid-server","title":"Complete Hybrid Server","text":"<p>The following example demonstrates a server that combines both resources and tools, showing how they work together to provide comprehensive functionality. </p> <p>The server maintains a document store that can be both read as resources and modified through tools.</p> Hybrid Server Class<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListToolsRequestSchema,\n  CallToolRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * MCP Server combining resources and tools\n */\nclass HybridServer {\n  private server: Server;\n  private documents: Map&lt;string, any&gt; = new Map();\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"hybrid-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},  // Enable resource capabilities\n          tools: {},      // Enable tool capabilities\n        },\n      }\n    );\n\n    // Initialize some sample documents\n    this.documents.set(\"doc1\", {\n      id: \"doc1\",\n      title: \"Getting Started Guide\",\n      content: \"This is a comprehensive guide to getting started...\",\n      tags: [\"tutorial\", \"beginner\"],\n      created: new Date().toISOString(),\n    });\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n</code></pre> <p>Key setup points:</p> <ul> <li>The server declares both <code>resources: {}</code> and <code>tools: {}</code> capabilities</li> <li>A Map is used to store documents in memory</li> <li>Sample data is initialized to demonstrate functionality</li> </ul> <p></p> Setup Handlers Method<pre><code>  private setupHandlers(): void {\n    // Resource handlers - provide read-only access to documents\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = Array.from(this.documents.entries()).map(([id, doc]) =&gt; ({\n        uri: `docs://documents/${id}`,\n        name: doc.title,\n        description: `Document: ${doc.title}`,\n        mimeType: \"application/json\",\n      }));\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = this.readDocument(uri);\n      return { contents: [content] };\n    });\n\n    // Tool handlers - provide write operations for documents\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"create_document\",\n            description: \"Create a new document\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                title: { type: \"string\" },\n                content: { type: \"string\" },\n                tags: {\n                  type: \"array\",\n                  items: { type: \"string\" },\n                  default: [],\n                },\n              },\n              required: [\"title\", \"content\"],\n            },\n          },\n          {\n            name: \"search_documents\",\n            description: \"Search documents by content or tags\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                query: { type: \"string\" },\n                tag: { type: \"string\" },\n                limit: { type: \"number\", default: 10 },\n              },\n            },\n          },\n          {\n            name: \"update_document\",\n            description: \"Update an existing document\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                id: { type: \"string\" },\n                title: { type: \"string\" },\n                content: { type: \"string\" },\n                tags: { type: \"array\", items: { type: \"string\" } },\n              },\n              required: [\"id\"],\n            },\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"create_document\":\n          return this.createDocument(args);\n\n        case \"search_documents\":\n          return this.searchDocuments(args);\n\n        case \"update_document\":\n          return this.updateDocument(args);\n\n        default:\n          throw new Error(`Unknown tool: ${name}`);\n      }\n    });\n  }\n</code></pre> <p>Resource vs Tool handlers:</p> <ul> <li>Resources expose existing documents for reading (<code>docs://documents/{id}</code>)</li> <li>Tools provide operations to create, search, and update documents</li> <li>Resources are passive (read-only), tools are active (perform actions)</li> </ul> <p></p> Read Document Method<pre><code>  private readDocument(uri: string): any {\n    const match = uri.match(/^docs:\\/\\/documents\\/(.+)$/);\n    if (!match) throw new Error(`Invalid document URI: ${uri}`);\n\n    const id = match[1];\n    const doc = this.documents.get(id);\n\n    if (!doc) throw new Error(`Document not found: ${id}`);\n\n    return {\n      uri,\n      mimeType: \"application/json\",\n      text: JSON.stringify(doc, null, 2),\n    };\n  }\n</code></pre> <p>Resource reading: Parses the URI to extract the document ID, retrieves the document from the Map, and returns it as JSON content.</p> <p></p> Create Document Method<pre><code>  private createDocument(args: any): any {\n    const id = `doc${Date.now()}`;\n    const doc = {\n      id,\n      title: args.title,\n      content: args.content,\n      tags: args.tags || [],\n      created: new Date().toISOString(),\n      modified: new Date().toISOString(),\n    };\n\n    this.documents.set(id, doc);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Document created successfully!\\n\\nID: ${id}\\nTitle: ${doc.title}\\nURI: docs://documents/${id}`,\n        },\n      ],\n    };\n  }\n</code></pre> <p>Tool implementation: Creates a new document with a timestamp-based ID, stores it in the Map, and returns success information including the new document\u2019s URI.</p> <p></p> Search Documents Method<pre><code>  private searchDocuments(args: any): any {\n    let results = Array.from(this.documents.values());\n\n    if (args.query) {\n      const query = args.query.toLowerCase();\n      results = results.filter(doc =&gt;\n        doc.title.toLowerCase().includes(query) ||\n        doc.content.toLowerCase().includes(query)\n      );\n    }\n\n    if (args.tag) {\n      results = results.filter(doc =&gt; doc.tags.includes(args.tag));\n    }\n\n    const limit = args.limit || 10;\n    results = results.slice(0, limit);\n\n    const formatted = results.map(doc =&gt; ({\n      id: doc.id,\n      title: doc.title,\n      tags: doc.tags,\n      uri: `docs://documents/${doc.id}`,\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Found ${results.length} documents:\\n\\n${formatted.map(doc =&gt;\n            `\ud83d\udcc4 ${doc.title} (${doc.tags.join(', ')})\\n   URI: ${doc.uri}`\n          ).join('\\n\\n')}`,\n        },\n      ],\n    };\n  }\n</code></pre> <p>Search tool: Filters documents by query string or tag, limits results, and returns formatted text output with document URIs for easy access.</p> <p></p> Update Document Method<pre><code>  private updateDocument(args: any): any {\n    const doc = this.documents.get(args.id);\n    if (!doc) throw new Error(`Document not found: ${args.id}`);\n\n    if (args.title) doc.title = args.title;\n    if (args.content) doc.content = args.content;\n    if (args.tags) doc.tags = args.tags;\n    doc.modified = new Date().toISOString();\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Document updated successfully!\\n\\nID: ${doc.id}\\nTitle: ${doc.title}\\nModified: ${doc.modified}`,\n        },\n      ],\n    };\n  }\n</code></pre> <p>Update tool: Modifies existing document fields and updates the modification timestamp, providing feedback about the changes made.</p> <p></p> <p>How resources and tools complement each other:</p> <ul> <li>Resources provide passive access: LLMs can read documents at <code>docs://documents/{id}</code></li> <li>Tools enable active operations: LLMs can create, search, and update documents</li> <li>Integration: Tools can reference resources in their responses (e.g., \u201cRead the new document at docs://documents/123\u201d)</li> <li>Workflow: Create documents with tools, then read them as resources for context</li> </ul>"},{"location":"Lab04-MCP-Resources/#hands-on-exercises","title":"Hands-On Exercises","text":""},{"location":"Lab04-MCP-Resources/#exercise-1-file-system-resource-server","title":"Exercise 1: File System Resource Server","text":"<p>Create a tool that:</p> <ul> <li>Exposes a directory as MCP resources</li> <li>Supports different file types (text, JSON, Markdown)</li> <li>Implements proper security (no directory traversal)</li> <li>Includes file metadata (size, modified date)</li> </ul> \ud83d\udca1 Solution: File System Resource Server  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"create_file_resource_server\",\n  description: \"Create an MCP server that exposes a directory as resources\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      directory: {\n        type: \"string\",\n        description: \"Directory path to expose as resources\",\n        default: \"./files\"\n      },\n      allowedExtensions: {\n        type: \"array\",\n        description: \"File extensions to include\",\n        items: { type: \"string\" },\n        default: [\".md\", \".txt\", \".json\", \".yaml\", \".yml\"]\n      },\n      maxFileSize: {\n        type: \"number\",\n        description: \"Maximum file size in bytes\",\n        default: 1048576\n      }\n    },\n    required: [\"directory\"]\n  }\n}\n</code></pre>  Implementation:  <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nclass FileSystemResourceServer {\n  private server: Server;\n  private rootDir: string;\n  private allowedExtensions: string[];\n  private maxFileSize: number;\n\n  constructor(rootDir: string = './files', allowedExtensions: string[] = ['.md', '.txt', '.json', '.yaml', '.yml'], maxFileSize: number = 1048576) {\n    this.rootDir = path.resolve(rootDir);\n    this.allowedExtensions = allowedExtensions;\n    this.maxFileSize = maxFileSize;\n\n    this.server = new Server(\n      {\n        name: \"filesystem-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = await this.discoverFiles();\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readFile(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async discoverFiles(): Promise&lt;any[]&gt; {\n    const resources: any[] = [];\n\n    try {\n      const files = await this.walkDirectory(this.rootDir);\n\n      for (const file of files) {\n        const relativePath = path.relative(this.rootDir, file);\n        const uri = `file:///${relativePath.replace(/\\\\/g, '/')}`;\n        const stats = await fs.stat(file);\n        const mimeType = this.getMimeType(file);\n\n        resources.push({\n          uri,\n          name: path.basename(file),\n          description: `File: ${relativePath} (${this.formatFileSize(stats.size)})`,\n          mimeType,\n        });\n      }\n    } catch (error) {\n      console.error('Error discovering files:', error);\n    }\n\n    return resources;\n  }\n\n  private async readFile(uri: string): Promise&lt;any&gt; {\n    if (!uri.startsWith('file:///')) {\n      throw new Error(`Invalid URI format: ${uri}`);\n    }\n\n    const relativePath = uri.substring('file:///'.length);\n    const filePath = path.join(this.rootDir, relativePath);\n\n    // Security: Prevent directory traversal\n    const resolvedPath = path.resolve(filePath);\n    if (!resolvedPath.startsWith(this.rootDir)) {\n      throw new Error('Access denied: path outside allowed directory');\n    }\n\n    // Check if file extension is allowed\n    const ext = path.extname(filePath).toLowerCase();\n    if (!this.allowedExtensions.includes(ext)) {\n      throw new Error(`File type not allowed: ${ext}`);\n    }\n\n    try {\n      const stats = await fs.stat(filePath);\n\n      // Check file size\n      if (stats.size &gt; this.maxFileSize) {\n        throw new Error(`File too large: ${stats.size} bytes (max: ${this.maxFileSize})`);\n      }\n\n      const content = await fs.readFile(filePath, 'utf8');\n      const mimeType = this.getMimeType(filePath);\n\n      return {\n        uri,\n        mimeType,\n        text: content,\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private async walkDirectory(dir: string): Promise&lt;string[]&gt; {\n    const files: string[] = [];\n\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (entry.isDirectory()) {\n          // Skip hidden directories\n          if (!entry.name.startsWith('.')) {\n            files.push(...await this.walkDirectory(fullPath));\n          }\n        } else if (entry.isFile()) {\n          const ext = path.extname(entry.name).toLowerCase();\n          if (this.allowedExtensions.includes(ext)) {\n            files.push(fullPath);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error walking directory ${dir}:`, error);\n    }\n\n    return files;\n  }\n\n  private getMimeType(filePath: string): string {\n    const ext = path.extname(filePath).toLowerCase();\n    const mimeTypes: { [key: string]: string } = {\n      '.md': 'text/markdown',\n      '.txt': 'text/plain',\n      '.json': 'application/json',\n      '.yaml': 'application/yaml',\n      '.yml': 'application/yaml',\n    };\n    return mimeTypes[ext] || 'text/plain';\n  }\n\n  private formatFileSize(bytes: number): string {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n\n    while (size &gt;= 1024 &amp;&amp; unitIndex &lt; units.length - 1) {\n      size /= 1024;\n      unitIndex++;\n    }\n\n    return `${size.toFixed(1)} ${units[unitIndex]}`;\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`File System Resource Server running (root: ${this.rootDir})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new FileSystemResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>  Testing - Create test files and test the server:  <pre><code>mkdir -p files/docs files/data\necho \"# API Documentation\" &gt; files/docs/api.md\necho '{\"version\": \"1.0.0\"}' &gt; files/data/config.json\necho \"Simple text file\" &gt; files/docs/notes.txt\n</code></pre>  Test with MCP Inspector to verify file discovery and reading."},{"location":"Lab04-MCP-Resources/#exercise-2-rest-api-resource-server","title":"Exercise 2: REST API Resource Server","text":"<p>Create a tool that:</p> <ul> <li>Exposes REST API endpoints as resources</li> <li>Supports query parameters in URIs</li> <li>Handles authentication and rate limiting</li> <li>Caches responses appropriately</li> </ul> \ud83d\udca1 Solution: REST API Resource Server  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"create_api_resource_server\",\n  description: \"Create an MCP server that exposes REST API endpoints as resources\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      baseUrl: {\n        type: \"string\",\n        description: \"Base URL of the API to expose\",\n        format: \"uri\"\n      },\n      apiKey: {\n        type: \"string\",\n        description: \"API key for authentication\"\n      },\n      cacheEnabled: {\n        type: \"boolean\",\n        description: \"Enable response caching\",\n        default: true\n      },\n      cacheTTL: {\n        type: \"number\",\n        description: \"Cache TTL in seconds\",\n        default: 300\n      },\n      rateLimit: {\n        type: \"number\",\n        description: \"Requests per minute limit\",\n        default: 60\n      }\n    },\n    required: [\"baseUrl\"]\n  }\n}\n</code></pre>  Implementation  <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport axios, { AxiosResponse } from 'axios';\n\ninterface CacheEntry {\n  data: any;\n  timestamp: number;\n  ttl: number;\n}\n\nclass APIResourceServer {\n  private server: Server;\n  private baseUrl: string;\n  private apiKey?: string;\n  private cache: Map&lt;string, CacheEntry&gt; = new Map();\n  private cacheEnabled: boolean;\n  private cacheTTL: number;\n  private rateLimit: number;\n  private requestCounts: Map&lt;string, { count: number; resetTime: number }&gt; = new Map();\n\n  constructor(baseUrl: string, apiKey?: string, cacheEnabled: boolean = true, cacheTTL: number = 300, rateLimit: number = 60) {\n    this.baseUrl = baseUrl.replace(/\\/$/, ''); // Remove trailing slash\n    this.apiKey = apiKey;\n    this.cacheEnabled = cacheEnabled;\n    this.cacheTTL = cacheTTL;\n    this.rateLimit = rateLimit;\n\n    this.server = new Server(\n      {\n        name: \"api-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n    this.startCacheCleanup();\n  }\n\n  private setupHandlers(): void {\n    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () =&gt; {\n      const templates: ResourceTemplate[] = [\n        {\n          uriTemplate: \"api://users/{userId}\",\n          name: \"User Profile\",\n          description: \"User profile data from API\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"api://posts/{postId}\",\n          name: \"Post Details\",\n          description: \"Post details from API\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"api://search?q={query}&amp;type={type}\",\n          name: \"Search Results\",\n          description: \"Search API results\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resourceTemplates: templates };\n    });\n\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      // For demonstration, we'll provide some example resources\n      // In a real implementation, you might fetch these from the API\n      const resources = [\n        {\n          uri: \"api://status\",\n          name: \"API Status\",\n          description: \"Current API status and health\",\n          mimeType: \"application/json\",\n        },\n        {\n          uri: \"api://info\",\n          name: \"API Information\",\n          description: \"API metadata and capabilities\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.fetchAPIResource(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async fetchAPIResource(uri: string): Promise&lt;any&gt; {\n    // Check rate limit\n    if (!this.checkRateLimit()) {\n      throw new Error(\"Rate limit exceeded. Please try again later.\");\n    }\n\n    // Check cache first\n    if (this.cacheEnabled) {\n      const cached = this.getCached(uri);\n      if (cached) {\n        return {\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify({\n            ...cached,\n            cached: true,\n            cacheAge: Math.floor((Date.now() - cached._cacheTimestamp) / 1000),\n          }, null, 2),\n        };\n      }\n    }\n\n    try {\n      const apiPath = this.uriToAPIPath(uri);\n      const url = `${this.baseUrl}${apiPath}`;\n\n      const headers: any = {\n        'User-Agent': 'MCP-API-Resource-Server/1.0',\n      };\n\n      if (this.apiKey) {\n        headers['Authorization'] = `Bearer ${this.apiKey}`;\n        // Or: headers['X-API-Key'] = this.apiKey;\n      }\n\n      const response: AxiosResponse = await axios.get(url, {\n        headers,\n        timeout: 10000,\n      });\n\n      const data = {\n        ...response.data,\n        _metadata: {\n          statusCode: response.status,\n          url: url,\n          fetchedAt: new Date().toISOString(),\n          contentType: response.headers['content-type'],\n        }\n      };\n\n      // Cache the response\n      if (this.cacheEnabled) {\n        this.setCache(uri, data);\n      }\n\n      return {\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(data, null, 2),\n      };\n\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        if (error.response) {\n          throw new Error(`API Error ${error.response.status}: ${error.response.statusText}`);\n        } else if (error.code === 'ECONNREFUSED') {\n          throw new Error(`Cannot connect to API: ${this.baseUrl}`);\n        } else {\n          throw new Error(`Network error: ${error.message}`);\n        }\n      } else {\n        throw new Error(`Failed to fetch API resource: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      }\n    }\n  }\n\n  private uriToAPIPath(uri: string): string {\n    if (!uri.startsWith('api://')) {\n      throw new Error(`Invalid API URI: ${uri}`);\n    }\n\n    const path = uri.substring('api://'.length);\n\n    // Handle special cases\n    if (path === 'status') return '/status';\n    if (path === 'info') return '/info';\n\n    // Handle template URIs\n    if (path.startsWith('users/')) {\n      const userId = path.substring('users/'.length);\n      return `/users/${userId}`;\n    }\n\n    if (path.startsWith('posts/')) {\n      const postId = path.substring('posts/'.length);\n      return `/posts/${postId}`;\n    }\n\n    if (path.startsWith('search?')) {\n      // Convert query parameters\n      const queryString = path.substring('search?'.length);\n      return `/search?${queryString}`;\n    }\n\n    // Default: use path as-is\n    return `/${path}`;\n  }\n\n  private checkRateLimit(): boolean {\n    const now = Date.now();\n    const windowMs = 60000; // 1 minute\n    const key = 'global'; // In a real app, use user/session ID\n\n    const record = this.requestCounts.get(key);\n\n    if (!record || now &gt; record.resetTime) {\n      this.requestCounts.set(key, { count: 1, resetTime: now + windowMs });\n      return true;\n    }\n\n    if (record.count &gt;= this.rateLimit) {\n      return false;\n    }\n\n    record.count++;\n    return true;\n  }\n\n  private getCached(uri: string): any | null {\n    const cached = this.cache.get(uri);\n    if (!cached) return null;\n\n    if (Date.now() - cached.timestamp &gt; cached.ttl * 1000) {\n      this.cache.delete(uri);\n      return null;\n    }\n\n    return cached.data;\n  }\n\n  private setCache(uri: string, data: any): void {\n    this.cache.set(uri, {\n      data: { ...data, _cacheTimestamp: Date.now() },\n      timestamp: Date.now(),\n      ttl: this.cacheTTL,\n    });\n  }\n\n  private startCacheCleanup(): void {\n    // Clean up expired cache entries every 5 minutes\n    setInterval(() =&gt; {\n      const now = Date.now();\n      for (const [uri, entry] of this.cache.entries()) {\n        if (now - entry.timestamp &gt; entry.ttl * 1000) {\n          this.cache.delete(uri);\n        }\n      }\n    }, 5 * 60 * 1000);\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`API Resource Server running (API: ${this.baseUrl})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  // Example: JSONPlaceholder API\n  const server = new APIResourceServer('https://jsonplaceholder.typicode.com');\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>  Testing - Test the server with the JSONPlaceholder API:  <pre><code># Start the server\nnpx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre>  Test these resources in the MCP Inspector:  <pre><code>// API status\n{ uri: \"api://status\" }\n\n// API info\n{ uri: \"api://info\" }\n\n// User profiles (using templates)\n{ uri: \"api://users/1\" }\n{ uri: \"api://users/2\" }\n\n// Posts\n{ uri: \"api://posts/1\" }\n\n// Search (if supported by API)\n{ uri: \"api://search?q=lorem&amp;type=post\" }\n</code></pre>"},{"location":"Lab04-MCP-Resources/#exercise-3-database-resource-server","title":"Exercise 3: Database Resource Server","text":"<p>Create a tool that:</p> <ul> <li>Exposes database tables as resources</li> <li>Supports parameterized queries via URI templates</li> <li>Implements read-only access for security</li> <li>Provides metadata about table schemas</li> </ul> \ud83d\udca1 Solution: Database Resource Server  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"create_database_resource_server\",\n  description: \"Create an MCP server that exposes database tables as resources\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      databasePath: {\n        type: \"string\",\n        description: \"Path to SQLite database file\",\n        default: \"./data.db\"\n      },\n      allowedTables: {\n        type: \"array\",\n        description: \"Tables to expose as resources\",\n        items: { type: \"string\" },\n        default: []\n      },\n      readOnly: {\n        type: \"boolean\",\n        description: \"Enforce read-only access\",\n        default: true\n      },\n      maxRows: {\n        type: \"number\",\n        description: \"Maximum rows to return per query\",\n        default: 1000\n      }\n    },\n    required: [\"databasePath\"]\n  }\n}\n</code></pre>  Implementation  <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport Database from 'better-sqlite3';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\ninterface TableInfo {\n  name: string;\n  columns: Array&lt;{\n    name: string;\n    type: string;\n    notnull: number;\n    pk: number;\n  }&gt;;\n  rowCount: number;\n}\n\nclass DatabaseResourceServer {\n  private server: Server;\n  private dbPath: string;\n  private allowedTables: string[];\n  private readOnly: boolean;\n  private maxRows: number;\n  private db: Database.Database | null = null;\n\n  constructor(dbPath: string = './data.db', allowedTables: string[] = [], readOnly: boolean = true, maxRows: number = 1000) {\n    this.dbPath = path.resolve(dbPath);\n    this.allowedTables = allowedTables;\n    this.readOnly = readOnly;\n    this.maxRows = maxRows;\n\n    this.server = new Server(\n      {\n        name: \"database-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () =&gt; {\n      const templates: ResourceTemplate[] = [\n        {\n          uriTemplate: \"db://tables/{tableName}/schema\",\n          name: \"Table Schema\",\n          description: \"Schema information for a database table\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://tables/{tableName}/data?limit={limit}&amp;offset={offset}\",\n          name: \"Table Data\",\n          description: \"Data from a database table with pagination\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://tables/{tableName}/records/{id}\",\n          name: \"Table Record\",\n          description: \"Specific record from a database table\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://query?sql={sql}&amp;params={params}\",\n          name: \"Custom Query\",\n          description: \"Execute a custom SELECT query\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resourceTemplates: templates };\n    });\n\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources: any[] = [];\n\n      try {\n        await this.ensureDatabase();\n        const tables = this.getTableInfo();\n\n        for (const table of tables) {\n          // Table schema resource\n          resources.push({\n            uri: `db://tables/${table.name}/schema`,\n            name: `${table.name} Schema`,\n            description: `Schema for table ${table.name} (${table.columns.length} columns)`,\n            mimeType: \"application/json\",\n          });\n\n          // Table data resource\n          resources.push({\n            uri: `db://tables/${table.name}/data?limit=100`,\n            name: `${table.name} Data`,\n            description: `Data from table ${table.name} (${table.rowCount} rows)`,\n            mimeType: \"application/json\",\n          });\n        }\n\n        // Database info resource\n        resources.push({\n          uri: \"db://info\",\n          name: \"Database Info\",\n          description: \"Database metadata and statistics\",\n          mimeType: \"application/json\",\n        });\n\n      } catch (error) {\n        console.error('Error listing resources:', error);\n      }\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readDatabaseResource(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async ensureDatabase(): Promise&lt;void&gt; {\n    if (this.db) return;\n\n    // Check if database file exists\n    try {\n      await fs.access(this.dbPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(`Database file not found: ${this.dbPath}`);\n    }\n\n    // Open database in read-only mode if specified\n    this.db = new Database(this.dbPath, { readonly: this.readOnly });\n  }\n\n  private getTableInfo(): TableInfo[] {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tables: TableInfo[] = [];\n\n    // Get all tables\n    const tableNames = this.db.prepare(`\n      SELECT name FROM sqlite_master \n      WHERE type='table' AND name NOT LIKE 'sqlite_%'\n    `).all() as Array&lt;{ name: string }&gt;;\n\n    for (const { name } of tableNames) {\n      // Check if table is allowed\n      if (this.allowedTables.length &gt; 0 &amp;&amp; !this.allowedTables.includes(name)) {\n        continue;\n      }\n\n      // Get column info\n      const columns = this.db.prepare(`PRAGMA table_info(${name})`).all() as any[];\n\n      // Get row count\n      const rowCount = (this.db.prepare(`SELECT COUNT(*) as count FROM ${name}`).get() as any).count;\n\n      tables.push({\n        name,\n        columns: columns.map(col =&gt; ({\n          name: col.name,\n          type: col.type,\n          notnull: col.notnull,\n          pk: col.pk,\n        })),\n        rowCount,\n      });\n    }\n\n    return tables;\n  }\n\n  private async readDatabaseResource(uri: string): Promise&lt;any&gt; {\n    await this.ensureDatabase();\n\n    if (!uri.startsWith('db://')) {\n      throw new Error(`Invalid database URI: ${uri}`);\n    }\n\n    const path = uri.substring('db://'.length);\n\n    if (path === 'info') {\n      return this.getDatabaseInfo();\n    }\n\n    if (path.startsWith('tables/')) {\n      return this.readTableResource(path.substring('tables/'.length));\n    }\n\n    if (path.startsWith('query?')) {\n      return this.executeCustomQuery(path.substring('query?'.length));\n    }\n\n    throw new Error(`Unknown database resource: ${uri}`);\n  }\n\n  private getDatabaseInfo(): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tables = this.getTableInfo();\n    const dbStats = this.db.prepare(`\n      SELECT \n        COUNT(*) as tableCount,\n        SUM(\n          (SELECT COUNT(*) FROM sqlite_master WHERE type='index') +\n          (SELECT COUNT(*) FROM pragma_table_info(name))\n        ) as totalColumns\n      FROM sqlite_master \n      WHERE type='table' AND name NOT LIKE 'sqlite_%'\n    `).get() as any;\n\n    return {\n      uri: \"db://info\",\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        database: {\n          path: this.dbPath,\n          readOnly: this.readOnly,\n          tableCount: dbStats.tableCount,\n          totalColumns: dbStats.totalColumns,\n        },\n        tables: tables.map(t =&gt; ({\n          name: t.name,\n          columns: t.columns.length,\n          rows: t.rowCount,\n          primaryKey: t.columns.find(c =&gt; c.pk)?.name,\n        })),\n        server: {\n          maxRows: this.maxRows,\n          allowedTables: this.allowedTables.length &gt; 0 ? this.allowedTables : 'all',\n        },\n      }, null, 2),\n    };\n  }\n\n  private readTableResource(tablePath: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const parts = tablePath.split('/');\n    const tableName = parts[0];\n    const action = parts[1];\n\n    // Validate table access\n    if (this.allowedTables.length &gt; 0 &amp;&amp; !this.allowedTables.includes(tableName)) {\n      throw new Error(`Access denied to table: ${tableName}`);\n    }\n\n    switch (action) {\n      case 'schema':\n        return this.getTableSchema(tableName);\n\n      case 'data':\n        const url = new URL(`db://tables/${tablePath}`);\n        const limit = parseInt(url.searchParams.get('limit') || '100');\n        const offset = parseInt(url.searchParams.get('offset') || '0');\n        return this.getTableData(tableName, limit, offset);\n\n      case 'records':\n        const recordId = parts[2];\n        return this.getTableRecord(tableName, recordId);\n\n      default:\n        throw new Error(`Unknown table action: ${action}`);\n    }\n  }\n\n  private getTableSchema(tableName: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tables = this.getTableInfo();\n    const table = tables.find(t =&gt; t.name === tableName);\n\n    if (!table) {\n      throw new Error(`Table not found: ${tableName}`);\n    }\n\n    return {\n      uri: `db://tables/${tableName}/schema`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        table: tableName,\n        columns: table.columns,\n        rowCount: table.rowCount,\n        indexes: this.getTableIndexes(tableName),\n      }, null, 2),\n    };\n  }\n\n  private getTableData(tableName: string, limit: number, offset: number): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    // Validate limits\n    const actualLimit = Math.min(limit, this.maxRows);\n    const actualOffset = Math.max(0, offset);\n\n    const query = `SELECT * FROM ${tableName} LIMIT ? OFFSET ?`;\n    const rows = this.db.prepare(query).all(actualLimit, actualOffset) as any[];\n\n    return {\n      uri: `db://tables/${tableName}/data?limit=${actualLimit}&amp;offset=${actualOffset}`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        table: tableName,\n        query: {\n          limit: actualLimit,\n          offset: actualOffset,\n          totalRows: rows.length,\n        },\n        data: rows,\n      }, null, 2),\n    };\n  }\n\n  private getTableRecord(tableName: string, recordId: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    // Get primary key column\n    const columns = this.db.prepare(`PRAGMA table_info(${tableName})`).all() as any[];\n    const pkColumn = columns.find(col =&gt; col.pk === 1);\n\n    if (!pkColumn) {\n      throw new Error(`No primary key found for table: ${tableName}`);\n    }\n\n    const query = `SELECT * FROM ${tableName} WHERE ${pkColumn.name} = ?`;\n    const row = this.db.prepare(query).get(recordId);\n\n    if (!row) {\n      throw new Error(`Record not found: ${tableName}.${pkColumn.name} = ${recordId}`);\n    }\n\n    return {\n      uri: `db://tables/${tableName}/records/${recordId}`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        table: tableName,\n        primaryKey: {\n          column: pkColumn.name,\n          value: recordId,\n        },\n        data: row,\n      }, null, 2),\n    };\n  }\n\n  private executeCustomQuery(queryString: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const url = new URL(`db://query?${queryString}`);\n    const sql = url.searchParams.get('sql');\n    const params = url.searchParams.get('params');\n\n    if (!sql) {\n      throw new Error('SQL parameter required for custom query');\n    }\n\n    // Security: Only allow SELECT queries\n    if (!sql.trim().toUpperCase().startsWith('SELECT')) {\n      throw new Error('Only SELECT queries are allowed for security');\n    }\n\n    let queryParams: any[] = [];\n    if (params) {\n      try {\n        queryParams = JSON.parse(params);\n      } catch {\n        throw new Error('Invalid params JSON');\n      }\n    }\n\n    const stmt = this.db.prepare(sql + ' LIMIT ?');\n    const rows = stmt.all(...queryParams, this.maxRows);\n\n    return {\n      uri: `db://query?sql=${encodeURIComponent(sql)}&amp;params=${encodeURIComponent(JSON.stringify(queryParams))}`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        query: sql,\n        parameters: queryParams,\n        resultCount: rows.length,\n        data: rows,\n      }, null, 2),\n    };\n  }\n\n  private getTableIndexes(tableName: string): any[] {\n    if (!this.db) return [];\n\n    try {\n      return this.db.prepare(`\n        SELECT name, sql \n        FROM sqlite_master \n        WHERE type='index' AND tbl_name=?\n      `).all(tableName) as any[];\n    } catch {\n      return [];\n    }\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      if (this.db) {\n        this.db.close();\n      }\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`Database Resource Server running (DB: ${this.dbPath})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new DatabaseResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>  Testing - First, create a test database:  <pre><code>sqlite3 test.db &lt;&lt; 'EOF'\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  email TEXT UNIQUE,\n  age INTEGER,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  price REAL,\n  category TEXT,\n  in_stock BOOLEAN DEFAULT 1\n);\n\nINSERT INTO users (name, email, age) VALUES \n  ('Alice Johnson', 'alice@example.com', 28),\n  ('Bob Smith', 'bob@example.com', 34);\n\nINSERT INTO products (name, price, category, in_stock) VALUES \n  ('Laptop', 999.99, 'Electronics', 1),\n  ('Book', 19.99, 'Education', 1);\n\n.quit\nEOF\n</code></pre>  Test the server:  <pre><code>// Database info\n{ uri: \"db://info\" }\n\n// Table schemas\n{ uri: \"db://tables/users/schema\" }\n{ uri: \"db://tables/products/schema\" }\n\n// Table data\n{ uri: \"db://tables/users/data?limit=10\" }\n{ uri: \"db://tables/products/data?limit=10\" }\n\n// Specific records\n{ uri: \"db://tables/users/records/1\" }\n{ uri: \"db://tables/products/records/2\" }\n\n// Custom query\n{ uri: \"db://query?sql=SELECT * FROM users WHERE age &gt; ?&amp;params=[25]\" }\n</code></pre>"},{"location":"Lab04-MCP-Resources/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Resources provide passive data access for LLMs</p> <p>\u2705 Tools perform active operations with side effects</p> <p>\u2705 URI schemes should be hierarchical and descriptive</p> <p>\u2705 Templates enable parameterized resource access</p> <p>\u2705 Subscriptions support real-time data updates</p> <p>\u2705 Security is critical for resource access control</p> <p>\u2705 Caching improves performance for static resources</p> <p>\u2705 Hybrid servers combine resources and tools effectively</p>"},{"location":"Lab04-MCP-Resources/#next-steps","title":"Next Steps","text":"<p>In Lab 5, you\u2019ll complete your MCP mastery by learning about Prompts:</p> <ul> <li>Creating reusable prompt templates</li> <li>Embedding resources in prompts</li> <li>Supporting prompt arguments</li> <li>Building complete, production-ready MCP servers</li> </ul> <p>Ready to add prompts to your MCP toolkit? Continue to Lab 5!</p>"},{"location":"Lab04-MCP-Resources/lab4-tasks/","title":"MCP Lab Tasks - Lab 4","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-41-static-text-resource","title":"Exercise 4.1: Static Text Resource","text":"<p>Create a simple text resource that returns static content.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://static/welcome\") {\n    return {\n      contents: [{\n        uri: \"mcp://static/welcome\",\n        mimeType: \"text/plain\",\n        text: \"Welcome to MCP Resources!\"\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-42-file-system-resource","title":"Exercise 4.2: File System Resource","text":"<p>Implement a resource that reads files from the file system.</p> Solution <pre><code>import { readFileSync } from \"fs\";\nimport { extname } from \"path\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"file://\")) {\n    const filePath = uri.replace(\"file://\", \"\");\n\n    try {\n      const content = readFileSync(filePath, \"utf-8\");\n      const mimeType = getMimeType(filePath);\n\n      return {\n        contents: [{\n          uri,\n          mimeType,\n          text: content\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n});\n\nfunction getMimeType(filePath: string): string {\n  const ext = extname(filePath).toLowerCase();\n  const mimeTypes: Record&lt;string, string&gt; = {\n    '.txt': 'text/plain',\n    '.json': 'application/json',\n    '.js': 'application/javascript',\n    '.ts': 'application/typescript',\n    '.md': 'text/markdown'\n  };\n  return mimeTypes[ext] || 'text/plain';\n}\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-43-dynamic-resource","title":"Exercise 4.3: Dynamic Resource","text":"<p>Create a resource that generates content dynamically.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://dynamic/time\")) {\n    const now = new Date();\n    const timeString = now.toISOString();\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify({\n          timestamp: timeString,\n          unix: Math.floor(now.getTime() / 1000)\n        })\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-44-database-resource","title":"Exercise 4.4: Database Resource","text":"<p>Implement a resource that queries a database.</p> Solution <pre><code>import sqlite3 from \"sqlite3\";\n\nconst db = new sqlite3.Database(':memory:');\n\n// Initialize database\ndb.serialize(() =&gt; {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')\");\n  db.run(\"INSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com')\");\n});\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://db/users\") {\n    return new Promise((resolve, reject) =&gt; {\n      db.all(\"SELECT * FROM users\", [], (err, rows) =&gt; {\n        if (err) {\n          reject(new Error(`Database error: ${err.message}`));\n        } else {\n          resolve({\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify(rows, null, 2)\n            }]\n          });\n        }\n      });\n    });\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-45-api-resource","title":"Exercise 4.5: API Resource","text":"<p>Create a resource that fetches data from an external API.</p> Solution <pre><code>import fetch from \"node-fetch\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://api/github/\")) {\n    const repo = uri.replace(\"mcp://api/github/\", \"\");\n\n    try {\n      const response = await fetch(`https://api.github.com/repos/${repo}`);\n      const data = await response.json();\n\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify({\n            name: data.name,\n            description: data.description,\n            stars: data.stargazers_count,\n            language: data.language\n          }, null, 2)\n        }]\n      };\n    } catch (error) {\n      throw new Error(`API request failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-46-configuration-resource","title":"Exercise 4.6: Configuration Resource","text":"<p>Implement a resource that provides configuration data.</p> Solution <pre><code>const config = {\n  app: {\n    name: \"MCP Server\",\n    version: \"1.0.0\",\n    environment: process.env.NODE_ENV || \"development\"\n  },\n  database: {\n    host: process.env.DB_HOST || \"localhost\",\n    port: parseInt(process.env.DB_PORT || \"5432\")\n  },\n  features: {\n    tools: true,\n    resources: true,\n    prompts: false\n  }\n};\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://config/app\") {\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(config, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-47-log-resource","title":"Exercise 4.7: Log Resource","text":"<p>Create a resource that provides access to application logs.</p> Solution <pre><code>import { readFileSync } from \"fs\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://logs/application\") {\n    try {\n      const logs = readFileSync(\"app.log\", \"utf-8\");\n      return {\n        contents: [{\n          uri,\n          mimeType: \"text/plain\",\n          text: logs\n        }]\n      };\n    } catch (error) {\n      // Return empty logs if file doesn't exist\n      return {\n        contents: [{\n          uri,\n          mimeType: \"text/plain\",\n          text: \"No logs available\"\n        }]\n      };\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-48-metrics-resource","title":"Exercise 4.8: Metrics Resource","text":"<p>Implement a resource that provides system metrics.</p> Solution <pre><code>import { cpus, freemem, totalmem } from \"os\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://metrics/system\") {\n    const metrics = {\n      cpu: {\n        cores: cpus().length,\n        model: cpus()[0].model\n      },\n      memory: {\n        free: freemem(),\n        total: totalmem(),\n        used: totalmem() - freemem(),\n        usagePercent: ((totalmem() - freemem()) / totalmem() * 100).toFixed(2)\n      },\n      uptime: process.uptime()\n    };\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(metrics, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-49-template-resource","title":"Exercise 4.9: Template Resource","text":"<p>Create a resource that renders templates with data.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://template/\")) {\n    const templateName = uri.replace(\"mcp://template/\", \"\");\n    const templates: Record&lt;string, string&gt; = {\n      welcome: \"Hello {{name}}! Welcome to {{app}}.\",\n      status: \"Service {{service}} is {{status}}.\"\n    };\n\n    const template = templates[templateName];\n    if (!template) {\n      throw new Error(`Template '${templateName}' not found`);\n    }\n\n    // Simple template rendering (in real app, use a proper template engine)\n    const rendered = template\n      .replace(\"{{name}}\", \"User\")\n      .replace(\"{{app}}\", \"MCP Server\")\n      .replace(\"{{service}}\", \"Database\")\n      .replace(\"{{status}}\", \"running\");\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"text/plain\",\n        text: rendered\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-410-cache-resource","title":"Exercise 4.10: Cache Resource","text":"<p>Implement a resource with caching capabilities.</p> Solution <pre><code>const cache = new Map&lt;string, { data: any; timestamp: number }&gt;();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://cache/random\") {\n    const cached = cache.get(uri);\n    const now = Date.now();\n\n    if (cached &amp;&amp; (now - cached.timestamp) &lt; CACHE_TTL) {\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify({ value: cached.data, cached: true }, null, 2)\n        }]\n      };\n    }\n\n    // Generate new random value\n    const randomValue = Math.random();\n    cache.set(uri, { data: randomValue, timestamp: now });\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify({ value: randomValue, cached: false }, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-411-directory-listing-resource","title":"Exercise 4.11: Directory Listing Resource","text":"<p>Create a resource that lists directory contents.</p> Solution <pre><code>import { readdirSync, statSync } from \"fs\";\nimport { join } from \"path\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://fs/dir/\")) {\n    const dirPath = uri.replace(\"mcp://fs/dir/\", \"/\");\n\n    try {\n      const items = readdirSync(dirPath).map(item =&gt; {\n        const fullPath = join(dirPath, item);\n        const stats = statSync(fullPath);\n\n        return {\n          name: item,\n          type: stats.isDirectory() ? \"directory\" : \"file\",\n          size: stats.size,\n          modified: stats.mtime.toISOString()\n        };\n      });\n\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify(items, null, 2)\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to list directory: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-412-environment-resource","title":"Exercise 4.12: Environment Resource","text":"<p>Implement a resource that provides environment information.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://env/variables\") {\n    const envVars = Object.keys(process.env)\n      .filter(key =&gt; !key.includes(\"SECRET\") &amp;&amp; !key.includes(\"PASSWORD\"))\n      .reduce((obj, key) =&gt; {\n        obj[key] = process.env[key];\n        return obj;\n      }, {} as Record&lt;string, string | undefined&gt;);\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(envVars, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-413-health-check-resource","title":"Exercise 4.13: Health Check Resource","text":"<p>Create a resource that provides health status.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://health/status\") {\n    const health = {\n      status: \"healthy\",\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      memory: process.memoryUsage(),\n      version: process.version\n    };\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(health, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-414-version-resource","title":"Exercise 4.14: Version Resource","text":"<p>Implement a resource that provides version information.</p> Solution <pre><code>const packageInfo = {\n  name: \"mcp-server\",\n  version: \"1.0.0\",\n  description: \"Model Context Protocol Server\",\n  dependencies: {\n    \"@modelcontextprotocol/sdk\": \"^0.4.0\"\n  }\n};\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://version/info\") {\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(packageInfo, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-415-documentation-resource","title":"Exercise 4.15: Documentation Resource","text":"<p>Create a resource that serves documentation.</p> Solution <pre><code>const documentation = {\n  title: \"MCP Server Documentation\",\n  version: \"1.0.0\",\n  endpoints: {\n    tools: \"/tools\",\n    resources: \"/resources\",\n    prompts: \"/prompts\"\n  },\n  examples: {\n    tool_call: {\n      method: \"tools/call\",\n      params: {\n        name: \"example_tool\",\n        arguments: { param: \"value\" }\n      }\n    }\n  }\n};\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://docs/api\") {\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(documentation, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/","title":"Lab 5: MCP Prompts and Integration","text":""},{"location":"Lab05-MCP-Prompts/#overview","title":"Overview","text":"<p>Congratulations on reaching the final lab!</p> <p>As you have already mastered tools and resources, now it\u2019s time to complete your MCP expertise with Prompts.</p> <p>Prompts are reusable templates that help users and LLMs perform common tasks consistently and effectively. They can embed resources, accept arguments, and create structured workflows that combine the best of human expertise with AI capabilities.</p> <p>In this lab, you\u2019ll learn how to create sophisticated prompt templates, integrate them with resources and tools, and build complete, production-ready MCP servers that showcase all three capabilities working together.</p>"},{"location":"Lab05-MCP-Prompts/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand the role of prompts in MCP ecosystems</li> <li>Create static and dynamic prompt templates</li> <li>Embed resources and arguments in prompts</li> <li>Implement prompt handlers with proper validation</li> <li>Build complete MCP servers combining all capabilities</li> <li>Apply production best practices for deployment</li> <li>Debug and troubleshoot complex MCP integrations</li> <li>Create reusable prompt libraries for common tasks</li> </ul>"},{"location":"Lab05-MCP-Prompts/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 4 - Implementing MCP Resources</li> <li>Understanding of prompt engineering concepts</li> <li>Familiarity with template systems and variable substitution</li> <li>Experience with complex application architecture</li> </ul>"},{"location":"Lab05-MCP-Prompts/#what-makes-prompts-special","title":"What Makes Prompts Special?","text":"<p>Prompts in MCP are more than just text templates - they\u2019re structured, reusable AI workflows that:</p> <ul> <li>Standardize common tasks across different users and contexts</li> <li>Combine expertise from domain specialists with AI capabilities</li> <li>Integrate resources to provide rich context automatically</li> <li>Accept parameters to customize behavior dynamically</li> <li>Create consistency in AI interactions and outputs</li> </ul>"},{"location":"Lab05-MCP-Prompts/#when-to-use-prompts-vs-tools","title":"When to Use Prompts vs. Tools","text":"Use Case Use Prompt Use Tool Why Code review \u2705 Prompt \u274c Tool Needs structured guidance and context Data analysis \u2705 Prompt \u274c Tool Requires analytical reasoning framework Content writing \u2705 Prompt \u274c Tool Benefits from style guides and examples API calls \u274c Prompt \u2705 Tool Direct action with predictable results Calculations \u274c Prompt \u2705 Tool Mathematical precision required Research synthesis \u2705 Prompt \u274c Tool Complex reasoning and integration needed"},{"location":"Lab05-MCP-Prompts/#prompt-architecture","title":"Prompt Architecture","text":"<pre><code>interface Prompt {\n  name: string;              // Unique identifier\n  description: string;       // What the prompt does\n  arguments?: Argument[];    // Optional parameters\n  messages: Message[];       // The actual prompt content\n}\n\ninterface Argument {\n  name: string;              // Parameter name\n  description: string;       // What it controls\n  required?: boolean;        // Is it mandatory?\n}\n\ninterface Message {\n  role: \"user\" | \"assistant\"; // Who says this\n  content: Content;          // The message content\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#project-setup","title":"Project Setup","text":""},{"location":"Lab05-MCP-Prompts/#step-1-create-your-project","title":"Step 1: Create Your Project","text":"<p>Let\u2019s start by creating a new MCP server project for prompts:</p> <pre><code>mkdir my-mcp-prompts-server  # &lt;-- next to the directory created in previous labs\ncd my-mcp-prompts-server\nnpm init -y\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<pre><code># Core MCP SDK\nnpm install @modelcontextprotocol/sdk\n\n# TypeScript and development tools\nnpm install -D typescript @types/node tsx\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#step-3-configure-typescript","title":"Step 3: Configure TypeScript","text":"<p>Create a <code>tsconfig.json</code> file with the following content inside the <code>my-mcp-prompts-server</code> directory you have just created:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#step-4-create-project-structure","title":"Step 4: Create Project Structure","text":"<pre><code>mkdir src     # &lt;-- inside \"my-mcp-prompts-server\" directory\ntouch src/index.ts   # and leave it empty for now\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#creating-your-first-prompt-server","title":"Creating Your First Prompt Server","text":""},{"location":"Lab05-MCP-Prompts/#step-1-basic-server-setup","title":"Step 1: Basic Server Setup","text":"<p>Let\u2019s create a basic MCP server that exposes prompts. Paste the following inside <code>src/index.ts</code>:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass PromptServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"mcp-prompts-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List available prompts\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"hello-prompt\",\n            description: \"A simple greeting prompt\",\n          },\n          {\n            name: \"code-review\",\n            description: \"Comprehensive code review with best practices\",\n            arguments: [\n              {\n                name: \"language\",\n                description: \"Programming language (e.g., typescript, python)\",\n                required: true,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    // Get specific prompt\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generatePrompt(name, args || {});\n    });\n  }\n\n  private generatePrompt(name: string, args: Record&lt;string, any&gt;): any {\n    switch (name) {\n      case \"hello-prompt\":\n        return {\n          description: \"A simple greeting prompt\",\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: \"Hello! Please introduce yourself and explain what you can help me with today.\",\n              },\n            },\n          ],\n        };\n\n      case \"code-review\":\n        const language = args.language || \"typescript\";\n        return {\n          description: `Code review for ${language}`,\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: `Please perform a comprehensive code review of the following ${language} code. Focus on:\n\n## Code Quality &amp; Best Practices\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify later?\n- **Performance**: Are there any obvious performance issues?\n- **Error Handling**: Are errors handled appropriately?\n\n## ${language.toUpperCase()}-Specific Checks\n- Follow ${language} conventions and best practices\n- Use appropriate design patterns\n- Ensure proper type safety (if applicable)\n\nPlease provide specific, actionable feedback with examples where possible.`,\n              },\n            },\n          ],\n        };\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Prompt Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new PromptServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#step-2-test-your-server","title":"Step 2: Test Your Server","text":"<p>Build and run the server:</p> <pre><code>npm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre> <p>The MCP Inspector will launch a web interface.</p> <p></p> <p>Test the prompts in the MCP Inspector UI:</p> <ol> <li> <p>List prompts: Click the \u201cPrompts\u201d tab, then click \u201cList Prompts\u201d to see your two prompts (\u201chello-prompt\u201d and \u201ccode-review\u201d).</p> </li> <li> <p>Get hello-prompt: In the same section, select \u201cGet Prompt\u201d, enter \u201chello-prompt\u201d as the name, and submit to see the greeting prompt content.</p> </li> <li> <p>Get code-review: Select \u201cGet Prompt\u201d, enter \u201ccode-review\u201d as the name, and optionally provide arguments like {\u201clanguage\u201d: \u201ctypescript\u201d} in the arguments field, then submit to see the code review prompt.</p> </li> </ol>"},{"location":"Lab05-MCP-Prompts/#step-3-adding-arguments-and-validation","title":"Step 3: Adding Arguments and Validation","text":"<p>Let\u2019s enhance our server with better argument handling. Update your existing <code>src/index.ts</code> file to add more arguments to the code-review prompt and include helper methods for dynamic content generation.</p> <p>Update the code-review prompt definition in the <code>ListPromptsRequestSchema</code> handler:</p> <pre><code>// Update the code-review prompt definition\n{\n  name: \"code-review\",\n  description: \"Comprehensive code review with best practices\",\n  arguments: [\n    {\n      name: \"language\",\n      description: \"Programming language (e.g., typescript, python, java)\",\n      required: true,\n    },\n    {\n      name: \"complexity\",\n      description: \"Code complexity level (beginner, intermediate, advanced)\",\n      required: false,\n    },\n    {\n      name: \"focus\",\n      description: \"Review focus areas (comma-separated: quality,security,performance)\",\n      required: false,\n    },\n  ],\n}\n</code></pre> <p></p> <p>Update the prompt generation:</p> <pre><code>case \"code-review\":\n  const language = args.language || \"typescript\";\n  const complexity = args.complexity || \"intermediate\";\n  const focus = args.focus || \"quality\";\n\n  return {\n    description: `Code review for ${language} (${complexity} level, focus: ${focus})`,\n    messages: [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Please perform a comprehensive code review of the following ${language} code.\n\n**Complexity Level:** ${complexity}\n**Focus Areas:** ${focus}\n\n## Review Guidelines\n\n### Code Quality &amp; Best Practices\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify later?\n- **Performance**: Are there any obvious performance issues?\n\n### ${complexity.charAt(0).toUpperCase() + complexity.slice(1)} Level Expectations\n${this.getComplexityExpectations(complexity)}\n\n### Focus Area: ${focus.toUpperCase()}\n${this.getFocusAreaGuidance(focus)}\n\nPlease provide specific, actionable feedback with examples where possible.`,\n        },\n      },\n    ],\n  };\n</code></pre> <p></p> <p>Add helper methods:</p> <pre><code>private getComplexityExpectations(level: string): string {\n  const expectations: { [key: string]: string } = {\n    beginner: `- Clear, self-documenting code\\n- Basic error handling\\n- Simple, understandable logic`,\n    intermediate: `- Good separation of concerns\\n- Comprehensive error handling\\n- Appropriate design patterns\\n- Unit test coverage`,\n    advanced: `- High performance and scalability\\n- Complex architectural patterns\\n- Extensive testing (unit, integration, e2e)\\n- Advanced optimization techniques`,\n  };\n  return expectations[level] || \"- Standard coding practices\";\n}\n\nprivate getFocusAreaGuidance(focus: string): string {\n  const guidance: { [key: string]: string } = {\n    quality: `**Code Quality Focus:**\n- Code readability and maintainability\n- Consistent naming conventions\n- Proper code organization\n- Documentation quality`,\n    security: `**Security Focus:**\n- Input validation and sanitization\n- Authentication and authorization\n- Data protection practices\n- Common vulnerability patterns`,\n    performance: `**Performance Focus:**\n- Algorithm efficiency\n- Memory usage optimization\n- Database query optimization\n- Caching strategies`,\n  };\n  return guidance[focus] || \"- General best practices\";\n}\n</code></pre> <p></p> <p>Here\u2019s the complete updated <code>src/index.ts</code> with all the above enhancements, just for review purposes:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass PromptServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"mcp-prompts-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List available prompts\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"hello-prompt\",\n            description: \"A simple greeting prompt\",\n          },\n          {\n            name: \"code-review\",\n            description: \"Comprehensive code review with best practices\",\n            arguments: [\n              {\n                name: \"language\",\n                description: \"Programming language (e.g., typescript, python, java)\",\n                required: true,\n              },\n              {\n                name: \"complexity\",\n                description: \"Code complexity level (beginner, intermediate, advanced)\",\n                required: false,\n              },\n              {\n                name: \"focus\",\n                description: \"Review focus areas (comma-separated: quality,security,performance)\",\n                required: false,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    // Get specific prompt\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generatePrompt(name, args || {});\n    });\n  }\n\n  private generatePrompt(name: string, args: Record&lt;string, any&gt;): any {\n    switch (name) {\n      case \"hello-prompt\":\n        return {\n          description: \"A simple greeting prompt\",\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: \"Hello! Please introduce yourself and explain what you can help me with today.\",\n              },\n            },\n          ],\n        };\n\n      case \"code-review\":\n        const language = args.language || \"typescript\";\n        const complexity = args.complexity || \"intermediate\";\n        const focus = args.focus || \"quality\";\n\n        return {\n          description: `Code review for ${language} (${complexity} level, focus: ${focus})`,\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: `Please perform a comprehensive code review of the following ${language} code.\n\n**Complexity Level:** ${complexity}\n**Focus Areas:** ${focus}\n\n## Review Guidelines\n\n### Code Quality &amp; Best Practices\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify later?\n- **Performance**: Are there any obvious performance issues?\n\n### ${complexity.charAt(0).toUpperCase() + complexity.slice(1)} Level Expectations\n${this.getComplexityExpectations(complexity)}\n\n### Focus Area: ${focus.toUpperCase()}\n${this.getFocusAreaGuidance(focus)}\n\nPlease provide specific, actionable feedback with examples where possible.`,\n              },\n            },\n          ],\n        };\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private getComplexityExpectations(level: string): string {\n    const expectations: { [key: string]: string } = {\n      beginner: `- Clear, self-documenting code\\n- Basic error handling\\n- Simple, understandable logic`,\n      intermediate: `- Good separation of concerns\\n- Comprehensive error handling\\n- Appropriate design patterns\\n- Unit test coverage`,\n      advanced: `- High performance and scalability\\n- Complex architectural patterns\\n- Extensive testing (unit, integration, e2e)\\n- Advanced optimization techniques`,\n    };\n    return expectations[level] || \"- Standard coding practices\";\n  }\n\n  private getFocusAreaGuidance(focus: string): string {\n    const guidance: { [key: string]: string } = {\n      quality: `**Code Quality Focus:**\n- Code readability and maintainability\n- Consistent naming conventions\n- Proper code organization\n- Documentation quality`,\n      security: `**Security Focus:**\n- Input validation and sanitization\n- Authentication and authorization\n- Data protection practices\n- Common vulnerability patterns`,\n      performance: `**Performance Focus:**\n- Algorithm efficiency\n- Memory usage optimization\n- Database query optimization\n- Caching strategies`,\n    };\n    return guidance[focus] || \"- General best practices\";\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Prompt Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new PromptServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre> <p></p>"},{"location":"Lab05-MCP-Prompts/#test-enhanced-prompts","title":"Test Enhanced Prompts","text":"<p>Test with different arguments:</p> <ol> <li> <p>Basic code review (with default values):    <pre><code>{ name: \"code-review\", arguments: { language: \"typescript\" } }\n</code></pre>    Expected: Returns a prompt with intermediate complexity and quality focus.</p> </li> <li> <p>Advanced code review with focus:    <pre><code>{\n  name: \"code-review\",\n  arguments: {\n    language: \"python\",\n    complexity: \"advanced\",\n    focus: \"security\"\n  }\n}\n</code></pre>    Expected: Returns a prompt with advanced complexity expectations and security focus guidance.</p> </li> </ol> <p>How to test in MCP Inspector:</p> <ol> <li> <p>Start the server: <pre><code>cd my-mcp-prompts-server\nnpm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre></p> </li> <li> <p>Inside MCP Inspector UI, navigate to Prompts:</p> <ul> <li>Click on the \u201cPrompts\u201d tab in the Inspector interface</li> </ul> </li> <li> <p>Test List Prompts:</p> <ul> <li>Click \u201cList Prompts\u201d button</li> <li>Verify you see \u201chello-prompt\u201d and \u201ccode-review\u201d with the updated arguments</li> </ul> </li> <li> <p>Test Get Prompt - Basic:</p> <ul> <li>Select \u201cGet Prompt\u201d from the dropdown or click the button</li> <li>Enter <code>code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"language\": \"typescript\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes intermediate complexity and quality focus</li> </ul> </li> <li> <p>Test Get Prompt - Advanced:</p> <ul> <li>Select \u201cGet Prompt\u201d again</li> <li>Enter <code>code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter:     <pre><code>{\n  \"language\": \"python\",\n  \"complexity\": \"advanced\",\n  \"focus\": \"security\"\n}\n</code></pre></li> <li>Click \u201cSend Request\u201d</li> <li>Verify the prompt content includes advanced expectations and security guidance</li> </ul> </li> <li> <p>Test without arguments:</p> <ul> <li>Try <code>code-review</code> with no arguments</li> <li>Should use defaults: typescript, intermediate, quality</li> </ul> </li> </ol> <p>Expected Results:</p> <ul> <li>The prompt description should reflect the arguments (e.g., \u201cCode review for python (advanced level, focus: security)\u201d)</li> <li>The prompt content should include the appropriate complexity expectations and focus area guidance</li> <li>Helper methods should dynamically insert the correct text based on arguments</li> </ul>"},{"location":"Lab05-MCP-Prompts/#integrating-resources-with-prompts","title":"Integrating Resources with Prompts","text":"<p>Prompts become more powerful when integrated with resources! </p> <p>This allows prompts to dynamically include contextual information from your knowledge base, documentation, or data sources, creating richer and more informed AI interactions.</p>"},{"location":"Lab05-MCP-Prompts/#step-1-add-resource-support","title":"Step 1: Add Resource Support","text":"<p>Create a new project for the resource-prompt server:</p> <pre><code># Create new directory next to your previous server\nmkdir my-resource-prompt-server  # &lt;-- next to the directory created previously\ncd my-resource-prompt-server\n\n# Initialize and install dependencies\nnpm init -y\nnpm install @modelcontextprotocol/sdk\nnpm install -D typescript @types/node tsx\n\n# Create TypeScript config (same as before)\ncat &gt; tsconfig.json &lt;&lt; 'EOF'\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\nEOF\n\n# Create directory structure\nmkdir src # &lt;-- inside \"my-resource-prompt-server\" directory\n</code></pre> <p></p> <p>Now create the server file <code>src/index.ts</code> with the following content that combines prompts with resources:</p> <pre><code>import {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass ResourcePromptServer {\n  private server: Server;\n  private knowledgeBase: Map&lt;string, any&gt; = new Map();\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"resource-prompt-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n          resources: {},\n        },\n      }\n    );\n\n    this.initializeKnowledgeBase();\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private initializeKnowledgeBase(): void {\n    this.knowledgeBase.set(\"best-practices\", {\n      title: \"Development Best Practices\",\n      content: `\n## Code Quality\n- Write self-documenting code\n- Use meaningful variable names\n- Keep functions small and focused\n\n## Testing\n- Write unit tests for all functions\n- Include integration tests\n- Test edge cases and error conditions\n      `,\n    });\n\n    this.knowledgeBase.set(\"security-guidelines\", {\n      title: \"Security Guidelines\",\n      content: `\n## Input Validation\n- Validate all user inputs\n- Use parameterized queries\n- Sanitize HTML content\n\n## Authentication\n- Use strong password policies\n- Implement multi-factor authentication\n      `,\n    });\n  }\n\n  private setupHandlers(): void {\n    // Resource handlers\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = Array.from(this.knowledgeBase.entries()).map(([key, doc]) =&gt; ({\n        uri: `kb://articles/${key}`,\n        name: doc.title,\n        description: `Knowledge base: ${doc.title}`,\n        mimeType: \"text/markdown\",\n      }));\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = this.readKnowledgeBase(uri);\n      return { contents: [content] };\n    });\n\n    // Prompt handlers\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"contextual-code-review\",\n            description: \"Code review with integrated best practices\",\n            arguments: [\n              {\n                name: \"language\",\n                description: \"Programming language\",\n                required: true,\n              },\n              {\n                name: \"focusAreas\",\n                description: \"Focus areas (comma-separated)\",\n                required: false,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generatePrompt(name, args || {});\n    });\n  }\n\n  private readKnowledgeBase(uri: string): any {\n    const match = uri.match(/^kb:\\/\\/articles\\/(.+)$/);\n    if (!match) throw new Error(`Invalid knowledge base URI: ${uri}`);\n\n    const key = match[1];\n    const article = this.knowledgeBase.get(key);\n\n    if (!article) throw new Error(`Article not found: ${key}`);\n\n    return {\n      uri,\n      mimeType: \"text/markdown\",\n      text: article.content,\n    };\n  }\n\n  private generatePrompt(name: string, args: Record&lt;string, any&gt;): any {\n    switch (name) {\n      case \"contextual-code-review\":\n        return this.createContextualCodeReviewPrompt(args);\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private createContextualCodeReviewPrompt(args: Record&lt;string, any&gt;): any {\n    const language = args.language || \"typescript\";\n    const focusAreas = args.focusAreas ? args.focusAreas.split(',').map((s: string) =&gt; s.trim()) : [\"quality\"];\n\n    // Fetch relevant knowledge base articles\n    let contextContent = \"\";\n\n    if (focusAreas.includes(\"quality\")) {\n      const bestPractices = this.knowledgeBase.get(\"best-practices\");\n      if (bestPractices) {\n        contextContent += `\\n## Development Best Practices\\n${bestPractices.content}`;\n      }\n    }\n\n    if (focusAreas.includes(\"security\")) {\n      const securityGuidelines = this.knowledgeBase.get(\"security-guidelines\");\n      if (securityGuidelines) {\n        contextContent += `\\n## Security Guidelines\\n${securityGuidelines.content}`;\n      }\n    }\n\n    return {\n      description: `Contextual code review for ${language} with focus on: ${focusAreas.join(', ')}`,\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Please perform a comprehensive code review of the following ${language} code. Use the integrated knowledge base context to provide informed recommendations.\n\n## Review Context\n${contextContent}\n\n## Code to Review\n[Insert code here]\n\n## Review Focus Areas\n${focusAreas.map(area =&gt; `- **${area.charAt(0).toUpperCase() + area.slice(1)}**: Apply relevant guidelines from the context above`).join('\\n')}\n\n## Review Structure\n1. **Summary**: Overall assessment and key findings\n2. **Strengths**: What the code does well\n3. **Areas for Improvement**: Specific recommendations with context references\n4. **Action Items**: Prioritized list of recommended changes\n\nPlease reference specific guidelines from the provided context and explain how they apply to this code.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Resource-Prompt Server running on stdio\");\n  }\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#step-2-test-resource-integration","title":"Step 2: Test Resource Integration","text":"<p>Build and run the resource-prompt server:</p> <pre><code>cd my-resource-prompt-server\nnpm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre> <p>Test the enhanced server inside the MCP Inspector UI:</p> <ol> <li> <p>Navigate to Resources tab:</p> <ul> <li>Click on the \u201cResources\u201d tab</li> </ul> </li> <li> <p>List resources:</p> <ul> <li>Click \u201cList Resources\u201d button</li> <li>Verify you see the knowledge base articles (\u201cDevelopment Best Practices\u201d and \u201cSecurity Guidelines\u201d)</li> </ul> </li> <li> <p>Read a resource:</p> <ul> <li>Select \u201cRead Resource\u201d from the dropdown</li> <li>Enter <code>kb://articles/best-practices</code> in the \u201cURI\u201d field</li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes the full content of the best practices article</li> </ul> </li> <li> <p>Read another resource:</p> <ul> <li>Select \u201cRead Resource\u201d again</li> <li>Enter <code>kb://articles/security-guidelines</code> in the \u201cURI\u201d field</li> <li>Click \u201cSend Request\u201d</li> <li>Verify the security guidelines content is returned</li> </ul> </li> <li> <p>Navigate to Prompts tab:</p> <ul> <li>Click on the \u201cPrompts\u201d tab</li> </ul> </li> <li> <p>List prompts:</p> <ul> <li>Click \u201cList Prompts\u201d button</li> <li>Verify you see the \u201ccontextual-code-review\u201d prompt with its arguments</li> </ul> </li> <li> <p>Get contextual prompt - Basic:</p> <ul> <li>Select \u201cGet Prompt\u201d</li> <li>Enter <code>contextual-code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"language\": \"typescript\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the prompt content includes the best practices from the knowledge base</li> </ul> </li> <li> <p>Get contextual prompt - With focus areas:</p> <ul> <li>Select \u201cGet Prompt\u201d again</li> <li>Enter <code>contextual-code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter:     <pre><code>{\n  \"language\": \"python\",\n  \"focusAreas\": \"quality,security\"\n}\n</code></pre></li> <li>Click \u201cSend Request\u201d</li> <li>Verify the prompt includes both best practices and security guidelines from the knowledge base</li> </ul> </li> </ol> <p></p> <p>Expected Results:</p> <ul> <li>Resources should list the knowledge base articles with proper URIs and descriptions</li> <li>Reading resources should return the full markdown content of each article</li> <li>Prompts should dynamically include relevant knowledge base content based on the focus areas argument</li> <li>The contextual prompt should reference specific guidelines from the integrated resources</li> </ul>"},{"location":"Lab05-MCP-Prompts/#complete-mcp-server-integration","title":"Complete MCP Server Integration","text":"<p>Complete MCP server integration combines all three core capabilities - tools, resources, and prompts - into a single server that can perform complex operations and provide rich, contextual AI interactions.</p>"},{"location":"Lab05-MCP-Prompts/#step-1-combine-all-capabilities","title":"Step 1: Combine All Capabilities","text":"<p>Create a new project for the complete MCP server:</p> <pre><code># Create new directory next to your previous servers\nmkdir my-complete-mcp-server\ncd my-complete-mcp-server\n\n# Initialize and install dependencies\nnpm init -y\nnpm install @modelcontextprotocol/sdk\nnpm install -D typescript @types/node tsx\n\n# Create TypeScript config (same as before)\ncat &gt; tsconfig.json &lt;&lt; 'EOF'\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\nEOF\n\n# Create directory structure\nmkdir src\n</code></pre> <p></p> <p>Now create the server file <code>src/index.ts</code>, that combines tools, resources, and prompts, with the following content:</p> <pre><code>import {\n  ListToolsRequestSchema,\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass CompleteMCPServer {\n  private server: Server;\n  private knowledgeBase: Map&lt;string, any&gt; = new Map();\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"complete-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    this.initializeKnowledgeBase();\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private initializeKnowledgeBase(): void {\n    this.knowledgeBase.set(\"development-workflow\", {\n      title: \"Complete Development Workflow\",\n      content: `\n## Development Process\n1. Requirements gathering and analysis\n2. System design and architecture\n3. Implementation with best practices\n4. Code review and quality assurance\n5. Testing and validation\n6. Deployment and monitoring\n7. Maintenance and updates\n      `,\n    });\n  }\n\n  private setupHandlers(): void {\n    // Tool handlers\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"analyze_codebase\",\n            description: \"Analyze codebase structure and provide insights\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                path: { type: \"string\", description: \"Path to analyze\" },\n                analysisType: {\n                  type: \"string\",\n                  enum: [\"structure\", \"complexity\", \"dependencies\"],\n                  default: \"structure\"\n                },\n              },\n              required: [\"path\"],\n            },\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"analyze_codebase\":\n          return this.analyzeCodebase(args);\n\n        default:\n          throw new Error(`Unknown tool: ${name}`);\n      }\n    });\n\n    // Resource handlers\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = [\n        ...Array.from(this.knowledgeBase.entries()).map(([key, doc]) =&gt; ({\n          uri: `kb://articles/${key}`,\n          name: doc.title,\n          description: `Knowledge: ${doc.title}`,\n          mimeType: \"text/markdown\",\n        })),\n      ];\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readResource(uri);\n      return { contents: [content] };\n    });\n\n    // Prompt handlers\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"full-development-workflow\",\n            description: \"Complete development workflow with integrated resources\",\n            arguments: [\n              {\n                name: \"projectType\",\n                description: \"Type of project (web, api, mobile)\",\n                required: true,\n              },\n            ],\n          },\n          {\n            name: \"code-quality-assessment\",\n            description: \"Comprehensive code quality assessment using all capabilities\",\n            arguments: [\n              {\n                name: \"codeSample\",\n                description: \"Code to assess\",\n                required: true,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generateIntegratedPrompt(name, args || {});\n    });\n  }\n\n  private async analyzeCodebase(args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    const targetPath = args.path || \"./\";\n    const analysisType = args.analysisType || \"structure\";\n\n    try {\n      const analysis = await this.performCodeAnalysis(targetPath, analysisType);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `## Codebase Analysis: ${analysisType.toUpperCase()}\\n\\n${analysis}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Codebase analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private async performCodeAnalysis(targetPath: string, analysisType: string): Promise&lt;string&gt; {\n    // Simplified analysis - in real implementation, use proper code analysis tools\n    return `### Analysis Results\n- **Path**: ${targetPath}\n- **Type**: ${analysisType}\n- **Status**: Analysis completed successfully\n\n### Recommendations\n- Consider organizing files by feature\n- Add proper documentation\n- Implement consistent coding standards`;\n  }\n\n  private async readResource(uri: string): Promise&lt;any&gt; {\n    if (uri.startsWith('kb://')) {\n      return this.readKnowledgeBase(uri);\n    }\n\n    throw new Error(`Unknown resource URI: ${uri}`);\n  }\n\n  private readKnowledgeBase(uri: string): any {\n    const match = uri.match(/^kb:\\/\\/articles\\/(.+)$/);\n    if (!match) throw new Error(`Invalid knowledge base URI: ${uri}`);\n\n    const key = match[1];\n    const article = this.knowledgeBase.get(key);\n\n    if (!article) throw new Error(`Article not found: ${key}`);\n\n    return {\n      uri,\n      mimeType: \"text/markdown\",\n      text: article.content,\n    };\n  }\n\n  private async generateIntegratedPrompt(name: string, args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    switch (name) {\n      case \"full-development-workflow\":\n        return this.createFullWorkflowPrompt(args);\n\n      case \"code-quality-assessment\":\n        return this.createQualityAssessmentPrompt(args);\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private async createFullWorkflowPrompt(args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    const projectType = args.projectType || \"web\";\n\n    const workflowDoc = this.knowledgeBase.get(\"development-workflow\");\n\n    return {\n      description: `Complete ${projectType} development workflow`,\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Guide me through a complete ${projectType} development project.\n\n## Development Workflow Reference\n${workflowDoc ? workflowDoc.content : \"Standard development practices apply\"}\n\n## Project Context\n- **Type**: ${projectType}\n- **Current Phase**: Planning\n\nPlease provide a comprehensive development plan with specific phases, deliverables, and best practices.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async createQualityAssessmentPrompt(args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    const codeSample = args.codeSample || \"[Insert code here]\";\n\n    // Use tools to analyze the code\n    const analysisResult = await this.analyzeCodebase({ path: \"./\", analysisType: \"structure\" });\n\n    return {\n      description: \"Comprehensive code quality assessment\",\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Perform a comprehensive code quality assessment of the following code.\n\n## Code to Assess\n\\`\\`\\`\n${codeSample}\n\\`\\`\\`\n\n## Automated Analysis Results\n${analysisResult.content[0].text}\n\n## Assessment Framework\n\n### 1. Code Quality Metrics\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify?\n- **Performance**: Are there any obvious issues?\n\n### 2. Best Practices\n- Does it follow coding standards?\n- Are there appropriate error handling?\n- Is the code well-structured?\n\n### 3. Recommendations\nProvide specific, prioritized recommendations for improvement.\n\nPlease provide a thorough assessment.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Complete MCP Server running on stdio\");\n  }\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/#step-2-test-complete-integration","title":"Step 2: Test Complete Integration","text":"<p>Build and run the complete MCP server:</p> <pre><code>cd my-complete-mcp-server\nnpm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre> <p>Test the complete integration inside the MCP Inspector UI:</p> <ol> <li> <p>Navigate to Tools tab:</p> <ul> <li>Click on the \u201cTools\u201d tab</li> </ul> </li> <li> <p>List tools:</p> <ul> <li>Click \u201cList Tools\u201d button</li> <li>Verify you see the \u201canalyze_codebase\u201d tool with its description and input schema</li> </ul> </li> <li> <p>Call tool:</p> <ul> <li>Select \u201cCall Tool\u201d from the dropdown</li> <li>Enter <code>analyze_codebase</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"path\": \"./\", \"analysisType\": \"structure\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes a codebase analysis with recommendations</li> </ul> </li> <li> <p>Navigate to Resources tab:</p> <ul> <li>Click on the \u201cResources\u201d tab</li> </ul> </li> <li> <p>List resources:</p> <ul> <li>Click \u201cList Resources\u201d button</li> <li>Verify you see the knowledge base article (\u201cComplete Development Workflow\u201d)</li> </ul> </li> <li> <p>Read resource:</p> <ul> <li>Select \u201cRead Resource\u201d from the dropdown</li> <li>Enter <code>kb://articles/development-workflow</code> in the \u201cURI\u201d field</li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes the full development workflow content</li> </ul> </li> <li> <p>Navigate to Prompts tab:</p> <ul> <li>Click on the \u201cPrompts\u201d tab</li> </ul> </li> <li> <p>List prompts:</p> <ul> <li>Click \u201cList Prompts\u201d button</li> <li>Verify you see the \u201cfull-development-workflow\u201d and \u201ccode-quality-assessment\u201d prompts with their arguments</li> </ul> </li> <li> <p>Get full development workflow prompt:</p> <ul> <li>Select \u201cGet Prompt\u201d</li> <li>Enter <code>full-development-workflow</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"projectType\": \"web\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the prompt content includes the development workflow from the knowledge base</li> </ul> </li> <li> <p>Get code quality assessment prompt:</p> <ul> <li>Select \u201cGet Prompt\u201d again</li> <li>Enter <code>code-quality-assessment</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"codeSample\": \"function test() { return true; }\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Verify the prompt includes automated analysis results and assessment framework</li> </ul> </li> </ol> <p></p> <p>Expected Results:</p> <ul> <li>Tools should list the analysis tool with proper schema and description</li> <li>Calling tools should return structured analysis results</li> <li>Resources should list knowledge base articles with proper URIs</li> <li>Reading resources should return the full markdown content</li> <li>Prompts should list integrated prompts with their arguments</li> <li>Getting prompts should dynamically include tool results and resource content</li> <li>The complete integration should demonstrate all three capabilities working together seamlessly</li> </ul>"},{"location":"Lab05-MCP-Prompts/#hands-on-exercises","title":"Hands-On Exercises","text":""},{"location":"Lab05-MCP-Prompts/#exercise-1-custom-prompt-library","title":"Exercise 1: Custom Prompt Library","text":"<p>Goal: Create a specialized prompt library for a specific domain.</p> <p>Steps:</p> <ol> <li>Choose a domain (e.g., data science, DevOps, content writing)</li> <li>Create 3-5 domain-specific prompts</li> <li>Add appropriate arguments for customization</li> <li>Include domain-specific resources</li> <li>Test with the MCP Inspector</li> </ol> <p>Requirements:</p> <ul> <li>At least one prompt with required arguments</li> <li>At least one prompt with optional arguments</li> <li>Include resource integration</li> <li>Proper error handling</li> </ul> Solution  Choose data science domain.  Create 3 domain-specific prompts: data-exploration, model-training, visualization.  Add arguments: dataset (required), focus (optional).  Include domain-specific resources: data science best practices.  Example code structure: <pre><code>// In ListPromptsRequestSchema handler\n{\n  name: \"data-exploration\",\n  description: \"Guide for exploratory data analysis\",\n  arguments: [\n    {\n      name: \"dataset\",\n      description: \"Dataset description\",\n      required: true,\n    },\n    {\n      name: \"focus\",\n      description: \"Analysis focus (distribution, correlation, outliers)\",\n      required: false,\n    },\n  ],\n},\n{\n  name: \"model-training\",\n  description: \"Guide for machine learning model training\",\n  arguments: [\n    {\n      name: \"algorithm\",\n      description: \"ML algorithm (linear, tree, neural)\",\n      required: true,\n    },\n    {\n      name: \"target\",\n      description: \"Target variable\",\n      required: false,\n    },\n  ],\n},\n{\n  name: \"data-visualization\",\n  description: \"Guide for creating effective data visualizations\",\n  arguments: [\n    {\n      name: \"chartType\",\n      description: \"Type of chart (bar, line, scatter)\",\n      required: true,\n    },\n  ],\n}\n\n// In generatePrompt method\ncase \"data-exploration\":\n  const dataset = args.dataset || \"dataset\";\n  const focus = args.focus || \"distribution\";\n  return {\n    description: `Data exploration for ${dataset} focusing on ${focus}`,\n    messages: [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Perform exploratory data analysis on the ${dataset} dataset.\n\nFocus areas: ${focus}\n\nGuidelines:\n- Examine data structure and types\n- Check for missing values and outliers\n- Analyze distributions and correlations\n- Generate summary statistics\n\nProvide insights and recommendations.`,\n        },\n      },\n    ],\n  };\n\n// Add resources in initializeKnowledgeBase\nthis.knowledgeBase.set(\"data-science-practices\", {\n  title: \"Data Science Best Practices\",\n  content: `\nData Quality\n- Validate data integrity\n- Handle missing values appropriately\n- Check for data consistency\n\nAnalysis Process\n- Start with descriptive statistics\n- Use visualizations for insights\n- Test hypotheses systematically\n  `,\n});\n</code></pre>  Test with MCP Inspector by listing prompts, getting prompts with different arguments, and verifying resource integration."},{"location":"Lab05-MCP-Prompts/#exercise-2-multi-step-workflow-prompt","title":"Exercise 2: Multi-Step Workflow Prompt","text":"<p>Goal: Create a prompt that guides users through complex, multi-step processes.</p> <p>Steps:</p> <ol> <li>Design a multi-step workflow (e.g., code review \u2192 testing \u2192 deployment)</li> <li>Create prompts for each step</li> <li>Add logic to chain prompts together</li> <li>Include progress tracking</li> <li>Test the complete workflow</li> </ol> <p>Requirements:</p> <ul> <li>Clear step progression</li> <li>State management between steps</li> <li>Error handling and recovery</li> <li>Progress indicators</li> </ul> Solution  Design a code review to deployment workflow with steps: review, testing, deployment.  Create prompts for each step with currentStep argument.  Add logic to chain prompts and track progress.  Example code structure:  <pre><code>// In ListPromptsRequestSchema handler\n{\n  name: \"workflow-step\",\n  description: \"Multi-step development workflow guidance\",\n  arguments: [\n    {\n      name: \"currentStep\",\n      description: \"Current workflow step (review, testing, deployment)\",\n      required: true,\n    },\n    {\n      name: \"projectType\",\n      description: \"Type of project\",\n      required: false,\n    },\n  ],\n}\n\n// In generatePrompt method\ncase \"workflow-step\":\n  const step = args.currentStep || \"review\";\n  const projectType = args.projectType || \"web\";\n  const workflowSteps = [\"review\", \"testing\", \"deployment\"];\n  const currentIndex = workflowSteps.indexOf(step);\n\n  return {\n    description: `${projectType} development workflow - Step ${currentIndex + 1}: ${step}`,\n    messages: [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Guide for ${projectType} project ${step} phase.\n\nProgress: Step ${currentIndex + 1} of ${workflowSteps.length}\nPrevious steps: ${workflowSteps.slice(0, currentIndex).join(', ') || 'None'}\nNext steps: ${workflowSteps.slice(currentIndex + 1).join(', ') || 'Complete'}\n\n${this.getStepGuidance(step, projectType)}\n\nProvide detailed guidance and check completion criteria before proceeding.`,\n        },\n      },\n    ],\n  };\n\n// Helper method\nprivate getStepGuidance(step: string, projectType: string): string {\n  const guidance: { [key: string]: { [key: string]: string } } = {\n    review: {\n      web: \"Code Review Guidelines:\\n- Check code quality and standards\\n- Verify security practices\\n- Review performance considerations\\n- Validate functionality\",\n      api: \"API Review Guidelines:\\n- Check endpoint design\\n- Validate error handling\\n- Review authentication\\n- Test API contracts\",\n    },\n    testing: {\n      web: \"Testing Guidelines:\\n- Unit test coverage\\n- Integration testing\\n- User acceptance testing\\n- Performance testing\",\n      api: \"API Testing Guidelines:\\n- Endpoint testing\\n- Load testing\\n- Security testing\\n- Contract testing\",\n    },\n    deployment: {\n      web: \"Deployment Guidelines:\\n- Environment configuration\\n- Database migrations\\n- Rollback procedures\\n- Monitoring setup\",\n      api: \"API Deployment Guidelines:\\n- API gateway configuration\\n- Version management\\n- Documentation publishing\\n- Client notifications\",\n    },\n  };\n  return guidance[step]?.[projectType] || \"Follow standard practices for this step.\";\n}\n</code></pre>  Test the workflow by calling the prompt with different currentStep values and verifying step progression and guidance."},{"location":"Lab05-MCP-Prompts/#exercise-3-production-ready-server","title":"Exercise 3: Production-Ready Server","text":"<p>Goal: Create a production-ready MCP server with all capabilities.</p> <p>Steps:</p> <ol> <li>Implement comprehensive error handling</li> <li>Add logging and monitoring</li> <li>Include health checks</li> <li>Add configuration management</li> <li>Implement rate limiting</li> <li>Create deployment scripts</li> </ol> <p>Requirements:</p> <ul> <li>Structured logging</li> <li>Health check endpoints</li> <li>Configuration validation</li> <li>Graceful shutdown</li> <li>Performance monitoring</li> </ul> Solution  Implement comprehensive error handling, logging, health checks, configuration management, rate limiting, and deployment scripts.  Example code structure:  <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nclass ProductionMCPServer {\n  private server: Server;\n  private config: any;\n  private requestCount = 0;\n  private startTime = Date.now();\n\n  constructor(configPath?: string) {\n    this.config = this.loadConfiguration(configPath);\n    this.server = new Server(\n      {\n        name: this.config.name,\n        version: this.config.version,\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupLogging();\n    this.setupHandlers();\n    this.setupErrorHandling();\n    this.setupHealthChecks();\n  }\n\n  private loadConfiguration(configPath?: string): any {\n    // Load from file or environment\n    return {\n      name: \"production-mcp-server\",\n      version: \"1.0.0\",\n      port: process.env.PORT || 3000,\n      logLevel: process.env.LOG_LEVEL || \"info\",\n      rateLimit: parseInt(process.env.RATE_LIMIT || \"100\"),\n    };\n  }\n\n  private setupLogging(): void {\n    // Use a proper logging library in production\n    console.log = this.createLogger(\"info\");\n    console.error = this.createLogger(\"error\");\n  }\n\n  private createLogger(level: string): (...args: any[]) =&gt; void {\n    return (...args: any[]) =&gt; {\n      const timestamp = new Date().toISOString();\n      process.stderr.write(`[${timestamp}] ${level.toUpperCase()}: ${args.join(' ')}\\n`);\n    };\n  }\n\n  private setupHandlers(): void {\n    // Add rate limiting to handlers\n    this.server.setRequestHandler(ListToolsRequestSchema, this.rateLimitedHandler(async () =&gt; {\n      return { tools: [] };\n    }));\n\n    // Add other handlers similarly\n  }\n\n  private rateLimitedHandler(handler: Function): Function {\n    return async (request: any) =&gt; {\n      this.requestCount++;\n      if (this.requestCount &gt; this.config.rateLimit) {\n        throw new Error(\"Rate limit exceeded\");\n      }\n      return handler(request);\n    };\n  }\n\n  private setupHealthChecks(): void {\n    // Add health check endpoint (if using HTTP transport)\n    // For stdio, we can add a special tool\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      if (request.params.name === \"health_check\") {\n        return {\n          content: [{\n            type: \"text\",\n            text: JSON.stringify({\n              status: \"healthy\",\n              uptime: Date.now() - this.startTime,\n              requestCount: this.requestCount,\n            }),\n          }],\n        };\n      }\n      // Handle other tools\n    });\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"Server error:\", error);\n      // Send to monitoring service\n    };\n\n    process.on(\"SIGTERM\", async () =&gt; {\n      console.log(\"Received SIGTERM, shutting down gracefully\");\n      await this.server.close();\n      process.exit(0);\n    });\n\n    process.on(\"uncaughtException\", (error) =&gt; {\n      console.error(\"Uncaught exception:\", error);\n      process.exit(1);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.log(\"Production MCP Server running on stdio\");\n  }\n}\n\n// Deployment script (deploy.sh)\n#!/bin/bash\nnpm run build\nnpm run test\ndocker build -t mcp-server .\ndocker run -p 3000:3000 mcp-server\n</code></pre>  Test by running the server, checking logs, calling health check tool, and verifying graceful shutdown."},{"location":"Lab05-MCP-Prompts/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Prompts create reusable AI workflows with structured guidance</p> <p>\u2705 Resource integration provides contextually rich prompt experiences</p> <p>\u2705 Arguments make prompts flexible and customizable</p> <p>\u2705 Complete servers combine tools, resources, and prompts effectively</p> <p>\u2705 Dynamic prompts adapt to current data and context</p> <p>\u2705 Production readiness requires comprehensive error handling and monitoring</p> <p>\u2705 Workflow orchestration enables complex, multi-step AI processes</p> <p>\u2705 Domain specialization creates powerful, focused AI capabilities</p>"},{"location":"Lab05-MCP-Prompts/#next-steps","title":"Next Steps","text":"<p>Congratulations! </p> <p>You\u2019ve completed the comprehensive MCP learning series. </p> <p>You now posses the knowledge and skills to:</p> <p>\u2705 Build complete MCP servers with all three capabilities</p> <p>\u2705 Create sophisticated AI workflows and integrations</p> <p>\u2705 Deploy production-ready MCP solutions</p> <p>\u2705 Contribute to the MCP ecosystem</p>"},{"location":"Lab05-MCP-Prompts/#whats-next","title":"What\u2019s Next?","text":""},{"location":"Lab05-MCP-Prompts/#further-experimentation","title":"Further experimentation","text":"<p>Go ahead and experiment further with MCP un the MCP Lab Tasks section, filled with hands-on exercises to deepen your understanding of MCP capabilities.</p>"},{"location":"Lab05-MCP-Prompts/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>MCP Extensions: Custom protocol extensions</li> <li>Multi-server Coordination: Server orchestration</li> <li>Performance Optimization: Scaling MCP servers</li> <li>Security Hardening: Advanced security patterns</li> </ul>"},{"location":"Lab05-MCP-Prompts/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Code Analysis Tools: Automated code review and improvement</li> <li>DevOps Automation: Infrastructure and deployment automation</li> <li>Data Science Workflows: AI-assisted data analysis</li> <li>Content Creation: AI-powered content generation pipelines</li> </ul>"},{"location":"Lab05-MCP-Prompts/#community-engagement","title":"Community Engagement","text":"<ul> <li>Contribute to MCP: Join the open-source development</li> <li>Share Your Servers: Publish your MCP servers</li> <li>Build Integrations: Create MCP clients and tools</li> <li>Teach Others: Help grow the MCP community</li> </ul> <p>Your MCP journey has just begun! </p> <p>The protocol provides endless possibilities for AI-human collaboration.</p> <p>Go forth and build amazing things!</p>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/","title":"MCP Lab Tasks - Lab 5","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-51-simple-prompt-template","title":"Exercise 5.1: Simple Prompt Template","text":"<p>Create a basic prompt template that generates greetings.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"greeting\") {\n    const { name: userName = \"World\" } = args || {};\n\n    return {\n      description: \"A friendly greeting prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Hello ${userName}! How are you doing today?`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-52-code-review-prompt","title":"Exercise 5.2: Code Review Prompt","text":"<p>Implement a prompt for code review assistance.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"code_review\") {\n    const { code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Code review assistant prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Please review the following ${language} code for:\\n- Code quality and best practices\\n- Potential bugs or issues\\n- Performance considerations\\n- Security concerns\\n\\nCode:\\n${code}\\n\\nPlease provide specific feedback and suggestions for improvement.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-53-sql-query-builder-prompt","title":"Exercise 5.3: SQL Query Builder Prompt","text":"<p>Create a prompt that helps build SQL queries.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"sql_builder\") {\n    const { table, columns, conditions } = args || {};\n\n    return {\n      description: \"SQL query building assistant\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Help me build an SQL query with the following requirements:\\n- Table: ${table || \"users\"}\\n- Columns: ${columns || \"name, email, created_at\"}\\n- Conditions: ${conditions || \"active = true\"}\\n\\nPlease provide the SQL query and explain what it does.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-54-documentation-generator-prompt","title":"Exercise 5.4: Documentation Generator Prompt","text":"<p>Implement a prompt that generates documentation.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_docs\") {\n    const { code, language = \"typescript\" } = args || {};\n\n    return {\n      description: \"Documentation generator prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Generate comprehensive documentation for the following ${language} code:\\n\\n${code}\\n\\nPlease include:\\n1. Function/class purpose\\n2. Parameters and return types\\n3. Usage examples\\n4. Important notes or caveats`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-55-error-analysis-prompt","title":"Exercise 5.5: Error Analysis Prompt","text":"<p>Create a prompt for analyzing error messages.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"error_analysis\") {\n    const { error_message, code_context } = args || {};\n\n    return {\n      description: \"Error analysis and debugging prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `I'm encountering this error:\\n\\n${error_message}\\n\\nCode context:\\n${code_context || \"No context provided\"}\\n\\nPlease help me:\\n1. Understand what this error means\\n2. Identify the likely cause\\n3. Suggest how to fix it\\n4. Provide preventive measures for similar errors`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-56-api-design-prompt","title":"Exercise 5.6: API Design Prompt","text":"<p>Implement a prompt for API design assistance.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"api_design\") {\n    const { resource, operations } = args || {};\n\n    return {\n      description: \"API design assistant prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Design a REST API for managing ${resource || \"users\"} with the following operations:\\n${operations || \"CRUD operations (Create, Read, Update, Delete)\"}\\n\\nPlease provide:\\n1. Endpoint definitions with HTTP methods\\n2. Request/response schemas\\n3. Error handling approach\\n4. Best practices recommendations`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-57-test-case-generator-prompt","title":"Exercise 5.7: Test Case Generator Prompt","text":"<p>Create a prompt that generates test cases.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_tests\") {\n    const { function_code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Test case generator prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Generate comprehensive test cases for this ${language} function:\\n\\n${function_code}\\n\\nPlease provide:\\n1. Unit tests for normal operation\\n2. Edge cases and error conditions\\n3. Integration test scenarios\\n4. Test framework code (Jest/Mocha for JS, pytest for Python, etc.)`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-58-performance-optimization-prompt","title":"Exercise 5.8: Performance Optimization Prompt","text":"<p>Implement a prompt for performance analysis.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"performance_tips\") {\n    const { code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Performance optimization prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Analyze this ${language} code for performance issues:\\n\\n${code}\\n\\nPlease identify:\\n1. Performance bottlenecks\\n2. Memory leaks or inefficiencies\\n3. Optimization opportunities\\n4. Recommended improvements with code examples`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-59-security-audit-prompt","title":"Exercise 5.9: Security Audit Prompt","text":"<p>Create a prompt for security code review.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"security_audit\") {\n    const { code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Security audit prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Perform a security audit on this ${language} code:\\n\\n${code}\\n\\nCheck for:\\n1. Input validation vulnerabilities\\n2. Authentication/authorization issues\\n3. SQL injection or XSS vulnerabilities\\n4. Secure coding practices\\n5. Data exposure risks\\n\\nProvide specific recommendations for each issue found.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-510-database-schema-design-prompt","title":"Exercise 5.10: Database Schema Design Prompt","text":"<p>Implement a prompt for database design.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"db_schema\") {\n    const { entities, relationships } = args || {};\n\n    return {\n      description: \"Database schema design prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Design a database schema for:\\nEntities: ${entities || \"users, posts, comments\"}\\nRelationships: ${relationships || \"users have many posts, posts have many comments\"}\\n\\nPlease provide:\\n1. Table definitions with columns and types\\n2. Primary and foreign key relationships\\n3. Indexes for performance\\n4. Sample SQL DDL statements`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-511-refactoring-prompt","title":"Exercise 5.11: Refactoring Prompt","text":"<p>Create a prompt for code refactoring suggestions.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"refactor_code\") {\n    const { code, language = \"javascript\", issues } = args || {};\n\n    return {\n      description: \"Code refactoring prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Refactor this ${language} code to improve:\\n- Readability and maintainability\\n- Performance\\n- Following best practices\\n${issues ? `- Address these specific issues: ${issues}` : \"\"}\\n\\nOriginal code:\\n${code}\\n\\nPlease provide the refactored version with explanations of the changes.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-512-deployment-strategy-prompt","title":"Exercise 5.12: Deployment Strategy Prompt","text":"<p>Implement a prompt for deployment planning.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"deployment_plan\") {\n    const { app_type, environment } = args || {};\n\n    return {\n      description: \"Deployment strategy prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Create a deployment strategy for a ${app_type || \"web application\"} to ${environment || \"production\"}.\\n\\nPlease include:\\n1. Infrastructure requirements\\n2. CI/CD pipeline setup\\n3. Environment configuration\\n4. Monitoring and logging\\n5. Rollback procedures\\n6. Scaling considerations`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-513-interview-question-generator-prompt","title":"Exercise 5.13: Interview Question Generator Prompt","text":"<p>Create a prompt that generates technical interview questions.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"interview_questions\") {\n    const { topic, level = \"intermediate\" } = args || {};\n\n    return {\n      description: \"Technical interview question generator\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Generate ${level} level interview questions for ${topic || \"JavaScript development\"}.\\n\\nPlease provide:\\n1. 5 conceptual questions\\n2. 3 coding problems with solutions\\n3. 2 system design questions\\n4. Expected answers or evaluation criteria for each`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-514-code-explanation-prompt","title":"Exercise 5.14: Code Explanation Prompt","text":"<p>Implement a prompt for explaining complex code.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"explain_code\") {\n    const { code, language = \"javascript\", audience = \"intermediate\" } = args || {};\n\n    return {\n      description: \"Code explanation prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Explain this ${language} code to an ${audience} developer:\\n\\n${code}\\n\\nPlease break down:\\n1. What the code does overall\\n2. Key components and their purposes\\n3. How the pieces fit together\\n4. Important concepts or patterns used\\n5. Potential improvements or alternatives`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-515-requirements-analysis-prompt","title":"Exercise 5.15: Requirements Analysis Prompt","text":"<p>Create a prompt for analyzing project requirements.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"requirements_analysis\") {\n    const { requirements, constraints } = args || {};\n\n    return {\n      description: \"Requirements analysis prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Analyze these project requirements:\\n\\n${requirements || \"Build a user management system with authentication, profiles, and admin features.\"}\\n\\nConstraints: ${constraints || \"Must be web-based, support 1000 concurrent users, comply with GDPR.\"}\\n\\nPlease provide:\\n1. Functional requirements breakdown\\n2. Non-functional requirements\\n3. Technical feasibility assessment\\n4. Recommended technology stack\\n5. High-level architecture suggestions\\n6. Potential risks and mitigation strategies`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab06-K-Agent/","title":"Lab 6: K-Agent Integration","text":""},{"location":"Lab06-K-Agent/#overview","title":"Overview","text":"<p>Welcome to the advanced MCP lab!</p> <p>Now that you\u2019ve mastered the fundamentals of MCP servers, tools, resources, and prompts, it\u2019s time to apply your knowledge to a real-world scenario: building and implementing a K-Agent.</p> <p>A K-Agent is an MCP server specifically designed to interact with Kubernetes clusters. </p> <p>In this lab, you\u2019ll build a focused K-Agent that communicates with a Kubernetes cluster and collects logs from all pods - a critical capability for monitoring, debugging, and operational intelligence.</p> <p>This lab bridges the gap between MCP theory and practical Kubernetes operations, showing how MCP servers can enhance DevOps workflows and provide AI-powered insights into cluster health and application behavior.</p>"},{"location":"Lab06-K-Agent/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand the concept and value of K-Agents (Kubernetes MCP servers)</li> <li>Use pre-configured Kubernetes cluster access</li> <li>Build MCP tools for pod log collection</li> <li>Implement error handling for cluster operations</li> </ul>"},{"location":"Lab06-K-Agent/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 5 - MCP Prompts and Integration</li> <li>A running Kubernetes cluster (OrbStack, Docker Desktop, Minikube, kind, or remote cluster)</li> <li>kubectl installed and configured with access to your cluster (<code>kubectl cluster-info</code> should work)</li> <li>Basic understanding of Kubernetes concepts (pods, namespaces, kubectl)</li> <li>Familiarity with container orchestration principles</li> <li>Understanding of log aggregation and monitoring concepts</li> </ul> <p>Verify Kubernetes Setup</p> <p>Before starting this lab, ensure your Kubernetes environment is ready: <pre><code># Check cluster access\nkubectl cluster-info\n\n# Verify you can list pods\nkubectl get pods --all-namespaces\n\n# Check your kubeconfig\nkubectl config view\n</code></pre></p>"},{"location":"Lab06-K-Agent/#what-is-a-k-agent","title":"What is a K-Agent?","text":"<p>A K-Agent is an MCP server that specializes in Kubernetes operations. </p> <p>Unlike generic MCP servers, K-Agents are designed specifically for:</p> <ul> <li>Cluster Communication: Secure, authenticated access to Kubernetes APIs</li> <li>Operational Intelligence: Real-time insights into cluster health and performance</li> <li>Log Analytics: Collection and analysis of application and system logs</li> <li>Resource Management: Monitoring and managing Kubernetes resources</li> <li>Troubleshooting: Automated diagnosis of cluster and application issues</li> </ul>"},{"location":"Lab06-K-Agent/#why-k-agents-matter","title":"Why K-Agents Matter","text":"<p>In modern DevOps environments, Kubernetes clusters generate enormous amounts of operational data. </p> <p>K-Agents provide:</p> <ul> <li>AI-Powered Monitoring: Intelligent analysis of logs and metrics</li> <li>Automated Troubleshooting: AI-assisted diagnosis of issues</li> <li>Operational Insights: Pattern recognition in cluster behavior</li> <li>Enhanced Observability: Structured access to distributed system data</li> </ul>"},{"location":"Lab06-K-Agent/#lab-architecture","title":"Lab Architecture","text":"<p>Your K-Agent will implement a focused set of capabilities:</p> <pre><code>graph TB\n    subgraph \"MCP Client (AI/Inspector)\"\n        Client[MCP Client]\n    end\n\n    subgraph \"K-Agent MCP Server\"\n        Server[K-Agent Server]\n        Tools[MCP Tools]\n        K8sClient[Kubernetes Client]\n\n        Server --&gt; Tools\n        Tools --&gt; K8sClient\n    end\n\n    subgraph \"Kubernetes Cluster\"\n        API[Kubernetes API]\n        Pods[Pods]\n        Logs[Container Logs]\n\n        API --&gt; Pods\n        Pods --&gt; Logs\n    end\n\n    Client --&gt;|\"stdio/JSON-RPC\"| Server\n    K8sClient --&gt;|\"REST API\"| API\n\n    Tools -.-&gt;|\"list_pods\"| API\n    Tools -.-&gt;|\"collect_pod_logs\"| Logs\n\n    style Server fill:#4CAF50\n    style Tools fill:#2196F3\n    style K8sClient fill:#FF9800\n    style API fill:#9C27B0</code></pre>"},{"location":"Lab06-K-Agent/#core-components","title":"Core Components","text":"<ol> <li> <p>Kubernetes Client Integration</p> <ul> <li>Secure cluster authentication</li> <li>API communication handling</li> <li>Error management for cluster operations</li> </ul> </li> <li> <p>Log Collection Tools</p> <ul> <li>Pod discovery across namespaces</li> <li>Log retrieval from all containers</li> <li>Structured log formatting</li> </ul> </li> <li> <p>Resource Management</p> <ul> <li>Namespace enumeration</li> <li>Pod status monitoring</li> <li>Health check capabilities</li> </ul> </li> </ol>"},{"location":"Lab06-K-Agent/#hands-on-exercise","title":"Hands-On Exercise","text":""},{"location":"Lab06-K-Agent/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>Create a new MCP server project with Kubernetes dependencies:</p> <pre><code># Create project directory and navigate to it\nmkdir k-agent-logs  # &lt;-- Create this directory next to the previous labs directories\ncd k-agent-logs\n</code></pre> <p></p> <p>Create a new <code>package.json</code> file inside the <code>k-agent-logs</code> directory with the following content:</p> <pre><code>{\n  \"name\": \"k-agent-logs\",\n  \"version\": \"1.0.0\",\n  \"description\": \"K-Agent MCP server for Kubernetes log collection\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx src/index.ts\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\"kubernetes\", \"mcp\", \"logs\", \"monitoring\"],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"type\": \"commonjs\",\n  \"dependencies\": {\n    \"@kubernetes/client-node\": \"^1.4.0\",\n    \"@modelcontextprotocol/sdk\": \"^1.25.2\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^25.0.3\",\n    \"tsx\": \"^4.21.0\",\n    \"typescript\": \"^5.9.3\"\n  }\n}\n</code></pre> <p></p> <p>Run the following command to install the dependencies:</p> <pre><code>npm install\n</code></pre> <p>This will create <code>node_modules/</code> and <code>package-lock.json</code> in your <code>k-agent-logs</code> directory.</p>"},{"location":"Lab06-K-Agent/#step-2-kubernetes-client-configuration-complete-server-setup","title":"Step 2: Kubernetes Client Configuration &amp; Complete Server Setup","text":"<p>Create an <code>src</code> directory, inside the <code>k-agent-logs</code> directory, and an empty file named <code>index.ts</code> inside it:</p> <pre><code>mkdir -p src &amp;&amp; touch src/index.ts\n</code></pre> <p></p> <p>Create your complete K-Agent server by pasting the following code inside <code>src/index.ts</code>:</p> <pre><code>// Import MCP SDK components and Kubernetes client\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  // Store Kubernetes API clients (for talking to your cluster)\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n  private server: Server;\n\n  constructor() {\n    // Initialize connection to your Kubernetes cluster (uses ~/.kube/config)\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sConfig.loadFromDefault();\n\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Create MCP server that AI tools can connect to\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      }\n    );\n\n    // Handle incoming MCP requests (you'll add tools here next)\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // TODO: Implement MCP handlers\n  }\n\n  // Start the server and listen for connections\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Actually run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n</code></pre> <p></p> <p>Create a file named <code>tsconfig.json</code> inside the <code>k-agent-logs</code> directory (not inside <code>src</code>): </p> <pre><code>cd ..  # Go back to k-agent-logs directory\ntouch tsconfig.json\n</code></pre> <p></p> <p>Paste the following content into <code>tsconfig.json</code>:</p> <pre><code>{\n    \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n    },\n    \"include\": [\"src/**/*\"],\n    \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre> <p></p> <p>Test that it works:</p> <pre><code>npm run dev\n</code></pre> <p>You should see: <code>K-Agent MCP server running on stdio</code></p> <p></p> <p>If you get errors:</p> <ul> <li><code>Missing script: \"dev\"</code> \u2192 You didn\u2019t update package.json (go back to step 2)</li> <li><code>Cannot find module</code> \u2192 Make sure you\u2019re in the k-agent-logs directory</li> <li>Other errors \u2192 Check that src/index.ts has the correct code</li> </ul>"},{"location":"Lab06-K-Agent/#step-3-pod-discovery-tool","title":"Step 3: Pod Discovery Tool","text":"<p>Implement pod enumeration across namespaces with the <code>list_pods</code> tool.</p> <p></p>"},{"location":"Lab06-K-Agent/#update-setuphandlers-method","title":"Update setupHandlers() Method","text":"<p>Open your <code>src/index.ts</code> file and find the <code>setupHandlers()</code> method. Replace the entire method with the following code:</p> <pre><code>private setupHandlers() {\n  // List available tools\n  this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        }\n      ]\n    };\n  });\n\n  // Handle tool calls\n  this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n    const { name, arguments: args } = request.params;\n\n    try {\n      switch (name) {\n        case \"list_pods\":\n          return await this.handleListPods(args);\n        default:\n          throw new McpError(\n            ErrorCode.MethodNotFound,\n            `Unknown tool: ${name}`\n          );\n      }\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  });\n}\n</code></pre> <p></p>"},{"location":"Lab06-K-Agent/#add-handler-methods","title":"Add Handler Methods","text":"<p>Below the <code>setupHandlers()</code> method, before the <code>async run()</code> method, add the following new methods:</p> <pre><code>private async handleListPods(args: any) {\n  const namespace = args?.namespace;\n  const pods = await this.getPods(namespace);\n\n  const podList = pods.map(pod =&gt; ({\n    name: pod.metadata?.name || 'unknown',\n    namespace: pod.metadata?.namespace || 'unknown',\n    status: pod.status?.phase || 'unknown',\n    containers: pod.spec?.containers?.map(c =&gt; c.name) || []\n  }));\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: JSON.stringify(podList, null, 2)\n      }\n    ]\n  };\n}\n\nprivate async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n  try {\n    if (namespace) {\n      const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n      return response.items || [];\n    } else {\n      const response = await this.k8sCoreApi.listPodForAllNamespaces();\n      return response.items || [];\n    }\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n\nprivate handleK8sError(error: any): Error {\n  if (error.response?.statusCode === 403) {\n    return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n  }\n\n  if (error.response?.statusCode === 404) {\n    return new Error('Resource not found: The specified pod or namespace may not exist');\n  }\n\n  return new Error(`Kubernetes operation failed: ${error.message}`);\n}\n</code></pre> <p></p> <p>Complete <code>src/index.ts</code> After Step 3</p> <p>Here\u2019s what your complete <code>src/index.ts</code> file should look like after completing Step 3:</p> <pre><code>// Import MCP SDK components and Kubernetes client\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  // Store Kubernetes API clients (for talking to your cluster)\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n  private server: Server;\n\n  constructor() {\n    // Initialize connection to your Kubernetes cluster (uses ~/.kube/config)\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sConfig.loadFromDefault();\n\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Create MCP server that AI tools can connect to\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      }\n    );\n\n    // Handle incoming MCP requests\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"list_pods\",\n            description: \"List all pods across namespaces with their status\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Optional: Filter by specific namespace\"\n                }\n              }\n            }\n          }\n        ]\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case \"list_pods\":\n            return await this.handleListPods(args);\n          default:\n            throw new McpError(\n              ErrorCode.MethodNotFound,\n              `Unknown tool: ${name}`\n            );\n        }\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    });\n  }\n\n  private async handleListPods(args: any) {\n    const namespace = args?.namespace;\n    const pods = await this.getPods(namespace);\n\n    const podList = pods.map(pod =&gt; ({\n      name: pod.metadata?.name || 'unknown',\n      namespace: pod.metadata?.namespace || 'unknown',\n      status: pod.status?.phase || 'unknown',\n      containers: pod.spec?.containers?.map(c =&gt; c.name) || []\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(podList, null, 2)\n        }\n      ]\n    };\n  }\n\n  private async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n    try {\n      if (namespace) {\n        const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n        return response.items || [];\n      } else {\n        const response = await this.k8sCoreApi.listPodForAllNamespaces();\n        return response.items || [];\n      }\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private handleK8sError(error: any): Error {\n    if (error.response?.statusCode === 403) {\n      return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n    }\n\n    if (error.response?.statusCode === 404) {\n      return new Error('Resource not found: The specified pod or namespace may not exist');\n    }\n\n    return new Error(`Kubernetes operation failed: ${error.message}`);\n  }\n\n  // Start the server and listen for connections\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Actually run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n</code></pre> <p></p>"},{"location":"Lab06-K-Agent/#test-pod-discovery","title":"Test Pod Discovery","text":"<p>Test the pod listing functionality using the MCP Inspector by running:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>This will start the MCP Inspector connected to your K-Agent server and open a browser window.</p> <p>Inside the MCP Inspector UI browser window:</p> <ol> <li>Click the \u201cConnect\u201d button</li> <li>Click the \u201cTools\u201d tab</li> <li>Click \u201cList Tools\u201d - you\u2019ll see the <code>list_pods</code> tool</li> <li>Click on <code>list_pods</code></li> <li>Optionally enter a namespace name</li> <li>Click \u201cRun Tool\u201d to test it</li> </ol> <p>You should see a JSON list of all pods with their status and container names.</p>"},{"location":"Lab06-K-Agent/#step-4-log-collection-tool","title":"Step 4: Log Collection Tool","text":"<p>Build the core log collection functionality with the <code>collect_pod_logs</code> tool.</p> <p></p>"},{"location":"Lab06-K-Agent/#add-collect_pod_logs-to-tools-array","title":"Add collect_pod_logs to Tools Array","text":"<p>In your <code>src/index.ts</code> file, locate the tools array inside <code>setupHandlers()</code> method. </p> <p>Add the following second tool code to the array:</p> <pre><code>private setupHandlers() {\n  // List available tools\n  this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        },\n        {\n          name: \"collect_pod_logs\",\n          description: \"Collect logs from all containers in specified pods\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Namespace to collect logs from\"\n              },\n              podName: {\n                type: \"string\",\n                description: \"Specific pod name (optional - collects from all if not specified)\"\n              },\n              tailLines: {\n                type: \"number\",\n                description: \"Number of recent log lines to retrieve\",\n                default: 100\n              }\n            },\n            required: [\"namespace\"]\n          }\n        }\n      ]\n    };\n  });\n  // ... rest of setupHandlers\n}\n</code></pre> <p></p>"},{"location":"Lab06-K-Agent/#update-tool-handler-switch","title":"Update Tool Handler Switch","text":"<p>In the same <code>setupHandlers()</code> method, locate the switch statement and add the following case for <code>collect_pod_logs</code>:</p> <pre><code>switch (name) {\n  case \"list_pods\":\n    return await this.handleListPods(args);\n  case \"collect_pod_logs\":\n    return await this.handleCollectPodLogs(args);\n  default:\n    throw new McpError(\n      ErrorCode.MethodNotFound,\n      `Unknown tool: ${name}`\n    );\n}\n</code></pre> <p></p>"},{"location":"Lab06-K-Agent/#implement-log-collection-methods","title":"Implement Log Collection Methods","text":"<p>Below your existing handler methods (after <code>handleK8sError()</code>), before the <code>async run()</code> method, add the following new methods:</p> <pre><code>private async handleCollectPodLogs(args: any) {\n  const { namespace, podName, tailLines = 100 } = args;\n\n  if (!namespace) {\n    throw new Error(\"Namespace is required\");\n  }\n\n  const logs = await this.collectPodLogs(namespace, podName, tailLines);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: logs\n      }\n    ]\n  };\n}\n\nprivate async collectPodLogs(namespace: string, podName?: string, tailLines: number = 100): Promise&lt;string&gt; {\n  const pods = podName \n    ? await this.getPods(namespace).then(pods =&gt; pods.filter(p =&gt; p.metadata?.name === podName)) \n    : await this.getPods(namespace);\n\n  const allLogs: string[] = [];\n\n  for (const pod of pods) {\n    if (!pod.metadata?.name) continue;\n\n    const containers = pod.spec?.containers || [];\n    for (const container of containers) {\n      try {\n        const logs = await this.getPodLogs(namespace, pod.metadata.name, container.name, tailLines);\n        allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\n${logs}\\n`);\n      } catch (error) {\n        allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\nError retrieving logs: ${error instanceof Error ? error.message : String(error)}\\n`);\n      }\n    }\n  }\n\n  return allLogs.join('\\n');\n}\n\nprivate async getPodLogs(namespace: string, podName: string, containerName: string, tailLines: number): Promise&lt;string&gt; {\n  try {\n    const response = await this.k8sCoreApi.readNamespacedPodLog({\n      name: podName,\n      namespace: namespace,\n      container: containerName,\n      tailLines: tailLines,\n      timestamps: true\n    });\n    return response || '';\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre> <p>Complete <code>src/index.ts</code> After Step 4</p> <p>Here\u2019s what your complete <code>src/index.ts</code> file should look like after completing Step 4:</p> <pre><code>// Import MCP SDK components and Kubernetes client\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  // Store Kubernetes API clients (for talking to your cluster)\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n  private server: Server;\n\n  constructor() {\n    // Initialize connection to your Kubernetes cluster (uses ~/.kube/config)\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sConfig.loadFromDefault();\n\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Create MCP server that AI tools can connect to\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      }\n    );\n\n    // Handle incoming MCP requests\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"list_pods\",\n            description: \"List all pods across namespaces with their status\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Optional: Filter by specific namespace\"\n                }\n              }\n            }\n          },\n          {\n            name: \"collect_pod_logs\",\n            description: \"Collect logs from all containers in specified pods\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Namespace to collect logs from\"\n                },\n                podName: {\n                  type: \"string\",\n                  description: \"Specific pod name (optional - collects from all if not specified)\"\n                },\n                tailLines: {\n                  type: \"number\",\n                  description: \"Number of recent log lines to retrieve\",\n                  default: 100\n                }\n              },\n              required: [\"namespace\"]\n            }\n          }\n        ]\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case \"list_pods\":\n            return await this.handleListPods(args);\n          case \"collect_pod_logs\":\n            return await this.handleCollectPodLogs(args);\n          default:\n            throw new McpError(\n              ErrorCode.MethodNotFound,\n              `Unknown tool: ${name}`\n            );\n        }\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    });\n  }\n\n  private async handleListPods(args: any) {\n    const namespace = args?.namespace;\n    const pods = await this.getPods(namespace);\n\n    const podList = pods.map(pod =&gt; ({\n      name: pod.metadata?.name || 'unknown',\n      namespace: pod.metadata?.namespace || 'unknown',\n      status: pod.status?.phase || 'unknown',\n      containers: pod.spec?.containers?.map(c =&gt; c.name) || []\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(podList, null, 2)\n        }\n      ]\n    };\n  }\n\n  private async handleCollectPodLogs(args: any) {\n    const { namespace, podName, tailLines = 100 } = args;\n\n    if (!namespace) {\n      throw new Error(\"Namespace is required\");\n    }\n\n    const logs = await this.collectPodLogs(namespace, podName, tailLines);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: logs\n        }\n      ]\n    };\n  }\n\n  private async collectPodLogs(namespace: string, podName?: string, tailLines: number = 100): Promise&lt;string&gt; {\n    const pods = podName \n      ? await this.getPods(namespace).then(pods =&gt; pods.filter(p =&gt; p.metadata?.name === podName)) \n      : await this.getPods(namespace);\n\n    const allLogs: string[] = [];\n\n    for (const pod of pods) {\n      if (!pod.metadata?.name) continue;\n\n      const containers = pod.spec?.containers || [];\n      for (const container of containers) {\n        try {\n          const logs = await this.getPodLogs(namespace, pod.metadata.name, container.name, tailLines);\n          allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\n${logs}\\n`);\n        } catch (error) {\n          allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\nError retrieving logs: ${error instanceof Error ? error.message : String(error)}\\n`);\n        }\n      }\n    }\n\n    return allLogs.join('\\n');\n  }\n\n  private async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n    try {\n      if (namespace) {\n        const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n        return response.items || [];\n      } else {\n        const response = await this.k8sCoreApi.listPodForAllNamespaces();\n        return response.items || [];\n      }\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private async getPodLogs(namespace: string, podName: string, containerName: string, tailLines: number): Promise&lt;string&gt; {\n    try {\n      const response = await this.k8sCoreApi.readNamespacedPodLog({\n        name: podName,\n        namespace: namespace,\n        container: containerName,\n        tailLines: tailLines,\n        timestamps: true\n      });\n      return response || '';\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private handleK8sError(error: any): Error {\n    if (error.response?.statusCode === 403) {\n      return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n    }\n\n    if (error.response?.statusCode === 404) {\n      return new Error('Resource not found: The specified pod or namespace may not exist');\n    }\n\n    return new Error(`Kubernetes operation failed: ${error.message}`);\n  }\n\n  // Start the server and listen for connections\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Actually run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n</code></pre> <p></p>"},{"location":"Lab06-K-Agent/#test-log-collection","title":"Test Log Collection","text":"<p>Test the log collection functionality with the MCP Inspector:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>This will start the MCP Inspector connected to your K-Agent server and open a browser window.</p> <p>In the MCP Inspector UI browser window:</p> <ol> <li>Click the \u201cConnect\u201d button</li> <li>Click the \u201cTools\u201d tab</li> <li>Click \u201cList Tools\u201d - you\u2019ll see both <code>list_pods</code> and <code>collect_pod_logs</code></li> <li>Click on <code>collect_pod_logs</code></li> <li>In the namespace field, enter: <code>default</code></li> <li>Click \u201cRun Tool\u201d</li> </ol> <p>You should see logs from all pods in the default namespace, formatted with pod and container names.</p>"},{"location":"Lab06-K-Agent/#optional-extensions","title":"Optional Extensions","text":"<p>Prerequisites</p> <p>These exercises assume you have completed Steps 1-4 and have a fully functional K-Agent server with <code>list_pods</code> and <code>collect_pod_logs</code> tools. These exercises extend the functionality beyond the core implementation.</p>"},{"location":"Lab06-K-Agent/#exercise-1-advanced-pod-filtering-and-sorting","title":"Exercise 1: Advanced Pod Filtering and Sorting","text":"<p>Enhance the <code>list_pods</code> tool to support filtering by status, labels, and sorting by various criteria.</p> <p>Update the list_pods tool schema in your <code>setupHandlers()</code> method to include new parameters:</p> <pre><code>{\n  name: \"list_pods\",\n  description: \"List all pods across namespaces with their status, with filtering and sorting options\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Optional: Filter by specific namespace\"\n      },\n      status: {\n        type: \"string\",\n        description: \"Optional: Filter by pod status (Running, Pending, Failed, etc.)\",\n        enum: [\"Running\", \"Pending\", \"Failed\", \"Succeeded\", \"Unknown\"]\n      },\n      labelSelector: {\n        type: \"string\",\n        description: \"Optional: Filter by label selector (e.g., 'app=nginx,env=prod')\"\n      },\n      sortBy: {\n        type: \"string\",\n        description: \"Sort results by field\",\n        enum: [\"name\", \"namespace\", \"status\", \"age\"],\n        default: \"name\"\n      }\n    }\n  }\n}\n</code></pre> <p></p> <p>Update the handleListPods method to support the new parameters:</p> <pre><code>private async handleListPods(args: any) {\n  const { namespace, status, labelSelector, sortBy = 'name' } = args;\n  let pods = await this.getPods(namespace, labelSelector);\n\n  // Filter by status if specified\n  if (status) {\n    pods = pods.filter(pod =&gt; pod.status?.phase === status);\n  }\n\n  // Map to simplified format\n  const podList = pods.map(pod =&gt; ({\n    name: pod.metadata?.name || 'unknown',\n    namespace: pod.metadata?.namespace || 'unknown',\n    status: pod.status?.phase || 'unknown',\n    containers: pod.spec?.containers?.map(c =&gt; c.name) || [],\n    age: pod.metadata?.creationTimestamp \n      ? Math.floor((Date.now() - new Date(pod.metadata.creationTimestamp).getTime()) / 1000 / 60)\n      : 0,\n    labels: pod.metadata?.labels || {}\n  }));\n\n  // Sort results\n  const sortedPods = this.sortPods(podList, sortBy);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: JSON.stringify(sortedPods, null, 2)\n      }\n    ]\n  };\n}\n</code></pre> <p></p> <p>Update the getPods method to support label selectors:</p> <pre><code>private async getPods(namespace?: string, labelSelector?: string): Promise&lt;k8s.V1Pod[]&gt; {\n  try {\n    if (namespace) {\n      const response = await this.k8sCoreApi.listNamespacedPod({\n        namespace,\n        labelSelector\n      });\n      return response.items || [];\n    } else {\n      const response = await this.k8sCoreApi.listPodForAllNamespaces({\n        labelSelector\n      });\n      return response.items || [];\n    }\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre> <p></p> <p>Add a sorting helper method after the <code>getPods</code> method:</p> <pre><code>private sortPods(pods: any[], sortBy: string): any[] {\n  return pods.sort((a, b) =&gt; {\n    switch (sortBy) {\n      case 'namespace':\n        return a.namespace.localeCompare(b.namespace);\n      case 'status':\n        return a.status.localeCompare(b.status);\n      case 'age':\n        return b.age - a.age; // Newest first\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n}\n</code></pre> <p></p> <p>Test the enhanced filtering:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>Try these test cases:</p> <ul> <li>List only Running pods: Set <code>status</code> to \u201cRunning\u201d</li> <li>Filter by labels: Set <code>labelSelector</code> to \u201capp=nginx\u201d</li> <li>Sort by age: Set <code>sortBy</code> to \u201cage\u201d</li> <li>Combine filters: Use namespace + status + sortBy together</li> </ul>"},{"location":"Lab06-K-Agent/#exercise-2-enhanced-log-analysis-with-search-and-export","title":"Exercise 2: Enhanced Log Analysis with Search and Export","text":"<p>Extend the <code>collect_pod_logs</code> tool to support log searching, filtering by severity, and exporting logs to files.</p> <p>Add a new tool <code>analyze_logs</code> to your tools array in <code>setupHandlers()</code>:</p> <pre><code>{\n  name: \"analyze_logs\",\n  description: \"Analyze and search through pod logs with filtering and export capabilities\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to analyze logs from\"\n      },\n      podName: {\n        type: \"string\",\n        description: \"Specific pod name (optional)\"\n      },\n      searchPattern: {\n        type: \"string\",\n        description: \"Regex pattern to search for in logs\"\n      },\n      severityLevel: {\n        type: \"string\",\n        description: \"Filter by log severity\",\n        enum: [\"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"]\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to analyze\",\n        default: 100\n      },\n      exportToFile: {\n        type: \"boolean\",\n        description: \"Export matching logs to a file\",\n        default: false\n      }\n    },\n    required: [\"namespace\"]\n  }\n}\n</code></pre> <p></p> <p>Add the case to your switch statement:</p> <pre><code>case \"analyze_logs\":\n  return await this.handleAnalyzeLogs(args);\n</code></pre> <p></p> <p>Implement the log analysis handler after your <code>handleCollectPodLogs</code> method:</p> <pre><code>private async handleAnalyzeLogs(args: any) {\n  const { namespace, podName, searchPattern, severityLevel, tailLines = 100, exportToFile = false } = args;\n\n  if (!namespace) {\n    throw new Error(\"Namespace is required\");\n  }\n\n  const logs = await this.collectPodLogs(namespace, podName, tailLines);\n  const analyzedLogs = this.analyzeLogs(logs, searchPattern, severityLevel);\n\n  if (exportToFile) {\n    const filename = await this.exportLogs(analyzedLogs, namespace, podName);\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Analysis complete. ${analyzedLogs.totalLines} lines analyzed, ${analyzedLogs.matchingLines} matches found.\\nExported to: ${filename}\\n\\n${analyzedLogs.summary}`\n        }\n      ]\n    };\n  }\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Analysis Results:\\n${analyzedLogs.summary}\\n\\nMatching Logs:\\n${analyzedLogs.matches.join('\\n')}`\n      }\n    ]\n  };\n}\n</code></pre> <p></p> <p>Add the log analysis helper method:</p> <pre><code>private analyzeLogs(logs: string, searchPattern?: string, severityLevel?: string) {\n  const lines = logs.split('\\n');\n  const matches: string[] = [];\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  for (const line of lines) {\n    // Filter by severity if specified\n    if (severityLevel) {\n      if (!line.includes(severityLevel)) continue;\n    }\n\n    // Search for pattern if specified\n    if (searchPattern) {\n      const regex = new RegExp(searchPattern, 'i');\n      if (regex.test(line)) {\n        matches.push(line);\n      }\n    } else {\n      matches.push(line);\n    }\n\n    // Categorize by severity\n    if (line.includes('ERROR') || line.includes('error')) {\n      errors.push(line);\n    } else if (line.includes('WARN') || line.includes('warning')) {\n      warnings.push(line);\n    }\n  }\n\n  const summary = [\n    `Total Lines: ${lines.length}`,\n    `Matching Lines: ${matches.length}`,\n    `Errors Found: ${errors.length}`,\n    `Warnings Found: ${warnings.length}`,\n    searchPattern ? `Search Pattern: ${searchPattern}` : '',\n    severityLevel ? `Severity Filter: ${severityLevel}` : ''\n  ].filter(Boolean).join('\\n');\n\n  return {\n    totalLines: lines.length,\n    matchingLines: matches.length,\n    matches: matches.slice(0, 100), // Limit to first 100 matches\n    errors,\n    warnings,\n    summary\n  };\n}\n</code></pre> <p></p> <p>Add the export helper method (requires fs module - add <code>import * as fs from 'fs';</code> at the top):</p> <pre><code>private async exportLogs(analyzedLogs: any, namespace: string, podName?: string): Promise&lt;string&gt; {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const filename = `logs_${namespace}_${podName || 'all'}_${timestamp}.txt`;\n  const filepath = `/tmp/${filename}`;\n\n  const content = [\n    `Kubernetes Log Analysis Report`,\n    `Generated: ${new Date().toISOString()}`,\n    `Namespace: ${namespace}`,\n    podName ? `Pod: ${podName}` : 'All Pods',\n    ``,\n    analyzedLogs.summary,\n    ``,\n    `=== Matching Log Entries ===`,\n    analyzedLogs.matches.join('\\n')\n  ].join('\\n');\n\n  // Note: In a real implementation, you'd want to handle file system operations more carefully\n  // For this exercise, we'll just return the intended filename\n  return filepath;\n}\n</code></pre> <p></p> <p>Test the log analysis:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>Try these test cases:</p> <ul> <li>Search for errors: Set <code>searchPattern</code> to \u201cerror\u201d and <code>severityLevel</code> to \u201cERROR\u201d</li> <li>Find warnings: Set <code>severityLevel</code> to \u201cWARN\u201d</li> <li>Export logs: Set <code>exportToFile</code> to true</li> <li>Pattern matching: Set <code>searchPattern</code> to a specific error code or message</li> </ul>"},{"location":"Lab06-K-Agent/#exercise-3-real-time-pod-monitoring","title":"Exercise 3: Real-Time Pod Monitoring","text":"<p>Create a new tool to monitor pod health and events in real-time, providing insights into pod lifecycle changes.</p> <p>Add the <code>monitor_pod_health</code> tool to your tools array:</p> <pre><code>{\n  name: \"monitor_pod_health\",\n  description: \"Monitor pod health, restart counts, and recent events\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to monitor\"\n      },\n      podName: {\n        type: \"string\",\n        description: \"Specific pod to monitor (optional)\"\n      },\n      includeEvents: {\n        type: \"boolean\",\n        description: \"Include recent Kubernetes events\",\n        default: true\n      }\n    },\n    required: [\"namespace\"]\n  }\n}\n</code></pre> <p></p> <p>Add the case to your switch statement:</p> <pre><code>case \"monitor_pod_health\":\n  return await this.handleMonitorPodHealth(args);\n</code></pre> <p></p> <p>Implement the monitoring handler:</p> <pre><code>private async handleMonitorPodHealth(args: any) {\n  const { namespace, podName, includeEvents = true } = args;\n\n  if (!namespace) {\n    throw new Error(\"Namespace is required\");\n  }\n\n  const pods = podName \n    ? await this.getPods(namespace).then(pods =&gt; pods.filter(p =&gt; p.metadata?.name === podName))\n    : await this.getPods(namespace);\n\n  const healthReports = [];\n\n  for (const pod of pods) {\n    if (!pod.metadata?.name) continue;\n\n    const health = this.analyzePodHealth(pod);\n    const events = includeEvents \n      ? await this.getPodEvents(namespace, pod.metadata.name)\n      : [];\n\n    healthReports.push({\n      pod: pod.metadata.name,\n      namespace: pod.metadata.namespace,\n      health,\n      events\n    });\n  }\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: JSON.stringify(healthReports, null, 2)\n      }\n    ]\n  };\n}\n</code></pre> <p></p> <p>Add the health analysis method:</p> <pre><code>private analyzePodHealth(pod: k8s.V1Pod) {\n  const status = pod.status;\n  const conditions = status?.conditions || [];\n  const containerStatuses = status?.containerStatuses || [];\n\n  // Calculate restart counts\n  const totalRestarts = containerStatuses.reduce(\n    (sum, cs) =&gt; sum + (cs.restartCount || 0), \n    0\n  );\n\n  // Check readiness\n  const readyCondition = conditions.find(c =&gt; c.type === 'Ready');\n  const isReady = readyCondition?.status === 'True';\n\n  // Check container states\n  const containerHealth = containerStatuses.map(cs =&gt; ({\n    name: cs.name,\n    ready: cs.ready,\n    restartCount: cs.restartCount || 0,\n    state: cs.state?.running ? 'Running' \n      : cs.state?.waiting ? `Waiting: ${cs.state.waiting.reason}` \n      : cs.state?.terminated ? `Terminated: ${cs.state.terminated.reason}`\n      : 'Unknown',\n    lastState: cs.lastState?.terminated \n      ? `Previously terminated: ${cs.lastState.terminated.reason}`\n      : undefined\n  }));\n\n  // Overall health assessment\n  const healthStatus = \n    status?.phase === 'Running' &amp;&amp; isReady &amp;&amp; totalRestarts === 0 ? 'Healthy' :\n    status?.phase === 'Running' &amp;&amp; totalRestarts &gt; 0 ? 'Unstable' :\n    status?.phase === 'Pending' ? 'Starting' :\n    status?.phase === 'Failed' ? 'Failed' :\n    'Unknown';\n\n  return {\n    phase: status?.phase,\n    healthStatus,\n    isReady,\n    totalRestarts,\n    age: pod.metadata?.creationTimestamp \n      ? Math.floor((Date.now() - new Date(pod.metadata.creationTimestamp).getTime()) / 1000 / 60)\n      : 0,\n    conditions: conditions.map(c =&gt; ({\n      type: c.type,\n      status: c.status,\n      reason: c.reason,\n      message: c.message\n    })),\n    containers: containerHealth\n  };\n}\n</code></pre> <p></p> <p>Add the events retrieval method:</p> <pre><code>private async getPodEvents(namespace: string, podName: string): Promise&lt;any[]&gt; {\n  try {\n    const response = await this.k8sCoreApi.listNamespacedEvent({\n      namespace,\n      fieldSelector: `involvedObject.name=${podName}`\n    });\n\n    const events = (response.items || [])\n      .sort((a, b) =&gt; {\n        const timeA = a.lastTimestamp || a.firstTimestamp || '';\n        const timeB = b.lastTimestamp || b.firstTimestamp || '';\n        return timeB.localeCompare(timeA);\n      })\n      .slice(0, 10) // Last 10 events\n      .map(event =&gt; ({\n        type: event.type,\n        reason: event.reason,\n        message: event.message,\n        count: event.count,\n        time: event.lastTimestamp || event.firstTimestamp\n      }));\n\n    return events;\n  } catch (error) {\n    console.error('Failed to retrieve events:', error);\n    return [];\n  }\n}\n</code></pre> <p></p> <p>Test the monitoring functionality:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>Try these test cases:</p> <ul> <li>Monitor a specific pod: Set <code>namespace</code> and <code>podName</code></li> <li>Check all pods in namespace: Set only <code>namespace</code></li> <li>Include events: Set <code>includeEvents</code> to true</li> <li>Look for unhealthy pods with high restart counts</li> </ul> <p>Extension Ideas</p> <p>Now that you have a robust K-Agent, consider these additional enhancements:</p> <ul> <li>Resource Metrics: Add CPU/memory usage monitoring using the Metrics API</li> <li>Multi-Cluster Support: Extend to work with multiple Kubernetes clusters</li> <li>Alerting: Implement threshold-based alerts for restart counts or error rates</li> <li>Log Aggregation: Integrate with log aggregation systems like ELK or Loki</li> <li>Historical Analysis: Store and analyze trends over time</li> <li>Auto-Remediation: Add tools to automatically restart or scale problematic pods</li> </ul>"},{"location":"Lab06-K-Agent/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Lab06-K-Agent/#common-issues","title":"Common Issues","text":"<p>\u201cKubernetes configuration not found\u201d - Ensure <code>kubectl</code> is installed and configured - Check <code>~/.kube/config</code> exists and is readable</p> <p>\u201cPod not found\u201d errors - Confirm pod names and namespaces are correct - Check pod status with <code>kubectl get pods</code></p>"},{"location":"Lab06-K-Agent/#debug-commands","title":"Debug Commands","text":"<pre><code># Check cluster access\nkubectl cluster-info\n\n# Verify service account permissions\nkubectl auth can-i list pods --as=system:serviceaccount:default:k-agent-sa\n\n# Check pod logs\nkubectl logs -n your-namespace your-pod-name\n</code></pre>"},{"location":"Lab06-K-Agent/#key-takeaways","title":"Key Takeaways","text":"<p>What You Learned</p> <ul> <li>K-Agent Architecture: Building specialized MCP servers for Kubernetes operations</li> <li>MCP Server Setup: Configuring TypeScript-based MCP servers with proper dependencies</li> <li>Kubernetes Client Integration: Using the @kubernetes/client-node library to interact with clusters</li> <li>Tool Implementation: Creating MCP tools for pod discovery and log collection</li> <li>Error Handling: Managing Kubernetes API errors and edge cases</li> <li>Testing with MCP Inspector: Using the Inspector to test and debug MCP tools</li> </ul> <p>Congratulations! You\u2019ve built a functional K-Agent with two core capabilities:</p> <ul> <li>Pod Discovery - List all pods across namespaces with status information</li> <li>Log Collection - Retrieve logs from pod containers with timestamp support</li> </ul>"},{"location":"Lab06-K-Agent/#whats-next","title":"What\u2019s Next?","text":"<p>Your K-Agent provides a foundation for more advanced Kubernetes automation. </p> <p>Consider exploring:</p> <ul> <li>Adding filtering, log analysis, and health monitoring</li> <li>Integrating your K-Agent with other MCP clients</li> <li>Adding more tools for resource management (deployments, services, configmaps)</li> <li>Implementing resource watching for real-time cluster monitoring</li> <li>Building custom tools specific to your set Kubernetes workflows</li> </ul>"},{"location":"Lab06-K-Agent/#additional-resources","title":"Additional Resources","text":"<ul> <li>Kubernetes API Documentation</li> <li>MCP SDK Reference</li> <li>Log Aggregation Patterns</li> </ul>"},{"location":"Lab06-K-Agent/lab6-tasks/","title":"MCP Lab Tasks - Lab 6: K-Agent","text":"<p>Welcome to Lab 6! In this lab, you\u2019ll build a K-Agent - an MCP server specialized for Kubernetes operations with a focus on log collection from all pods.</p> <p>The exercises build progressively, starting with basic Kubernetes client setup and culminating in a complete log collection system.</p>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-61-k-agent-project-setup","title":"Exercise 6.1: K-Agent Project Setup","text":"<p>Create a new MCP server project with Kubernetes dependencies.</p> Solution <pre><code># Create project directory\nmkdir k-agent-logs\ncd k-agent-logs\n\n# Initialize Node.js project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk @kubernetes/client-node\nnpm install -D typescript @types/node tsx\n\n# Create TypeScript configuration\nnpx tsc --init --target ES2022 --module NodeNext --moduleResolution NodeNext --esModuleInterop --allowSyntheticDefaultImports --strict --skipLibCheck --forceConsistentCasingInFileNames --outDir ./dist --rootDir ./src\n\n# Create source directory structure\nmkdir -p src\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-62-basic-k-agent-server-structure","title":"Exercise 6.2: Basic K-Agent Server Structure","text":"<p>Create the basic MCP server structure with Kubernetes client initialization.</p> Solution <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  private server: Server;\n  private k8sConfig: k8s.KubeConfig;\n  private k8sCoreApi: k8s.CoreV1Api;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    // Initialize Kubernetes client\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // Tools will be added in subsequent exercises\n  }\n\n  async start() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent server started\");\n  }\n}\n\n// Start the server\nconst server = new KAgentServer();\nserver.start().catch(console.error);\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-63-kubernetes-authentication","title":"Exercise 6.3: Kubernetes Authentication","text":"<p>Implement secure Kubernetes cluster authentication with proper error handling.</p> Solution <pre><code>private loadKubeConfig(): void {\n  try {\n    this.k8sConfig.loadFromDefault();\n\n    // Validate cluster access\n    this.validateClusterAccess();\n  } catch (error) {\n    throw new Error(`Kubernetes configuration error: ${error.message}`);\n  }\n}\n\nprivate async validateClusterAccess(): Promise&lt;void&gt; {\n  try {\n    // Test API access by listing namespaces\n    await this.k8sCoreApi.listNamespace();\n  } catch (error: any) {\n    if (error.response?.statusCode === 403) {\n      throw new Error('Access denied: Insufficient permissions to access Kubernetes cluster');\n    }\n    throw new Error(`Cluster access validation failed: ${error.message}`);\n  }\n}\n\nconstructor() {\n  // ... existing constructor code ...\n\n  // Initialize Kubernetes client\n  this.loadKubeConfig();\n}\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-64-pod-listing-tool","title":"Exercise 6.4: Pod Listing Tool","text":"<p>Implement a tool to list all pods across namespaces with their status.</p> Solution <pre><code>private setupHandlers() {\n  // Tools list handler\n  this.server.setRequestHandler(\"tools/list\", async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        }\n      ]\n    };\n  });\n\n  // Tools call handler\n  this.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n    const { name, arguments: args } = request.params;\n\n    switch (name) {\n      case \"list_pods\":\n        return await this.handleListPods(args);\n      default:\n        throw new Error(`Unknown tool: ${name}`);\n    }\n  });\n}\n\nprivate async handleListPods(args: any) {\n  try {\n    const namespace = args?.namespace;\n    const pods = namespace\n      ? await this.k8sCoreApi.listNamespacedPod(namespace)\n      : await this.k8sCoreApi.listPodForAllNamespaces();\n\n    const podInfo = pods.body.items.map(pod =&gt; ({\n      name: pod.metadata?.name,\n      namespace: pod.metadata?.namespace,\n      status: pod.status?.phase,\n      containers: pod.spec?.containers?.length || 0\n    }));\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Found ${podInfo.length} pods:\\n${podInfo.map(p =&gt;\n          `- ${p.namespace}/${p.name}: ${p.status} (${p.containers} containers)`\n        ).join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n\nprivate handleK8sError(error: any): Error {\n  if (error.response?.statusCode === 403) {\n    return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n  }\n\n  if (error.response?.statusCode === 404) {\n    return new Error('Resource not found: The specified namespace may not exist');\n  }\n\n  return new Error(`Kubernetes operation failed: ${error.message}`);\n}\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-65-single-pod-log-collection","title":"Exercise 6.5: Single Pod Log Collection","text":"<p>Implement log collection from a specific pod.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"get_pod_logs\",\n  description: \"Get logs from a specific pod\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace of the pod\"\n      },\n      podName: {\n        type: \"string\",\n        description: \"Name of the pod\"\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to retrieve\",\n        default: 100\n      }\n    },\n    required: [\"namespace\", \"podName\"]\n  }\n}\n\n// Add to tools call handler\ncase \"get_pod_logs\":\n  return await this.handleGetPodLogs(args);\n\nprivate async handleGetPodLogs(args: any) {\n  const { namespace, podName, tailLines = 100 } = args;\n\n  try {\n    const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n      podName,\n      namespace,\n      undefined, // container\n      false, // follow\n      undefined, // previous\n      undefined, // sinceSeconds\n      undefined, // sinceTime\n      tailLines, // tailLines\n      undefined, // timestamps\n      undefined // limitBytes\n    );\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Logs from pod ${namespace}/${podName}:\\n\\n${logResponse.body}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-66-multi-pod-log-collection","title":"Exercise 6.6: Multi-Pod Log Collection","text":"<p>Extend the system to collect logs from all pods in a namespace.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"collect_namespace_logs\",\n  description: \"Collect logs from all pods in a namespace\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to collect logs from\"\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines per pod\",\n        default: 50\n      }\n    },\n    required: [\"namespace\"]\n  }\n}\n\n// Add to tools call handler\ncase \"collect_namespace_logs\":\n  return await this.handleCollectNamespaceLogs(args);\n\nprivate async handleCollectNamespaceLogs(args: any) {\n  const { namespace, tailLines = 50 } = args;\n\n  try {\n    // Get all pods in namespace\n    const podsResponse = await this.k8sCoreApi.listNamespacedPod(namespace);\n    const pods = podsResponse.body.items.filter(pod =&gt;\n      pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n    );\n\n    if (pods.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: `No running pods found in namespace ${namespace}`\n        }]\n      };\n    }\n\n    const allLogs: string[] = [];\n\n    for (const pod of pods) {\n      const podName = pod.metadata?.name!;\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          namespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        allLogs.push(`=== ${podName} ===\\n${logResponse.body}\\n`);\n      } catch (error: any) {\n        allLogs.push(`=== ${podName} ===\\nError retrieving logs: ${error.message}\\n`);\n      }\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Logs from ${pods.length} pods in namespace ${namespace}:\\n\\n${allLogs.join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-67-all-namespace-log-collection","title":"Exercise 6.7: All-Namespace Log Collection","text":"<p>Implement the core feature: collect logs from all pods across all namespaces.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"collect_all_logs\",\n  description: \"Collect logs from all pods across all namespaces\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines per pod\",\n        default: 25\n      },\n      maxPods: {\n        type: \"number\",\n        description: \"Maximum number of pods to collect logs from\",\n        default: 50\n      }\n    }\n  }\n}\n\n// Add to tools call handler\ncase \"collect_all_logs\":\n  return await this.handleCollectAllLogs(args);\n\nprivate async handleCollectAllLogs(args: any) {\n  const { tailLines = 25, maxPods = 50 } = args;\n\n  try {\n    // Get all pods across all namespaces\n    const podsResponse = await this.k8sCoreApi.listPodForAllNamespaces();\n    const pods = podsResponse.body.items\n      .filter(pod =&gt;\n        pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n      )\n      .slice(0, maxPods); // Limit for performance\n\n    if (pods.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: \"No running pods found in the cluster\"\n        }]\n      };\n    }\n\n    const allLogs: string[] = [];\n    let processedCount = 0;\n\n    for (const pod of pods) {\n      const podName = pod.metadata?.name!;\n      const namespace = pod.metadata?.namespace!;\n\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          namespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        allLogs.push(`=== ${namespace}/${podName} ===\\n${logResponse.body}\\n`);\n        processedCount++;\n      } catch (error: any) {\n        allLogs.push(`=== ${namespace}/${podName} ===\\nError retrieving logs: ${error.message}\\n`);\n      }\n    }\n\n    const summary = `Collected logs from ${processedCount} out of ${pods.length} pods (limited to ${maxPods} max)\\n\\n`;\n\n    return {\n      content: [{\n        type: \"text\",\n        text: summary + allLogs.join('\\n')\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-68-log-filtering-and-search","title":"Exercise 6.8: Log Filtering and Search","text":"<p>Add filtering capabilities to search through logs.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"search_logs\",\n  description: \"Search for specific patterns in pod logs\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to search in (optional)\"\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Text pattern to search for\"\n      },\n      caseSensitive: {\n        type: \"boolean\",\n        description: \"Whether search should be case sensitive\",\n        default: false\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to search through\",\n        default: 100\n      }\n    },\n    required: [\"pattern\"]\n  }\n}\n\n// Add to tools call handler\ncase \"search_logs\":\n  return await this.handleSearchLogs(args);\n\nprivate async handleSearchLogs(args: any) {\n  const { namespace, pattern, caseSensitive = false, tailLines = 100 } = args;\n\n  try {\n    const podsResponse = namespace\n      ? await this.k8sCoreApi.listNamespacedPod(namespace)\n      : await this.k8sCoreApi.listPodForAllNamespaces();\n\n    const runningPods = podsResponse.body.items.filter(pod =&gt;\n      pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n    );\n\n    const matches: string[] = [];\n    const flags = caseSensitive ? 'g' : 'gi';\n    const regex = new RegExp(pattern, flags);\n\n    for (const pod of runningPods) {\n      const podName = pod.metadata?.name!;\n      const podNamespace = pod.metadata?.namespace!;\n\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          podNamespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        const logs = logResponse.body;\n        const lines = logs.split('\\n');\n\n        const matchingLines = lines\n          .map((line, index) =&gt; ({ line, index }))\n          .filter(({ line }) =&gt; regex.test(line))\n          .map(({ line, index }) =&gt; `  Line ${index + 1}: ${line}`);\n\n        if (matchingLines.length &gt; 0) {\n          matches.push(`=== ${podNamespace}/${podName} ===`);\n          matches.push(...matchingLines);\n          matches.push('');\n        }\n      } catch (error) {\n        // Skip pods where we can't read logs\n      }\n    }\n\n    if (matches.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: `No logs matching pattern \"${pattern}\" found`\n        }]\n      };\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Found ${matches.length} matches for pattern \"${pattern}\":\\n\\n${matches.join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-69-resource-integration","title":"Exercise 6.9: Resource Integration","text":"<p>Create MCP resources for recent log summaries.</p> Solution <pre><code>constructor() {\n  this.server = new Server(\n    {\n      name: \"k-agent-logs\",\n      version: \"1.0.0\",\n    },\n    {\n      capabilities: {\n        tools: {},\n        resources: {},\n      },\n    }\n  );\n\n  // ... rest of constructor\n}\n\nprivate setupHandlers() {\n  // ... existing tools setup ...\n\n  // Resources handlers\n  this.server.setRequestHandler(\"resources/list\", async () =&gt; {\n    return {\n      resources: [\n        {\n          uri: \"logs://cluster/summary\",\n          name: \"Cluster Logs Summary\",\n          description: \"Summary of recent logs from all pods\",\n          mimeType: \"application/json\"\n        }\n      ]\n    };\n  });\n\n  this.server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n    const { uri } = request.params;\n\n    if (uri === \"logs://cluster/summary\") {\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify(await this.getClusterLogsSummary(), null, 2)\n        }]\n      };\n    }\n\n    throw new Error(`Resource not found: ${uri}`);\n  });\n}\n\nprivate async getClusterLogsSummary() {\n  try {\n    const podsResponse = await this.k8sCoreApi.listPodForAllNamespaces();\n    const pods = podsResponse.body.items;\n\n    const summary = {\n      timestamp: new Date().toISOString(),\n      totalPods: pods.length,\n      runningPods: pods.filter(p =&gt; p.status?.phase === 'Running').length,\n      namespaces: [...new Set(pods.map(p =&gt; p.metadata?.namespace))].length,\n      podStatusCounts: pods.reduce((acc, pod) =&gt; {\n        const phase = pod.status?.phase || 'Unknown';\n        acc[phase] = (acc[phase] || 0) + 1;\n        return acc;\n      }, {} as Record&lt;string, number&gt;)\n    };\n\n    return summary;\n  } catch (error: any) {\n    return {\n      error: `Failed to get cluster summary: ${error.message}`,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-610-error-handling-and-validation","title":"Exercise 6.10: Error Handling and Validation","text":"<p>Implement comprehensive error handling and input validation.</p> Solution <pre><code>private validateToolArguments(toolName: string, args: any): void {\n  switch (toolName) {\n    case 'list_pods':\n      if (args?.namespace &amp;&amp; typeof args.namespace !== 'string') {\n        throw new Error('namespace must be a string');\n      }\n      break;\n\n    case 'get_pod_logs':\n      if (!args?.namespace || typeof args.namespace !== 'string') {\n        throw new Error('namespace is required and must be a string');\n      }\n      if (!args?.podName || typeof args.podName !== 'string') {\n        throw new Error('podName is required and must be a string');\n      }\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      break;\n\n    case 'collect_namespace_logs':\n      if (!args?.namespace || typeof args.namespace !== 'string') {\n        throw new Error('namespace is required and must be a string');\n      }\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      break;\n\n    case 'collect_all_logs':\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      if (args?.maxPods &amp;&amp; (typeof args.maxPods !== 'number' || args.maxPods &lt; 1)) {\n        throw new Error('maxPods must be a positive number');\n      }\n      break;\n\n    case 'search_logs':\n      if (!args?.pattern || typeof args.pattern !== 'string') {\n        throw new Error('pattern is required and must be a string');\n      }\n      if (args?.namespace &amp;&amp; typeof args.namespace !== 'string') {\n        throw new Error('namespace must be a string');\n      }\n      break;\n  }\n}\n\n// Update tools call handler to include validation\nthis.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  // Validate arguments\n  this.validateToolArguments(name, args);\n\n  switch (name) {\n    // ... existing cases\n  }\n});\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-611-package-configuration","title":"Exercise 6.11: Package Configuration","text":"<p>Create proper package.json and tsconfig.json for the K-Agent.</p> Solution <p>package.json: <pre><code>{\n  \"name\": \"k-agent-logs\",\n  \"version\": \"1.0.0\",\n  \"description\": \"K-Agent MCP server for Kubernetes log collection\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\",\n    \"test\": \"echo \\\"No tests specified\\\"\"\n  },\n  \"keywords\": [\"mcp\", \"kubernetes\", \"logs\", \"monitoring\"],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@kubernetes/client-node\": \"^0.20.0\",\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre></p> <p>tsconfig.json: <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre></p>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-612-docker-configuration","title":"Exercise 6.12: Docker Configuration","text":"<p>Create a Dockerfile for containerized deployment.</p> Solution <pre><code>FROM node:18-alpine\n\n# Install kubectl\nRUN apk add --no-cache curl &amp;&amp; \\\n    curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" &amp;&amp; \\\n    install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl &amp;&amp; \\\n    rm kubectl &amp;&amp; \\\n    kubectl version --client\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nCOPY tsconfig.json ./\n\n# Install dependencies\nRUN npm ci --only=production &amp;&amp; npm cache clean --force\n\n# Copy source code\nCOPY src/ ./src/\n\n# Build TypeScript\nRUN npm run build\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs &amp;&amp; \\\n    adduser -S kagent -u 1001\n\n# Change ownership\nRUN chown -R kagent:nodejs /app\nUSER kagent\n\nEXPOSE 3000\n\nCMD [\"npm\", \"start\"]\n</code></pre>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-613-testing-the-k-agent","title":"Exercise 6.13: Testing the K-Agent","text":"<p>Create a test script to verify all functionality.</p> Solution <p>test-kagent.js: <pre><code>const { spawn } = require('child_process');\n\nasync function testKAgent() {\n  console.log('Testing K-Agent functionality...\\n');\n\n  const server = spawn('node', ['dist/index.js'], {\n    stdio: ['pipe', 'pipe', 'pipe']\n  });\n\n  // Give server time to start\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  const tests = [\n    {\n      name: 'List tools',\n      request: {\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/list',\n        params: {}\n      }\n    },\n    {\n      name: 'List pods',\n      request: {\n        jsonrpc: '2.0',\n        id: 2,\n        method: 'tools/call',\n        params: {\n          name: 'list_pods'\n        }\n      }\n    }\n  ];\n\n  for (const test of tests) {\n    console.log(`Running test: ${test.name}`);\n\n    server.stdin.write(JSON.stringify(test.request) + '\\n');\n\n    // Wait for response\n    await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n  }\n\n  server.kill();\n  console.log('\\nTesting completed!');\n}\n\ntestKAgent().catch(console.error);\n</code></pre></p>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-614-production-deployment-manifest","title":"Exercise 6.14: Production Deployment Manifest","text":"<p>Create Kubernetes deployment manifests for production deployment.</p> Solution <p>k8s-deployment.yaml: <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: k-agent-sa\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: k-agent-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/log\", \"namespaces\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: k-agent-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: k-agent-role\nsubjects:\n- kind: ServiceAccount\n  name: k-agent-sa\n  namespace: default\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: k-agent-logs\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: k-agent-logs\n  template:\n    metadata:\n      labels:\n        app: k-agent-logs\n    spec:\n      serviceAccountName: k-agent-sa\n      containers:\n      - name: k-agent\n        image: your-registry/k-agent-logs:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: k-agent-service\n  namespace: default\nspec:\n  selector:\n    app: k-agent-logs\n  ports:\n  - port: 3000\n    targetPort: 3000\n  type: ClusterIP\n</code></pre></p>"},{"location":"Lab06-K-Agent/lab6-tasks/#exercise-615-complete-integration-test","title":"Exercise 6.15: Complete Integration Test","text":"<p>Create a comprehensive integration test that exercises all K-Agent capabilities.</p> Solution <p>integration-test.js: <pre><code>const { spawn } = require('child_process');\nconst fs = require('fs');\n\nasync function runIntegrationTest() {\n  console.log('\ud83d\ude80 Starting K-Agent Integration Test\\n');\n\n  const server = spawn('node', ['dist/index.js'], {\n    stdio: ['pipe', 'pipe', 'inherit']\n  });\n\n  let requestId = 1;\n\n  function sendRequest(method, params = {}) {\n    const request = {\n      jsonrpc: '2.0',\n      id: requestId++,\n      method,\n      params\n    };\n    server.stdin.write(JSON.stringify(request) + '\\n');\n  }\n\n  // Wait for server to start\n  await new Promise(resolve =&gt; setTimeout(resolve, 3000));\n\n  console.log('\ud83d\udccb Testing tools/list...');\n  sendRequest('tools/list');\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n  console.log('\ud83d\udccb Testing tools/call - list_pods...');\n  sendRequest('tools/call', {\n    name: 'list_pods',\n    arguments: { namespace: 'default' }\n  });\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  console.log('\ud83d\udccb Testing resources/list...');\n  sendRequest('resources/list');\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n  console.log('\ud83d\udccb Testing resources/read...');\n  sendRequest('resources/read', {\n    uri: 'logs://cluster/summary'\n  });\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  console.log('\ud83d\udd0d Testing search functionality...');\n  sendRequest('tools/call', {\n    name: 'search_logs',\n    arguments: {\n      pattern: 'error|Error|ERROR',\n      tailLines: 50\n    }\n  });\n\n  // Wait for all responses\n  await new Promise(resolve =&gt; setTimeout(resolve, 5000));\n\n  server.kill();\n  console.log('\\n\u2705 Integration test completed!');\n}\n\n// Run the test\nrunIntegrationTest().catch(error =&gt; {\n  console.error('\u274c Integration test failed:', error);\n  process.exit(1);\n});\n</code></pre></p>"},{"location":"Resources/001-MCP-Basics/001-MCP-Basics-py/","title":"001 MCP Basics py","text":""},{"location":"Resources/001-MCP-Basics/001-MCP-Basics-py/#mcp-basics-with-python","title":"MCP Basics with Python","text":"<pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create server instance\nmcp = FastMCP(\"kagent-mcp-server\")\n\n@mcp.tool()\ndef hello(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to K-Agent Labs.\"\n\n@mcp.tool()\ndef add(a: float, b: float) -&gt; str:\n    \"\"\"Adds two numbers together\"\"\"\n    result = a + b\n    return f\"The sum of {a} and {b} is {result}\"\n\ndef main():\n    # Initialize and run the server\n    mcp.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Resources/001-MCP-Basics/002-MCP-Basics-ts/","title":"MCP Server Example (TS)","text":"<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * K-Agent MCP Server\n * A simple Model Context Protocol server with example tools\n */\n\n// Create server instance\nconst server = new Server(\n  {\n    name: \"kagent-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\n// List available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n  return {\n    tools: [\n      {\n        name: \"hello\",\n        description: \"Returns a friendly greeting message\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            name: {\n              type: \"string\",\n              description: \"Name to greet\",\n            },\n          },\n          required: [\"name\"],\n        },\n      },\n      {\n        name: \"add\",\n        description: \"Adds two numbers together\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            a: {\n              type: \"number\",\n              description: \"First number\",\n            },\n            b: {\n              type: \"number\",\n              description: \"Second number\",\n            },\n          },\n          required: [\"a\", \"b\"],\n        },\n      },\n    ],\n  };\n});\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  switch (name) {\n    case \"hello\": {\n      const nameArg = args?.name as string;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Hello, ${nameArg}! Welcome to K-Agent Labs.`,\n          },\n        ],\n      };\n    }\n\n    case \"add\": {\n      const a = args?.a as number;\n      const b = args?.b as number;\n      const result = a + b;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `The sum of ${a} and ${b} is ${result}`,\n          },\n        ],\n      };\n    }\n\n    default:\n      throw new Error(`Unknown tool: ${name}`);\n  }\n});\n\n// Start the server\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"K-Agent MCP Server running on stdio\");\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Server error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/","title":"003 - MCP Advanced (PY)","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#mcp-basics-with-python","title":"MCP Basics with Python","text":"<pre><code>from mcp.server.fastmcp import FastMCP\nfrom starlette.responses import Response, JSONResponse, StreamingResponse\nfrom starlette.requests import Request\nimport types\nimport httpx\nimport json\nimport asyncio\nimport time\nimport inspect\nfrom typing import Any, Dict, List\n\n# Ollama configuration\nOLLAMA_BASE_URL = \"http://localhost:11434\"\nDEFAULT_MODEL = \"codestral:latest\"\n\n# Tool execution tracking\nTOOL_EXECUTIONS = {}\nEXECUTION_COUNTER = 0\n\nmcp = FastMCP(\"kagent-mcp-server\", port=8889)\n\n# Backwards-compat shim: some inspector tooling (fastmcp helpers)\n# expect a `_list_tools_mcp` coroutine on the server instance. Provide\n# a thin wrapper that forwards to the FastMCP `list_tools` implementation.\nasync def _list_tools_mcp(self):\n    return await self.list_tools()\n\n# Bind the method to the instance\n# MCP need to access it as an instance method later\n# This will return list of ToolMetadata objects\nmcp._list_tools_mcp = types.MethodType(_list_tools_mcp, mcp)\n\n# Common CORS headers used by the inspector (browser-based)\nHEADERS = {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET,POST,OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type,Authorization,X-Proxy-Token\",\n}\n\n# Helper functions for tool execution\ndef get_tool_function(tool_name: str):\n    \"\"\"Get the actual function for a tool by name\"\"\"\n    # Build a mapping of tool names to functions\n    tool_map = {\n        'hello': hello,\n        'add': add,\n        'ollama_generate': ollama_generate,\n        'ollama_chat': ollama_chat,\n        'ollama_list_models': ollama_list_models,\n        'code_review_prompt': code_review_prompt,\n        'debug_prompt': debug_prompt,\n    }\n    return tool_map.get(tool_name)\n\ndef validate_tool_arguments(tool_func, arguments: Dict[str, Any]) -&gt; tuple[bool, str]:\n    \"\"\"Validate arguments against function signature\"\"\"\n    try:\n        sig = inspect.signature(tool_func)\n        params = sig.parameters\n\n        # Check required arguments\n        for param_name, param in params.items():\n            if param.default == inspect.Parameter.empty and param_name not in arguments:\n                return False, f\"Missing required argument: {param_name}\"\n\n        # Check for unexpected arguments\n        for arg_name in arguments:\n            if arg_name not in params:\n                return False, f\"Unexpected argument: {arg_name}\"\n\n        return True, \"Valid\"\n    except Exception as e:\n        return False, f\"Validation error: {str(e)}\"\n\nasync def execute_tool(tool_name: str, arguments: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute a tool and return the result\"\"\"\n    global EXECUTION_COUNTER\n    execution_id = f\"exec_{EXECUTION_COUNTER}\"\n    EXECUTION_COUNTER += 1\n\n    start_time = time.time()\n\n    try:\n        tool_func = get_tool_function(tool_name)\n        if not tool_func:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": f\"Tool '{tool_name}' not found\",\n                \"duration_ms\": 0\n            }\n\n        # Validate arguments\n        valid, message = validate_tool_arguments(tool_func, arguments)\n        if not valid:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": message,\n                \"duration_ms\": 0\n            }\n\n        # Execute the tool\n        if inspect.iscoroutinefunction(tool_func):\n            result = await tool_func(**arguments)\n        else:\n            result = tool_func(**arguments)\n\n        duration_ms = (time.time() - start_time) * 1000\n\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": True,\n            \"result\": result,\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n\n    except Exception as e:\n        duration_ms = (time.time() - start_time) * 1000\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": False,\n            \"error\": str(e),\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n\n# Example tool definitions\n# These will be automatically registered with the MCP server\n@mcp.tool()\ndef hello(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to K-Agent Labs.\"\n\n# Example tool that adds two numbers\n# Demonstrates handling of numeric inputs and outputs\n# This will become MCP tool available at /tools\n@mcp.tool()\ndef add(a: float, b: float) -&gt; str:\n    \"\"\"Adds two numbers together\"\"\"\n    result = a + b\n    return f\"The sum of {a} and {b} is {result}\"\n\n# Ollama integration tools\n@mcp.tool()\ndef ollama_generate(prompt: str, model: str = DEFAULT_MODEL, max_tokens: int = 500) -&gt; str:\n    \"\"\"Generate text using Ollama LLM\"\"\"\n    try:\n        import requests\n        response = requests.post(\n            f\"{OLLAMA_BASE_URL}/api/generate\",\n            json={\n                \"model\": model,\n                \"prompt\": prompt,\n                \"stream\": False,\n                \"options\": {\n                    \"num_predict\": max_tokens\n                }\n            },\n            timeout=60\n        )\n        if response.status_code == 200:\n            result = response.json()\n            return result.get(\"response\", \"No response from model\")\n        else:\n            return f\"Error: {response.status_code} - {response.text}\"\n    except Exception as e:\n        return f\"Error calling Ollama: {str(e)}\"\n\n@mcp.tool()\ndef ollama_chat(message: str, model: str = DEFAULT_MODEL, system: str = \"\") -&gt; str:\n    \"\"\"Chat with Ollama LLM using chat API\"\"\"\n    try:\n        import requests\n        messages = []\n        if system:\n            messages.append({\"role\": \"system\", \"content\": system})\n        messages.append({\"role\": \"user\", \"content\": message})\n\n        response = requests.post(\n            f\"{OLLAMA_BASE_URL}/api/chat\",\n            json={\n                \"model\": model,\n                \"messages\": messages,\n                \"stream\": False\n            },\n            timeout=60\n        )\n        if response.status_code == 200:\n            result = response.json()\n            return result.get(\"message\", {}).get(\"content\", \"No response\")\n        else:\n            return f\"Error: {response.status_code} - {response.text}\"\n    except Exception as e:\n        return f\"Error calling Ollama: {str(e)}\"\n\n@mcp.tool()\ndef ollama_list_models() -&gt; str:\n    \"\"\"List available Ollama models\"\"\"\n    try:\n        import requests\n        response = requests.get(f\"{OLLAMA_BASE_URL}/api/tags\", timeout=5)\n        if response.status_code == 200:\n            data = response.json()\n            models = data.get(\"models\", [])\n            if not models:\n                return \"No models available\"\n\n            result = \"Available Ollama models:\\n\"\n            for model in models:\n                name = model.get(\"name\", \"unknown\")\n                size = model.get(\"size\", 0) // (1024**3)  # Convert to GB\n                result += f\"- {name} ({size}GB)\\n\"\n            return result\n        else:\n            return f\"Error: {response.status_code}\"\n    except Exception as e:\n        return f\"Error listing models: {str(e)}\"\n\n# Prompts - Reusable prompt templates\n@mcp.prompt()\ndef code_review_prompt(code: str, language: str = \"python\") -&gt; str:\n    \"\"\"Generate a code review prompt for the given code\"\"\"\n    return f\"\"\"Please review this {language} code and provide feedback:\n\n```{language}\n{code}\n</code></pre> <p>Focus on: - Code quality and best practices - Potential bugs or issues - Performance improvements - Security concerns \u201c\u201d\u201c</p> <p>@mcp.prompt() def debug_prompt(error_message: str, code_context: str = \u201c\u201d) -&gt; str:     \u201c\u201d\u201cGenerate a debugging prompt\u201d\u201c\u201d     prompt = f\u201d\u201c\u201dHelp me debug this error:</p> <p>Error: {error_message} \u201c\u201d\u201d     if code_context:         prompt += f\u201d\\n\\nCode context:\\n<code>\\n{code_context}\\n</code>\u201d     return prompt</p>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#resource-to-return-the-source-code-of-this-server","title":"Resource to return the source code of this server","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#useful-for-inspection-and-learning-purposes","title":"Useful for inspection and learning purposes","text":"<p>@mcp.resource(\u201cmcp://code\u201d) def get_code() -&gt; str:     \u201c\u201d\u201cReturns the source code of this server\u201d\u201c\u201d     with open(file, \u201cr\u201d) as f:         return f.read()</p> <p>@mcp.resource(\u201cmcp://server-info\u201d) def get_server_info() -&gt; str:     \u201c\u201d\u201cReturns information about this MCP server\u201d\u201c\u201d     return \u201c\u201d\u201cK-Agent MCP Server</p> <p>Version: 0.1.0 Capabilities: - Tools: hello, add - Prompts: code_review_prompt, debug_prompt - Resources: code, server-info - Sampling: LLM sampling support - Roots: File system access \u201c\u201d\u201c</p> <p>@mcp.custom_route(\u201c/\u201d, methods=[\u201cGET\u201d, \u201cOPTIONS\u201d]) async def root_health_check(request: Request) -&gt; Response:     return Response(\u201cMCP Server Running\u201d, status_code=200, headers=HEADERS)</p>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#health-check-endpoints","title":"Health check endpoints","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#mcp-manifest-endpoint-negotiation-and-tools-listing","title":"MCP manifest endpoint, negotiation, and tools listing","text":"<p>@mcp.custom_route(\u201c/health\u201d, methods=[\u201cGET\u201d, \u201cOPTIONS\u201d]) async def health_check(request: Request) -&gt; Response:     return Response(\u201cMCP Server Running\u201d, status_code=200, headers=HEADERS)</p>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#mcp-manifest-endpoint-as-per-mcp-specification","title":"MCP Manifest endpoint as per MCP specification","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#provides-metadata-about-the-mcp-server","title":"Provides metadata about the MCP server","text":"<p>@mcp.custom_route(\u201c/.well-known/mcp\u201d, methods=[\u201cGET\u201d, \u201cOPTIONS\u201d]) async def mcp_manifest(request: Request) -&gt; JSONResponse:     host = request.headers.get(\u201chost\u201d, \u201clocalhost:8889\u201d)     scheme = request.url.scheme or \u201chttp\u201d     base = f\u201d{scheme}://{host}\u201d     manifest = {         \u201cname\u201d: \u201ckagent-mcp-server\u201d,         \u201cversion\u201d: \u201c0.1.0\u201d,         \u201cbase_url\u201d: base,         \u201ctransport\u201d: \u201cstreamable-http\u201d,         \u201ccapabilities\u201d: {             \u201ctools\u201d: True,             \u201cprompts\u201d: True,             \u201cresources\u201d: True,             \u201csampling\u201d: True,             \u201croots\u201d: True,             \u201clogging\u201d: True         },         \u201cendpoints\u201d: {             \u201cmanifest\u201d: \u201c/.well-known/mcp\u201d,             \u201chealth\u201d: \u201c/health\u201d,             \u201cping\u201d: \u201c/ping\u201d,             \u201croot\u201d: \u201c/\u201d,             \u201cnegotiate\u201d: \u201c/negotiate\u201d,             \u201cmetadata\u201d: \u201c/metadata\u201d,             \u201cevents\u201d: \u201c/mcp\u201d,             \u201ctools\u201d: \u201c/tools\u201d,             \u201ctools_execute\u201d: \u201c/tools/execute\u201d,             \u201ctools_batch\u201d: \u201c/tools/batch\u201d,             \u201ctools_stream\u201d: \u201c/tools/stream\u201d,             \u201ctools_history\u201d: \u201c/tools/history\u201d,             \u201cprompts\u201d: \u201c/prompts\u201d,             \u201cresources\u201d: \u201c/resources\u201d,             \u201csampling\u201d: \u201c/sampling\u201d,             \u201croots\u201d: \u201c/roots\u201d,             \u201collama_status\u201d: \u201c/ollama/status\u201d,         },     }     return JSONResponse(manifest, headers=HEADERS)</p>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#mcp-negotiation-endpoint","title":"MCP Negotiation endpoint","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#clients-use-this-to-negotiate-connection-parameters","title":"Clients use this to negotiate connection parameters","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#supports-token-based-authentication","title":"Supports token-based authentication","text":"<p>@mcp.custom_route(\u201c/negotiate\u201d, methods=[\u201cGET\u201d, \u201cPOST\u201d, \u201cOPTIONS\u201d]) async def negotiate(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>host = request.headers.get(\"host\", \"localhost:8889\")\nscheme = request.url.scheme or \"http\"\nmcp_url = f\"{scheme}://{host}/mcp\"\n\n# Accept proxy token from query param, X-Proxy-Token header, or Authorization bearer\ntoken = request.query_params.get(\"token\") or request.headers.get(\"x-proxy-token\") or request.headers.get(\"X-Proxy-Token\")\nauth = request.headers.get(\"authorization\") or request.headers.get(\"Authorization\")\nif not token and auth and auth.lower().startswith(\"bearer \"):\n    token = auth.split(None, 1)[1]\n\nresponse = {\n    \"transport\": \"streamable-http\",\n    \"url\": mcp_url,\n}\n\n# Include token in response if provided\nif token:\n    response[\"proxy_token\"] = token\nelse:\n    # When no token is provided, explicitly indicate no auth is required\n    # This helps the Inspector understand it can connect without authentication\n    response[\"requiresAuth\"] = False\n\nreturn JSONResponse(response, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#tools-listing-endpoint","title":"Tools listing endpoint","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#returns-metadata-about-all-registered-tools","title":"Returns metadata about all registered tools","text":""},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#used-by-inspectors-to-discover-available-tools","title":"Used by inspectors to discover available tools","text":"<p>@mcp.custom_route(\u201c/tools\u201d, methods=[\u201cPOST\u201d, \u201cGET\u201d, \u201cOPTIONS\u201d]) async def tools_list(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code># Use the server's list_tools implementation so the inspector sees\n# the canonical, generated tool metadata instead of a hand-written list.\ntools = await mcp._list_tools_mcp()\n\nserializable = []\nfor t in tools:\n    try:\n        serializable.append(t.model_dump())\n    except Exception:\n        try:\n            serializable.append(t.dict())\n        except Exception:\n            serializable.append(str(t))\n\nreturn JSONResponse({\"tools\": serializable}, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#tool-execution-endpoint-execute-a-single-tool","title":"Tool execution endpoint - Execute a single tool","text":"<p>@mcp.custom_route(\u201c/tools/execute\u201d, methods=[\u201cPOST\u201d, \u201cOPTIONS\u201d]) async def tool_execute(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>try:\n    body = await request.json()\n    tool_name = body.get(\"tool\")\n    arguments = body.get(\"arguments\", {})\n\n    if not tool_name:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": \"Missing 'tool' field\"\n        }, headers=HEADERS, status_code=400)\n\n    result = await execute_tool(tool_name, arguments)\n    return JSONResponse(result, headers=HEADERS)\n\nexcept Exception as e:\n    return JSONResponse({\n        \"success\": False,\n        \"error\": f\"Execution failed: {str(e)}\"\n    }, headers=HEADERS, status_code=500)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#batch-tool-execution-endpoint","title":"Batch tool execution endpoint","text":"<p>@mcp.custom_route(\u201c/tools/batch\u201d, methods=[\u201cPOST\u201d, \u201cOPTIONS\u201d]) async def tool_batch_execute(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>try:\n    body = await request.json()\n    calls = body.get(\"calls\", [])\n\n    if not calls:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": \"Missing 'calls' array\"\n        }, headers=HEADERS, status_code=400)\n\n    results = []\n    for call in calls:\n        tool_name = call.get(\"tool\")\n        arguments = call.get(\"arguments\", {})\n\n        if tool_name:\n            result = await execute_tool(tool_name, arguments)\n            results.append(result)\n        else:\n            results.append({\n                \"success\": False,\n                \"error\": \"Missing tool name in call\"\n            })\n\n    return JSONResponse({\n        \"success\": True,\n        \"results\": results,\n        \"total\": len(results)\n    }, headers=HEADERS)\n\nexcept Exception as e:\n    return JSONResponse({\n        \"success\": False,\n        \"error\": f\"Batch execution failed: {str(e)}\"\n    }, headers=HEADERS, status_code=500)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#tool-execution-history-endpoint","title":"Tool execution history endpoint","text":"<p>@mcp.custom_route(\u201c/tools/history\u201d, methods=[\u201cGET\u201d, \u201cOPTIONS\u201d]) async def tool_history(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>limit = int(request.query_params.get(\"limit\", 10))\n\n# Get recent executions\nexecutions = list(TOOL_EXECUTIONS.values())\nexecutions.sort(key=lambda x: x.get(\"timestamp\", 0), reverse=True)\n\nreturn JSONResponse({\n    \"executions\": executions[:limit],\n    \"total\": len(executions)\n}, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#get-specific-execution-details","title":"Get specific execution details","text":"<p>@mcp.custom_route(\u201c/tools/execution/{execution_id}\u201d, methods=[\u201cGET\u201d, \u201cOPTIONS\u201d]) async def tool_execution_detail(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>execution_id = request.path_params.get(\"execution_id\")\n\nif execution_id in TOOL_EXECUTIONS:\n    return JSONResponse(TOOL_EXECUTIONS[execution_id], headers=HEADERS)\nelse:\n    return JSONResponse({\n        \"error\": f\"Execution '{execution_id}' not found\"\n    }, headers=HEADERS, status_code=404)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#streaming-tool-execution","title":"Streaming tool execution","text":"<p>@mcp.custom_route(\u201c/tools/stream\u201d, methods=[\u201cPOST\u201d, \u201cOPTIONS\u201d]) async def tool_stream_execute(request: Request):     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>try:\n    body = await request.json()\n    tool_name = body.get(\"tool\")\n    arguments = body.get(\"arguments\", {})\n\n    async def generate_stream():\n        # Send start event\n        yield json.dumps({\n            \"event\": \"start\",\n            \"tool\": tool_name,\n            \"timestamp\": time.time()\n        }) + \"\\n\"\n\n        # Execute tool\n        result = await execute_tool(tool_name, arguments)\n\n        # Send result event\n        yield json.dumps({\n            \"event\": \"result\",\n            \"data\": result\n        }) + \"\\n\"\n\n        # Send end event\n        yield json.dumps({\n            \"event\": \"end\",\n            \"timestamp\": time.time()\n        }) + \"\\n\"\n\n    return StreamingResponse(\n        generate_stream(),\n        media_type=\"application/x-ndjson\",\n        headers=HEADERS\n    )\n\nexcept Exception as e:\n    return JSONResponse({\n        \"success\": False,\n        \"error\": f\"Stream execution failed: {str(e)}\"\n    }, headers=HEADERS, status_code=500)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#prompts-listing-endpoint","title":"Prompts listing endpoint","text":"<p>@mcp.custom_route(\u201c/prompts\u201d, methods=[\u201cPOST\u201d, \u201cGET\u201d, \u201cOPTIONS\u201d]) async def prompts_list(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>prompts = [\n    {\n        \"name\": \"code_review_prompt\",\n        \"description\": \"Generate a code review prompt for the given code\",\n        \"arguments\": [\n            {\"name\": \"code\", \"description\": \"The code to review\", \"required\": True},\n            {\"name\": \"language\", \"description\": \"Programming language\", \"required\": False}\n        ]\n    },\n    {\n        \"name\": \"debug_prompt\",\n        \"description\": \"Generate a debugging prompt\",\n        \"arguments\": [\n            {\"name\": \"error_message\", \"description\": \"The error message\", \"required\": True},\n            {\"name\": \"code_context\", \"description\": \"Relevant code context\", \"required\": False}\n        ]\n    }\n]\n\nreturn JSONResponse({\"prompts\": prompts}, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#resources-listing-endpoint","title":"Resources listing endpoint","text":"<p>@mcp.custom_route(\u201c/resources\u201d, methods=[\u201cPOST\u201d, \u201cGET\u201d, \u201cOPTIONS\u201d]) async def resources_list(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>resources = [\n    {\n        \"uri\": \"mcp://code\",\n        \"name\": \"Server Source Code\",\n        \"description\": \"Returns the source code of this server\",\n        \"mimeType\": \"text/plain\"\n    },\n    {\n        \"uri\": \"mcp://server-info\",\n        \"name\": \"Server Information\",\n        \"description\": \"Returns information about this MCP server\",\n        \"mimeType\": \"text/plain\"\n    }\n]\n\nreturn JSONResponse({\"resources\": resources}, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#ping-endpoint-for-connection-health-checks","title":"Ping endpoint for connection health checks","text":"<p>@mcp.custom_route(\u201c/ping\u201d, methods=[\u201cPOST\u201d, \u201cGET\u201d, \u201cOPTIONS\u201d]) async def ping(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>return JSONResponse({\n    \"status\": \"ok\",\n    \"timestamp\": __import__('time').time(),\n    \"server\": \"kagent-mcp-server\"\n}, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#sampling-endpoint-llm-sampling-capability-using-ollama","title":"Sampling endpoint - LLM sampling capability using Ollama","text":"<p>@mcp.custom_route(\u201c/sampling\u201d, methods=[\u201cPOST\u201d, \u201cOPTIONS\u201d]) async def sampling(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>body = await request.json() if request.method == \"POST\" else {}\nprompt = body.get(\"prompt\", \"\")\nmax_tokens = body.get(\"maxTokens\", 100)\nmodel = body.get(\"model\", DEFAULT_MODEL)\n\ntry:\n    async with httpx.AsyncClient(timeout=60.0) as client:\n        response = await client.post(\n            f\"{OLLAMA_BASE_URL}/api/generate\",\n            json={\n                \"model\": model,\n                \"prompt\": prompt,\n                \"stream\": False,\n                \"options\": {\n                    \"num_predict\": max_tokens\n                }\n            }\n        )\n\n        if response.status_code == 200:\n            result = response.json()\n            return JSONResponse({\n                \"completion\": result.get(\"response\", \"\"),\n                \"stopReason\": \"endTurn\" if result.get(\"done\") else \"length\",\n                \"model\": model,\n                \"context\": result.get(\"context\", [])\n            }, headers=HEADERS)\n        else:\n            return JSONResponse({\n                \"error\": f\"Ollama error: {response.status_code}\",\n                \"completion\": \"\",\n                \"stopReason\": \"error\",\n                \"model\": model\n            }, headers=HEADERS, status_code=500)\nexcept Exception as e:\n    return JSONResponse({\n        \"error\": f\"Failed to connect to Ollama: {str(e)}\",\n        \"completion\": \"\",\n        \"stopReason\": \"error\",\n        \"model\": model\n    }, headers=HEADERS, status_code=500)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#roots-endpoint-file-system-roots","title":"Roots endpoint - File system roots","text":"<p>@mcp.custom_route(\u201c/roots\u201d, methods=[\u201cPOST\u201d, \u201cGET\u201d, \u201cOPTIONS\u201d]) async def roots_list(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>import os\nroots = [\n    {\n        \"uri\": f\"file://{os.getcwd()}\",\n        \"name\": \"Current Directory\"\n    }\n]\n\nreturn JSONResponse({\"roots\": roots}, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#ollama-status-endpoint","title":"Ollama status endpoint","text":"<p>@mcp.custom_route(\u201c/ollama/status\u201d, methods=[\u201cGET\u201d, \u201cOPTIONS\u201d]) async def ollama_status(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>try:\n    async with httpx.AsyncClient(timeout=5.0) as client:\n        response = await client.get(f\"{OLLAMA_BASE_URL}/api/tags\")\n        if response.status_code == 200:\n            data = response.json()\n            models = data.get(\"models\", [])\n            return JSONResponse({\n                \"status\": \"connected\",\n                \"url\": OLLAMA_BASE_URL,\n                \"models_count\": len(models),\n                \"models\": [{\n                    \"name\": m.get(\"name\"),\n                    \"size\": m.get(\"size\"),\n                    \"modified\": m.get(\"modified_at\")\n                } for m in models],\n                \"default_model\": DEFAULT_MODEL\n            }, headers=HEADERS)\n        else:\n            return JSONResponse({\n                \"status\": \"error\",\n                \"url\": OLLAMA_BASE_URL,\n                \"error\": f\"HTTP {response.status_code}\"\n            }, headers=HEADERS)\nexcept Exception as e:\n    return JSONResponse({\n        \"status\": \"disconnected\",\n        \"url\": OLLAMA_BASE_URL,\n        \"error\": str(e)\n    }, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#server-metadata-endpoint","title":"Server metadata endpoint","text":"<p>@mcp.custom_route(\u201c/metadata\u201d, methods=[\u201cGET\u201d, \u201cOPTIONS\u201d]) async def metadata(request: Request) -&gt; JSONResponse:     # Handle OPTIONS preflight     if request.method == \u201cOPTIONS\u201d:         return JSONResponse({}, headers=HEADERS)</p> <pre><code>return JSONResponse({\n    \"serverInfo\": {\n        \"name\": \"kagent-mcp-server\",\n        \"version\": \"0.1.0\",\n        \"protocolVersion\": \"2024-11-05\"\n    },\n    \"capabilities\": {\n        \"tools\": {\"listChanged\": False},\n        \"prompts\": {\"listChanged\": False},\n        \"resources\": {\"subscribe\": False, \"listChanged\": False},\n        \"logging\": {},\n        \"sampling\": {},\n        \"roots\": {\"listChanged\": False}\n    }\n}, headers=HEADERS)\n</code></pre>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#add-cors-middleware-to-handle-preflight-requests-for-all-endpoints","title":"Add CORS middleware to handle preflight requests for all endpoints","text":"<p>@mcp.custom_route(\u201c/mcp\u201d, methods=[\u201cOPTIONS\u201d]) async def mcp_options(request: Request) -&gt; Response:     \u201c\u201d\u201cHandle CORS preflight for the MCP endpoint\u201d\u201c\u201d     return Response(status_code=200, headers=HEADERS)</p>"},{"location":"Resources/001-MCP-Basics/003-MCP-Advanced-py/#main-entry-point-to-run-the-mcp-server","title":"Main entry point to run the MCP server","text":"<p>def main():     # Start the MCP server with streamable-http transport     # Mounted at /mcp path     # This will listen on port 8889 as configured above     mcp.run(transport=\u201dstreamable-http\u201d, mount_path=\u201d/mcp\u201d)</p> <p>if name == \u201cmain\u201d:     main()</p> <p>```</p>"},{"location":"Tasks/","title":"List of tasks","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/","title":"Task: Install and Setup Roo Code","text":"<ul> <li>This guide outlines the steps to install Roo Code (formerly Cline), configure it with custom instructions and MCP (Model Context Protocol), and demonstrates a usage example with a hypothetical \u201cContext7\u201d MCP server.</li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#1-install-roo-code","title":"1. Install Roo Code","text":"<p>Roo Code is an autonomous coding agent extension for VS Code.</p> <ol> <li>Open VS Code.</li> <li>Go to the Extensions view (Click the square icon on the sidebar or press <code>Cmd+Shift+X</code>).</li> <li>Search for \u201cRoo Code\u201d.</li> <li>Look for the extension published by RooVeterinaryInc (ID: <code>RooVeterinaryInc.roo-cline</code>).</li> <li>Click Install.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#2-setup-roo-code","title":"2. Setup Roo Code","text":"<ol> <li>Once installed, you need to configure Roo Code.</li> <li>Open the Roo Code sidebar by clicking the Roo Code icon on the sidebar.</li> <li>You will see the main Roo Code interface.</li> <li>We will go over the key configuration options during the lecture.</li> <li> <p>Adding API Keys (Use exiting or create new keys as needed) https://aistudio.google.com/api-keys</p> <p></p> <p></p> </li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#3-configuring-roo-code-features","title":"3. Configuring Roo Code Features","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#create-profile","title":"Create Profile","text":"<p>Creating a Profile</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Profile icon (user icon).</li> <li>Click \u201cCreate Profile\u201d.</li> <li>Fill in your details and preferences.</li> <li>Click \u201cSave Profile\u201d.</li> <li>Your profile will help Roo Code tailor its responses to your coding style and preferences.</li> <li>You can create multiple profiles for different projects or coding styles.</li> <li>Switch between profiles as needed.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#api-keys","title":"API Keys","text":"<p>Setting Up API Keys</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Settings (gear icon).</li> <li>Scroll to \u201cAPI Keys\u201d.</li> <li>Enter your API keys for the models you want to use (e.g., OpenAI, Google Gemini).</li> <li>Click \u201cSave\u201d.</li> <li>Roo Code will use these keys to access the respective language models for code generation and assistance.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#modes","title":"Modes","text":"<p>Setting Up Modes</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Settings (gear icon).</li> <li>Scroll to \u201cDefault Mode\u201d.</li> <li>Select your preferred default mode (e.g., Code, Architect, Ask).</li> <li>Click \u201cSave\u201d.</li> <li>This setting determines how Roo Code will approach tasks by default.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#4-advanced-configuration","title":"4. Advanced Configuration","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#mcp-servers","title":"MCP Servers","text":"<ul> <li>MCP (Model Context Protocol) allows Roo Code to connect to external tools and data sources.</li> </ul> <p>Setting Up MCP Servers</p> <ol> <li>In the Roo Code sidebar, click the MCP icon (server icon) or go to Settings &gt; MCP Servers.</li> <li>Click \u201cEdit MCP Settings\u201d (Global or Project).  </li> <li>This will open a JSON file for the MCP settings.</li> <li>Add your MCP servers to the <code>mcpServers</code> object.<ul> <li>Each server configuration includes the command to start the server, arguments, and environment variables if needed.</li> </ul> </li> <li>Save the file. </li> <li>Roo Code will now be able to use these MCP servers for enhanced context and capabilities.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#additional-settings","title":"Additional Settings","text":"<ul> <li> <p>We will cover these in the lecture.</p> Setting Description Auto-Approve Automatically approve Roo Code\u2019s suggested changes. Slash Commands Enable or disable slash commands for quick actions. Context Configure how much file context Roo Code uses when generating code (Tabs, limits etc.). Prompts Customize prompt templates for different modes. </li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#4-adding-custom-instructions","title":"4. Adding Custom Instructions","text":"<ul> <li>Adding custom instructions to Roo Code is a powerful way to enforce coding standards, project context, or specific AI behaviors. </li> <li>There are three primary ways to do this: Project-specific files, the UI (Prompts Tab), and Global configuration.</li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#1-project-specific-instructions-recommended","title":"1. Project-Specific Instructions (Recommended)","text":"<ul> <li>This is the best way to ensure that any developer working on your specific project gets the same AI behavior.</li> </ul> <p>Method A: The <code>.roo/rules/</code> Directory (Modern)</p> <ul> <li> <p>Roo Code now looks for a directory in your project root to load instructions.</p> <p>Setting Up Custom Rules</p> <ul> <li>Create a folder named <code>.roo/rules/</code> in your project\u2019s root directory.  </li> <li>Roo Code will read all files in this directory and apply the instructions when working on the project.   </li> <li>Example filenames:  <pre><code>  coding-standards.md\n  project-context.md\n  api-guidelines.md\n  testing-instructions.md\n</code></pre></li> <li>Add any number of <code>.md</code> (Markdown) files in this directory. <pre><code>  your-project/\n  \u251c\u2500\u2500 .roo/\n  \u2502   \u2514\u2500\u2500 rules/\n  \u2502       \u251c\u2500\u2500 coding-standards.md\n  \u2502       \u251c\u2500\u2500 project-context.md\n  \u2502       \u2514\u2500\u2500 api-guidelines.md\n  \u2514\u2500\u2500 src/\n      \u2514\u2500\u2500 main.py\n\n  # Each file can contain specific instructions or context for Roo Code.      \n</code></pre></li> <li>Example content for <code>coding-standards.md</code>:     <pre><code># Coding Standards\n- Follow PEP 8 for Python code.\n- Use meaningful variable names.\n- Write unit tests for all new features.\n</code></pre></li> <li>This method allows for easy version control and sharing of instructions with your team.</li> <li>Roo Code will automatically pick up changes to these files.</li> </ul> </li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#2-using-the-prompts-tab-in-the-ui-globalquick-edits","title":"2. Using the Prompts Tab in the UI (Global/Quick Edits)","text":"<ul> <li>You can also add custom instructions directly through the Roo Code UI.</li> <li> <p>This method is less ideal for project-specific instructions but can be useful for quick adjustments.</p> <p>Adding Custom Prompts via UI</p> <ul> <li>Open the Roo Code sidebar.</li> <li>Click on the Prompts tab.</li> <li>Here, you can add or edit custom prompts for different modes.</li> <li>Save your changes.</li> </ul> <ul> <li>Roo Code will use these prompts when generating code.</li> </ul> </li> </ul>"}]}