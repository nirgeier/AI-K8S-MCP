{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MCP Labs - Learning Series","text":"<p>Welcome to the Model Context Protocol (MCP) hands-on learning series! </p> <p>This comprehensive set of labs will take you from MCP fundamentals to building production-ready MCP servers.</p>"},{"location":"#what-youll-learn","title":"What You\u2019ll Learn","text":"<p>Through these five progressive labs, you\u2019ll master:</p> <ul> <li>MCP Architecture - Understanding the client-server model and core concepts</li> <li>Server Development - Building MCP servers from scratch with TypeScript</li> <li>Tools Implementation - Creating sophisticated tools that interact with external systems</li> <li>Resource Management - Exposing contextual data through MCP resources</li> <li>Prompt Engineering - Building reusable prompt templates for common tasks</li> </ul>"},{"location":"#lab-overview","title":"Lab Overview","text":""},{"location":"#lab-1-mcp-fundamentals","title":"Lab 1: MCP Fundamentals","text":"<p>Get started with the basics! Learn what MCP is, why it exists, and understand its architecture and core components.</p> <p>Topics:</p> <ul> <li>What is MCP and the problem it solves</li> <li>Client-server architecture</li> <li>Core capabilities: Tools, Resources, and Prompts</li> <li>MCP communication model and lifecycle</li> <li>Common use cases</li> </ul>"},{"location":"#lab-2-building-your-first-mcp-server","title":"Lab 2: Building Your First MCP Server","text":"<p>Build a complete, working MCP server from the ground up.</p> <p>Topics:</p> <ul> <li>Project setup with Node.js and TypeScript</li> <li>Implementing the MCP protocol</li> <li>Creating your first tool</li> <li>Testing with MCP Inspector</li> <li>Connecting to Claude Desktop</li> </ul>"},{"location":"#lab-3-implementing-mcp-tools","title":"Lab 3: Implementing MCP Tools","text":"<p>Master the art of creating sophisticated, production-ready tools.</p> <p>Topics:</p> <ul> <li>Advanced input validation with JSON Schema</li> <li>Real-world tool examples (Weather API, File operations, Database queries)</li> <li>Returning rich content types</li> <li>Error handling patterns</li> <li>Performance optimization and caching</li> </ul>"},{"location":"#lab-4-working-with-mcp-resources","title":"Lab 4: Working with MCP Resources","text":"<p>Learn to expose contextual data that LLMs can read and reference.</p> <p>Topics:</p> <ul> <li>Understanding tools vs. resources</li> <li>Implementing different resource types</li> <li>Resource URI schemes and templates</li> <li>Resource subscriptions for live updates</li> <li>Combining tools and resources</li> </ul>"},{"location":"#lab-5-mcp-prompts-and-complete-integration","title":"Lab 5: MCP Prompts and Complete Integration","text":"<p>Complete your MCP education with prompts and production best practices.</p> <p>Topics:</p> <ul> <li>Creating reusable prompt templates</li> <li>Embedding resources in prompts</li> <li>Building a complete server with all capabilities</li> <li>Production deployment and configuration</li> <li>Debugging and troubleshooting</li> </ul>"},{"location":"#lab-6-k-agent-integration","title":"Lab 6: K-Agent Integration","text":"<p>Implement a specialized MCP server (K-Agent) that interacts with Kubernetes clusters to provide AI-driven log collection and analysis.</p> <p>Topics:</p> <ul> <li>MCP server architecture for Kubernetes</li> <li>Secure communication with Kubernetes API</li> <li>Implementing tools for pod discovery and log retrieval</li> <li>Collecting and structuring logs for LLM consumption</li> <li>Containerizing and deploying the K-Agent server</li> </ul>"},{"location":"#tasks","title":"Tasks","text":"<p>A dedicated section with exercises and challenges to reinforce your learning from all labs.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js v18 or later</li> <li>Basic knowledge of JavaScript/TypeScript</li> <li>A code editor (VS Code recommended)</li> <li>Terminal/command line familiarity</li> </ul>"},{"location":"#recommended-path","title":"Recommended Path","text":"<ol> <li>Start with Lab 1 - Even if you\u2019re experienced, the fundamentals are important</li> <li>Complete labs in order - Each builds on previous knowledge</li> <li>Do the hands-on exercises - Practice is key to mastery</li> <li>Experiment freely - Try variations and explore beyond the examples</li> </ol>"},{"location":"#lab-format","title":"Lab Format","text":"<p>Each lab includes:</p> <ul> <li>Clear learning objectives</li> <li>Detailed explanations</li> <li>Complete code examples</li> <li>Hands-on exercises</li> <li>Key takeaways</li> <li>Links to additional resources</li> </ul>"},{"location":"#tips-for-success","title":"Tips for Success","text":"<ol> <li>Set aside focused time - Labs require concentration and experimentation</li> <li>Type the code yourself - Don\u2019t just copy-paste; understand each line</li> <li>Test frequently - Run your code after each major change</li> <li>Read error messages carefully - They often tell you exactly what\u2019s wrong</li> <li>Experiment with modifications - Try changing parameters and adding features</li> <li>Join the community - Connect with other MCP learners and developers</li> </ol>"},{"location":"#development-tools","title":"Development Tools","text":"<p>You\u2019ll use these tools throughout the labs:</p> <ul> <li>MCP TypeScript SDK - Official SDK for building servers</li> <li>MCP Inspector - Essential testing tool</li> </ul>"},{"location":"#additional-resources","title":"Additional Resources","text":"<ul> <li>MCP Official Documentation</li> <li>MCP Specification</li> <li>MCP GitHub Organization</li> <li>Example Servers Repository</li> <li>JSON-RPC 2.0 Specification</li> </ul>"},{"location":"#after-completing-the-labs","title":"After Completing the Labs","text":"<p>Once you\u2019ve finished all five labs, you\u2019ll be ready to:</p> <ul> <li>Build custom MCP servers for your specific needs</li> <li>Integrate LLMs with your company\u2019s tools and data</li> <li>Contribute to the MCP open source ecosystem</li> <li>Share your servers with the community</li> <li>Help others learn MCP</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>Stack Overflow - Tag questions with <code>model-context-protocol</code></li> <li>MCP Discord - Ask questions, share projects</li> <li>GitHub Organization - Contribute to the ecosystem</li> <li>Official Documentation - Comprehensive reference</li> <li>MCP Specification - Protocol details</li> </ul>"},{"location":"#ready-to-begin","title":"Ready to Begin?","text":"<p>Start with Lab 1: MCP Fundamentals \u2192</p> <p>Let\u2019s build something amazing with MCP!</p>"},{"location":"explanations/","title":"Explanations","text":"<p>This document provides detailed explanations of key concepts in the MCP (Model Context Protocol) server implementation, including endpoints, function calls, and RAGs (Retrieval-Augmented Generation).</p>"},{"location":"explanations/#endpoints","title":"Endpoints","text":""},{"location":"explanations/#general-meaning-of-endpoints-in-this-mcp-server","title":"General Meaning of Endpoints in This MCP Server","text":"<p>In the context of this MCP (Model Context Protocol) server, the \u201cendpoints\u201d refer to the API routes (URLs) that the server exposes for clients (like MCP inspectors, AI assistants, or other tools) to interact with it. </p> <p>These endpoints are part of the server\u2019s manifest, which is a metadata document that describes the server\u2019s capabilities, transport method (e.g., \u201cstreamable-http\u201d), and available routes. </p> <p>The manifest is served at <code>/.well-known/mcp</code> and helps clients discover and connect to the server.</p> <p>The endpoints follow RESTful conventions and support HTTP methods like GET, POST, and OPTIONS (for CORS preflight). They enable core MCP functionalities such as tool execution, resource access, prompt management, and server health checks. The server uses FastMCP (a framework for building MCP servers) and runs on port 8889 by default. </p> <p>Each endpoint is implemented as a custom route in the code, often with CORS headers for browser-based clients.</p> <p>Below, you\u2019ll find explanations for each endpoint from the manifest, including its purpose, typical HTTP methods, and what it does based on the code implementation. </p> <p>They are grouped logically for clarity.</p>"},{"location":"explanations/#core-server-and-discovery-endpoints","title":"Core Server and Discovery Endpoints","text":"<p>These handle basic server operations, discovery, and connection setup.</p> <ul> <li> <p>manifest (<code>/.well-known/mcp</code>):   Serves the MCP manifest (metadata about the server, including capabilities and all endpoints). Clients use this to understand what the server supports. Handled by <code>mcp_manifest()</code> \u2013 returns JSON with server info, base URL, and endpoint list.</p> </li> <li> <p>health (<code>/health</code>):   Simple health check to confirm the server is running. Returns a plain text response like \u201cMCP Server Running\u201d. Handled by <code>health_check()</code>.</p> </li> <li> <p>ping (<code>/ping</code>):   Connection health check with more details. Returns JSON with status (\u201cok\u201d), timestamp, and server name. Handled by <code>ping()</code>.</p> </li> <li> <p>root (<code>/</code>):   Root endpoint for basic server status. Similar to health, returns \u201cMCP Server Running\u201d. Handled by <code>root_health_check()</code>.</p> </li> <li> <p>negotiate (<code>/negotiate</code>):   Used for connection negotiation (e.g., transport setup and optional authentication via tokens). Clients send tokens here; the server responds with connection details. Handled by <code>negotiate()</code> \u2013 supports proxy tokens from headers or query params.</p> </li> <li> <p>metadata (<code>/metadata</code>):   Provides detailed server metadata, including protocol version and capabilities (e.g., support for tools, prompts). Handled by <code>metadata()</code> \u2013 returns JSON with server info and feature flags.</p> </li> <li> <p>events (<code>/mcp</code>):   The main MCP event stream endpoint for streamable HTTP transport. This is where real-time communication happens (e.g., tool calls, responses). It\u2019s the core mount path for the FastMCP server. Handled by the FastMCP framework\u2019s run method.</p> </li> </ul>"},{"location":"explanations/#tool-related-endpoints","title":"Tool-Related Endpoints","text":"<p>These manage MCP tools (functions the server exposes, like \u201chello\u201d or \u201cadd\u201d).</p> <ul> <li> <p>tools (<code>/tools</code>):   Lists all available tools with metadata (names, descriptions, arguments). Clients use this to discover tools. Handled by <code>tools_list()</code> \u2013 returns JSON with tool details from the server\u2019s <code>list_tools()</code> method.</p> </li> <li> <p>tools_execute (<code>/tools/execute</code>):   Executes a single tool synchronously. Clients send the tool name and arguments; the server runs it and returns the result. Handled by <code>tool_execute()</code> \u2013 validates args, executes via <code>execute_tool()</code>, and tracks executions.</p> </li> <li> <p>tools_batch (<code>/tools/batch</code>):   Executes multiple tools in a batch (array of calls). Useful for efficiency. Handled by <code>tool_batch_execute()</code> \u2013 processes each call and returns results.</p> </li> <li> <p>tools_stream (<code>/tools/stream</code>):   Executes a tool with streaming responses (e.g., for long-running tasks). Returns NDJSON (newline-delimited JSON) events like \u201cstart\u201d, \u201cresult\u201d, and \u201cend\u201d. Handled by <code>tool_stream_execute()</code>.</p> </li> <li> <p>tools_history (<code>/tools/history</code>):   Retrieves execution history for tools (recent runs, with optional limit). Handled by <code>tool_history()</code> \u2013 returns JSON with past executions from <code>TOOL_EXECUTIONS</code>.</p> </li> </ul>"},{"location":"explanations/#prompt-and-resource-endpoints","title":"Prompt and Resource Endpoints","text":"<p>These handle reusable prompts and static resources.</p> <ul> <li> <p>prompts (<code>/prompts</code>):   Lists available prompt templates (e.g., \u201ccode_review_prompt\u201d). Clients can use these for structured interactions. Handled by <code>prompts_list()</code> \u2013 returns JSON with prompt metadata.</p> </li> <li> <p>resources (<code>/resources</code>):   Lists available resources (e.g., server source code or info). Handled by <code>resources_list()</code> \u2013 returns JSON with resource URIs and descriptions.</p> </li> </ul>"},{"location":"explanations/#sampling-and-roots-endpoints","title":"Sampling and Roots Endpoints","text":"<p>These support advanced MCP features like LLM sampling and file system access.</p> <ul> <li> <p>sampling (<code>/sampling</code>):   Provides LLM sampling (text generation) using Ollama. Clients send a prompt; the server generates a response. Handled by <code>sampling()</code> \u2013 integrates with Ollama API for completions.</p> </li> <li> <p>roots (<code>/roots</code>):   Lists file system roots (e.g., the current working directory). Used for file-based operations. Handled by <code>roots_list()</code> \u2013 returns JSON with root URIs.</p> </li> </ul>"},{"location":"explanations/#customollama-specific-endpoint","title":"Custom/Ollama-Specific Endpoint","text":"<ul> <li>ollama_status (<code>/ollama/status</code>):   Checks the status of the connected Ollama instance (local LLM server). Returns model info, connection status, and available models. Handled by <code>ollama_status()</code> \u2013 queries Ollama\u2019s <code>/api/tags</code> endpoint.</li> </ul> <p>All endpoints include CORS headers for cross-origin requests and handle OPTIONS preflights. The server tracks tool executions globally for history/debugging.</p>"},{"location":"explanations/#function-calls","title":"Function Calls","text":""},{"location":"explanations/#what-are-function-calls","title":"What Are Function Calls?","text":"<p>In the context of MCP (Model Context Protocol) and AI systems, function calls (often referred to as \u201ctools\u201d in MCP terminology) are mechanisms that allow AI models or clients to invoke external functions or services dynamically. </p> <p>Instead of generating plain text responses, the AI can decide to call a predefined function with specific arguments, execute it on the server, and incorporate the results into its response. </p> <p>This enables more interactive, tool-augmented AI behaviors, such as performing calculations, querying databases, or interacting with APIs.</p> <p>In this MCP server, tools are essentially function calls exposed via the <code>/tools</code> endpoints. For example, the <code>hello</code> tool is a function that takes a <code>name</code> argument and returns a greeting string.</p>"},{"location":"explanations/#what-do-they-do","title":"What Do They Do?","text":"<p>Function calls allow the AI to extend its capabilities beyond static knowledge. </p> <p>They enable:</p> <ul> <li>Dynamic Execution: The AI can perform real-time actions, like adding numbers or generating text via Ollama.</li> <li>Structured Interactions: Clients (e.g., an AI assistant) can call functions to retrieve data or perform tasks, then use the output in conversations.</li> <li>Modularity: Developers can add new functions without retraining the AI model.</li> <li>Safety and Control: Arguments are validated, and executions are tracked for auditing.</li> </ul> <p>In MCP, tools are registered with decorators like <code>@mcp.tool()</code>, and clients discover them via the <code>/tools</code> endpoint.</p>"},{"location":"explanations/#how-to-set-them-up","title":"How to Set Them Up","text":"<ol> <li> <p>Define the Function: Write a Python function with type hints and a docstring. For example:    <pre><code>@mcp.tool()\ndef my_tool(arg1: str, arg2: int = 0) -&gt; str:\n    \"\"\"Description of what the tool does.\"\"\"\n    # Implementation here\n    return f\"Result: {arg1} and {arg2}\"\n</code></pre></p> <ul> <li>Use <code>@mcp.tool()</code> to register it with FastMCP.</li> <li>Arguments should have types; defaults are optional.</li> </ul> </li> <li> <p>Validation and Execution: The server automatically validates arguments against the function signature (via <code>validate_tool_arguments</code>) and executes it (via <code>execute_tool</code>). Results are tracked in <code>TOOL_EXECUTIONS</code>.</p> </li> <li> <p>Expose via Endpoints: Tools are listed at <code>/tools</code>, executed at <code>/tools/execute</code>, etc. No additional setup needed beyond registration.</p> </li> <li> <p>Testing: Use the <code>/tools/history</code> endpoint to debug executions. Ensure the function handles errors gracefully.</p> </li> <li> <p>Integration with AI: Clients (e.g., via MCP inspectors) can call these functions. For LLM integration, the AI might be prompted to output function call JSON, which the client then executes.</p> </li> </ol> <p>Function calls are asynchronous if the function is a coroutine (<code>async def</code>).</p>"},{"location":"explanations/#rags-retrieval-augmented-generation","title":"RAGs (Retrieval-Augmented Generation)","text":""},{"location":"explanations/#what-are-rags","title":"What Are RAGs?","text":"<p>RAGs stand for Retrieval-Augmented Generation, a technique in AI where an LLM (Large Language Model) retrieves relevant information from external data sources before generating a response. </p> <p>This improves accuracy, reduces hallucinations, and allows the model to access up-to-date or domain-specific knowledge not in its training data. </p> <p>Instead of relying solely on pre-trained knowledge, RAGs \u201caugment\u201d generation with retrieved context.</p> <p>In this MCP server context, RAGs can be implemented using resources (static data) or sampling (dynamic retrieval via Ollama). </p> <p>For example, retrieving code snippets or server info to inform responses.</p>"},{"location":"explanations/#how-do-they-work","title":"How Do They Work?","text":"<ol> <li>Retrieval Phase: When a query is made, the system searches a knowledge base (e.g., documents, databases) for relevant chunks of data.</li> <li>Augmentation: Retrieved data is fed into the LLM\u2019s prompt as context.</li> <li>Generation: The LLM generates a response based on both the query and retrieved data.</li> </ol> <ul> <li> <p>Key components:</p> <ul> <li>Data Sources: Could be files, APIs, or databases.</li> <li>Retriever: Searches and ranks relevant data (e.g., via embeddings or keywords).</li> <li>Generator: The LLM that produces the final output.</li> </ul> </li> </ul> <p>In MCP, resources at <code>/resources</code> can serve as static data sources, while sampling at <code>/sampling</code> can generate augmented responses.</p>"},{"location":"explanations/#how-to-set-them-up_1","title":"How to Set Them Up","text":"<ol> <li> <p>Define Data Sources: Use MCP resources for static data. For example:    <pre><code>@mcp.resource(\"mcp://my-data\")\ndef get_data() -&gt; str:\n    \"\"\"Returns relevant data.\"\"\"\n    return \"Retrieved information here.\"\n</code></pre></p> <ul> <li>Resources are listed at <code>/resources</code> and can be queried by URI.</li> </ul> </li> <li> <p>Implement Retrieval: For dynamic retrieval, integrate with tools or sampling. For instance, use a tool to query a database or API, then pass results to Ollama via <code>/sampling</code>.</p> </li> <li> <p>Augment with Sampling: At <code>/sampling</code>, send a prompt that includes retrieved context:    <pre><code>{\n  \"prompt\": \"Using this data: [retrieved info]. Answer: [query]\",\n  \"model\": \"llama3.2:latest\"\n}\n</code></pre></p> <ul> <li>Ollama generates the response with augmentation.</li> </ul> </li> <li> <p>Full RAG Pipeline:</p> <ul> <li>Client queries the server.</li> <li>Server retrieves data (e.g., via a tool or resource).</li> <li>Data is injected into a prompt.</li> <li>Sampling generates the augmented response.</li> </ul> </li> <li> <p>Tools for RAG: Add tools like <code>search_documents</code> that retrieve data. Combine with prompts for structured queries.</p> </li> <li> <p>Best Practices: Use embeddings (e.g., via Ollama or external services) for semantic search. Cache retrieved data for efficiency. Ensure data sources are secure and up-to-date.</p> </li> </ol> <p>RAGs enhance MCP servers by making them knowledge-aware, useful for applications like chatbots with custom data or code assistants.</p>"},{"location":"explanations/#additional-mcp-inspector-tabs-and-configuration","title":"Additional MCP Inspector Tabs and Configuration","text":"<p>The MCP Inspector provides various tabs that correspond to different capabilities and endpoints in your MCP server. </p> <p>These tabs allow you to test and interact with the server\u2019s features. Below, you\u2019ll find explanations for each tab mentioned (resources, prompts, tools, ping, sampling, elicitations, roots, auth, metadata) and how to configure them in the JSON manifest within <code>mcp02.py</code>.</p> <p>The manifest is defined in the <code>mcp_manifest()</code> function. It includes a <code>\"capabilities\"</code> object (boolean flags indicating support) and an <code>\"endpoints\"</code> object (URL paths). To enable or configure a feature, update these sections accordingly.</p>"},{"location":"explanations/#resources-tab","title":"Resources Tab","text":"<ul> <li>Purpose: Displays static data sources (e.g., files, server info) that clients can access.</li> <li>Configuration: <ul> <li>Set <code>\"resources\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"resources\": \"/resources\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/resources</code> endpoint to list available resources (e.g., URIs like <code>mcp://code</code>).</li> <li>Register resources with <code>@mcp.resource(\"uri\")</code> decorators.</li> </ul> </li> <li>Example: In <code>mcp02.py</code>, resources like <code>get_code()</code> and <code>get_server_info()</code> are registered and listed via <code>/resources</code>.</li> </ul>"},{"location":"explanations/#prompts-tab","title":"Prompts Tab","text":"<ul> <li>Purpose: Shows reusable prompt templates for structured interactions (e.g., code review prompts).</li> <li>Configuration:<ul> <li>Set <code>\"prompts\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"prompts\": \"/prompts\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/prompts</code> endpoint to return a list of prompt metadata.</li> <li>Register prompts with <code>@mcp.prompt()</code> decorators.</li> </ul> </li> <li>Example: Prompts like <code>code_review_prompt()</code> are defined and exposed via <code>/prompts</code>.</li> </ul>"},{"location":"explanations/#tools-tab","title":"Tools Tab","text":"<ul> <li>Purpose: Lists executable functions (tools) that clients can invoke (e.g., <code>hello</code>, <code>add</code>).</li> <li>Configuration:<ul> <li>Set <code>\"tools\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"tools\": \"/tools\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/tools</code> to return tool metadata from <code>mcp.list_tools()</code>.</li> <li>Register tools with <code>@mcp.tool()</code> decorators.</li> </ul> </li> <li>Example: Tools like <code>hello()</code> and <code>add()</code> are registered and discoverable via <code>/tools</code>.</li> </ul>"},{"location":"explanations/#ping-tab","title":"Ping Tab","text":"<ul> <li>Purpose: Tests server connectivity and health with a simple ping.</li> <li>Configuration:<ul> <li>Add <code>\"ping\": \"/ping\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/ping</code> endpoint to return JSON with status, timestamp, and server name.</li> </ul> </li> <li>Example: The <code>ping()</code> function returns <code>{\"status\": \"ok\", ...}</code>.</li> </ul>"},{"location":"explanations/#sampling-tab","title":"Sampling Tab","text":"<ul> <li>Purpose: Allows LLM text generation (e.g., via Ollama) for completions.</li> <li>Configuration:<ul> <li>Set <code>\"sampling\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"sampling\": \"/sampling\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/sampling</code> to accept prompts and return generated text.</li> </ul> </li> <li>Example: Uses Ollama API to generate responses based on input prompts.</li> </ul>"},{"location":"explanations/#elicitations-tab","title":"Elicitations Tab","text":"<ul> <li>Purpose: Likely refers to logging or event elicitation (capturing server events/logs). In MCP, this may map to <code>\"logging\"</code> capability for debugging.</li> <li>Configuration:<ul> <li>Set <code>\"logging\": true</code> in <code>\"capabilities\"</code>.</li> <li>No specific endpoint needed, but ensure logging is enabled in the server framework.</li> </ul> </li> <li>Note: If this refers to \u201cevents,\u201d use the <code>/mcp</code> endpoint for streamable HTTP events.</li> </ul>"},{"location":"explanations/#roots-tab","title":"Roots Tab","text":"<ul> <li>Purpose: Lists file system roots for file-based operations.</li> <li>Configuration:<ul> <li>Set <code>\"roots\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"roots\": \"/roots\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/roots</code> to return root URIs (e.g., current directory).</li> </ul> </li> <li>Example: Returns <code>[{\"uri\": \"file://current/dir\", \"name\": \"Current Directory\"}]</code>.</li> </ul>"},{"location":"explanations/#auth-tab","title":"Auth Tab","text":"<ul> <li>Purpose: Handles authentication (e.g., token-based access).</li> <li>Configuration:<ul> <li>Use the <code>/negotiate</code> endpoint for auth negotiation.</li> <li>Accept tokens via headers (e.g., <code>Authorization: Bearer &lt;token&gt;</code>).</li> <li>In the manifest, no direct flag, but ensure <code>/negotiate</code> supports auth.</li> </ul> </li> <li>Example: The <code>negotiate()</code> function checks for tokens and includes them in responses.</li> </ul>"},{"location":"explanations/#metadata-tab","title":"Metadata Tab","text":"<ul> <li>Purpose: Provides server metadata (version, capabilities, protocol info).</li> <li>Configuration:<ul> <li>Add <code>\"metadata\": \"/metadata\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/metadata</code> to return detailed server info.</li> </ul> </li> <li>Example: Returns JSON with <code>serverInfo</code> and <code>capabilities</code>.</li> </ul> <p>To update the manifest in <code>mcp02.py</code>, edit the <code>manifest</code> dictionary in <code>mcp_manifest()</code>. For instance, to add a new capability, include it in <code>\"capabilities\"</code> and its endpoint in <code>\"endpoints\"</code>. Restart the server after changes.</p>"},{"location":"explanations/#creating-a-personal-custom-rag","title":"Creating a Personal Custom RAG","text":"<p>Retrieval-Augmented Generation (RAG) allows you to build a custom knowledge system by combining data retrieval with LLM generation. </p> <p>Here\u2019s how to create one in your MCP server context:</p>"},{"location":"explanations/#step-1-define-data-sources","title":"Step 1: Define Data Sources","text":"<ul> <li>Static Data: Use MCP resources for fixed content (e.g., documents, code).<ul> <li>Register with <code>@mcp.resource(\"mcp://my-data\")</code>.</li> <li>Store data in files, databases, or variables.</li> </ul> </li> <li>Dynamic Data: Integrate APIs or databases for real-time retrieval.<ul> <li>Create tools to query external sources (e.g., a tool that searches a vector database).</li> </ul> </li> </ul>"},{"location":"explanations/#step-2-implement-retrieval","title":"Step 2: Implement Retrieval","text":"<ul> <li>Simple Retrieval: Use keyword search or basic queries.<ul> <li>Example: A tool that reads from a JSON file or API.</li> </ul> </li> <li>Advanced Retrieval: Use embeddings for semantic search.<ul> <li>Install libraries like <code>sentence-transformers</code> or <code>faiss</code>.</li> <li>Embed your data and queries, then find similar vectors.</li> <li>Example: Store document chunks in a vector DB, retrieve top matches for a query.</li> </ul> </li> </ul>"},{"location":"explanations/#step-3-augment-with-llm","title":"Step 3: Augment with LLM","text":"<ul> <li>Integration: Pass retrieved data into prompts.<ul> <li>Use the <code>/sampling</code> endpoint or a tool like <code>ollama_generate()</code>.</li> <li>Example Prompt: <code>\"Using this data: {retrieved_info}. Answer: {user_query}\"</code>.</li> </ul> </li> <li>Pipeline:<ol> <li>User queries the server.</li> <li>Retrieve relevant data (via tool or resource).</li> <li>Inject data into LLM prompt.</li> <li>Generate response via sampling.</li> </ol> </li> </ul>"},{"location":"explanations/#step-4-set-up-in-mcp-server","title":"Step 4: Set Up in MCP Server","text":"<ul> <li>Add Tools/Resources: Register retrieval functions as tools (e.g., <code>@mcp.tool() def search_docs(query: str)</code>).</li> <li>Configure Endpoints: Ensure <code>/resources</code>, <code>/tools</code>, and <code>/sampling</code> are enabled.</li> <li>Testing: Use the Inspector to test retrieval and generation.</li> </ul>"},{"location":"explanations/#best-practices","title":"Best Practices","text":"<ul> <li>Data Management: Keep data secure and up-to-date.</li> <li>Performance: Cache embeddings; use efficient search.</li> <li>Scalability: For large datasets, use external vector DBs like Pinecone or Weaviate.</li> <li> <p>Example Code Snippet:</p> <pre><code>@mcp.tool()\ndef rag_query(query: str) -&gt; str:\n    # Retrieve data (simplified)\n    retrieved = \"Relevant info from your data source.\"\n    # Augment and generate\n    prompt = f\"Data: {retrieved}. Query: {query}\"\n    return ollama_generate(prompt)\n</code></pre> </li> </ul> <p>This creates a personal RAG tailored to your data, enhancing AI responses with custom knowledge.</p>"},{"location":"explanations/#adding-clients-internal-llm","title":"Adding Clients (Internal LLM)","text":"<p>To integrate an internal Large Language Model (LLM) as a client with your MCP server, you need to set up a client that can connect to the MCP server, discover its capabilities, and invoke tools, resources, or prompts. </p> <p>This allows the LLM to augment its responses using the server\u2019s functionalities, such as executing custom tools or retrieving data.</p>"},{"location":"explanations/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>MCP Server Running: Ensure your MCP server is running and accessible (e.g., at <code>http://localhost:8889</code>).</p> </li> <li> <p>Client Library: Use an MCP-compatible client library. For Python, you can use libraries like <code>mcp-client</code> or integrate with frameworks like LangChain or LlamaIndex that support MCP. For other languages, check for MCP SDKs (e.g., Node.js MCP clients).</p> </li> <li> <p>LLM Setup: Have an internal LLM ready, such as Ollama running locally, or another model that supports tool calling (e.g., via function calling APIs).</p> </li> <li> <p>Information Needed:</p> <ul> <li>Server Base URL: The full URL where the MCP server is hosted (e.g., <code>http://localhost:8889</code>).</li> <li>Manifest URL: The URL to the manifest endpoint (e.g., <code>http://localhost:8889/.well-known/mcp</code>). This provides metadata about the server\u2019s capabilities and endpoints.</li> <li>Authentication Token (optional): If the server requires authentication, obtain a token (e.g., via the <code>/negotiate</code> endpoint). Pass it in headers like <code>Authorization: Bearer &lt;token&gt;</code>.</li> <li>Transport Method: Confirm the server uses \u201cstreamable-http\u201d transport, as indicated in the manifest.</li> </ul> </li> </ul>"},{"location":"explanations/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Install Required Libraries:</p> <ul> <li>For Python: Install the MCP client library if available (e.g., <code>pip install mcp-client</code> or similar). If using LangChain, install <code>langchain</code> and MCP integrations.</li> <li>For other setups: Ensure your LLM framework supports MCP (e.g., LlamaIndex has MCP connectors).</li> </ul> </li> <li> <p>Fetch the Server Manifest:</p> <ul> <li>Make a GET request to the manifest URL to retrieve the server\u2019s metadata.</li> <li>Example (using curl): <code>curl http://localhost:8889/.well-known/mcp</code></li> <li>Parse the JSON response to understand available endpoints (e.g., <code>/tools</code>, <code>/resources</code>, <code>/sampling</code>) and capabilities (e.g., <code>tools: true</code>).</li> </ul> </li> <li> <p>Initialize the MCP Client:</p> <ul> <li>In your client code, create an MCP client instance and connect to the server.</li> <li>Provide the base URL and any authentication details.</li> <li> <p>Example in Python (pseudo-code):</p> <pre><code>from mcp_client import MCPClient  # Assuming a library exists\n\nclient = MCPClient(base_url=\"http://localhost:8889\", auth_token=\"your_token_if_needed\")\nclient.connect()\n</code></pre> </li> </ul> </li> <li> <p>Discover Capabilities:</p> <ul> <li>Use the client to list available tools, resources, or prompts.</li> <li>Example: Call <code>client.list_tools()</code> to get tool metadata, which includes names, descriptions, and argument schemas.</li> </ul> </li> <li> <p>Integrate with the Internal LLM:</p> <ul> <li>Configure the LLM to use the MCP client for tool calling.</li> <li>For LLMs that support function calling (e.g., GPT models or local models via libraries), map MCP tools to callable functions.</li> <li>Example workflow:<ul> <li>When the LLM generates a response, check if it needs to call a tool (e.g., based on a prompt or decision).</li> <li>Use the MCP client to execute the tool: <code>result = client.call_tool(\"tool_name\", args={\"arg1\": \"value\"})</code>.</li> <li>Feed the result back into the LLM\u2019s context for the final response.</li> </ul> </li> <li>For Ollama or similar local LLMs, you may need a wrapper script that handles the tool calling logic.</li> </ul> </li> <li> <p>Handle Sampling or Generation:</p> <ul> <li>If the LLM needs to generate text augmented by the server, use the <code>/sampling</code> endpoint via the client.</li> <li>Example: <code>response = client.sample(prompt=\"Your prompt here\", model=\"llama3.2:latest\")</code>.</li> </ul> </li> <li> <p>Test the Integration:</p> <ul> <li>Run a test query where the LLM invokes a tool (e.g., the \u201chello\u201d tool).</li> <li>Verify that the client connects, executes the tool, and the LLM incorporates the result.</li> <li>Check logs on the server side (e.g., via <code>/tools/history</code>) for executions.</li> </ul> </li> <li> <p>Handle Errors and Authentication:</p> <ul> <li>Implement error handling for failed connections or tool executions.</li> <li>If authentication fails, renegotiate tokens via <code>/negotiate</code>.</li> <li>Ensure CORS and security settings allow the client to connect.</li> </ul> </li> <li> <p>Advanced Setup:</p> <ul> <li>For streaming: Use the <code>/tools/stream</code> endpoint for real-time tool execution.</li> <li>For batch operations: Call multiple tools at once via <code>/tools/batch</code>.</li> <li>Integrate with prompts: Use <code>/prompts</code> to retrieve structured prompts for the LLM.</li> </ul> </li> </ol> <p>By following these steps, your internal LLM can act as an MCP client, leveraging the server\u2019s tools and resources to provide more capable and context-aware responses. </p> <p>If using a specific LLM framework, refer to its documentation for MCP integration details.</p>"},{"location":"labs/","title":"MCP Labs - Learning Series","text":"<ul> <li>Welcome to the Model Context Protocol (MCP) hands-on learning series!</li> <li>This comprehensive set of labs will take you from MCP fundamentals to building production-ready MCP servers.</li> <li>Here you\u2019ll learn and build the Model Context Protocol (MCP) from scratch</li> <li>Whether you\u2019re new to MCP or looking to deepen your understanding, this learning series will take you from fundamentals to building production-ready MCP servers.</li> </ul>"},{"location":"labs/#what-youll-learn","title":"What You\u2019ll Learn","text":"<p>Through these 8 progressive labs, you\u2019ll master:</p> Topic Description MCP Architecture Understanding and mastering the client-server model and core concepts Server Development Building MCP servers from scratch with TypeScript using the official SDK Tools Implementation Creating sophisticated tools that interact with external systems and developing functions that LLMs can call to perform actions Resource Management Exposing contextual data through MCP resources that LLMs can read and reference Prompt Engineering Building reusable prompt templates for common tasks Production Deployment Applying best practices for real-world applications"},{"location":"labs/#labs-overview","title":"Labs Overview","text":""},{"location":"labs/#lab-0-environment-setup","title":"Lab 0: Environment Setup","text":"<p>Get your development environment ready for MCP server development.</p> <p>Topics:</p> <ul> <li>Install and configure required tools (Docker, kubectl, Helm, Ollama, MCP Inspector, K-Agent etc.)</li> <li>Build and run the K-Agent labs environment (Docker container or locally)</li> <li>Verify Kubernetes cluster connectivity</li> <li>Prepare the MCP server setup</li> </ul>"},{"location":"labs/#lab-1-mcp-fundamentals","title":"Lab 1: MCP Fundamentals","text":"<p>Get started with the basics! Learn what MCP is, why it exists, and understand its architecture and core components.</p> <p>Topics:</p> <ul> <li>What is MCP and the problem it solves</li> <li>Client-server architecture</li> <li>Core capabilities: Tools, Resources, and Prompts</li> <li>MCP communication model and lifecycle</li> <li>Common use cases</li> </ul>"},{"location":"labs/#lab-2-building-your-first-mcp-server","title":"Lab 2: Building Your First MCP Server","text":"<p>Build a complete, working MCP server from the ground up.</p> <p>Topics:</p> <ul> <li>Project setup with Node.js and TypeScript</li> <li>Implementing the MCP protocol</li> <li>Creating your first tool</li> <li>Testing with MCP Inspector</li> <li>Connecting to Claude Desktop</li> </ul>"},{"location":"labs/#lab-3-implementing-mcp-tools","title":"Lab 3: Implementing MCP Tools","text":"<p>Master the art of creating sophisticated, production-ready tools.</p> <p>Topics:</p> <ul> <li>Advanced input validation with JSON Schema</li> <li>Real-world tool examples (Weather API, File operations, Database queries)</li> <li>Returning rich content types</li> <li>Error handling patterns</li> <li>Performance optimization and caching</li> </ul>"},{"location":"labs/#lab-4-working-with-mcp-resources","title":"Lab 4: Working with MCP Resources","text":"<p>Learn to expose contextual data that LLMs can read and reference.</p> <p>Topics:</p> <ul> <li>Understanding tools vs. resources</li> <li>Implementing different resource types</li> <li>Resource URI schemes and templates</li> <li>Resource subscriptions for live updates</li> <li>Combining tools and resources</li> </ul>"},{"location":"labs/#lab-5-mcp-prompts-and-complete-integration","title":"Lab 5: MCP Prompts and Complete Integration","text":"<p>Complete your MCP education with prompts and production best practices.</p> <p>Topics:</p> <ul> <li>Creating reusable prompt templates</li> <li>Embedding resources in prompts</li> <li>Building a complete server with all capabilities</li> <li>Production deployment and configuration</li> <li>Debugging and troubleshooting</li> </ul>"},{"location":"labs/#lab-6-complete-mcp-server-implementation","title":"Lab 6: Complete MCP Server Implementation","text":"<p>Build a complete MCP server from scratch, learning each component.</p> <p>Topics:</p> <ul> <li>Project setup with Python</li> <li>Implementing the MCP protocol</li> <li>Creating tools, resources, and prompts</li> <li>Testing and debugging</li> </ul>"},{"location":"labs/#lab-7-mcp-tools-with-ollama-integration","title":"Lab 7: MCP Tools with Ollama Integration","text":"<p>Master creating sophisticated MCP tools with Ollama integration.</p> <p>Topics:</p> <ul> <li>Design robust tool schemas with advanced validation</li> <li>Implement tools that interact with external systems</li> <li>Return multiple content types</li> <li>Handle errors gracefully</li> <li>Apply best practices for tool composition</li> </ul>"},{"location":"labs/#lab-8-k-agent-integration","title":"Lab 8: K-Agent Integration","text":"<p>Implement a specialized MCP server (K-Agent) that interacts with Kubernetes clusters to provide AI-driven log collection and analysis.</p> <p>Topics:</p> <ul> <li>MCP server architecture for Kubernetes</li> <li>Secure communication with Kubernetes API</li> <li>Implementing tools for pod discovery and log retrieval</li> <li>Collecting and structuring logs for LLM consumption</li> <li>Containerizing and deploying the K-Agent server</li> </ul>"},{"location":"labs/#lab-9-k8s-event-log-monitor","title":"Lab 9: K8s Event &amp; Log Monitor","text":"<p>Build a complete observability stack with a custom Python MCP server, Kagent, Prometheus, and Grafana.</p> <p>Topics:</p> <ul> <li>Minimal Kagent installation</li> <li>Building Python-based MCP servers</li> <li>Registering custom tools with Kagent</li> <li>Deploying Prometheus and Grafana via Helm</li> <li>Connecting Log/Event collection to visualization dashboards</li> </ul>"},{"location":"labs/#ready-to-begin","title":"Ready to Begin?","text":"<p>Start with Lab 1: MCP Fundamentals \u2192</p> <p>Let\u2019s build something amazing with MCP!</p>"},{"location":"resources/","title":"MCP Server Examples","text":"<p>This section provides complete, working examples of MCP servers in both TypeScript and Python. These examples demonstrate the core concepts of MCP server development and can be used as starting points for your own implementations.</p>"},{"location":"resources/#typescript-mcp-server-example","title":"TypeScript MCP Server Example","text":""},{"location":"resources/#complete-mcp-server-with-tools-resources-and-prompts","title":"Complete MCP Server with Tools, Resources, and Prompts","text":"<pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { readFileSync } from \"fs\";\nimport fetch from \"node-fetch\";\n\nclass MCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"example-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // Tools handlers\n    this.server.setRequestHandler(\"tools/list\", async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"calculate\",\n            description: \"Perform basic arithmetic operations\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                operation: {\n                  type: \"string\",\n                  enum: [\"add\", \"subtract\", \"multiply\", \"divide\"]\n                },\n                a: { type: \"number\" },\n                b: { type: \"number\" }\n              },\n              required: [\"operation\", \"a\", \"b\"]\n            }\n          },\n          {\n            name: \"get_weather\",\n            description: \"Get current weather for a city\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: { type: \"string\" }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"read_file\",\n            description: \"Read contents of a file\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                path: { type: \"string\" }\n              },\n              required: [\"path\"]\n            }\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"calculate\":\n          return this.handleCalculate(args);\n        case \"get_weather\":\n          return this.handleWeather(args);\n        case \"read_file\":\n          return this.handleReadFile(args);\n        default:\n          throw new Error(`Unknown tool: ${name}`);\n      }\n    });\n\n    // Resources handlers\n    this.server.setRequestHandler(\"resources/list\", async () =&gt; {\n      return {\n        resources: [\n          {\n            uri: \"file://server-info\",\n            name: \"Server Information\",\n            description: \"Information about this MCP server\",\n            mimeType: \"application/json\"\n          },\n          {\n            uri: \"file://system-status\",\n            name: \"System Status\",\n            description: \"Current system status and metrics\",\n            mimeType: \"application/json\"\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n      const { uri } = request.params;\n\n      switch (uri) {\n        case \"file://server-info\":\n          return {\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                name: \"Example MCP Server\",\n                version: \"1.0.0\",\n                capabilities: [\"tools\", \"resources\", \"prompts\"],\n                uptime: process.uptime()\n              }, null, 2)\n            }]\n          };\n        case \"file://system-status\":\n          return {\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                platform: process.platform,\n                nodeVersion: process.version,\n                memory: process.memoryUsage(),\n                cpuUsage: process.cpuUsage()\n              }, null, 2)\n            }]\n          };\n        default:\n          throw new Error(`Resource not found: ${uri}`);\n      }\n    });\n\n    // Prompts handlers\n    this.server.setRequestHandler(\"prompts/list\", async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"code_review\",\n            description: \"Review code for best practices and improvements\",\n            arguments: [\n              {\n                name: \"code\",\n                description: \"The code to review\",\n                required: true\n              },\n              {\n                name: \"language\",\n                description: \"Programming language\",\n                required: false\n              }\n            ]\n          },\n          {\n            name: \"debug_help\",\n            description: \"Get help debugging an issue\",\n            arguments: [\n              {\n                name: \"problem\",\n                description: \"Description of the problem\",\n                required: true\n              },\n              {\n                name: \"code\",\n                description: \"Relevant code snippet\",\n                required: false\n              }\n            ]\n          }\n        ]\n      };\n    });\n\n    this.server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"code_review\":\n          return {\n            description: \"Code Review Assistant\",\n            messages: [\n              {\n                role: \"user\",\n                content: {\n                  type: \"text\",\n                  text: `Please review the following ${args.language || 'code'} for best practices, potential bugs, and improvements:\\n\\n${args.code}\\n\\nPlease provide:\\n1. Code quality assessment\\n2. Potential issues or bugs\\n3. Suggestions for improvement\\n4. Best practices recommendations`\n                }\n              }\n            ]\n          };\n        case \"debug_help\":\n          return {\n            description: \"Debugging Assistant\",\n            messages: [\n              {\n                role: \"user\",\n                content: {\n                  type: \"text\",\n                  text: `I'm experiencing this problem: ${args.problem}\\n\\n${args.code ? `Here's the relevant code:\\n${args.code}\\n` : ''}\\n\\nPlease help me:\\n1. Understand what might be causing this issue\\n2. Suggest debugging steps\\n3. Provide potential solutions\\n4. Recommend best practices to avoid similar issues`\n                }\n              }\n            ]\n          };\n        default:\n          throw new Error(`Unknown prompt: ${name}`);\n      }\n    });\n  }\n\n  private handleCalculate(args: any) {\n    const { operation, a, b } = args;\n    let result: number;\n\n    switch (operation) {\n      case \"add\":\n        result = a + b;\n        break;\n      case \"subtract\":\n        result = a - b;\n        break;\n      case \"multiply\":\n        result = a * b;\n        break;\n      case \"divide\":\n        if (b === 0) throw new Error(\"Division by zero\");\n        result = a / b;\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Result: ${result}`\n      }]\n    };\n  }\n\n  private async handleWeather(args: any) {\n    const { city } = args;\n    const apiKey = process.env.WEATHER_API_KEY;\n\n    if (!apiKey) {\n      throw new Error(\"Weather API key not configured\");\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${city}&amp;appid=${apiKey}&amp;units=metric`\n      );\n\n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Weather in ${city}: ${data.weather[0].description}, ${data.main.temp}\u00b0C`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Weather fetch failed: ${error.message}`);\n    }\n  }\n\n  private handleReadFile(args: any) {\n    const { path } = args;\n\n    try {\n      const content = readFileSync(path, \"utf-8\");\n      return {\n        content: [{\n          type: \"text\",\n          text: content\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n\n  async start() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"MCP Server started\");\n  }\n}\n\n// Start the server\nconst server = new MCPServer();\nserver.start().catch(console.error);\n</code></pre>"},{"location":"resources/#packagejson-for-typescript-mcp-server","title":"package.json for TypeScript MCP Server","text":"<pre><code>{\n  \"name\": \"example-mcp-server-ts\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Example MCP server in TypeScript\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\",\n    \"node-fetch\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre>"},{"location":"resources/#tsconfigjson","title":"tsconfig.json","text":"<pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre>"},{"location":"resources/#python-mcp-server-example","title":"Python MCP Server Example","text":""},{"location":"resources/#complete-mcp-server-with-tools-resources-and-prompts_1","title":"Complete MCP Server with Tools, Resources, and Prompts","text":"<pre><code>#!/usr/bin/env python3\n\nimport asyncio\nimport json\nimport os\nimport sys\nfrom typing import Any, Dict, List\nimport httpx\nfrom mcp import Tool, types\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\n\nserver = Server(\"example-mcp-server\")\n\n@server.list_tools()\nasync def list_tools() -&gt; List[Tool]:\n    \"\"\"List available tools.\"\"\"\n    return [\n        Tool(\n            name=\"calculate\",\n            description=\"Perform basic arithmetic operations\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"operation\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"]\n                    },\n                    \"a\": {\"type\": \"number\"},\n                    \"b\": {\"type\": \"number\"}\n                },\n                \"required\": [\"operation\", \"a\", \"b\"]\n            }\n        ),\n        Tool(\n            name=\"get_weather\",\n            description=\"Get current weather for a city\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"city\": {\"type\": \"string\"}\n                },\n                \"required\": [\"city\"]\n            }\n        ),\n        Tool(\n            name=\"read_file\",\n            description=\"Read contents of a file\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\"type\": \"string\"}\n                },\n                \"required\": [\"path\"]\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle tool calls.\"\"\"\n    if name == \"calculate\":\n        return await handle_calculate(arguments)\n    elif name == \"get_weather\":\n        return await handle_weather(arguments)\n    elif name == \"read_file\":\n        return await handle_read_file(arguments)\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n\nasync def handle_calculate(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle calculator tool.\"\"\"\n    operation = args[\"operation\"]\n    a = args[\"a\"]\n    b = args[\"b\"]\n\n    if operation == \"add\":\n        result = a + b\n    elif operation == \"subtract\":\n        result = a - b\n    elif operation == \"multiply\":\n        result = a * b\n    elif operation == \"divide\":\n        if b == 0:\n            raise ValueError(\"Division by zero\")\n        result = a / b\n    else:\n        raise ValueError(f\"Unknown operation: {operation}\")\n\n    return [types.TextContent(type=\"text\", text=f\"Result: {result}\")]\n\nasync def handle_weather(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle weather tool.\"\"\"\n    city = args[\"city\"]\n    api_key = os.getenv(\"WEATHER_API_KEY\")\n\n    if not api_key:\n        raise ValueError(\"Weather API key not configured\")\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            f\"https://api.openweathermap.org/data/2.5/weather?q={city}&amp;appid={api_key}&amp;units=metric\"\n        )\n\n        if response.status_code != 200:\n            raise ValueError(f\"Weather API error: {response.status_code}\")\n\n        data = response.json()\n        weather_desc = data[\"weather\"][0][\"description\"]\n        temp = data[\"main\"][\"temp\"]\n\n        return [types.TextContent(\n            type=\"text\",\n            text=f\"Weather in {city}: {weather_desc}, {temp}\u00b0C\"\n        )]\n\nasync def handle_read_file(args: Dict[str, Any]) -&gt; List[types.TextContent]:\n    \"\"\"Handle file reading tool.\"\"\"\n    path = args[\"path\"]\n\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        return [types.TextContent(type=\"text\", text=content)]\n    except Exception as e:\n        raise ValueError(f\"Failed to read file: {e}\")\n\n@server.list_resources()\nasync def list_resources() -&gt; List[types.Resource]:\n    \"\"\"List available resources.\"\"\"\n    return [\n        types.Resource(\n            uri=\"file://server-info\",\n            name=\"Server Information\",\n            description=\"Information about this MCP server\",\n            mimeType=\"application/json\"\n        ),\n        types.Resource(\n            uri=\"file://system-status\",\n            name=\"System Status\",\n            description=\"Current system status and metrics\",\n            mimeType=\"application/json\"\n        )\n    ]\n\n@server.read_resource()\nasync def read_resource(uri: str) -&gt; str:\n    \"\"\"Read resource content.\"\"\"\n    if uri == \"file://server-info\":\n        import psutil\n        import time\n\n        info = {\n            \"name\": \"Example MCP Server\",\n            \"version\": \"1.0.0\",\n            \"capabilities\": [\"tools\", \"resources\", \"prompts\"],\n            \"uptime\": time.time() - psutil.boot_time()\n        }\n        return json.dumps(info, indent=2)\n\n    elif uri == \"file://system-status\":\n        import psutil\n\n        status = {\n            \"cpu_percent\": psutil.cpu_percent(interval=1),\n            \"memory\": {\n                \"total\": psutil.virtual_memory().total,\n                \"available\": psutil.virtual_memory().available,\n                \"percent\": psutil.virtual_memory().percent\n            },\n            \"disk\": {\n                \"total\": psutil.disk_usage('/').total,\n                \"free\": psutil.disk_usage('/').free,\n                \"percent\": psutil.disk_usage('/').percent\n            }\n        }\n        return json.dumps(status, indent=2)\n\n    else:\n        raise ValueError(f\"Resource not found: {uri}\")\n\n@server.list_prompts()\nasync def list_prompts() -&gt; List[types.Prompt]:\n    \"\"\"List available prompts.\"\"\"\n    return [\n        types.Prompt(\n            name=\"code_review\",\n            description=\"Review code for best practices and improvements\",\n            arguments=[\n                types.PromptArgument(\n                    name=\"code\",\n                    description=\"The code to review\",\n                    required=True\n                ),\n                types.PromptArgument(\n                    name=\"language\",\n                    description=\"Programming language\",\n                    required=False\n                )\n            ]\n        ),\n        types.Prompt(\n            name=\"debug_help\",\n            description=\"Get help debugging an issue\",\n            arguments=[\n                types.PromptArgument(\n                    name=\"problem\",\n                    description=\"Description of the problem\",\n                    required=True\n                ),\n                types.PromptArgument(\n                    name=\"code\",\n                    description=\"Relevant code snippet\",\n                    required=False\n                )\n            ]\n        )\n    ]\n\n@server.get_prompt()\nasync def get_prompt(name: str, arguments: Dict[str, Any]) -&gt; types.GetPromptResult:\n    \"\"\"Get prompt content.\"\"\"\n    if name == \"code_review\":\n        code = arguments.get(\"code\", \"\")\n        language = arguments.get(\"language\", \"\")\n\n        return types.GetPromptResult(\n            description=\"Code Review Assistant\",\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(\n                        type=\"text\",\n                        text=f\"\"\"Please review the following {language or 'code'} for best practices, potential bugs, and improvements:\n\n{code}\n\nPlease provide:\n1. Code quality assessment\n2. Potential issues or bugs\n3. Suggestions for improvement\n4. Best practices recommendations\"\"\"\n                    )\n                )\n            ]\n        )\n\n    elif name == \"debug_help\":\n        problem = arguments.get(\"problem\", \"\")\n        code = arguments.get(\"code\", \"\")\n\n        content = f\"I'm experiencing this problem: {problem}\\n\\n\"\n        if code:\n            content += f\"Here's the relevant code:\\n{code}\\n\\n\"\n\n        content += \"\"\"Please help me:\n1. Understand what might be causing this issue\n2. Suggest debugging steps\n3. Provide potential solutions\n4. Recommend best practices to avoid similar issues\"\"\"\n\n        return types.GetPromptResult(\n            description=\"Debugging Assistant\",\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(type=\"text\", text=content)\n                )\n            ]\n        )\n\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n\nasync def main():\n    \"\"\"Main server function.\"\"\"\n    async with stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            server.create_initialization_options()\n        )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"resources/#requirementstxt-for-python-mcp-server","title":"requirements.txt for Python MCP Server","text":"<pre><code>mcp&gt;=0.1.0\nhttpx&gt;=0.25.0\npsutil&gt;=5.9.0\n</code></pre>"},{"location":"resources/#pyprojecttoml-alternative-to-requirementstxt","title":"pyproject.toml (Alternative to requirements.txt)","text":"<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"example-mcp-server-py\"\nversion = \"1.0.0\"\ndescription = \"Example MCP server in Python\"\ndependencies = [\n    \"mcp&gt;=0.1.0\",\n    \"httpx&gt;=0.25.0\",\n    \"psutil&gt;=5.9.0\"\n]\n\n[project.scripts]\nmcp-server = \"main:main\"\n\n[tool.setuptools]\npackages = [\".\"]\n</code></pre>"},{"location":"resources/#running-the-examples","title":"Running the Examples","text":""},{"location":"resources/#typescript-server","title":"TypeScript Server","text":"<pre><code># Install dependencies\nnpm install\n\n# Build the server\nnpm run build\n\n# Run the server\nnpm start\n</code></pre>"},{"location":"resources/#python-server","title":"Python Server","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Run the server\npython server.py\n</code></pre>"},{"location":"resources/#configuration-for-roo-code","title":"Configuration for Roo Code","text":"<p>To use these servers with Roo Code, add them to your MCP configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"typescript-server\": {\n      \"command\": \"node\",\n      \"args\": [\"/path/to/typescript-server/dist/index.js\"]\n    },\n    \"python-server\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/python-server/server.py\"]\n    }\n  }\n}\n</code></pre>"},{"location":"resources/#key-differences-typescript-vs-python","title":"Key Differences: TypeScript vs Python","text":""},{"location":"resources/#typescript-advantages","title":"TypeScript Advantages:","text":"<ul> <li>Strong typing and compile-time error checking</li> <li>Rich ecosystem and tooling</li> <li>Better IDE support</li> <li>More mature MCP SDK</li> </ul>"},{"location":"resources/#python-advantages","title":"Python Advantages:","text":"<ul> <li>Simpler syntax and faster development</li> <li>Great for data processing and AI/ML integration</li> <li>Extensive scientific computing libraries</li> <li>Easier deployment in some environments</li> </ul> <p>Both implementations provide the same MCP functionality and can be used interchangeably based on your project requirements and preferences.</p>"},{"location":"welcome/","title":"Welcome to the MCP Labs","text":"<p>Here you\u2019ll Learn and Build Model Context Protocol (MCP) from Scratch</p> <p></p>"},{"location":"welcome/#introduction","title":"Introduction","text":"<ul> <li>Welcome to the MCP Labs - a comprehensive, hands-on guide to mastering the Model Context Protocol! </li> <li>Whether you\u2019re new to MCP or looking to deepen your understanding, this learning series will take you from fundamentals to building production-ready MCP servers.</li> </ul>"},{"location":"welcome/#what-is-mcp","title":"What is MCP?","text":"<ul> <li>The Model Context Protocol (MCP) is an open protocol that standardizes how applications provide context to Large Language Models (LLMs). </li> <li>Think of it as a universal adapter that allows AI applications to connect to various data sources, tools, and services in a consistent and scalable way.</li> </ul>"},{"location":"welcome/#what-youll-learn","title":"What You\u2019ll Learn","text":"<p>Through hands-on labs, you\u2019ll:</p> <ul> <li>Understand MCP Architecture - Master the client-server model and protocol fundamentals</li> <li>Build MCP Servers - Create servers from scratch using TypeScript and the official SDK</li> <li>Implement Tools - Develop functions that LLMs can call to perform actions</li> <li>Expose Resources - Provide contextual data that LLMs can read and reference</li> <li>Create Prompts - Build reusable templates for common tasks</li> <li>Deploy to Production - Apply best practices for real-world applications</li> </ul>"},{"location":"welcome/#learning-path","title":"Learning Path","text":""},{"location":"welcome/#who-is-this-for","title":"Who Is This For?","text":"<p>This learning series is designed for:</p> <ul> <li>Developers building AI-powered applications</li> <li>Engineers integrating LLMs with existing systems</li> <li>Technical Architects designing AI infrastructure</li> <li>DevOps Professionals deploying and maintaining MCP servers</li> <li>AI Enthusiasts wanting to understand standardized AI application development</li> <li>Anyone curious about standardized AI application development</li> </ul>"},{"location":"welcome/#prerequisites","title":"Prerequisites","text":"<p>To get the most out of these labs, you should have:</p> <ul> <li>Basic Programming Knowledge - Familiarity with JavaScript/TypeScript</li> <li>Node.js Experience - Understanding of npm and basic Node.js concepts</li> <li>Command Line Skills - Comfortable with terminal/shell commands</li> <li>Code Editor - VS Code or similar IDEs (VS Code recommended)</li> </ul>"},{"location":"welcome/#required-software","title":"Required Software","text":"<p>Before starting, ensure you have installed:</p> <ul> <li>Node.js v18 or later (download)</li> <li>npm or yarn package manager</li> <li>Git for version control</li> <li>A code editor (VS Code with TypeScript is support recommended)</li> </ul>"},{"location":"welcome/#tools-youll-use","title":"Tools You\u2019ll Use","text":"<p>Throughout the labs, you\u2019ll work with:</p> <ul> <li>@modelcontextprotocol/sdk - Official TypeScript SDK</li> <li>MCP Inspector - Essential testing tool</li> <li>TypeScript - Type-safe server development</li> <li>JSON-RPC 2.0 - Communication protocol</li> </ul>"},{"location":"welcome/#learning-approach","title":"Learning Approach","text":"<p>Each lab includes:</p> <ul> <li>Clear Objectives - Know what you\u2019ll learn before you start</li> <li>Detailed Explanations - Understand the \u201cwhy\u201d behind the code</li> <li>Complete Code Examples - Working, tested code you can run</li> <li>Hands-on Exercises - Practice what you\u2019ve learned</li> <li>Key Takeaways - Reinforce important concepts</li> <li>Additional Resources - Dive deeper on specific topics</li> </ul> <p>In addition, you\u2019ll find a complete Tasks section dedicated just to exercises and challenges to solidify your understanding.</p>"},{"location":"welcome/#getting-started","title":"Getting Started","text":"<p>Ready to begin your MCP journey? </p> <p>Here\u2019s how to start:</p> <ol> <li>Browse the Labs - See an overview of all available labs</li> <li>Start with Lab 1 - Begin with the fundamentals</li> <li>Complete the various labs in Order - Each lab builds on previous knowledge</li> <li>Practice &amp; Experiment - Try variations and explore beyond examples in the Tasks section</li> </ol>"},{"location":"welcome/#community-support","title":"Community &amp; Support","text":"<p>Join the growing MCP community:</p> <ul> <li>MCP Discord - Ask questions, share projects</li> <li>GitHub Organization - Contribute to the ecosystem</li> <li>Official Documentation - Comprehensive reference</li> <li>MCP Specification - Protocol details</li> </ul>"},{"location":"welcome/#why-learn-mcp","title":"Why Learn MCP?","text":"<p>MCP is revolutionizing how we build AI applications:</p> <ul> <li>Universal Connectivity - One integration works across all MCP-compatible apps</li> <li>Reusability - Build once, use everywhere</li> <li>Scalability - Add new capabilities without rebuilding integrations</li> <li>Standardization - Consistent patterns and best practices</li> <li>Growing Ecosystem - Join a vibrant, expanding community</li> </ul>"},{"location":"welcome/#after-this-course","title":"After This Course","text":"<p>Upon completion, you\u2019ll be able to:</p> <ul> <li>Build custom MCP servers for your specific needs</li> <li>Integrate LLMs with your company\u2019s tools and data sources</li> <li>Contribute to the MCP open source ecosystem</li> <li>Create servers that others can use</li> <li>Help others learn and adopt MCP</li> </ul>"},{"location":"welcome/#explanations","title":"Explanations","text":"<p>This document provides detailed explanations of key concepts in the MCP (Model Context Protocol) server implementation, including endpoints, function calls, and RAGs (Retrieval-Augmented Generation).</p>"},{"location":"welcome/#endpoints","title":"Endpoints","text":""},{"location":"welcome/#general-meaning-of-endpoints-in-this-mcp-server","title":"General Meaning of Endpoints in This MCP Server","text":"<p>In the context of this MCP (Model Context Protocol) server, the \u201cendpoints\u201d refer to the API routes (URLs) that the server exposes for clients (like MCP inspectors, AI assistants, or other tools) to interact with it. </p> <p>These endpoints are part of the server\u2019s manifest, which is a metadata document that describes the server\u2019s capabilities, transport method (e.g., \u201cstreamable-http\u201d), and available routes. </p> <p>The manifest is served at <code>/.well-known/mcp</code> and helps clients discover and connect to the server.</p> <p>The endpoints follow RESTful conventions and support HTTP methods like GET, POST, and OPTIONS (for CORS preflight). They enable core MCP functionalities such as tool execution, resource access, prompt management, and server health checks. The server uses FastMCP (a framework for building MCP servers) and runs on port 8889 by default. </p> <p>Each endpoint is implemented as a custom route in the code, often with CORS headers for browser-based clients.</p> <p>Below, you\u2019ll find explanations for each endpoint from the manifest, including its purpose, typical HTTP methods, and what it does based on the code implementation. </p> <p>They are grouped logically for clarity.</p>"},{"location":"welcome/#core-server-and-discovery-endpoints","title":"Core Server and Discovery Endpoints","text":"<p>These handle basic server operations, discovery, and connection setup.</p> <ul> <li> <p>manifest (<code>/.well-known/mcp</code>):   Serves the MCP manifest (metadata about the server, including capabilities and all endpoints). Clients use this to understand what the server supports. Handled by <code>mcp_manifest()</code> \u2013 returns JSON with server info, base URL, and endpoint list.</p> </li> <li> <p>health (<code>/health</code>):   Simple health check to confirm the server is running. Returns a plain text response like \u201cMCP Server Running\u201d. Handled by <code>health_check()</code>.</p> </li> <li> <p>ping (<code>/ping</code>):   Connection health check with more details. Returns JSON with status (\u201cok\u201d), timestamp, and server name. Handled by <code>ping()</code>.</p> </li> <li> <p>root (<code>/</code>):   Root endpoint for basic server status. Similar to health, returns \u201cMCP Server Running\u201d. Handled by <code>root_health_check()</code>.</p> </li> <li> <p>negotiate (<code>/negotiate</code>):   Used for connection negotiation (e.g., transport setup and optional authentication via tokens). Clients send tokens here; the server responds with connection details. Handled by <code>negotiate()</code> \u2013 supports proxy tokens from headers or query params.</p> </li> <li> <p>metadata (<code>/metadata</code>):   Provides detailed server metadata, including protocol version and capabilities (e.g., support for tools, prompts). Handled by <code>metadata()</code> \u2013 returns JSON with server info and feature flags.</p> </li> <li> <p>events (<code>/mcp</code>):   The main MCP event stream endpoint for streamable HTTP transport. This is where real-time communication happens (e.g., tool calls, responses). It\u2019s the core mount path for the FastMCP server. Handled by the FastMCP framework\u2019s run method.</p> </li> </ul>"},{"location":"welcome/#tool-related-endpoints","title":"Tool-Related Endpoints","text":"<p>These manage MCP tools (functions the server exposes, like \u201chello\u201d or \u201cadd\u201d).</p> <ul> <li> <p>tools (<code>/tools</code>):   Lists all available tools with metadata (names, descriptions, arguments). Clients use this to discover tools. Handled by <code>tools_list()</code> \u2013 returns JSON with tool details from the server\u2019s <code>list_tools()</code> method.</p> </li> <li> <p>tools_execute (<code>/tools/execute</code>):   Executes a single tool synchronously. Clients send the tool name and arguments; the server runs it and returns the result. Handled by <code>tool_execute()</code> \u2013 validates args, executes via <code>execute_tool()</code>, and tracks executions.</p> </li> <li> <p>tools_batch (<code>/tools/batch</code>):   Executes multiple tools in a batch (array of calls). Useful for efficiency. Handled by <code>tool_batch_execute()</code> \u2013 processes each call and returns results.</p> </li> <li> <p>tools_stream (<code>/tools/stream</code>):   Executes a tool with streaming responses (e.g., for long-running tasks). Returns NDJSON (newline-delimited JSON) events like \u201cstart\u201d, \u201cresult\u201d, and \u201cend\u201d. Handled by <code>tool_stream_execute()</code>.</p> </li> <li> <p>tools_history (<code>/tools/history</code>):   Retrieves execution history for tools (recent runs, with optional limit). Handled by <code>tool_history()</code> \u2013 returns JSON with past executions from <code>TOOL_EXECUTIONS</code>.</p> </li> </ul>"},{"location":"welcome/#prompt-and-resource-endpoints","title":"Prompt and Resource Endpoints","text":"<p>These handle reusable prompts and static resources.</p> <ul> <li> <p>prompts (<code>/prompts</code>):   Lists available prompt templates (e.g., \u201ccode_review_prompt\u201d). Clients can use these for structured interactions. Handled by <code>prompts_list()</code> \u2013 returns JSON with prompt metadata.</p> </li> <li> <p>resources (<code>/resources</code>):   Lists available resources (e.g., server source code or info). Handled by <code>resources_list()</code> \u2013 returns JSON with resource URIs and descriptions.</p> </li> </ul>"},{"location":"welcome/#sampling-and-roots-endpoints","title":"Sampling and Roots Endpoints","text":"<p>These support advanced MCP features like LLM sampling and file system access.</p> <ul> <li> <p>sampling (<code>/sampling</code>):   Provides LLM sampling (text generation) using Ollama. Clients send a prompt; the server generates a response. Handled by <code>sampling()</code> \u2013 integrates with Ollama API for completions.</p> </li> <li> <p>roots (<code>/roots</code>):   Lists file system roots (e.g., the current working directory). Used for file-based operations. Handled by <code>roots_list()</code> \u2013 returns JSON with root URIs.</p> </li> </ul>"},{"location":"welcome/#customollama-specific-endpoint","title":"Custom/Ollama-Specific Endpoint","text":"<ul> <li>ollama_status (<code>/ollama/status</code>):   Checks the status of the connected Ollama instance (local LLM server). Returns model info, connection status, and available models. Handled by <code>ollama_status()</code> \u2013 queries Ollama\u2019s <code>/api/tags</code> endpoint.</li> </ul> <p>All endpoints include CORS headers for cross-origin requests and handle OPTIONS preflights. The server tracks tool executions globally for history/debugging.</p>"},{"location":"welcome/#function-calls","title":"Function Calls","text":""},{"location":"welcome/#what-are-function-calls","title":"What Are Function Calls?","text":"<p>In the context of MCP (Model Context Protocol) and AI systems, function calls (often referred to as \u201ctools\u201d in MCP terminology) are mechanisms that allow AI models or clients to invoke external functions or services dynamically. </p> <p>Instead of generating plain text responses, the AI can decide to call a predefined function with specific arguments, execute it on the server, and incorporate the results into its response. </p> <p>This enables more interactive, tool-augmented AI behaviors, such as performing calculations, querying databases, or interacting with APIs.</p> <p>In this MCP server, tools are essentially function calls exposed via the <code>/tools</code> endpoints. For example, the <code>hello</code> tool is a function that takes a <code>name</code> argument and returns a greeting string.</p>"},{"location":"welcome/#what-do-they-do","title":"What Do They Do?","text":"<p>Function calls allow the AI to extend its capabilities beyond static knowledge. </p> <p>They enable:</p> <ul> <li>Dynamic Execution: The AI can perform real-time actions, like adding numbers or generating text via Ollama.</li> <li>Structured Interactions: Clients (e.g., an AI assistant) can call functions to retrieve data or perform tasks, then use the output in conversations.</li> <li>Modularity: Developers can add new functions without retraining the AI model.</li> <li>Safety and Control: Arguments are validated, and executions are tracked for auditing.</li> </ul> <p>In MCP, tools are registered with decorators like <code>@mcp.tool()</code>, and clients discover them via the <code>/tools</code> endpoint.</p>"},{"location":"welcome/#how-to-set-them-up","title":"How to Set Them Up","text":"<ol> <li> <p>Define the Function: Write a Python function with type hints and a docstring. For example:    <pre><code>@mcp.tool()\ndef my_tool(arg1: str, arg2: int = 0) -&gt; str:\n    \"\"\"Description of what the tool does.\"\"\"\n    # Implementation here\n    return f\"Result: {arg1} and {arg2}\"\n</code></pre></p> <ul> <li>Use <code>@mcp.tool()</code> to register it with FastMCP.</li> <li>Arguments should have types; defaults are optional.</li> </ul> </li> <li> <p>Validation and Execution: The server automatically validates arguments against the function signature (via <code>validate_tool_arguments</code>) and executes it (via <code>execute_tool</code>). Results are tracked in <code>TOOL_EXECUTIONS</code>.</p> </li> <li> <p>Expose via Endpoints: Tools are listed at <code>/tools</code>, executed at <code>/tools/execute</code>, etc. No additional setup needed beyond registration.</p> </li> <li> <p>Testing: Use the <code>/tools/history</code> endpoint to debug executions. Ensure the function handles errors gracefully.</p> </li> <li> <p>Integration with AI: Clients (e.g., via MCP inspectors) can call these functions. For LLM integration, the AI might be prompted to output function call JSON, which the client then executes.</p> </li> </ol> <p>Function calls are asynchronous if the function is a coroutine (<code>async def</code>).</p>"},{"location":"welcome/#rags-retrieval-augmented-generation","title":"RAGs (Retrieval-Augmented Generation)","text":""},{"location":"welcome/#what-are-rags","title":"What Are RAGs?","text":"<p>RAGs stand for Retrieval-Augmented Generation, a technique in AI where an LLM (Large Language Model) retrieves relevant information from external data sources before generating a response. </p> <p>This improves accuracy, reduces hallucinations, and allows the model to access up-to-date or domain-specific knowledge not in its training data. </p> <p>Instead of relying solely on pre-trained knowledge, RAGs \u201caugment\u201d generation with retrieved context.</p> <p>In this MCP server context, RAGs can be implemented using resources (static data) or sampling (dynamic retrieval via Ollama). </p> <p>For example, retrieving code snippets or server info to inform responses.</p>"},{"location":"welcome/#how-do-they-work","title":"How Do They Work?","text":"<ol> <li>Retrieval Phase: When a query is made, the system searches a knowledge base (e.g., documents, databases) for relevant chunks of data.</li> <li>Augmentation: Retrieved data is fed into the LLM\u2019s prompt as context.</li> <li>Generation: The LLM generates a response based on both the query and retrieved data.</li> </ol> <ul> <li> <p>Key components:</p> <ul> <li>Data Sources: Could be files, APIs, or databases.</li> <li>Retriever: Searches and ranks relevant data (e.g., via embeddings or keywords).</li> <li>Generator: The LLM that produces the final output.</li> </ul> </li> </ul> <p>In MCP, resources at <code>/resources</code> can serve as static data sources, while sampling at <code>/sampling</code> can generate augmented responses.</p>"},{"location":"welcome/#how-to-set-them-up_1","title":"How to Set Them Up","text":"<ol> <li> <p>Define Data Sources: Use MCP resources for static data. For example:    <pre><code>@mcp.resource(\"mcp://my-data\")\ndef get_data() -&gt; str:\n    \"\"\"Returns relevant data.\"\"\"\n    return \"Retrieved information here.\"\n</code></pre></p> <ul> <li>Resources are listed at <code>/resources</code> and can be queried by URI.</li> </ul> </li> <li> <p>Implement Retrieval: For dynamic retrieval, integrate with tools or sampling. For instance, use a tool to query a database or API, then pass results to Ollama via <code>/sampling</code>.</p> </li> <li> <p>Augment with Sampling: At <code>/sampling</code>, send a prompt that includes retrieved context:    <pre><code>{\n  \"prompt\": \"Using this data: [retrieved info]. Answer: [query]\",\n  \"model\": \"llama3.2:latest\"\n}\n</code></pre></p> <ul> <li>Ollama generates the response with augmentation.</li> </ul> </li> <li> <p>Full RAG Pipeline:</p> <ul> <li>Client queries the server.</li> <li>Server retrieves data (e.g., via a tool or resource).</li> <li>Data is injected into a prompt.</li> <li>Sampling generates the augmented response.</li> </ul> </li> <li> <p>Tools for RAG: Add tools like <code>search_documents</code> that retrieve data. Combine with prompts for structured queries.</p> </li> <li> <p>Best Practices: Use embeddings (e.g., via Ollama or external services) for semantic search. Cache retrieved data for efficiency. Ensure data sources are secure and up-to-date.</p> </li> </ol> <p>RAGs enhance MCP servers by making them knowledge-aware, useful for applications like chatbots with custom data or code assistants.</p>"},{"location":"welcome/#additional-mcp-inspector-tabs-and-configuration","title":"Additional MCP Inspector Tabs and Configuration","text":"<p>The MCP Inspector provides various tabs that correspond to different capabilities and endpoints in your MCP server. </p> <p>These tabs allow you to test and interact with the server\u2019s features. Below, you\u2019ll find explanations for each tab mentioned (resources, prompts, tools, ping, sampling, elicitations, roots, auth, metadata) and how to configure them in the JSON manifest within <code>mcp02.py</code>.</p> <p>The manifest is defined in the <code>mcp_manifest()</code> function. It includes a <code>\"capabilities\"</code> object (boolean flags indicating support) and an <code>\"endpoints\"</code> object (URL paths). To enable or configure a feature, update these sections accordingly.</p>"},{"location":"welcome/#resources-tab","title":"Resources Tab","text":"<ul> <li>Purpose: Displays static data sources (e.g., files, server info) that clients can access.</li> <li>Configuration: <ul> <li>Set <code>\"resources\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"resources\": \"/resources\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/resources</code> endpoint to list available resources (e.g., URIs like <code>mcp://code</code>).</li> <li>Register resources with <code>@mcp.resource(\"uri\")</code> decorators.</li> </ul> </li> <li>Example: In <code>mcp02.py</code>, resources like <code>get_code()</code> and <code>get_server_info()</code> are registered and listed via <code>/resources</code>.</li> </ul>"},{"location":"welcome/#prompts-tab","title":"Prompts Tab","text":"<ul> <li>Purpose: Shows reusable prompt templates for structured interactions (e.g., code review prompts).</li> <li>Configuration:<ul> <li>Set <code>\"prompts\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"prompts\": \"/prompts\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/prompts</code> endpoint to return a list of prompt metadata.</li> <li>Register prompts with <code>@mcp.prompt()</code> decorators.</li> </ul> </li> <li>Example: Prompts like <code>code_review_prompt()</code> are defined and exposed via <code>/prompts</code>.</li> </ul>"},{"location":"welcome/#tools-tab","title":"Tools Tab","text":"<ul> <li>Purpose: Lists executable functions (tools) that clients can invoke (e.g., <code>hello</code>, <code>add</code>).</li> <li>Configuration:<ul> <li>Set <code>\"tools\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"tools\": \"/tools\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/tools</code> to return tool metadata from <code>mcp.list_tools()</code>.</li> <li>Register tools with <code>@mcp.tool()</code> decorators.</li> </ul> </li> <li>Example: Tools like <code>hello()</code> and <code>add()</code> are registered and discoverable via <code>/tools</code>.</li> </ul>"},{"location":"welcome/#ping-tab","title":"Ping Tab","text":"<ul> <li>Purpose: Tests server connectivity and health with a simple ping.</li> <li>Configuration:<ul> <li>Add <code>\"ping\": \"/ping\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement the <code>/ping</code> endpoint to return JSON with status, timestamp, and server name.</li> </ul> </li> <li>Example: The <code>ping()</code> function returns <code>{\"status\": \"ok\", ...}</code>.</li> </ul>"},{"location":"welcome/#sampling-tab","title":"Sampling Tab","text":"<ul> <li>Purpose: Allows LLM text generation (e.g., via Ollama) for completions.</li> <li>Configuration:<ul> <li>Set <code>\"sampling\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"sampling\": \"/sampling\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/sampling</code> to accept prompts and return generated text.</li> </ul> </li> <li>Example: Uses Ollama API to generate responses based on input prompts.</li> </ul>"},{"location":"welcome/#elicitations-tab","title":"Elicitations Tab","text":"<ul> <li>Purpose: Likely refers to logging or event elicitation (capturing server events/logs). In MCP, this may map to <code>\"logging\"</code> capability for debugging.</li> <li>Configuration:<ul> <li>Set <code>\"logging\": true</code> in <code>\"capabilities\"</code>.</li> <li>No specific endpoint needed, but ensure logging is enabled in the server framework.</li> </ul> </li> <li>Note: If this refers to \u201cevents,\u201d use the <code>/mcp</code> endpoint for streamable HTTP events.</li> </ul>"},{"location":"welcome/#roots-tab","title":"Roots Tab","text":"<ul> <li>Purpose: Lists file system roots for file-based operations.</li> <li>Configuration:<ul> <li>Set <code>\"roots\": true</code> in <code>\"capabilities\"</code>.</li> <li>Add <code>\"roots\": \"/roots\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/roots</code> to return root URIs (e.g., current directory).</li> </ul> </li> <li>Example: Returns <code>[{\"uri\": \"file://current/dir\", \"name\": \"Current Directory\"}]</code>.</li> </ul>"},{"location":"welcome/#auth-tab","title":"Auth Tab","text":"<ul> <li>Purpose: Handles authentication (e.g., token-based access).</li> <li>Configuration:<ul> <li>Use the <code>/negotiate</code> endpoint for auth negotiation.</li> <li>Accept tokens via headers (e.g., <code>Authorization: Bearer &lt;token&gt;</code>).</li> <li>In the manifest, no direct flag, but ensure <code>/negotiate</code> supports auth.</li> </ul> </li> <li>Example: The <code>negotiate()</code> function checks for tokens and includes them in responses.</li> </ul>"},{"location":"welcome/#metadata-tab","title":"Metadata Tab","text":"<ul> <li>Purpose: Provides server metadata (version, capabilities, protocol info).</li> <li>Configuration:<ul> <li>Add <code>\"metadata\": \"/metadata\"</code> in <code>\"endpoints\"</code>.</li> <li>Implement <code>/metadata</code> to return detailed server info.</li> </ul> </li> <li>Example: Returns JSON with <code>serverInfo</code> and <code>capabilities</code>.</li> </ul> <p>To update the manifest in <code>mcp02.py</code>, edit the <code>manifest</code> dictionary in <code>mcp_manifest()</code>. For instance, to add a new capability, include it in <code>\"capabilities\"</code> and its endpoint in <code>\"endpoints\"</code>. Restart the server after changes.</p>"},{"location":"welcome/#creating-a-personal-custom-rag","title":"Creating a Personal Custom RAG","text":"<p>Retrieval-Augmented Generation (RAG) allows you to build a custom knowledge system by combining data retrieval with LLM generation. </p> <p>Here\u2019s how to create one in your MCP server context:</p>"},{"location":"welcome/#step-1-define-data-sources","title":"Step 1: Define Data Sources","text":"<ul> <li>Static Data: Use MCP resources for fixed content (e.g., documents, code).<ul> <li>Register with <code>@mcp.resource(\"mcp://my-data\")</code>.</li> <li>Store data in files, databases, or variables.</li> </ul> </li> <li>Dynamic Data: Integrate APIs or databases for real-time retrieval.<ul> <li>Create tools to query external sources (e.g., a tool that searches a vector database).</li> </ul> </li> </ul>"},{"location":"welcome/#step-2-implement-retrieval","title":"Step 2: Implement Retrieval","text":"<ul> <li>Simple Retrieval: Use keyword search or basic queries.<ul> <li>Example: A tool that reads from a JSON file or API.</li> </ul> </li> <li>Advanced Retrieval: Use embeddings for semantic search.<ul> <li>Install libraries like <code>sentence-transformers</code> or <code>faiss</code>.</li> <li>Embed your data and queries, then find similar vectors.</li> <li>Example: Store document chunks in a vector DB, retrieve top matches for a query.</li> </ul> </li> </ul>"},{"location":"welcome/#step-3-augment-with-llm","title":"Step 3: Augment with LLM","text":"<ul> <li>Integration: Pass retrieved data into prompts.<ul> <li>Use the <code>/sampling</code> endpoint or a tool like <code>ollama_generate()</code>.</li> <li>Example Prompt: <code>\"Using this data: {retrieved_info}. Answer: {user_query}\"</code>.</li> </ul> </li> <li>Pipeline:<ol> <li>User queries the server.</li> <li>Retrieve relevant data (via tool or resource).</li> <li>Inject data into LLM prompt.</li> <li>Generate response via sampling.</li> </ol> </li> </ul>"},{"location":"welcome/#step-4-set-up-in-mcp-server","title":"Step 4: Set Up in MCP Server","text":"<ul> <li>Add Tools/Resources: Register retrieval functions as tools (e.g., <code>@mcp.tool() def search_docs(query: str)</code>).</li> <li>Configure Endpoints: Ensure <code>/resources</code>, <code>/tools</code>, and <code>/sampling</code> are enabled.</li> <li>Testing: Use the Inspector to test retrieval and generation.</li> </ul>"},{"location":"welcome/#best-practices","title":"Best Practices","text":"<ul> <li>Data Management: Keep data secure and up-to-date.</li> <li>Performance: Cache embeddings; use efficient search.</li> <li>Scalability: For large datasets, use external vector DBs like Pinecone or Weaviate.</li> <li> <p>Example Code Snippet:</p> <pre><code>@mcp.tool()\ndef rag_query(query: str) -&gt; str:\n    # Retrieve data (simplified)\n    retrieved = \"Relevant info from your data source.\"\n    # Augment and generate\n    prompt = f\"Data: {retrieved}. Query: {query}\"\n    return ollama_generate(prompt)\n</code></pre> </li> </ul> <p>This creates a personal RAG tailored to your data, enhancing AI responses with custom knowledge.</p>"},{"location":"welcome/#adding-clients-internal-llm","title":"Adding Clients (Internal LLM)","text":"<p>To integrate an internal Large Language Model (LLM) as a client with your MCP server, you need to set up a client that can connect to the MCP server, discover its capabilities, and invoke tools, resources, or prompts. </p> <p>This allows the LLM to augment its responses using the server\u2019s functionalities, such as executing custom tools or retrieving data.</p>"},{"location":"welcome/#prerequisites_1","title":"Prerequisites","text":"<ul> <li> <p>MCP Server Running: Ensure your MCP server is running and accessible (e.g., at <code>http://localhost:8889</code>).</p> </li> <li> <p>Client Library: Use an MCP-compatible client library. For Python, you can use libraries like <code>mcp-client</code> or integrate with frameworks like LangChain or LlamaIndex that support MCP. For other languages, check for MCP SDKs (e.g., Node.js MCP clients).</p> </li> <li> <p>LLM Setup: Have an internal LLM ready, such as Ollama running locally, or another model that supports tool calling (e.g., via function calling APIs).</p> </li> <li> <p>Information Needed:</p> <ul> <li>Server Base URL: The full URL where the MCP server is hosted (e.g., <code>http://localhost:8889</code>).</li> <li>Manifest URL: The URL to the manifest endpoint (e.g., <code>http://localhost:8889/.well-known/mcp</code>). This provides metadata about the server\u2019s capabilities and endpoints.</li> <li>Authentication Token (optional): If the server requires authentication, obtain a token (e.g., via the <code>/negotiate</code> endpoint). Pass it in headers like <code>Authorization: Bearer &lt;token&gt;</code>.</li> <li>Transport Method: Confirm the server uses \u201cstreamable-http\u201d transport, as indicated in the manifest.</li> </ul> </li> </ul>"},{"location":"welcome/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Install Required Libraries:</p> <ul> <li>For Python: Install the MCP client library if available (e.g., <code>pip install mcp-client</code> or similar). If using LangChain, install <code>langchain</code> and MCP integrations.</li> <li>For other setups: Ensure your LLM framework supports MCP (e.g., LlamaIndex has MCP connectors).</li> </ul> </li> <li> <p>Fetch the Server Manifest:</p> <ul> <li>Make a GET request to the manifest URL to retrieve the server\u2019s metadata.</li> <li>Example (using curl): <code>curl http://localhost:8889/.well-known/mcp</code></li> <li>Parse the JSON response to understand available endpoints (e.g., <code>/tools</code>, <code>/resources</code>, <code>/sampling</code>) and capabilities (e.g., <code>tools: true</code>).</li> </ul> </li> <li> <p>Initialize the MCP Client:</p> <ul> <li>In your client code, create an MCP client instance and connect to the server.</li> <li>Provide the base URL and any authentication details.</li> <li> <p>Example in Python (pseudo-code):</p> <pre><code>from mcp_client import MCPClient  # Assuming a library exists\n\nclient = MCPClient(base_url=\"http://localhost:8889\", auth_token=\"your_token_if_needed\")\nclient.connect()\n</code></pre> </li> </ul> </li> <li> <p>Discover Capabilities:</p> <ul> <li>Use the client to list available tools, resources, or prompts.</li> <li>Example: Call <code>client.list_tools()</code> to get tool metadata, which includes names, descriptions, and argument schemas.</li> </ul> </li> <li> <p>Integrate with the Internal LLM:</p> <ul> <li>Configure the LLM to use the MCP client for tool calling.</li> <li>For LLMs that support function calling (e.g., GPT models or local models via libraries), map MCP tools to callable functions.</li> <li>Example workflow:<ul> <li>When the LLM generates a response, check if it needs to call a tool (e.g., based on a prompt or decision).</li> <li>Use the MCP client to execute the tool: <code>result = client.call_tool(\"tool_name\", args={\"arg1\": \"value\"})</code>.</li> <li>Feed the result back into the LLM\u2019s context for the final response.</li> </ul> </li> <li>For Ollama or similar local LLMs, you may need a wrapper script that handles the tool calling logic.</li> </ul> </li> <li> <p>Handle Sampling or Generation:</p> <ul> <li>If the LLM needs to generate text augmented by the server, use the <code>/sampling</code> endpoint via the client.</li> <li>Example: <code>response = client.sample(prompt=\"Your prompt here\", model=\"llama3.2:latest\")</code>.</li> </ul> </li> <li> <p>Test the Integration:</p> <ul> <li>Run a test query where the LLM invokes a tool (e.g., the \u201chello\u201d tool).</li> <li>Verify that the client connects, executes the tool, and the LLM incorporates the result.</li> <li>Check logs on the server side (e.g., via <code>/tools/history</code>) for executions.</li> </ul> </li> <li> <p>Handle Errors and Authentication:</p> <ul> <li>Implement error handling for failed connections or tool executions.</li> <li>If authentication fails, renegotiate tokens via <code>/negotiate</code>.</li> <li>Ensure CORS and security settings allow the client to connect.</li> </ul> </li> <li> <p>Advanced Setup:</p> <ul> <li>For streaming: Use the <code>/tools/stream</code> endpoint for real-time tool execution.</li> <li>For batch operations: Call multiple tools at once via <code>/tools/batch</code>.</li> <li>Integrate with prompts: Use <code>/prompts</code> to retrieve structured prompts for the LLM.</li> </ul> </li> </ol> <p>By following these steps, your internal LLM can act as an MCP client, leveraging the server\u2019s tools and resources to provide more capable and context-aware responses. </p> <p>If using a specific LLM framework, refer to its documentation for MCP integration details.</p>"},{"location":"welcome/#next-steps","title":"Next StepsReady to Build the Future of AI Applications?","text":"<p>View All Labs \u2192 - See the complete learning path</p> <p>Start Lab 1 \u2192 - Begin your MCP journey!</p> <p>Let's get started!</p>"},{"location":"Lab00-Setup/lab/","title":"Lab 000 - Environment Setup","text":"<ul> <li>Welcome to <code>K-Agent</code> Labs! </li> <li>In this first lab, you\u2019ll set up your development environment with all the tools needed for the <code>K-Agent</code> infrastructure. </li> <li>This lab covers <code>Docker</code>, <code>Kubernetes</code>, and the <code>K-Agent</code> labs environment container.</li> </ul>"},{"location":"Lab00-Setup/lab/#what-youll-learn-in-this-workshop","title":"What you\u2019ll learn in this workshop:","text":"<ul> <li>Install and configure required tools (Docker, kubectl, Helm, Ollama, MCP Inspector, K-Agent etc.)</li> <li>Build and run the K-Agent labs environment (Docker container or locally)</li> <li>Verify Kubernetes cluster connectivity </li> <li>Prepare the MCP server setup</li> </ul>"},{"location":"Lab00-Setup/lab/#01-prerequisites-installation","title":"01. Prerequisites Installation","text":""},{"location":"Lab00-Setup/lab/#docker-installation","title":"\ud83d\udc33 Docker Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code># Install Docker Desktop\nbrew install --cask docker\n\n# Start Docker Desktop from Applications\n# Or use command line:\nopen /Applications/Docker.app\n</code></pre> <pre><code># Update package index\nsudo apt-get update\n\n# Install Docker\ncurl -fsSL https://get.docker.com | sh\n\n# Add user to docker group\nsudo usermod -aG docker $USER\n\n# Restart session or run:\nnewgrp docker\n</code></pre> <pre><code># Set up the repository\nsudo yum install -y yum-utils\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n# Install Docker\nsudo yum install -y docker-ce docker-ce-cli containerd.io\n# Start Docker\nsudo systemctl start docker\n# Add user to docker group\nsudo usermod -aG docker $USER\n# Restart session or run:\nnewgrp docker\n</code></pre> <pre><code># Docker is pre-installed in Cloud Shell\ndocker --version\n</code></pre>"},{"location":"Lab00-Setup/lab/#kubectl-installation","title":"\u2638\ufe0f kubectl Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install kubectl\n</code></pre> <pre><code>curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n</code></pre> <pre><code>curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" \nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n</code></pre> <pre><code># kubectl is pre-installed\nkubectl version --client\n</code></pre>"},{"location":"Lab00-Setup/lab/#helm-installation","title":"\u2693 Helm Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install helm\n</code></pre> <pre><code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre> <pre><code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre> <pre><code># Helm is pre-installed\nhelm version\n</code></pre>"},{"location":"Lab00-Setup/lab/#git-installation","title":"\ud83d\udc19 Git Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install git\n</code></pre> <pre><code>sudo apt-get install -y git\n</code></pre> <pre><code>sudo yum install -y git\n</code></pre> <pre><code># Git is pre-installed\ngit --version\n</code></pre>"},{"location":"Lab00-Setup/lab/#python3-installation","title":"\ud83d\udc0d Python3 Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install python\n</code></pre> <pre><code>sudo apt-get install -y python3 python3-pip\n</code></pre> <pre><code>sudo yum install -y python3 python3-pip\n</code></pre> <pre><code># Python3 is pre-installed\npython3 --version\n</code></pre>"},{"location":"Lab00-Setup/lab/#nodejs-installation","title":"\ud83d\udce6 Node.js Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install node\n</code></pre> <pre><code>sudo apt-get install -y nodejs npm\n</code></pre> <pre><code>sudo yum install -y nodejs npm\n</code></pre> <pre><code># Node.js is pre-installed\nnode --version\n</code></pre>"},{"location":"Lab00-Setup/lab/#ollama-installation","title":"\ud83e\udd16 Ollama Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install ollama\n\n# Start Ollama service\nollama serve\n</code></pre> <pre><code>curl -fsSL https://ollama.ai/install.sh | sh\n\n# Start Ollama service\nollama serve\n</code></pre> <pre><code>curl -fsSL https://ollama.ai/install.sh | sh\n\n# Start Ollama service\nollama serve\n</code></pre> <pre><code># Ollama is not supported in Cloud Shell\necho \"Ollama is not supported in Cloud Shell\"\n</code></pre>"},{"location":"Lab00-Setup/lab/#mcp-inspector-installation","title":"\ud83d\udd0d MCP Inspector Installation","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre> <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre> <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre> <pre><code>npm install -g @modelcontextprotocol/inspector\n</code></pre>"},{"location":"Lab00-Setup/lab/#kubernetes-cluster-setup-minikube","title":"Kubernetes Cluster Setup (minikube)","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install minikube\n</code></pre> <pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\n</code></pre> <pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\n</code></pre> <pre><code># Minikube is already installed in Cloud Shell\nminikube version\n</code></pre>"},{"location":"Lab00-Setup/lab/#kubernetes-cluster-setup-kind","title":"Kubernetes Cluster Setup (kind)","text":"\uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install kind\n</code></pre> <pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64\nchmod +x ./kind\nsudo mv ./kind /usr/local/bin/kind\n</code></pre> <pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64\nchmod +x ./kind\nsudo mv ./kind /usr/local/bin/kind\n</code></pre> <pre><code>Kind is not supported in Cloud Shell - Use minikube instead\n</code></pre>"},{"location":"Lab00-Setup/lab/#02-verify-tools-installation","title":"02. Verify Tools Installation","text":"<ul> <li>Verify that all the tools are installed <pre><code># Verify Docker\ndocker --version\n# Verify kubectl\nkubectl version --client\n# Verify Helm\nhelm version\n# Verify Git\ngit --version\n# Verify Python3\npython3 --version\n# Verify Node.js\nnode --version\n# Verify Ollama (if installed)\nollama --version\n# Verify MCP Inspector\nmcp-inspector --version \n# Verify Kind (if installed)\nkind --version\n# Verify Minikube (if installed)\nminikube version\n# Verify Cluster Info (if cluster is running)\nkubectl cluster-info\n</code></pre></li> </ul>"},{"location":"Lab00-Setup/lab/#03-install-the-k-agent","title":"03. Install the K-Agent","text":"<ul> <li>The <code>K-Agent</code> labs environment is the fundamental building block for all labs.</li> <li>Its an Open Source framework to write MCP tools and interact with Kubernetes clusters.</li> </ul> \uf8ff macOS\ud83d\udc27 Linux (Ubuntu/Debian)\ud83d\udc27 Linux (CentOS)\u2601\ufe0f GCP Cloud Shell <pre><code>brew install kagent\n</code></pre> <p>```bash curl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash</p> <pre><code>curl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash\n</code></pre> <pre><code>curl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash\n</code></pre>"},{"location":"Lab00-Setup/lab/#verifty-k-agent-installation","title":"Verifty K-Agent Installation","text":"<pre><code>kagent version\n</code></pre>"},{"location":"Lab00-Setup/lab/#04-ollama-setup","title":"04. Ollama Setup","text":"<ul> <li>Ollama will be used as our LLLM model for the labs.</li> <li>Ollama is a local LLM server that allows you to run large language models on your machine.</li> <li>Ollama supports various models, for example: Qwen and Llama.</li> <li>We will ise the <code>qwen3-coder</code> model which is optimized for coding tasks or the <code>gpt-oos</code> model.  </li> </ul> <p>Pulling Models (Ollama)</p> <ul> <li>Pulling models can take a while depending on your internet speed and system performance.</li> <li>You can skip this step and return to it later when needed.</li> </ul>"},{"location":"Lab00-Setup/lab/#setup-ollama-models","title":"Setup Ollama models","text":"<pre><code># Start Ollama service\nollama serve\n\n# In a new terminal, pull the qwen3-coder model (optimized for coding tasks)\nollama pull qwen3-coder:30b\n\n# Alternatively, pull the gpt-oos model\nollama pull gpt-oos:7b\n\n# Verify\nollama list\n</code></pre>"},{"location":"Lab00-Setup/lab/#pull-a-model","title":"Pull a Model","text":"<pre><code># In a new terminal, pull the qwen3-coder model (optimized for coding tasks)\nollama pull qwen3-coder:30b\n\n# Verify\nollama list\n</code></pre>"},{"location":"Lab00-Setup/lab/#07-verify-setup","title":"07. Verify Setup","text":"<ul> <li>Let\u2019s verify your setup by running a simple test.</li> </ul>"},{"location":"Lab00-Setup/lab/#task-01-check-cluster-information","title":"Task 01: Check Cluster Information","text":"<pre><code># Check cluster info\nkubectl cluster-info\nkubectl get nodes\nkubectl get namespaces\n</code></pre> <p>Exercise 2: Test Container Environment</p> <pre><code># Start labs environment if not running\ncd labs-environment\ndocker compose up -d\n\n# Execute commands in container\ndocker exec kagent-controller bash -c \"\necho '=== Environment Check ==='\necho 'Node.js:' \\$(node --version)\necho 'Python:' \\$(python --version)\necho 'kubectl:' \\$(kubectl version --client --short)\necho 'Helm:' \\$(helm version --short)\necho '========================='\n\"\n</code></pre> <p>Expected Output: <pre><code>=== Environment Check ===\nNode.js: v18.x.x\nPython: Python 3.10.x\nkubectl: Client Version: v1.28.x\nHelm: v3.13.x\n=========================\n</code></pre></p>"},{"location":"Lab00-Setup/lab/#08-troubleshooting","title":"08. Troubleshooting","text":"<p>Container Won\u2019t Start</p> <p>If the container fails to start, check: <pre><code>docker compose logs\ndocker images | grep kagent\ndocker ps -a\n</code></pre></p> <p>Kubectl Not Working in Container</p> <p>If kubectl commands fail in the container: <pre><code># Verify kubeconfig is mounted correctly\ndocker exec kagent-controller ls -la /root/.kube/\n\n# Try copying kubeconfig again\ncp ~/.kube/config $(git rev-parse --show-toplevel)//runtime/.kube/config\n\n# Restart container\ncd labs-environment\ndocker compose restart\n</code></pre></p> <p>Platform Issues (M1/M2 Mac)</p> <p>If you encounter platform errors: <pre><code># Verify platform in .env file\ncat labs-environment/.env\n\n# Should show: TARGET_PLATFORM=linux/arm64\n# If not, update it manually\n</code></pre></p>"},{"location":"Lab01-MCP-Fundamentals/lab/","title":"Lab 1 - MCP Fundamentals","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#overview","title":"Overview","text":"<ul> <li><code>MCP</code> is a game-changer for AI application development .</li> <li>In this lab, you\u2019ll learn about the Model Context Protocol (<code>MCP</code>), the communication standard that enables AI assistants to interact with external tools and services. </li> <li>You\u2019ll explore MCP concepts, test simple tools, and understand the protocol structure.</li> <li> <p>This lab uses the MCP server included in the K-Agent labs environment.</p> <p>Prerequisites</p> <ul> <li>Make sure you have completed Lab 000 - Environment Setup before starting this lab.</li> </ul> </li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand what <code>MCP</code> is and why it was created</li> <li>Learn the core architecture and components of <code>MCP</code></li> <li>Identify the key capabilities <code>MCP</code> provides</li> <li>Understand the client-server model in <code>MCP</code></li> <li>Recognize common use cases for <code>MCP</code></li> <li>Learn MCP server and client communication</li> <li>Testing MCP tools with stdio transport</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#what-is-mcp","title":"What is MCP?","text":"<ul> <li>The Model Context Protocol (MCP) is an open protocol that standardizes how AI applications interact with external data sources and tools. </li> <li>It defines a structured way for AI assistants (clients) to discover, call, and receive responses from tools (servers) using JSON-RPC over various transport layers.</li> <li>MCP is designed to be flexible and extensible, allowing developers to create custom tools that can be easily integrated with different AI models.</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#what-does-mcp-offer","title":"What does MCP offer?","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#standardized-communication","title":"Standardized Communication","text":"<p>AI assistants can work with any MCP-compatible tool</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#tool-discovery","title":"Tool Discovery","text":"<p>Clients can discover available tools from servers</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#structured-interaction","title":"Structured Interaction","text":"<p>Well-defined input/output schemas using JSON</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#standardized-communication_1","title":"Standardized Communication","text":"<p>AI assistants can work with any MCP-compatible tool</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#tool-discovery_1","title":"Tool Discovery","text":"<p>Clients can discover available tools from servers</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#structured-interaction_1","title":"Structured Interaction","text":"<p>Well-defined input/output schemas using JSON</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#multiple-transports","title":"Multiple Transports","text":"<p>Supports stdio, HTTP, WebSocket</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#the-problem-mcp-solves","title":"The Problem MCP Solves","text":"<p>Before <code>MCP</code>, every AI application had to build custom integrations for each data source or tool it wanted to use. This led to:</p> <ul> <li>Fragmentation: Each app using different methods to connect to the same services</li> <li>Duplication: Developers rebuilding the same integrations repeatedly</li> <li>Limited scalability: Adding new integrations was time-consuming and error-prone</li> <li>Inconsistent experiences: No standard way for LLMs to interact with external systems</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#the-mcp-solution","title":"The MCP Solution","text":"<p><code>MCP</code> provides a standardized protocol that:</p> <ul> <li>Enables universal connectivity between LLMs and data sources</li> <li>Allows one integration to work across all MCP-compatible applications</li> <li>Provides a consistent interface for accessing tools, resources, and prompts</li> <li>Supports secure, controlled access to external systems</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-architecture-overview","title":"MCP Architecture Overview","text":"<p><code>MCP</code> follows a client-server architecture with clear separation of concerns:</p> <pre><code>graph TD\n    A[MCP Client] --&gt; B[Ollama Module]\n    A --&gt; C[IDEs &amp; Apps]\n    A --&gt; D[AI Tools]\n    B --&gt; E[MCP Protocol]\n    C --&gt; E\n    D --&gt; E\n    E --&gt; F[MCP Server]\n    F --&gt; G[Exposes: Tools, Resources &amp; Prompts]\n    F --&gt; H[Connects to: APIs, Databases, Files, etc.]</code></pre>"},{"location":"Lab01-MCP-Fundamentals/lab/#k-agent-architecture-flow","title":"K-Agent Architecture Flow","text":"<pre><code>flowchart TD\n    assistant[AI Assistant] --&gt;|MCP tool request| kagent[K-Agent MCP Server]\n    kagent --&gt; toolRouter[K-Agent Tool Router]\n    toolRouter --&gt;|kubeclient| k8s[Kubernetes API]\n    toolRouter --&gt;|cloud sdk| clouds[Cloud Providers]\n    kagent --&gt;|context updates| datastore[State &amp; Context Store]\n    datastore --&gt;|observability| observ[Logs &amp; Metrics]\n    k8s --&gt;|responses| kagent\n    clouds --&gt;|responses| kagent\n    kagent --&gt;|MCP response| assistant\n    subgraph cluster [Kubernetes Cluster]\n        direction LR\n        k8s\n        datastore\n        observ\n    end</code></pre>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-components","title":"MCP Components","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-server","title":"MCP Server","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#exposes-toolsresources-to-clients","title":"Exposes tools/resources to clients","text":"<ul> <li>Provides a standardized interface for tool interaction</li> <li>Allows AI assistants to discover and call tools</li> <li>Manages tool lifecycle and execution</li> <li>Handles tool errors and retries</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#implements-the-mcp-protocol","title":"Implements the MCP protocol","text":"<ul> <li>Follows JSON-RPC 2.0 specification</li> <li>Supports multiple transport layers (stdio, HTTP, WebSocket)</li> <li>Manages tool schemas and validation</li> <li>Supports tool discovery and listing</li> <li>Provides structured responses</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#typical-mcp-server-features","title":"Typical MCP Server Features","text":"<ul> <li>Runs as a standalone process or service</li> <li>Can be deployed locally or in the cloud</li> <li>Can run in containers or serverless environments</li> <li>Scales based on demand</li> <li>Monitors tool usage and performance</li> <li>Logs tool interactions for auditing</li> <li>Supports authentication and authorization</li> <li>Integrates with AI assistants and applications</li> <li>Defines tool schemas (inputs/outputs)</li> <li>Handles tool execution</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-server-notes","title":"MCP Server Notes","text":"<ul> <li>Communicates via transport layer (stdio, HTTP, WebSocket)</li> <li>Typically runs as a local process or container</li> <li>In K-Agent, the MCP server exposes Kubernetes and cloud management tools.</li> <li>The server listens for incoming MCP requests from AI assistants and executes the requested tools.</li> <li>In our lab The server translates MCP tool calls into Kubernetes API calls or cloud service operations.</li> <li>The server returns structured responses back to the AI assistant.</li> <li>The server can also update context/state in a datastore for persistent information.</li> <li>The server is implemented using the MCP SDK, which simplifies tool definition and communication handling.</li> <li>The server supports multiple transport layers, allowing it to communicate with different types of AI assistants.</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-client","title":"MCP Client","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#general-mcp-client-features","title":"General MCP Client Features","text":"<ul> <li>The application that hosts the LLM (e.g., Roo Code, VS Code, Visual Studio, etc.)</li> <li>Discovers available tools from MCP servers</li> <li>Sends tool call requests with parameters</li> <li>Receives and processes tool responses</li> <li>Manages tool invocation lifecycle</li> <li>Handles errors and retries</li> <li>Typically embedded in remote AI assistants (Claude, ChatGPT, etc.) or local models (Ollama, etc.)</li> <li>Presents server capabilities to the user/LLM</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#the-host-application","title":"The Host Application","text":"<ul> <li>The <code>Client</code> is often part of a Host Application (like VS Code, Claude Desktop, or a CLI).</li> <li>The Host manages the connection to the MCP Server.</li> <li>It provides the user interface for interacting with the AI.</li> <li>It handles permissions (asking the user before running a tool).</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#client-capabilities","title":"Client Capabilities","text":"Capability Description Sampling The server can request the client to sample an LLM (generate text). Roots The client can tell the server which files/folders are accessible. Notifications The client can receive notifications from the server (e.g. logs, progress). Context Updates The client can send context/state updates to the server. Authentication The client can provide authentication tokens/credentials to the server. Transport The client supports multiple transport layers (stdio, HTTP, WebSocket). Error Handling The client manages errors and retries for tool calls. Tool Discovery The client can list available tools from the server. Tool Invocation The client can call tools with parameters and receive structured responses. Logging The client can log tool interactions for auditing and debugging."},{"location":"Lab01-MCP-Fundamentals/lab/#transport-layer-mcp-communication","title":"Transport Layer - MCP Communication","text":"<ul> <li>MCP supports multiple transport mechanisms:</li> </ul> Protocol Description <code>stdio</code> Standard input/output (used in K-Agent) <code>HTTP</code> RESTful API communication <code>WebSocket</code> Real-time bidirectional communication <code>gRPC</code> High-performance RPC framework <code>MQTT</code> Lightweight messaging protocol <code>Custom</code> Any custom transport implementation"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-communication-flow","title":"MCP Communication Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant S as Server\n\n    C-&gt;&gt;S: 1. Discover available tools\n    C-&gt;&gt;S: 2. Send tool call request (parameters)\n    Note over S: 3. Validate request against schema\n    Note over S: 4. Execute tool logic\n    S--&gt;&gt;C: 5. Return structured response\n    Note over C: 6. Process response &amp; continue interaction</code></pre>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-tool-structure","title":"MCP Tool Structure","text":"<ul> <li>An MCP tool consists of:</li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul> <ul> <li> </li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#tool-definition","title":"Tool Definition","text":"<ul> <li>Metadata about the tool (name, description)</li> <li>Input schema defining parameters</li> <li>Output schema defining response structure</li> <li>Versioning information</li> <li>Dependencies and requirements</li> <li>Authentication requirements</li> <li>Rate limiting information</li> <li>Error handling strategies</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#tool-handler","title":"Tool Handler","text":"<ul> <li>Function that implements the tool\u2019s logic</li> <li>Receives input parameters</li> <li>Performs the tool\u2019s operation</li> <li>Returns structured output</li> <li>Handles errors and exceptions</li> <li>Logs execution details</li> <li>Manages state/context if needed</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#tool-execution-flow","title":"Tool Execution Flow","text":"<ul> <li>Client discovers tool from server</li> <li>Client sends tool call request with parameters</li> <li>Server validates request against tool schema</li> <li>Server invokes tool handler with parameters</li> <li>Tool handler executes logic and returns response</li> <li>Server sends structured response back to client</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#input-schema","title":"Input Schema","text":"<ul> <li>Defines expected parameters for the tool</li> <li>Uses JSON Schema format</li> <li>Specifies data types, required fields, and descriptions</li> <li>Enables validation of incoming requests</li> <li>Facilitates client-side form generation</li> <li>Supports complex nested structures</li> <li>Allows default values and constraints</li> <li>Enhances interoperability between clients and servers</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#core-mcp-capabilities","title":"Core MCP Capabilities","text":"<p><code>MCP</code> servers can expose three main types of capabilities:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-tools","title":"1. Tools","text":"<p>Functions that the LLM can call to perform actions or retrieve information.</p> <p>Examples:</p> <ul> <li>Search a database</li> <li>Make an API call</li> <li>Perform calculations</li> <li>Execute system commands</li> </ul> <p>Characteristics:</p> <ul> <li>Defined with JSON Schema for input validation</li> <li>Return structured results</li> <li>Can have side effects (create, update, delete operations)</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#examples","title":"Examples:","text":"<ul> <li> <p>Tool Definition:</p> <pre><code>{\n  name: \"hello\",\n  description: \"Returns a greeting message\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      name: {\n        type: \"string\",\n        description: \"Name to greet\"\n      }\n    },\n    required: [\"name\"]\n  }\n}\n</code></pre> </li> <li> <p>Tool Handler:</p> <pre><code>async function handleHello(args: { name: string }) {\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Hello, ${args.name}!`\n      }\n    ]\n  };\n}\n</code></pre> </li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-resources","title":"2. Resources","text":"<p>Contextual data that can be read by the LLM.</p> <p>Examples:</p> <ul> <li>File contents</li> <li>Database records</li> <li>API responses</li> <li>Documentation</li> </ul> <p>Characteristics:</p> <ul> <li>Identified by URI (Uniform Resource Identifier)</li> <li>Can be text, binary, or structured data</li> <li>Typically read-only</li> <li>Support for templates and subscriptions</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-prompts","title":"3. Prompts","text":"<p>Pre-built prompt templates that users can invoke.</p> <p>Examples:</p> <ul> <li>Code review templates</li> <li>Documentation generation prompts</li> <li>Analysis frameworks</li> <li>Interaction patterns</li> </ul> <p>Characteristics:</p> <ul> <li>Can include embedded resources</li> <li>Support arguments for customization</li> <li>Help standardize common tasks</li> <li>Improve consistency and quality</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#the-mcp-lifecycle","title":"The MCP Lifecycle","text":"<p>Understanding how <code>MCP</code> clients and servers interact:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-initialization","title":"1. Initialization","text":"<ul> <li>Client connects to server via transport layer</li> <li>Handshake to establish protocol version and capabilities</li> <li>Server sends initial tool/resource/prompt listings</li> <li>Client acknowledges and prepares for interaction</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-capability-discovery","title":"2. Capability Discovery","text":"<ul> <li>Client requests list of available tools, resources, or prompts</li> <li>Server responds with detailed descriptions</li> <li>Client presents these to the user/LLM</li> <li>Client selects tools/resources/prompts to use</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-execution","title":"3. Execution","text":"<ul> <li>Client sends requests to invoke tools, read resources, or render prompts</li> <li>Server processes the request</li> <li>Server returns results in standardized format</li> <li>Client handles the response and continues interaction</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#4-cleanup","title":"4. Cleanup","text":"<ul> <li>Either party can close the connection</li> <li>Graceful shutdown with notifications</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-communication-model","title":"MCP Communication Model","text":"<p><code>MCP</code> uses three types of messages:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-requests","title":"1. Requests","text":"<ul> <li>Require a response</li> <li>Include a unique request ID</li> <li>Examples: <code>tools/list</code>, <code>resources/read</code>, <code>tools/call</code></li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-responses","title":"2. Responses","text":"<ul> <li>Match to requests by ID</li> <li>Contain either results or errors</li> <li>Must be sent for every request</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-notifications","title":"3. Notifications","text":"<ul> <li>One-way messages</li> <li>Don\u2019t require responses</li> <li>Examples: <code>notifications/initialized</code>, <code>notifications/cancelled</code></li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#security-considerations","title":"Security Considerations","text":"<p>When working with <code>MCP</code>, keep these best practices in mind:</p> <ol> <li> <p>Authentication &amp; Authorization</p> <ul> <li>Servers should validate requests</li> <li>Use appropriate credentials management</li> <li>Implement least-privilege access</li> </ul> </li> <li> <p>Data Privacy</p> <ul> <li>Be mindful of what data is exposed</li> <li>Implement proper access controls</li> <li>Consider encryption for sensitive data</li> </ul> </li> <li> <p>Rate Limiting</p> <ul> <li>Protect against abuse</li> <li>Implement appropriate throttling</li> <li>Monitor usage patterns</li> </ul> </li> <li> <p>Input Validation</p> <ul> <li>Always validate tool inputs</li> <li>Sanitize user-provided data</li> <li>Prevent injection attacks</li> </ul> </li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab/#common-use-cases","title":"Common Use Cases","text":"<p><code>MCP</code> is ideal for:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#enterprise-integration","title":"Enterprise Integration","text":"<ul> <li>Connect LLMs to internal databases</li> <li>Access corporate knowledge bases</li> <li>Integrate with business tools (CRM, ERP, etc.)</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#developer-tools","title":"Developer Tools","text":"<ul> <li>File system access</li> <li>Git operations</li> <li>Database queries</li> <li>API testing and documentation</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#data-analysis","title":"Data Analysis","text":"<ul> <li>Query and visualize data</li> <li>Generate reports</li> <li>Perform statistical analysis</li> <li>Access multiple data sources</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#productivity","title":"Productivity","text":"<ul> <li>Calendar and email management</li> <li>Task and project tracking</li> <li>Document processing</li> <li>Automated workflows</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-vs-other-approaches","title":"MCP vs. Other Approaches","text":"Approach Pros Cons Function Calling Simple, direct Requires custom implementation per app API Integration Flexible No standard, duplicated effort MCP Universal standard, reusable, scalable Requires initial setup"},{"location":"Lab01-MCP-Fundamentals/lab/#hands-on-exercise","title":"Hands-On Exercise","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#explore-an-mcp-server-configuration","title":"Explore an MCP Server Configuration","text":"<p>Look at how an <code>MCP</code> server is configured in a client application (like Roo Code):</p> <pre><code>{\n  \"mcpServers\": {\n    \"example-server\": {\n      \"command\": \"node\",\n      \"args\": [\"/path/to/server/index.js\"],\n      \"env\": {\n        \"API_KEY\": \"your-api-key\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Lab01-MCP-Fundamentals/lab/#testing-mcp-tools-ts","title":"Testing MCP Tools (TS)","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#using-mcp-inspector","title":"Using MCP Inspector","text":"<p><code>MCP Inspector</code> is a tool for testing MCP servers interactively.</p> <pre><code># Install mcp-inspector (if not already installed)\nnpm install -g @modelcontextprotocol/inspector\n\n# Start the MCP Inspector with the TS code\nnpx @modelcontextprotocol/inspector node ./build/index.js\n</code></pre> <p>MCP Inspector UI</p> <ul> <li>MCP Inspector will start a web interface at <code>http://localhost:6274</code></li> <li>You can also test tools programmatically using the examples below.</li> </ul> <p>Step-by-step MCP Inspector Testing:</p> <ol> <li> <p>Get the Authentication Token    When you start MCP Inspector, the terminal displays:</p> <pre><code>\ud83d\udd11 Session token: [long-token-string]\n\n\ud83d\udd17 Open inspector with token pre-filled:\n    http://localhost:6274/?MCP_PROXY_AUTH_TOKEN=[token]\n</code></pre> </li> <li> <p>Copy the Authentication URL    Copy the complete URL with the token (the second line starting with <code>http://</code>)</p> </li> <li> <p>Open MCP Inspector in Your Browser    Paste the complete URL with the token from step 2 into your browser. You\u2019ll be authenticated immediately.</p> </li> <li> <p>Configure the Server Connection    In the MCP Inspector interface:</p> <ul> <li>Verify the \u201cTransport\u201d is set to <code>stdio</code> (NOT http or streamable-http)</li> <li>You\u2019ll see a \u201cCommand\u201d field - it should already show: <code>node</code></li> <li>look for the \u201cArgument\u201d field - it should show: <code>/app/build/index.js</code></li> <li>Click the \u201cConnect\u201d button</li> <li>Wait for the status to show \u201cConnected\u201d with a green indicator</li> </ul> </li> <li> <p>Explore Available Tools:</p> <ul> <li>Once connected, click on the \u201cTools\u201d tab at the top of the interface, and the on \u201cList Tools\u201d button</li> <li>You\u2019ll see a list of available tools from your MCP server</li> </ul> </li> </ol> <p>Authentication Required</p> <ul> <li>The MCP Inspector requires authentication by default. </li> <li>Always use the URL with the token (shown in the terminal when you start the inspector), or manually enter the token in the Configuration settings. </li> <li>If you forget the token, restart the MCP Inspector to generate a new one.</li> </ul> <p>Disabling Authentication (Development Only)</p> <p>Y* ou can disable authentication by setting the <code>DANGEROUSLY_OMIT_AUTH=true</code> environment variable: <pre><code>DANGEROUSLY_OMIT_AUTH=true npx @modelcontextprotocol/inspector node /app/build/index.js\n</code></pre> \u26a0\ufe0f WARNING: This is dangerous and should ONLY be used in isolated development environments, never in production or when exposed to the internet.</p> <p>Keep MCP Inspector Running</p> <ul> <li>Make sure the MCP Inspector command (<code>npx @modelcontextprotocol/inspector node /app/build/index.js</code>) is still running in your terminal. </li> <li>If the connection fails or you see errors, restart the command in the container.</li> </ul> <p>Interactive Testing</p> <ul> <li>The MCP Inspector provides a user-friendly web interface to test your MCP server without writing code. </li> <li>This is perfect for debugging and understanding how MCP tools work before integrating them with AI assistants.</li> </ul> <p>Understanding MCP Inspector Output</p> <ul> <li>The Inspector displays tool results in a readable format. </li> <li>Internally, MCP uses JSON-RPC 2.0 protocol with structured responses, but the UI shows you the human-readable content. </li> <li>For JSON view, see the \u201cHistory\u201d section below the UI</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#deep-dive-mcp-base-components-python-focus","title":"Deep Dive: MCP Base Components (Python Focus)","text":"<p>Now let\u2019s examine the essential building blocks of MCP and how they\u2019re implemented in Python. We\u2019ll focus on the Python implementation since it\u2019s often clearer and more accessible than TypeScript.</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-mcp-server-framework-fastmcp","title":"1. MCP Server Framework (FastMCP)","text":"<p>The foundation of any MCP server is the server framework. In Python, we use <code>FastMCP</code>:</p> <pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create the MCP server instance\nmcp = FastMCP(\"my-mcp-server\", port=8889)\n</code></pre> <p>What it does:</p> <ul> <li>Provides the HTTP server infrastructure</li> <li>Handles JSON-RPC communication</li> <li>Manages tool, resource, and prompt registration</li> <li>Implements the MCP protocol handshake</li> </ul> <p>What\u2019s inside:</p> <ul> <li>HTTP request handlers for all MCP endpoints</li> <li>Tool execution engine</li> <li>Resource serving system</li> <li>Prompt template management</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-tool-registration-decorator","title":"2. Tool Registration Decorator","text":"<p>Tools are the core functionality exposed by MCP servers:</p> <pre><code>@mcp.tool()\ndef hello(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to K-Agent Labs.\"\n</code></pre> <p>What it produces:</p> <ul> <li>A callable function registered with the MCP server</li> <li>JSON Schema for input validation</li> <li>Metadata for client discovery</li> </ul> <p>What\u2019s inside:</p> <ul> <li>Function signature inspection</li> <li>Automatic parameter validation</li> <li>Execution tracking and logging</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-resource-handlers","title":"3. Resource Handlers","text":"<p>Resources provide read-only data access:</p> <pre><code>@mcp.resource(\"mcp://server-info\")\ndef get_server_info() -&gt; str:\n    \"\"\"Returns information about this MCP server\"\"\"\n    return \"\"\"K-Agent MCP Server\n\nVersion: 0.1.0\nCapabilities:\n- Tools: hello, add\n- Prompts: code_review_prompt, debug_prompt\n- Resources: code, server-info\n\"\"\"\n</code></pre> <p>What it produces:</p> <ul> <li>A resource accessible via a URI</li> <li>Content generation logic</li> <li>MIME type specification</li> <li>URI-addressable data endpoints</li> <li>Structured metadata for discovery</li> <li>MIME type information</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#4-prompt-templates","title":"4. Prompt Templates","text":"<p>Reusable prompt templates for consistent interactions:</p> <pre><code>@mcp.prompt()\ndef code_review_prompt(code: str, language: str = \"python\") -&gt; str:\n    \"\"\"Generate a code review prompt for the given code\"\"\"\n    # Create the prompt template with proper markdown formatting\n    template = f\"\"\"Please review this {language} code and provide feedback:\n\n``` + language + f\"\"\"\n\"\"\" + code + f\"\"\"\n\nFocus on:\n- Code quality and best practices\n- Potential bugs or issues\n- Performance improvements\n- Security concerns\n\"\"\"\n    return template\n</code></pre> <p>What it produces:</p> <ul> <li>A prompt template registered with the MCP server</li> <li>Argument definitions for dynamic rendering</li> <li>Metadata for client discovery</li> <li>Parameterized prompt templates</li> <li>Standardized interaction patterns</li> <li>Consistent output formatting</li> </ul> <p>Example output when called: <pre><code>Please review this python code and provide feedback:\n\n&amp;#96;&amp;#96;&amp;#96;python\ndef hello(): pass\n&amp;#96;&amp;#96;&amp;#96;\n\nFocus on:\n- Code quality and best practices\n- Potential bugs or issues\n- Performance improvements\n- Security concerns\n</code></pre></p>"},{"location":"Lab01-MCP-Fundamentals/lab/#5-transport-layer-http-routes","title":"5. Transport Layer (HTTP Routes)","text":"<p>Custom routes handle the MCP protocol communication:</p> <pre><code>@mcp.custom_route(\"/.well-known/mcp\", methods=[\"GET\", \"OPTIONS\"])\nasync def mcp_manifest(request: Request) -&gt; JSONResponse:\n    manifest = {\n        \"name\": \"kagent-mcp-server\",\n        \"version\": \"0.1.0\",\n        \"capabilities\": {\n            \"tools\": True,\n            \"prompts\": True,\n            \"resources\": True,\n            \"sampling\": True\n        }\n    }\n    return JSONResponse(manifest)\n</code></pre> <p>What it does:</p> <ul> <li>Implements MCP protocol endpoints</li> <li>Handles client-server negotiation</li> <li>Provides capability discovery</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#mcp-method-flow-with-echo-commands","title":"MCP Method Flow with Echo Commands","text":"<p>Let\u2019s trace through the Python methods called during a typical MCP interaction, with echo commands to show what\u2019s happening:</p> <pre><code># 1. Server Initialization\ndef main():\n    print(\"\ud83d\udd27 Initializing MCP server...\")\n    mcp = FastMCP(\"kagent-mcp-server\", port=8889)\n    print(\"\u2705 Server instance created with port 8889\")\n\n    # Register tools\n    print(\"\ud83d\udee0\ufe0f  Registering tools...\")\n    @mcp.tool()\n    def hello(name: str) -&gt; str:\n        print(f\"\ud83d\udc4b Executing hello tool for {name}\")\n        return f\"Hello, {name}!\"\n    print(\"\u2705 Tool 'hello' registered\")\n\n    # Start the server\n    print(\"\ud83d\ude80 Starting MCP server...\")\n    mcp.run(transport=\"streamable-http\", mount_path=\"/mcp\")\n    print(\"\u2705 Server running on http://localhost:8889\")\n\n# 2. Client Connection Process\nasync def connect_to_server():\n    print(\"\ud83d\udd17 Connecting to MCP server...\")\n\n    # Get manifest\n    print(\"\ud83d\udccb Fetching server manifest...\")\n    manifest = await client.get(f\"{base_url}/.well-known/mcp\")\n    print(f\"\u2705 Got manifest: {manifest['name']} v{manifest['version']}\")\n\n    # Negotiate connection\n    print(\"\ud83e\udd1d Negotiating connection...\")\n    negotiate_response = await client.get(f\"{base_url}/negotiate\")\n    print(f\"\u2705 Negotiation complete: {negotiate_response['transport']}\")\n\n    # List tools\n    print(\"\ud83d\udccb Listing available tools...\")\n    tools = await client.post(f\"{base_url}/tools\")\n    print(f\"\u2705 Found {len(tools['tools'])} tools\")\n\n    return True\n\n# 3. Tool Execution Flow\nasync def execute_tool_flow():\n    print(\"\ud83c\udfaf Executing tool 'hello'...\")\n\n    # Validate arguments\n    print(\"\ud83d\udd0d Validating tool arguments...\")\n    # (validation logic here)\n    print(\"\u2705 Arguments valid\")\n\n    # Execute tool\n    print(\"\u26a1 Calling tool function...\")\n    result = await execute_tool(\"hello\", {\"name\": \"Alice\"})\n    print(f\"\u2705 Tool executed successfully: {result['result']}\")\n\n    # Track execution\n    print(\"\ud83d\udcca Recording execution metrics...\")\n    # (tracking logic here)\n    print(\"\u2705 Execution tracked\")\n\n    return result\n\n# 4. Resource Access Flow\nasync def access_resource_flow():\n    print(\"\ud83d\udcd6 Accessing resource...\")\n\n    # Resolve resource URI\n    print(\"\ud83d\udd17 Resolving resource URI...\")\n    # (URI resolution logic)\n    print(\"\u2705 Resource resolved\")\n\n    # Fetch resource content\n    print(\"\ud83d\udce5 Fetching resource content...\")\n    content = await get_resource_content(\"mcp://server-info\")\n    print(f\"\u2705 Resource content retrieved ({len(content)} chars)\")\n\n    return content\n\n# 5. Prompt Usage Flow\nasync def use_prompt_flow():\n    print(\"\ud83d\udcdd Using prompt template...\")\n\n    # Get prompt template\n    print(\"\ud83d\udd0d Finding prompt template...\")\n    template = await get_prompt_template(\"code_review_prompt\", \n                                       code=\"def test(): pass\")\n    print(f\"\u2705 Template retrieved ({len(template)} chars)\")\n\n    # Render with arguments\n    print(\"\ud83c\udfa8 Rendering prompt with arguments...\")\n    final_prompt = template  # Already rendered\n    print(\"\u2705 Prompt rendered\")\n\n    # Send to LLM\n    print(\"\ud83e\udd16 Sending to LLM for processing...\")\n    response = await sample_llm(final_prompt)\n    print(f\"\u2705 LLM response received ({len(response)} chars)\")\n\n    return response\n</code></pre> <p>Method Call Order:</p> <ol> <li><code>FastMCP.__init__()</code> - Server initialization</li> <li><code>@mcp.tool()</code> decorator - Tool registration</li> <li><code>mcp.run()</code> - Start HTTP server</li> <li><code>/.well-known/mcp</code> GET - Client discovery</li> <li><code>/negotiate</code> GET - Connection negotiation</li> <li><code>/tools</code> POST - Tool discovery</li> <li><code>/tools/execute</code> POST - Tool execution</li> <li><code>/resources</code> GET - Resource discovery</li> <li><code>/sampling</code> POST - LLM interaction</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab/#what-realizes-mcp","title":"What Realizes MCP","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#what-makes-mcp-work","title":"What Makes MCP Work","text":"<p>MCP is realized through several key mechanisms:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-protocol-standardization","title":"1. Protocol Standardization","text":"<ul> <li>JSON-RPC 2.0 as the communication protocol</li> <li>HTTP transport for reliable message delivery</li> <li>Capability negotiation during connection establishment</li> <li>Structured error handling and response formatting</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-component-integration","title":"2. Component Integration","text":"<ul> <li>Server frameworks (FastMCP, MCP SDK) that implement the protocol</li> <li>Client libraries that know how to communicate with servers</li> <li>Tool execution engines that safely run server-provided functions</li> <li>Resource resolution systems that handle URI-based data access</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-security-boundaries","title":"3. Security Boundaries","text":"<ul> <li>Process isolation between client and server</li> <li>Input validation using JSON Schema</li> <li>Access control through authentication tokens</li> <li>Rate limiting and abuse prevention</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#whats-still-missing","title":"What\u2019s Still Missing","text":"<p>While MCP provides a solid foundation, some aspects are still evolving:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-advanced-authentication","title":"1. Advanced Authentication","text":"<ul> <li>OAuth 2.0 integration patterns</li> <li>Role-based access control (RBAC)</li> <li>Token refresh mechanisms</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-streaming-and-real-time-updates","title":"2. Streaming and Real-time Updates","text":"<ul> <li>Server-sent events for live data</li> <li>WebSocket support for bidirectional streaming</li> <li>Real-time resource subscriptions</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-performance-optimization","title":"3. Performance Optimization","text":"<ul> <li>Connection pooling</li> <li>Caching strategies</li> <li>Batch operation optimizations</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#4-enterprise-features","title":"4. Enterprise Features","text":"<ul> <li>Audit logging and compliance</li> <li>Multi-tenant isolation</li> <li>Service mesh integration</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#extra-value-mcp-provides","title":"Extra Value MCP Provides","text":"<p>Beyond basic integration, MCP adds significant value:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-developer-experience","title":"1. Developer Experience","text":"<ul> <li>Consistent APIs across different tools and services</li> <li>Auto-discovery of capabilities</li> <li>Type safety through schema validation</li> <li>Rich tooling (debuggers, inspectors, documentation)</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-operational-benefits","title":"2. Operational Benefits","text":"<ul> <li>Centralized management of AI integrations</li> <li>Version compatibility checking</li> <li>Health monitoring and metrics</li> <li>Graceful degradation when services are unavailable</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-security-advantages","title":"3. Security Advantages","text":"<ul> <li>Controlled access to external systems</li> <li>Audit trails of AI actions</li> <li>Input sanitization and validation</li> <li>Isolation between different integrations</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#4-scalability-features","title":"4. Scalability Features","text":"<ul> <li>Horizontal scaling of MCP servers</li> <li>Load balancing across multiple instances</li> <li>Caching layers for performance</li> <li>Circuit breakers for resilience</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#core-primitive-operations","title":"Core Primitive Operations","text":"<p>Let\u2019s examine the fundamental MCP operations that make everything work:</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#1-wellknownmcp-server-discovery","title":"1. wellknown/mcp - Server Discovery","text":"<p>Location: <code>/.well-known/mcp</code> endpoint When it happens: During initial client connection How it works: <pre><code>@mcp.custom_route(\"/.well-known/mcp\", methods=[\"GET\"])\nasync def mcp_manifest(request: Request) -&gt; JSONResponse:\n    manifest = {\n        \"name\": \"kagent-mcp-server\",\n        \"version\": \"0.1.0\",\n        \"capabilities\": {\n            \"tools\": True,\n            \"prompts\": True,\n            \"resources\": True,\n            \"sampling\": True\n        },\n        \"endpoints\": {\n            \"negotiate\": \"/negotiate\",\n            \"tools\": \"/tools\",\n            \"resources\": \"/resources\",\n            \"sampling\": \"/sampling\"\n        }\n    }\n    return JSONResponse(manifest)\n</code></pre></p> <p>Outcome: Client learns server capabilities and available endpoints</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#2-negotiate-connection-establishment","title":"2. negotiate - Connection Establishment","text":"<p>Location: <code>/negotiate</code> endpoint When it happens: After manifest discovery, before using server How it works: <pre><code>@mcp.custom_route(\"/negotiate\", methods=[\"GET\", \"POST\"])\nasync def negotiate(request: Request) -&gt; JSONResponse:\n    token = request.headers.get(\"x-proxy-token\")\n    response = {\n        \"transport\": \"streamable-http\",\n        \"url\": f\"{request.url.scheme}://{request.host}/mcp\"\n    }\n    if token:\n        response[\"proxy_token\"] = token\n    return JSONResponse(response)\n</code></pre></p> <p>Outcome: Establishes authenticated connection parameters</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#3-toolcall-tool-execution","title":"3. tool/call - Tool Execution","text":"<p>Location: <code>/tools/execute</code> endpoint When it happens: When client wants to execute a tool function How it works: <pre><code>@mcp.custom_route(\"/tools/execute\", methods=[\"POST\"])\nasync def tool_execute(request: Request) -&gt; JSONResponse:\n    body = await request.json()\n    tool_name = body.get(\"tool\")\n    arguments = body.get(\"arguments\", {})\n\n    # Validate and execute\n    result = await execute_tool(tool_name, arguments)\n    return JSONResponse(result)\n</code></pre></p> <p>Outcome: Executes server-side function and returns structured result</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#4-resourceread-resource-access","title":"4. resource/read - Resource Access","text":"<p>Location: <code>/resources</code> endpoint (for listing) or direct URI resolution When it happens: When client needs to access data resources How it works: <pre><code>@mcp.resource(\"mcp://server-info\")\ndef get_server_info() -&gt; str:\n    return \"Server information content\"\n\n# Or via endpoint:\n@mcp.custom_route(\"/resources\", methods=[\"GET\"])\nasync def resources_list(request: Request) -&gt; JSONResponse:\n    resources = [\n        {\n            \"uri\": \"mcp://server-info\",\n            \"name\": \"Server Information\",\n            \"mimeType\": \"text/plain\"\n        }\n    ]\n    return JSONResponse({\"resources\": resources})\n</code></pre></p> <p>Outcome: Provides access to structured data through URI-based addressing</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#5-sampling-llm-integration","title":"5. sampling - LLM Integration","text":"<p>Location: <code>/sampling</code> endpoint When it happens: When client needs LLM processing How it works: <pre><code>@mcp.custom_route(\"/sampling\", methods=[\"POST\"])\nasync def sampling(request: Request) -&gt; JSONResponse:\n    body = await request.json()\n    prompt = body.get(\"prompt\")\n\n    # Call LLM API\n    response = await call_llm_api(prompt)\n    return JSONResponse({\n        \"completion\": response,\n        \"model\": \"llama3.2:latest\"\n    })\n</code></pre></p> <p>Outcome: Enables AI processing through standardized interface</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#building-your-own-mcp-components","title":"Building Your Own MCP Components","text":""},{"location":"Lab01-MCP-Fundamentals/lab/#step-by-step-creating-a-basic-tool","title":"Step-by-Step: Creating a Basic Tool","text":"<pre><code>from mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"my-basic-server\")\n\n@mcp.tool()\ndef calculate_area(length: float, width: float) -&gt; str:\n    \"\"\"Calculate the area of a rectangle\"\"\"\n    area = length * width\n    return f\"The area of a rectangle with length {length} and width {width} is {area}\"\n\n@mcp.resource(\"mcp://math-constants\")\ndef get_math_constants() -&gt; str:\n    \"\"\"Returns common mathematical constants\"\"\"\n    return \"\"\"\nPi: 3.14159\nE: 2.71828\nGolden Ratio: 1.61803\n\"\"\"\n\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre> <p>What this produces: - A tool that can be called by MCP clients - A resource that can be read by clients - A complete MCP server ready to run</p> <p>What\u2019s inside each component: - Tool: Function + JSON schema + metadata - Resource: URI + content generator + MIME type - Server: HTTP handlers + protocol implementation + capability management</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 MCP consists of server frameworks, tool decorators, resource handlers, and transport layers</p> <p>\u2705 Python methods follow a clear execution flow: init \u2192 register \u2192 run \u2192 handle requests</p> <p>\u2705 MCP is realized through protocol standardization, component integration, and security boundaries</p> <p>\u2705 Core primitives handle discovery (<code>wellknown/mcp</code>), connection (<code>negotiate</code>), execution (<code>tool/call</code>), and data access (<code>resource/read</code>)</p> <p>\u2705 Each step produces structured outputs with clear interfaces and validation</p> <p>\u2705 Extra value comes from consistency, security, scalability, and developer experience</p>"},{"location":"Lab01-MCP-Fundamentals/lab/#next-steps","title":"Next Steps","text":"<p>In Lab 2, you\u2019ll get hands-on experience by building your first MCP server from scratch. You\u2019ll learn:</p> <ul> <li>Setting up the development environment</li> <li>Creating a basic MCP server structure</li> <li>Implementing the initialization handshake</li> <li>Testing your server with an MCP client</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab/#additional-resources","title":"Additional Resources","text":"<ul> <li>MCP Official Documentation</li> <li>MCP Specification</li> <li>MCP GitHub Repository</li> <li>JSON-RPC 2.0 Specification</li> <li>FastMCP Python Library</li> </ul> <p>Ready to build your first MCP server? Continue to Lab 2!</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/","title":"MCP Fundementals Tasks - Lab 1","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-11-identify-mcp-components","title":"Exercise 1.1: Identify MCP Components","text":"<p>Identify the three main components of the MCP architecture and explain their roles.</p> Solution <p>The three main components are:</p> <ol> <li>MCP Client: Applications that host LLMs (like Roo Code, Claude Desktop)</li> <li>MCP Server: Exposes capabilities to clients (tools, resources, prompts)</li> <li>MCP Protocol: JSON-RPC 2.0 based communication standard</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-12-mcp-vs-traditional-apis","title":"Exercise 1.2: MCP vs Traditional APIs","text":"<p>Explain how MCP differs from traditional REST APIs in terms of LLM integration.</p> Solution <p>MCP provides a standardized protocol specifically designed for LLM integration, while traditional APIs require custom integration code for each application. MCP enables universal connectivity across all MCP-compatible clients.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-13-transport-layers","title":"Exercise 1.3: Transport Layers","text":"<p>List the three main transport mechanisms supported by MCP and their use cases.</p> Solution <ol> <li>STDIO: Most common, for local subprocess communication</li> <li>SSE (Server-Sent Events): HTTP-based for remote servers</li> <li>Streamable HTTP: Modern standard for remote MCP servers</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-14-mcp-capabilities","title":"Exercise 1.4: MCP Capabilities","text":"<p>Name the three types of capabilities MCP servers can expose.</p> Solution <ol> <li>Tools: Functions for performing actions</li> <li>Resources: Contextual data for reading</li> <li>Prompts: Pre-built prompt templates</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-15-json-rpc-message-types","title":"Exercise 1.5: JSON-RPC Message Types","text":"<p>Identify the three types of messages used in MCP communication.</p> Solution <ol> <li>Requests: Require responses (tools/list, resources/read)</li> <li>Responses: Match to requests with results or errors</li> <li>Notifications: One-way messages (initialized, cancelled)</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-16-mcp-initialization-flow","title":"Exercise 1.6: MCP Initialization Flow","text":"<p>Describe the sequence of messages during MCP server initialization.</p> Solution <ol> <li>Client sends <code>initialize</code> request</li> <li>Server processes and responds with <code>initialize</code> response</li> <li>Client sends <code>initialized</code> notification</li> <li>Connection is established</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-17-tool-definition-schema","title":"Exercise 1.7: Tool Definition Schema","text":"<p>What information must be included when defining an MCP tool?</p> Solution <ul> <li>Tool name</li> <li>Description</li> <li>Input parameters (JSON Schema)</li> <li>Whether it has side effects</li> </ul>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-18-resource-identifiers","title":"Exercise 1.8: Resource Identifiers","text":"<p>How are MCP resources identified and what types of data can they contain?</p> Solution <p>Resources are identified by URIs and can contain text, binary data, or structured data. They are typically read-only.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-19-prompt-templates","title":"Exercise 1.9: Prompt Templates","text":"<p>Explain the purpose of MCP prompts and how they differ from regular prompts.</p> Solution <p>MCP prompts are pre-built, reusable prompt templates that can include embedded resources and support arguments for customization, ensuring consistency across applications.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-110-security-considerations","title":"Exercise 1.10: Security Considerations","text":"<p>List three security best practices for MCP implementations.</p> Solution <ol> <li>Authentication &amp; Authorization: Validate requests and use least-privilege access</li> <li>Data Privacy: Control what data is exposed</li> <li>Input Validation: Sanitize user inputs to prevent injection attacks</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-111-mcp-client-examples","title":"Exercise 1.11: MCP Client Examples","text":"<p>Name three popular MCP client applications.</p> Solution <ol> <li>Roo Code (VS Code extension)</li> <li>Claude Desktop</li> <li>Continue.dev</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-112-protocol-versioning","title":"Exercise 1.12: Protocol Versioning","text":"<p>How does MCP handle protocol versioning and backward compatibility?</p> Solution <p>MCP uses capability negotiation during initialization, allowing clients and servers to agree on supported features and maintain backward compatibility.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-113-error-handling","title":"Exercise 1.13: Error Handling","text":"<p>How are errors communicated in MCP?</p> Solution <p>Errors are communicated through JSON-RPC error responses with error codes, messages, and optional data fields.</p>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-114-connection-lifecycle","title":"Exercise 1.14: Connection Lifecycle","text":"<p>Describe the complete MCP connection lifecycle from start to finish.</p> Solution <ol> <li>Initialization handshake</li> <li>Capability discovery</li> <li>Normal operation (tool calls, resource access)</li> <li>Cleanup and graceful shutdown</li> </ol>"},{"location":"Lab01-MCP-Fundamentals/lab1-tasks/#exercise-115-mcp-ecosystem-benefits","title":"Exercise 1.15: MCP Ecosystem Benefits","text":"<p>Explain three key benefits of the MCP ecosystem approach.</p> Solution <ol> <li>Universal Integration: One server works with all MCP clients</li> <li>Standardized Communication: Consistent interface across applications</li> <li>Rapid Development: Reduced integration time and duplication</li> </ol>"},{"location":"Lab02-First-MCP-Server/lab/","title":"Lab 2: Building Your First MCP Server","text":""},{"location":"Lab02-First-MCP-Server/lab/#overview","title":"Overview","text":"<p>Now that you understand the fundamentals of <code>MCP</code>, it\u2019s time to get hands-on! </p> <p>In this lab, you\u2019ll build a complete, working <code>MCP</code> server from scratch. You\u2019ll learn how to set up the project, implement the core protocol, and connect it to an <code>MCP</code> client.</p>"},{"location":"Lab02-First-MCP-Server/lab/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Set up a Node.js / TypeScript project for <code>MCP</code> development</li> <li>Implement the <code>MCP</code> initialization handshake</li> <li>Create a basic server structure using the <code>MCP</code> SDK</li> <li>Test your server with a real <code>MCP</code> client</li> <li>Understand the request/response lifecycle</li> <li>Debug and troubleshoot common issues</li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Node.js (v18 or later) installed</li> <li>npm or yarn package manager</li> <li>A code editor (VS Code recommended)</li> <li>Basic understanding of JavaScript / TypeScript</li> <li>Completed Lab 1 - MCP Fundamentals</li> </ul> <p>To verify your prerequisites are installed correctly, run the following commands:</p> <pre><code># Check Node.js version\nnode --version\n\n# Check yarn version\nyarn --version\n\n# Check npm version\nnpm --version\n\n# Check JavaScript version (via Node.js V8 engine)\nnode -e \"console.log('V8 version:', process.versions.v8)\"\n\n# Check VS Code version\ncode --version\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab/#project-setup","title":"Project Setup","text":""},{"location":"Lab02-First-MCP-Server/lab/#step-1-initialize-your-project","title":"Step 1: Initialize Your Project","text":"<ul> <li> <p>Create a new directory for your <code>MCP</code> server, navigate into it, and initialize a new Node.js project:</p> <pre><code>mkdir my-first-mcp-server\ncd my-first-mcp-server\nnpm init -y\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<ul> <li> <p>Install the MCP SDK and TypeScript dependencies using npm and build tool:</p> <pre><code># Core MCP SDK\nnpm install @modelcontextprotocol/sdk\n\n# TypeScript and type definitions\nnpm install -D typescript @types/node\n\n# Build tool\nnpm install -D tsx\n</code></pre> </li> <li> <p>To verify TypeScript installation:</p> <pre><code>tsc --version\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#step-3-configure-typescript","title":"Step 3: Configure TypeScript","text":"<ul> <li> <p>Create a <code>tsconfig.json</code> file:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#step-4-update-packagejson","title":"Step 4: Update package.json","text":"<ul> <li> <p>Replace (copy / paste) the entire content of the file <code>package.json</code>, located inside the previously created <code>my-first-mcp-server</code> directory, with the following content to add scripts and set module type:</p> <pre><code>{\n  \"name\": \"my-first-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"description\": \"My first MCP server\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx src/index.ts\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\"mcp\", \"server\"],\n  \"author\": \"Your Name\"\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#building-the-mcp-server","title":"Building the MCP Server","text":""},{"location":"Lab02-First-MCP-Server/lab/#step-5-create-the-server-structure","title":"Step 5: Create the Server Structure","text":"<ul> <li>Create a directory named <code>src</code> inside <code>my-first-mcp-server</code>.</li> <li> <p>Create a file named <code>index.ts</code> inside the <code>src</code> directory and fill it with the following basic server skeleton code (copy / paste inside the file):</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n* Create an MCP server with core capabilities\n*/\nclass MyFirstMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"my-first-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          {\n            name: \"hello_world\",\n            description: \"Returns a friendly greeting message\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                name: {\n                  type: \"string\",\n                  description: \"The name to greet\",\n                },\n              },\n              required: [\"name\"],\n            },\n          },\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        if (name === \"hello_world\") {\n          const userName = args?.name as string;\n\n          if (!userName) {\n            throw new Error(\"Name parameter is required\");\n          }\n\n          return {\n            content: [\n              {\n                type: \"text\",\n                text: `Hello, ${userName}! Welcome to your first MCP server! \ud83c\udf89`,\n              },\n            ],\n          };\n        }\n\n        throw new Error(`Unknown tool: ${name}`);\n      }\n    );\n  }\n\n  /**\n  * Set up error handling\n  */\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  /**\n  * Start the server\n  */\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n\n    console.error(\"My First MCP Server running on stdio\");\n  }\n}\n\n/**\n* Main entry point\n*/\nasync function main() {\n  const server = new MyFirstMCPServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#understanding-the-code","title":"Understanding the Code","text":"<p>Let\u2019s break down the key components:</p>"},{"location":"Lab02-First-MCP-Server/lab/#1-server-initialization","title":"1. Server Initialization","text":"<pre><code>this.server = new Server(\n  {\n    name: \"my-first-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n</code></pre> <ul> <li>Defines server metadata (name and version)</li> <li>Declares capabilities (in this case, the server supports tools)</li> <li>This information is sent during the initialization handshake</li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#2-list-tools-handler","title":"2. List Tools Handler","text":"<pre><code>this.server.setRequestHandler(\n  ListToolsRequestSchema,\n  async () =&gt; ({\n    tools: [...],\n  })\n);\n</code></pre> <ul> <li>Responds to <code>tools/list</code> requests from clients</li> <li>Returns an array of tool definitions</li> <li>Each tool has: name, description and inputSchema (JSON Schema)</li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#3-call-tool-handler","title":"3. Call Tool Handler","text":"<pre><code>this.server.setRequestHandler(\n  CallToolRequestSchema,\n  async (request) =&gt; {\n    // Tool execution logic\n  }\n);\n</code></pre> <ul> <li>Responds to <code>tools/call</code> requests</li> <li>Receives tool name and arguments</li> <li>Returns tool results in a standardized format</li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#4-transport-layer","title":"4. Transport Layer","text":"<pre><code>const transport = new StdioServerTransport();\nawait this.server.connect(transport);\n</code></pre> <ul> <li>Uses stdio (standard input/output) for communication</li> <li>Server runs as a subprocess of the client</li> <li>All <code>MCP</code> messages flow through stdin/stdout</li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#testing-your-server","title":"Testing Your Server","text":""},{"location":"Lab02-First-MCP-Server/lab/#testing-with-the-mcp-inspector","title":"Testing with the MCP Inspector","text":"<ul> <li> <p>The MCP Inspector is a web-based tool for testing MCP servers. Run these commands from your <code>my-first-mcp-server</code> directory:</p> <pre><code># Install the inspector globally\nnpm install -g @modelcontextprotocol/inspector\n\n# Run your server with the inspector\nnpx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> </li> <li> <p>This will open a web interface where you can:</p> <ul> <li>See the server\u2019s capabilities</li> <li>List available tools</li> <li>Call tools with test inputs</li> <li>View request/response messages</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#how-to-test","title":"How to Test:","text":"<ol> <li> <p>Open the Inspector: After running the command above, your default web browser should automatically open to the MCP Inspector interface (typically at <code>http://localhost:3000</code> or similar).</p> </li> <li> <p>Connect to the Server: Look for a \u201cConnect\u201d button and click it. You should see a \u201cConnected\u201d status indicator. If the server fails to connect, check the terminal for error messages.</p> </li> <li> <p>List Tools: Click on the \u201cTools\u201d tab and then the \u201cList Tools\u201d button. You should see your <code>hello_world</code> tool appear in the list with its description and input schema. This confirms the server connection and capabilities.</p> </li> <li> <p>Call a Tool: In the \u201cTools\u201d tab, select the <code>hello_world</code> tool from the dropdown. Enter a name in the \u201cname\u201d field and click \u201cRun Tool\u201d.</p> </li> <li> <p>View Results: The response should appear below, showing the greeting message. Check the logs or response sections for any errors or debug information.</p> </li> <li> <p>Test Error Handling: Try calling the tool without any input in the  \u201cname\u201d field to see how your server handles errors.</p> </li> <li> <p>Monitor Messages: Check the response areas in the Tools tab or other sections to see details about the JSON-RPC messages being exchanged.</p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/lab/#the-request-response-lifecycle","title":"The Request - Response Lifecycle","text":"<p>Here\u2019s what happens when a tool is called:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Client-&gt;&gt;Server: tools/list request\n    Note over Server: Process request:&lt;br/&gt;- Match handler&lt;br/&gt;- Execute handler function\n    Server--&gt;&gt;Client: tools/list response&lt;br/&gt;(list of available tools)\n\n    Client-&gt;&gt;Server: tools/call request&lt;br/&gt;{ name: \"hello_world\",&lt;br/&gt;arguments: { name: \"Alice\" } }\n    Note over Server: Process request:&lt;br/&gt;- Validate tool name&lt;br/&gt;- Validate arguments&lt;br/&gt;- Execute tool logic&lt;br/&gt;- Format response\n    Server--&gt;&gt;Client: tools/call response&lt;br/&gt;{ content: [...] }</code></pre>"},{"location":"Lab02-First-MCP-Server/lab/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<p>Proper error handling is crucial for <code>MCP</code> servers! </p> <p>Here\u2019s how to implement robust error handling, step by step:</p>"},{"location":"Lab02-First-MCP-Server/lab/#1-validate-inputs","title":"1. Validate Inputs","text":"<p>Why: Always validate input parameters before processing to prevent runtime errors and provide clear feedback to clients.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Check for required parameters:    <pre><code>if (!userName) {\n  throw new Error(\"Name parameter is required\");\n}\n</code></pre></p> </li> <li> <p>Validate parameter types:    <pre><code>if (typeof userName !== 'string') {\n  throw new Error(\"Name parameter must be a string\");\n}\n</code></pre></p> </li> <li> <p>Combine validation checks:    <pre><code>if (!userName || typeof userName !== 'string') {\n  throw new Error(\"Name parameter is required and must be a string\");\n}\n</code></pre></p> </li> <li> <p>Validate against schema constraints:    <pre><code>if (userName.length === 0) {\n  throw new Error(\"Name parameter cannot be empty\");\n}\nif (userName.length &gt; 100) {\n  throw new Error(\"Name parameter cannot exceed 100 characters\");\n}\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/lab/#2-provide-helpful-error-messages","title":"2. Provide Helpful Error Messages","text":"<p>Why: Clear error messages help developers understand what went wrong and how to fix it.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Include the problematic value in the error:    <pre><code>throw new Error(`Unknown tool: ${name}`);\n</code></pre></p> </li> <li> <p>Suggest available alternatives:    <pre><code>throw new Error(`Unknown tool: ${name}. Available tools: hello_world`);\n</code></pre></p> </li> <li> <p>Provide context about what was expected:    <pre><code>throw new Error(`Invalid operation: ${operation}. Expected: add, subtract, multiply, or divide`);\n</code></pre></p> </li> <li> <p>Include parameter names for clarity:    <pre><code>throw new Error(`Parameter 'count' must be a positive number, got: ${count}`);\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/lab/#3-handle-async-errors","title":"3. Handle Async Errors","text":"<p>Why: Asynchronous operations can fail, and these errors need to be caught and handled properly.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Wrap async operations in try-catch:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  // Handle the error\n}\n</code></pre></p> </li> <li> <p>Extract error information safely:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n  throw new Error(`Operation failed: ${errorMessage}`);\n}\n</code></pre></p> </li> <li> <p>Preserve original error context:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  console.error('Async operation failed:', error);\n  throw new Error(`Operation failed: ${error.message}`);\n}\n</code></pre></p> </li> <li> <p>Handle different error types appropriately:    <pre><code>try {\n  const result = await someAsyncOperation();\n  return { content: [{ type: \"text\", text: result }] };\n} catch (error) {\n  if (error.code === 'ENOTFOUND') {\n    throw new Error('Network connection failed. Please check your internet connection.');\n  } else if (error.code === 'ETIMEDOUT') {\n    throw new Error('Operation timed out. Please try again.');\n  } else {\n    throw new Error(`Operation failed: ${error.message}`);\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"Lab02-First-MCP-Server/lab/#4-log-to-stderr","title":"4. Log to stderr","text":"<p>Why: <code>MCP</code> protocol uses <code>stdout</code> for communication. Logging to <code>stdout</code> can break the protocol.</p> <p>Step-by-step implementation:</p> <ol> <li> <p>Use console.error() for all logging:    <pre><code>console.error(\"[DEBUG] Tool called:\", name);\nconsole.error(\"[DEBUG] Arguments:\", args);\n</code></pre></p> </li> <li> <p>Structure your log messages:    <pre><code>console.error(`[INFO] Processing tool: ${name}`);\nconsole.error(`[DEBUG] Input validation passed`);\nconsole.error(`[ERROR] Tool execution failed:`, error.message);\n</code></pre></p> </li> <li> <p>Log at appropriate levels:    <pre><code>// Debug information\nconsole.error(\"[DEBUG] Server initialized with capabilities:\", capabilities);\n\n// Info for normal operations\nconsole.error(\"[INFO] Tool executed successfully\");\n\n// Warnings for potential issues\nconsole.error(\"[WARN] Using default value for optional parameter\");\n\n// Errors for failures\nconsole.error(\"[ERROR] Tool execution failed:\", error);\n</code></pre></p> </li> <li> <p>Include timestamps for debugging:    <pre><code>const timestamp = new Date().toISOString();\nconsole.error(`[${timestamp}] [INFO] Server started`);\n</code></pre></p> </li> </ol> <p>Important</p> <p>Use <code>console.error()</code> for logging, not <code>console.log()</code>. Your MCP server must not write to <code>stdout</code> for logging purposes, as stdout is reserved for MCP protocol messages!</p>"},{"location":"Lab02-First-MCP-Server/lab/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"Lab02-First-MCP-Server/lab/#issue-1-server-not-connecting","title":"Issue 1: Server Not Connecting","text":"<ul> <li> <p>Symptoms: Client doesn\u2019t see the server or times out</p> </li> <li> <p>Solutions:</p> <ul> <li>Check that the command path is absolute</li> <li>Verify Node.js is in the PATH</li> <li>Look at client logs for connection errors</li> <li>Ensure the server starts without crashing</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#issue-2-tools-not-appearing","title":"Issue 2: Tools Not Appearing","text":"<ul> <li> <p>Symptoms: Server connects but no tools are listed</p> </li> <li> <p>Solutions:</p> <ul> <li>Verify <code>capabilities.tools</code> is declared in server initialization</li> <li>Check that <code>ListToolsRequestSchema</code> handler is registered</li> <li>Ensure the handler returns the correct format</li> <li>Restart the client after code changes</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#issue-3-tool-execution-fails","title":"Issue 3: Tool Execution Fails","text":"<ul> <li> <p>Symptoms: Tool appears but fails when called</p> </li> <li> <p>Solutions:</p> <ul> <li>Validate input arguments match the schema</li> <li>Check for typos in tool names</li> <li>Add debug logging to see what\u2019s received</li> <li>Ensure return format matches <code>MCP</code> specification</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#issue-4-server-crashes","title":"Issue 4: Server Crashes","text":"<ul> <li> <p>Symptoms: Server exits unexpectedly</p> </li> <li> <p>Solutions:</p> <ul> <li>Add try-catch blocks around async code</li> <li>Check for unhandled promise rejections</li> <li>Validate all external data</li> <li>Add process error handlers</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#extending-your-server-hands-on-exercises","title":"Extending Your Server: Hands-On Exercises","text":"<p>Now that you have a working server, try these exercises:</p>"},{"location":"Lab02-First-MCP-Server/lab/#exercise-1-add-a-calculator-tool","title":"Exercise 1: Add a Calculator Tool","text":"<ul> <li> <p>Create a tool that performs basic math operations:</p> <pre><code>{\n  name: \"calculate\",\n  description: \"Performs basic math operations\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      operation: {\n        type: \"string\",\n        enum: [\"add\", \"subtract\", \"multiply\", \"divide\"],\n        description: \"The operation to perform\"\n      },\n      a: {\n        type: \"number\",\n        description: \"First number\"\n      },\n      b: {\n        type: \"number\",\n        description: \"Second number\"\n      }\n    },\n    required: [\"operation\", \"a\", \"b\"]\n  }\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#exercise-2-add-an-echo-tool","title":"Exercise 2: Add an Echo Tool","text":"<ul> <li> <p>Create a tool that returns whatever text it receives:</p> <pre><code>{\n  name: \"echo\",\n  description: \"Echoes back the input text\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      message: {\n        type: \"string\",\n        description: \"The message to echo\"\n      },\n      repeat: {\n        type: \"number\",\n        description: \"Number of times to repeat (default: 1)\",\n        default: 1\n      }\n    },\n    required: [\"message\"]\n  }\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#exercise-3-add-logging","title":"Exercise 3: Add Logging","text":"<ul> <li> <p>Enhance your server with structured logging:</p> <pre><code>private log(level: string, message: string, data?: any): void {\n  const timestamp = new Date().toISOString();\n  const logEntry = { timestamp, level, message, data };\n  console.error(JSON.stringify(logEntry));\n}\n</code></pre> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 MCP servers are built using the <code>@modelcontextprotocol/sdk</code> package</p> <p>\u2705 The SDK handles protocol details, letting you focus on business logic</p> <p>\u2705 Servers communicate via stdio, HTTP, or custom transports</p> <p>\u2705 Tools are defined with JSON Schema for type safety</p> <p>\u2705 Error handling and validation are critical for reliability</p> <p>\u2705 The MCP Inspector is invaluable for development and testing</p> <p>\u2705 Always log to stderr, never stdout (reserved for protocol)</p>"},{"location":"Lab02-First-MCP-Server/lab/#next-steps","title":"Next Steps","text":"<p>In Lab 3, you\u2019ll dive deeper into implementing sophisticated MCP tools. </p> <ul> <li> <p>You\u2019ll learn:</p> <ul> <li>Advanced input validation techniques</li> <li>Returning rich content types (text, images, embedded resources)</li> <li>Implementing async operations and long-running tasks</li> <li>Error handling patterns</li> <li>Tool composition and dependencies</li> </ul> </li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#additional-resources","title":"Additional Resources","text":"<ul> <li>MCP TypeScript SDK Documentation</li> <li>MCP Inspector Tool</li> <li>JSON Schema Reference</li> <li>MCP Protocol Specification</li> </ul>"},{"location":"Lab02-First-MCP-Server/lab/#troubleshooting-checklist","title":"Troubleshooting Checklist","text":"<ul> <li> <p>Before moving on, verify:</p> <ul> <li> Your server builds without TypeScript errors</li> <li> The server starts and logs \u201crunning on stdio\u201d</li> <li> The MCP Inspector can connect to your server</li> <li> Tools appear in the inspector\u2019s tool list</li> <li> You can successfully call the <code>hello_world</code> tool</li> <li> Error messages are helpful and informative</li> </ul> </li> </ul> <p>Congratulations! You\u2019ve built your first MCP server! Ready for more? Continue to Lab 3!</p>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/","title":"MCP Lab Tasks - Lab 2","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-21-basic-server-structure","title":"Exercise 2.1: Basic Server Structure","text":"<p>Create the basic file structure for a new MCP server project.</p> Solution <pre><code>my-mcp-server/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 index.ts\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-22-packagejson-dependencies","title":"Exercise 2.2: Package.json Dependencies","text":"<p>What are the essential dependencies for an MCP server?</p> Solution <pre><code>{\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-23-server-initialization","title":"Exercise 2.3: Server Initialization","text":"<p>Write the basic server initialization code.</p> Solution <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nconst server = new Server(\n  {\n    name: \"my-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-24-tool-registration","title":"Exercise 2.4: Tool Registration","text":"<p>How do you register a tool with the MCP server?</p> Solution <pre><code>server.setRequestHandler(\"tools/list\", async () =&gt; {\n  return {\n    tools: [\n      {\n        name: \"example_tool\",\n        description: \"An example tool\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            message: { type: \"string\" }\n          }\n        }\n      }\n    ]\n  };\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-25-tool-implementation","title":"Exercise 2.5: Tool Implementation","text":"<p>Implement a simple tool that echoes back the input message.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"echo\") {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Echo: ${args.message}`\n        }\n      ]\n    };\n  }\n\n  throw new Error(`Unknown tool: ${name}`);\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-26-error-handling","title":"Exercise 2.6: Error Handling","text":"<p>Add proper error handling to the tool implementation.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  try {\n    const { name, arguments: args } = request.params;\n\n    if (name === \"echo\") {\n      if (!args || !args.message) {\n        throw new Error(\"Message parameter is required\");\n      }\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Echo: ${args.message}`\n          }\n        ]\n      };\n    }\n\n    throw new Error(`Unknown tool: ${name}`);\n  } catch (error) {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Error: ${error.message}`\n        }\n      ],\n      isError: true\n    };\n  }\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-27-server-logging","title":"Exercise 2.7: Server Logging","text":"<p>Add logging to track server operations.</p> Solution <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\n\nconst server = new Server(\n  {\n    name: \"my-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\nserver.setRequestHandler(\"tools/list\", async () =&gt; {\n  console.log(\"Listing available tools\");\n  return { tools: [] };\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-28-typescript-configuration","title":"Exercise 2.8: TypeScript Configuration","text":"<p>Create a proper tsconfig.json for an MCP server.</p> Solution <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-29-build-script","title":"Exercise 2.9: Build Script","text":"<p>Add build and start scripts to package.json.</p> Solution <pre><code>{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\"\n  }\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-210-input-validation","title":"Exercise 2.10: Input Validation","text":"<p>Implement input validation for tool parameters.</p> Solution <pre><code>function validateEchoInput(args: any): { message: string } {\n  if (!args || typeof args.message !== 'string') {\n    throw new Error(\"message parameter must be a string\");\n  }\n  if (args.message.length &gt; 1000) {\n    throw new Error(\"message too long (max 1000 characters)\");\n  }\n  return args;\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-211-server-capabilities","title":"Exercise 2.11: Server Capabilities","text":"<p>Configure server capabilities in the initialization.</p> Solution <pre><code>const server = new Server(\n  {\n    name: \"my-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n      resources: {},\n      prompts: {}\n    },\n  }\n);\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-212-graceful-shutdown","title":"Exercise 2.12: Graceful Shutdown","text":"<p>Implement graceful shutdown handling.</p> Solution <pre><code>process.on('SIGINT', async () =&gt; {\n  console.log('Shutting down MCP server...');\n  await server.close();\n  process.exit(0);\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-213-environment-variables","title":"Exercise 2.13: Environment Variables","text":"<p>Use environment variables for server configuration.</p> Solution <pre><code>const PORT = process.env.PORT || 3000;\nconst API_KEY = process.env.API_KEY;\n\nif (!API_KEY) {\n  throw new Error(\"API_KEY environment variable is required\");\n}\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-214-testing-setup","title":"Exercise 2.14: Testing Setup","text":"<p>Create a basic test structure for the MCP server.</p> Solution <pre><code>// test/server.test.ts\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\n\ndescribe(\"MCP Server\", () =&gt; {\n  let server: Server;\n\n  beforeEach(() =&gt; {\n    server = new Server(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: { tools: {} } }\n    );\n  });\n\n  it(\"should initialize correctly\", () =&gt; {\n    expect(server).toBeDefined();\n  });\n});\n</code></pre>"},{"location":"Lab02-First-MCP-Server/lab2-tasks/#exercise-215-documentation","title":"Exercise 2.15: Documentation","text":"<p>Create a README.md for the MCP server project.</p> Solution <pre><code># My MCP Server\n\nA Model Context Protocol server that provides useful tools.\n\n## Installation\n\n```bash\nnpm install\nnpm run build\n</code></pre> <p>Usage</p> <pre><code>npm start\n</code></pre> <p>Configuration</p> <p>Set the following environment variables: - <code>API_KEY</code>: Your API key - <code>PORT</code>: Server port (optional, defaults to 3000) ```</p>"},{"location":"Lab03-MCP-Tools/lab/","title":"Lab 3: Implementing MCP Tools","text":""},{"location":"Lab03-MCP-Tools/lab/#overview","title":"Overview","text":"<p>In Lab 2, you created a basic <code>MCP</code> server with a simple \u201chello world\u201d tool. Now it\u2019s time to level up! </p> <p>In this lab, you\u2019ll master the art of creating sophisticated, production-ready <code>MCP</code> tools that can handle complex inputs, perform real-world operations, and return rich content types.</p>"},{"location":"Lab03-MCP-Tools/lab/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Design robust tool schemas with advanced validation</li> <li>Implement tools that interact with external systems (APIs, databases, file systems)</li> <li>Return multiple content types (text, images, resources)</li> <li>Handle errors gracefully with detailed feedback</li> <li>Implement async operations and streaming responses</li> <li>Apply best practices for tool composition</li> <li>Test tools thoroughly with various edge cases</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 2 - Building Your First MCP Server</li> <li>Understanding of async/await in JavaScript/TypeScript</li> <li>Basic knowledge of REST APIs and JSON</li> <li>Node.js development environment set up</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#understanding-tool-design","title":"Understanding Tool Design","text":""},{"location":"Lab03-MCP-Tools/lab/#what-makes-a-great-mcp-tool","title":"What Makes a Great <code>MCP</code> Tool?","text":"<p>A well-designed tool should be:</p> <ol> <li>Single Purpose: Does one thing well</li> <li>Self-Descriptive: Clear name and description</li> <li>Well-Validated: Comprehensive input schema</li> <li>Error-Resilient: Handles failures gracefully</li> <li>Efficient: Returns results quickly</li> <li>Composable: Can work with other tools</li> </ol>"},{"location":"Lab03-MCP-Tools/lab/#tool-anatomy","title":"Tool Anatomy","text":"<p>Every <code>MCP</code> tool consists of the following key components:</p> <pre><code>{\n  name: \"tool_name\",              // Unique identifier\n  description: \"What it does\",    // Clear explanation for LLM\n  inputSchema: {                  // JSON Schema for validation\n    type: \"object\",\n    properties: { ... },\n    required: [ ... ]\n  }\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab/#advanced-input-schema-design","title":"Advanced Input Schema Design","text":""},{"location":"Lab03-MCP-Tools/lab/#example-1-file-search-tool","title":"Example 1: File Search Tool","text":"<p>Key Features:</p> <ul> <li>Pattern validation using <code>regex</code></li> <li>Default values for optional parameters</li> <li>Min/max constraints for numbers</li> <li>Clear descriptions for the LLM </li> </ul> <pre><code>{\n  name: \"search_files\",\n  description: \"Search for files in a directory using glob patterns\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      path: {\n        type: \"string\",\n        description: \"Directory path to search in\",\n        pattern: \"^(/|\\\\./|\\\\.\\\\./).*\"  // Must be absolute or relative path\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Glob pattern (e.g., '*.ts', '**/*.json')\",\n        default: \"*\"\n      },\n      recursive: {\n        type: \"boolean\",\n        description: \"Search subdirectories\",\n        default: false\n      },\n      maxResults: {\n        type: \"number\",\n        description: \"Maximum number of results to return\",\n        minimum: 1,\n        maximum: 1000,\n        default: 100\n      }\n    },\n    required: [\"path\"]\n  }\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab/#example-2-api-request-tool","title":"Example 2: API Request Tool","text":"<p>Key Features:</p> <ul> <li>Format validation (<code>uri</code>)</li> <li>Enum constraints</li> <li>Nested objects with additional properties</li> <li>Practical defaults</li> </ul> <pre><code>{\n  name: \"make_api_request\",\n  description: \"Make HTTP requests to REST APIs\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      url: {\n        type: \"string\",\n        description: \"Full URL to request\",\n        format: \"uri\"\n      },\n      method: {\n        type: \"string\",\n        description: \"HTTP method\",\n        enum: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\"],\n        default: \"GET\"\n      },\n      headers: {\n        type: \"object\",\n        description: \"HTTP headers as key-value pairs\",\n        additionalProperties: {\n          type: \"string\"\n        }\n      },\n      body: {\n        type: \"string\",\n        description: \"Request body (JSON string for POST/PUT)\"\n      },\n      timeout: {\n        type: \"number\",\n        description: \"Request timeout in milliseconds\",\n        minimum: 100,\n        maximum: 30000,\n        default: 5000\n      }\n    },\n    required: [\"url\", \"method\"]\n  }\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab/#implementing-real-world-tools","title":"Implementing Real-World Tools","text":""},{"location":"Lab03-MCP-Tools/lab/#tool-1-weather-information-with-ollama","title":"Tool 1: Weather Information with Ollama","text":"<p>Goal: Create a production-ready weather tool that uses Ollama (local AI) to generate weather information, handles errors gracefully, and returns formatted information.</p>"},{"location":"Lab03-MCP-Tools/lab/#complete-weather-tool-implementation-with-ollama","title":"Complete Weather Tool Implementation with Ollama","text":"<p>Here is the complete <code>src/index.ts</code> file with the Ollama-based weather tool added. Copy this entire code and overwrite your existing <code>src/index.ts</code> file:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n* Create an MCP server with core capabilities\n*/\nclass MyFirstMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"my-first-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          {\n            name: \"get_weather\",\n            description: \"Get current weather information for a city using AI\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: {\n                  type: \"string\",\n                  description: \"City name (e.g., 'London', 'New York')\"\n                },\n                units: {\n                  type: \"string\",\n                  description: \"Temperature units\",\n                  enum: [\"celsius\", \"fahrenheit\"],\n                  default: \"celsius\"\n                }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"hello_world\",\n            description: \"Returns a friendly greeting message\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                name: {\n                  type: \"string\",\n                  description: \"The name to greet\",\n                },\n              },\n              required: [\"name\"],\n            },\n          },\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        if (name === \"get_weather\") {\n          try {\n            // Extract and validate parameters\n            const city = args.city as string;\n            const units = (args.units as string) || \"celsius\";\n\n            if (!city || city.trim().length === 0) {\n              throw new Error(\"City name cannot be empty\");\n            }\n\n            // Use Ollama to generate weather information\n            const prompt = `Generate realistic current weather information for ${city}.\n            Return ONLY a JSON object with this exact structure:\n            {\n              \"name\": \"${city}\",\n              \"sys\": {\"country\": \"XX\"},\n              \"main\": {\"temp\": 20.5, \"feels_like\": 22.1, \"humidity\": 65},\n              \"weather\": [{\"description\": \"clear sky\"}],\n              \"wind\": {\"speed\": 3.2}\n            }\n\n            Use realistic weather data appropriate for the location. Temperature should be in Celsius. Choose an appropriate 2-letter country code for the city. Make the weather description realistic for the location and season.`;\n\n            // Call Ollama API\n            const response = await fetch('http://localhost:11434/api/generate', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                model: 'gpt-oss:20b',\n                prompt: prompt,\n                stream: false,\n                format: 'json'\n              }),\n            });\n\n            if (!response.ok) {\n              throw new Error(`Ollama API error: ${response.status} ${response.statusText}. Make sure Ollama is running with 'ollama serve'.`);\n            }\n\n            const ollamaResult = await response.json();\n            let data;\n\n            try {\n              // Parse the JSON response from Ollama\n              data = JSON.parse(ollamaResult.response);\n            } catch (parseError) {\n              // Fallback to mock data if parsing fails\n              console.warn('Failed to parse Ollama response, using fallback data');\n              const fallbackData: Record&lt;string, any&gt; = {\n                \"london\": {\n                  name: \"London\",\n                  sys: { country: \"GB\" },\n                  main: { temp: 15.2, feels_like: 14.8, humidity: 82 },\n                  weather: [{ description: \"light rain\" }],\n                  wind: { speed: 3.6 }\n                },\n                \"new york\": {\n                  name: \"New York\",\n                  sys: { country: \"US\" },\n                  main: { temp: 22.5, feels_like: 24.1, humidity: 65 },\n                  weather: [{ description: \"clear sky\" }],\n                  wind: { speed: 2.1 }\n                },\n                \"tokyo\": {\n                  name: \"Tokyo\",\n                  sys: { country: \"JP\" },\n                  main: { temp: 18.7, feels_like: 18.2, humidity: 78 },\n                  weather: [{ description: \"few clouds\" }],\n                  wind: { speed: 1.8 }\n                },\n                \"paris\": {\n                  name: \"Paris\",\n                  sys: { country: \"FR\" },\n                  main: { temp: 12.8, feels_like: 11.9, humidity: 71 },\n                  weather: [{ description: \"overcast clouds\" }],\n                  wind: { speed: 4.2 }\n                },\n                \"sydney\": {\n                  name: \"Sydney\",\n                  sys: { country: \"AU\" },\n                  main: { temp: 24.3, feels_like: 25.1, humidity: 73 },\n                  weather: [{ description: \"sunny\" }],\n                  wind: { speed: 2.8 }\n                }\n              };\n              data = fallbackData[city.toLowerCase().trim()] || fallbackData[\"london\"];\n            }\n\n            // Format response\n            const tempUnit = units === \"fahrenheit\" ? \"\u00b0F\" : \"\u00b0C\";\n            const weatherText = `\nWeather in ${data.name}, ${data.sys.country}:\n- Temperature: ${data.main.temp}${tempUnit}\n- Feels like: ${data.main.feels_like}${tempUnit}\n- Conditions: ${data.weather[0].description}\n- Humidity: ${data.main.humidity}%\n- Wind Speed: ${data.wind.speed} m/s\n\n*Generated by Ollama AI*\n`.trim();\n\n            // Return MCP response\n            return {\n              content: [\n                {\n                  type: \"text\",\n                  text: weatherText\n                }\n              ]\n            };\n\n          } catch (error) {\n            // Handle errors\n            throw new Error(\n              `Failed to get weather: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n        }\n\n        if (name === \"hello_world\") {\n          const userName = args?.name as string;\n\n          if (!userName) {\n            throw new Error(\"Name parameter is required\");\n          }\n\n          return {\n            content: [\n              {\n                type: \"text\",\n                text: `Hello, ${userName}! Welcome to your first MCP server! \ud83c\udf89`,\n              },\n            ],\n          };\n        }\n\n        throw new Error(`Unknown tool: ${name}`);\n      }\n    );\n  }\n\n  /**\n  * Set up error handling\n  */\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  /**\n  * Start the server\n  */\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n\n    console.error(\"My First MCP Server running on stdio\");\n  }\n}\n\n/**\n* Main entry point\n*/\nasync function main() {\n  const server = new MyFirstMCPServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab/#testing-the-weather-tool-with-ollama","title":"Testing the Weather Tool with Ollama:","text":"<p>Step 1: Install Ollama</p> <pre><code># On macOS (using Homebrew)\nbrew install ollama\n\n# Or download from the official website: https://ollama.ai/download\n</code></pre> <p>Step 2: Download a Model</p> <pre><code># Pull the recommended model for this lab\nollama pull gpt-oss:20b\n\n# List available models to verify the download completed successfully\nollama list\n</code></pre> <p>Step 3: Start Ollama Server</p> <pre><code># Start the Ollama server (keep this running in a terminal)\nollama serve\n\n# Check which models are currently running locally:\ncurl http://localhost:11434/api/tags | jq .\n</code></pre> <p>The server will run on http://localhost:11434 by default.</p> <p>Step 4: Test the Weather Tool</p> <ol> <li> <p>Start the MCP Inspector (in a new terminal):    <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre></p> </li> <li> <p>In the MCP Inspector interface:</p> <ul> <li>You should see both <code>get_weather</code> and <code>hello_world</code> tools listed</li> <li>Click on <code>get_weather</code> tool</li> <li>Enter a city name like \u201cLondon\u201d, \u201cNew York\u201d, \u201cTokyo\u201d, \u201cParis\u201d, or \u201cSydney\u201d</li> <li>Optionally set units to \u201cfahrenheit\u201d for Fahrenheit temperatures</li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test different scenarios:</p> <ul> <li>Valid cities: \u201cLondon\u201d, \u201cNew York\u201d, \u201cTokyo\u201d, \u201cParis\u201d, \u201cSydney\u201d</li> <li>Invalid cities: \u201cInvalidCity123\u201d (will use fallback data)</li> <li>Different units: Try both \u201ccelsius\u201d and \u201cfahrenheit\u201d</li> <li>Empty city: Try with empty string (should show validation error)</li> </ul> </li> <li> <p>Test error cases:</p> <ul> <li>Stop Ollama server and try calling the tool (should show API error)</li> <li>Try with invalid model name in the code (should show error)</li> </ul> </li> </ol> <p>Step 5: Verify Everything Works</p> <ul> <li> <p>You should see AI-generated weather information formatted like this:</p> <pre><code>Weather in London, GB:\n- Temperature: 15.2\u00b0C\n- Feels like: 14.8\u00b0C\n- Conditions: light rain\n- Humidity: 82%\n- Wind Speed: 3.6 m/s\n\n*Generated by Ollama AI*\n</code></pre> </li> </ul> <p>Troubleshooting:</p> <ul> <li>If you get \u201cOllama API error\u201d, make sure <code>ollama serve</code> is running</li> <li>If you see fallback data, Ollama might not be responding properly</li> <li>Check that the model is downloaded with <code>ollama list</code></li> <li>Try a different model if gpt-oss:20b doesn\u2019t work well</li> <li>Make sure you\u2019re in the correct directory when running commands</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#key-learning-points","title":"Key Learning Points:","text":"<ul> <li>Local AI integration using Ollama for generating content</li> <li>Fallback handling when AI services are unavailable</li> <li>JSON parsing from AI-generated responses</li> <li>Error handling for external service dependencies</li> <li>Input validation and data formatting</li> <li>API communication with local services</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#tool-2-file-operations","title":"Tool 2: File Operations","text":"<p>Goal: Create a secure file reading tool that can handle various file types, validate paths, and return formatted content with metadata.</p>"},{"location":"Lab03-MCP-Tools/lab/#complete-file-operations-tool-implementation","title":"Complete File Operations Tool Implementation","text":"<p>Important: Do NOT copy the entire code block below. Instead, add the <code>read_file</code> tool to your existing <code>src/index.ts</code> file by following these specific steps:</p> <ol> <li> <p>Add the import at the top of your file (after existing imports):    <pre><code>import * as fs from 'fs/promises';\nimport * as path from 'path';\n</code></pre></p> </li> <li> <p>Add the <code>read_file</code> tool to your tools array in the <code>ListToolsRequestSchema</code> handler:    <pre><code>{\n  name: \"read_file\",\n  description: \"Read contents of a text file with security validation\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      filepath: {\n        type: \"string\",\n        description: \"Absolute path to the file\"\n      },\n      encoding: {\n        type: \"string\",\n        description: \"File encoding\",\n        enum: [\"utf8\", \"ascii\", \"base64\"],\n        default: \"utf8\"\n      },\n      maxSize: {\n        type: \"number\",\n        description: \"Maximum file size in bytes\",\n        minimum: 1,\n        maximum: 10485760,\n        default: 1048576\n      }\n    },\n    required: [\"filepath\"]\n  }\n}\n</code></pre></p> </li> <li> <p>Add the <code>read_file</code> handler in the <code>CallToolRequestSchema</code> handler (before the final <code>throw new Error</code>):    <pre><code>if (name === \"read_file\") {\n  try {\n    const filepath = args.filepath as string;\n    const encoding = (args.encoding as BufferEncoding) || \"utf8\";\n    const maxSize = (args.maxSize as number) || 1048576;\n\n    // Security: Validate input\n    if (!filepath || typeof filepath !== 'string' || filepath.trim().length === 0) {\n      throw new Error(\"filepath must be a non-empty string\");\n    }\n\n    // Security: Resolve and validate path\n    const resolvedPath = path.resolve(filepath);\n\n    // Prevent directory traversal attacks\n    if (!resolvedPath.startsWith(process.cwd())) {\n      throw new Error(\"Access denied: file path outside allowed directory\");\n    }\n\n    // Check if file exists and is readable\n    try {\n      await fs.access(resolvedPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(`File not found or not readable: ${filepath}`);\n    }\n\n    // Get file stats\n    const stats = await fs.stat(resolvedPath);\n\n    // Check if it's actually a file (not a directory)\n    if (!stats.isFile()) {\n      throw new Error(`Path is not a file: ${filepath}`);\n    }\n\n    // Check file size\n    if (stats.size &gt; maxSize) {\n      throw new Error(\n        `File too large: ${stats.size} bytes (max: ${maxSize})`\n      );\n    }\n\n    // Read file content\n    const content = await fs.readFile(resolvedPath, encoding);\n\n    // Format response with metadata\n    const fileInfo = {\n      path: resolvedPath,\n      size: stats.size,\n      modified: stats.mtime.toISOString(),\n      encoding: encoding\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `File Information:\\n${JSON.stringify(fileInfo, null, 2)}\\n\\nContent:\\n${content}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(\n      `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n</code></pre></p> </li> </ol> <p>The code block below is for reference only - it shows what your complete file should look like after adding the tool. Do not copy-paste the entire block:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\n/**\n* Create an MCP server with core capabilities\n*/\nclass MyFirstMCPServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"my-first-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          {\n            name: \"get_weather\",\n            description: \"Get current weather information for a city using AI\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                city: {\n                  type: \"string\",\n                  description: \"City name (e.g., 'London', 'New York')\"\n                },\n                units: {\n                  type: \"string\",\n                  description: \"Temperature units\",\n                  enum: [\"celsius\", \"fahrenheit\"],\n                  default: \"celsius\"\n                }\n              },\n              required: [\"city\"]\n            }\n          },\n          {\n            name: \"read_file\",\n            description: \"Read contents of a text file with security validation\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                filepath: {\n                  type: \"string\",\n                  description: \"Absolute path to the file\"\n                },\n                encoding: {\n                  type: \"string\",\n                  description: \"File encoding\",\n                  enum: [\"utf8\", \"ascii\", \"base64\"],\n                  default: \"utf8\"\n                },\n                maxSize: {\n                  type: \"number\",\n                  description: \"Maximum file size in bytes\",\n                  minimum: 1,\n                  maximum: 10485760,\n                  default: 1048576\n                }\n              },\n              required: [\"filepath\"]\n            }\n          },\n          {\n            name: \"hello_world\",\n            description: \"Returns a friendly greeting message\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                name: {\n                  type: \"string\",\n                  description: \"The name to greet\",\n                },\n              },\n              required: [\"name\"],\n            },\n          },\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        if (name === \"get_weather\") {\n          // ... existing weather tool code ...\n        }\n\n        if (name === \"read_file\") {\n          try {\n            const filepath = args.filepath as string;\n            const encoding = (args.encoding as BufferEncoding) || \"utf8\";\n            const maxSize = (args.maxSize as number) || 1048576;\n\n            // Security: Validate input\n            if (!filepath || typeof filepath !== 'string' || filepath.trim().length === 0) {\n              throw new Error(\"filepath must be a non-empty string\");\n            }\n\n            // Security: Resolve and validate path\n            const resolvedPath = path.resolve(filepath);\n\n            // Prevent directory traversal attacks\n            if (!resolvedPath.startsWith(process.cwd())) {\n              throw new Error(\"Access denied: file path outside allowed directory\");\n            }\n\n            // Check if file exists and is readable\n            try {\n              await fs.access(resolvedPath, fs.constants.R_OK);\n            } catch {\n              throw new Error(`File not found or not readable: ${filepath}`);\n            }\n\n            // Get file stats\n            const stats = await fs.stat(resolvedPath);\n\n            // Check if it's actually a file (not a directory)\n            if (!stats.isFile()) {\n              throw new Error(`Path is not a file: ${filepath}`);\n            }\n\n            // Check file size\n            if (stats.size &gt; maxSize) {\n              throw new Error(\n                `File too large: ${stats.size} bytes (max: ${maxSize})`\n              );\n            }\n\n            // Read file content\n            const content = await fs.readFile(resolvedPath, encoding);\n\n            // Format response with metadata\n            const fileInfo = {\n              path: resolvedPath,\n              size: stats.size,\n              modified: stats.mtime.toISOString(),\n              encoding: encoding\n            };\n\n            return {\n              content: [\n                {\n                  type: \"text\",\n                  text: `File Information:\\n${JSON.stringify(fileInfo, null, 2)}\\n\\nContent:\\n${content}`\n                }\n              ]\n            };\n\n          } catch (error) {\n            throw new Error(\n              `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n        }\n\n        if (name === \"hello_world\") {\n          // ... existing hello world code ...\n        }\n\n        throw new Error(`Unknown tool: ${name}`);\n      }\n    );\n  }\n\n  // ... rest of the class remains the same ...\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab/#testing-the-file-operations-tool","title":"Testing the File Operations Tool","text":"<p>Step 1: Create Test Files</p> <pre><code># Create a test directory and files\nmkdir -p test-files\necho \"Hello, this is a test file!\" &gt; test-files/hello.txt\necho '{\"name\": \"test\", \"value\": 123}' &gt; test-files/data.json\necho \"Line 1\\nLine 2\\nLine 3\" &gt; test-files/lines.txt\n</code></pre> <p>Step 2: Start the MCP Inspector</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>Step 3: Test File Reading</p> <ol> <li> <p>Test with a simple text file:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/hello.txt</code> (use the full absolute path)</li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test with JSON file:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/data.json</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test with different encoding:</p> <ul> <li>Tool: <code>read_file</code></li> <li>filepath: <code>/absolute/path/to/test-files/hello.txt</code></li> <li>encoding: <code>base64</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Test file size limit:</p> <ul> <li>Create a large file: <code>dd if=/dev/zero of=test-files/large.txt bs=1M count=2</code></li> <li>Try reading it with default maxSize (1MB)</li> <li>Try with maxSize: <code>2097152</code> (2MB)</li> </ul> </li> </ol> <p>Step 4: Test Error Cases</p> <ol> <li> <p>Non-existent file:</p> <ul> <li>filepath: <code>/absolute/path/to/test-files/nonexistent.txt</code></li> </ul> </li> <li> <p>Directory instead of file:</p> <ul> <li>filepath: <code>/absolute/path/to/test-files</code> (the directory itself)</li> </ul> </li> <li> <p>Empty filepath:</p> <ul> <li>filepath: <code>\"\"</code></li> </ul> </li> <li> <p>Path traversal attempt:</p> <ul> <li>filepath: <code>/absolute/path/../../../etc/passwd</code></li> </ul> </li> </ol> <p>Step 5: Verify Output</p> <ul> <li> <p>You should see output like:</p> <pre><code>File Information:\n{\n  \"path\": \"/Users/username/project/test-files/hello.txt\",\n  \"size\": 27,\n  \"modified\": \"2024-01-06T10:30:00.000Z\",\n  \"encoding\": \"utf8\"\n}\n\nContent:\nHello, this is a test file!\n</code></pre> </li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#troubleshooting","title":"Troubleshooting:","text":"<ul> <li>\u201cFile not found\u201d: Make sure you\u2019re using the absolute path</li> <li>\u201cAccess denied\u201d: The file path is outside your project directory</li> <li>\u201cPath is not a file\u201d: You tried to read a directory</li> <li>\u201cFile too large\u201d: Increase the maxSize parameter</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#key-learning-points_1","title":"Key Learning Points:","text":"<ul> <li>Path security and preventing directory traversal attacks</li> <li>File system operations with Node.js fs/promises</li> <li>Input validation beyond JSON Schema</li> <li>File metadata extraction and formatting</li> <li>Error handling for various file system scenarios</li> <li>Resource limits to prevent abuse</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#tool-3-database-query","title":"Tool 3: Database Query","text":"<p>Goal: Create a secure database query tool that can execute SELECT statements on a SQLite database with proper validation and safety measures.</p>"},{"location":"Lab03-MCP-Tools/lab/#complete-database-query-tool-implementation","title":"Complete Database Query Tool Implementation","text":"<ul> <li> <p>First, install the SQLite dependency:</p> <pre><code>npm install better-sqlite3\nnpm install --save-dev @types/better-sqlite3\n</code></pre> </li> </ul> <p>Important: Do NOT copy the entire code block below. Instead, add the <code>query_database</code> tool to your existing <code>src/index.ts</code> file by following these specific steps:</p> <ol> <li> <p>Add the imports at the top of your file (after existing imports):    <pre><code>import Database from 'better-sqlite3';\n</code></pre></p> </li> <li> <p>Add the <code>query_database</code> tool to your tools array in the <code>ListToolsRequestSchema</code> handler:    <pre><code>{\n  name: \"query_database\",\n  description: \"Execute SELECT queries on a SQLite database\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"SQL SELECT query to execute\"\n      },\n      parameters: {\n        type: \"array\",\n        description: \"Query parameters for prepared statement\",\n        items: {\n          type: [\"string\", \"number\", \"boolean\", \"null\"]\n        },\n        default: []\n      },\n      limit: {\n        type: \"number\",\n        description: \"Maximum number of rows to return\",\n        minimum: 1,\n        maximum: 1000,\n        default: 100\n      }\n    },\n    required: [\"query\"]\n  }\n}\n</code></pre></p> </li> <li> <p>Add the <code>query_database</code> handler in the <code>CallToolRequestSchema</code> handler (before the final <code>throw new Error</code>):    <pre><code>if (name === \"query_database\") {\n  try {\n    const query = args.query as string;\n    const parameters = (args.parameters as any[]) || [];\n    const limit = (args.limit as number) || 100;\n\n    // Security: Validate input\n    if (!query || typeof query !== 'string' || query.trim().length === 0) {\n      throw new Error(\"query must be a non-empty string\");\n    }\n\n    // Security: Only allow SELECT queries\n    const trimmedQuery = query.trim().toUpperCase();\n    if (!trimmedQuery.startsWith('SELECT')) {\n      throw new Error(\"Only SELECT queries are allowed for security\");\n    }\n\n    // Check if database file exists\n    const dbPath = './data.db';\n    try {\n      await fs.access(dbPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(\"Database file 'data.db' not found in project root\");\n    }\n\n    // Open database in read-only mode\n    const db = new Database(dbPath, { readonly: true });\n\n    try {\n      // Prepare statement\n      const stmt = db.prepare(query + ' LIMIT ?');\n\n      // Execute query\n      const rows = stmt.all(...parameters, limit);\n\n      // Format results\n      const resultText = rows.length &gt; 0\n        ? JSON.stringify(rows, null, 2)\n        : \"No results found\";\n\n      // Get query info\n      const info = stmt.columns();\n      const columnNames = info.map(col =&gt; col.name);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Query executed successfully.\\nDatabase: ${dbPath}\\nColumns: ${columnNames.join(', ')}\\nRows returned: ${rows.length}\\n\\nResults:\\n${resultText}`\n          }\n        ]\n      };\n\n    } finally {\n      db.close();\n    }\n\n  } catch (error) {\n    throw new Error(\n      `Database query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n</code></pre></p> </li> </ol> <p></p> <ul> <li> <p>The code block below is for reference only - it shows what your complete file should look like after adding the tool. Do not copy-paste the entire block:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport Database from 'better-sqlite3';\n\n// ... existing imports and class definition ...\n\n  /**\n  * Set up request handlers\n  */\n  private setupHandlers(): void {\n    // Handler for listing available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async () =&gt; ({\n        tools: [\n          // ... existing tools ...\n          {\n            name: \"query_database\",\n            description: \"Execute SELECT queries on a SQLite database\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                query: {\n                  type: \"string\",\n                  description: \"SQL SELECT query to execute\"\n                },\n                parameters: {\n                  type: \"array\",\n                  description: \"Query parameters for prepared statement\",\n                  items: {\n                    type: [\"string\", \"number\", \"boolean\", \"null\"]\n                  },\n                  default: []\n                },\n                limit: {\n                  type: \"number\",\n                  description: \"Maximum number of rows to return\",\n                  minimum: 1,\n                  maximum: 1000,\n                  default: 100\n                }\n              },\n              required: [\"query\"]\n            }\n          },\n          // ... existing tools ...\n        ],\n      })\n    );\n\n    // Handler for calling tools\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request) =&gt; {\n        const { name, arguments: args } = request.params;\n\n        // ... existing tool handlers ...\n\n        if (name === \"query_database\") {\n          try {\n            const query = args.query as string;\n            const parameters = (args.parameters as any[]) || [];\n            const limit = (args.limit as number) || 100;\n\n            // Security: Validate input\n            if (!query || typeof query !== 'string' || query.trim().length === 0) {\n              throw new Error(\"query must be a non-empty string\");\n            }\n\n            // Security: Only allow SELECT queries\n            const trimmedQuery = query.trim().toUpperCase();\n            if (!trimmedQuery.startsWith('SELECT')) {\n              throw new Error(\"Only SELECT queries are allowed for security\");\n            }\n\n            // Check if database file exists\n            const dbPath = './data.db';\n            try {\n              await fs.access(dbPath, fs.constants.R_OK);\n            } catch {\n              throw new Error(\"Database file 'data.db' not found in project root\");\n            }\n\n            // Open database in read-only mode\n            const db = new Database(dbPath, { readonly: true });\n\n            try {\n              // Prepare statement\n              const stmt = db.prepare(query + ' LIMIT ?');\n\n              // Execute query\n              const rows = stmt.all(...parameters, limit);\n\n              // Format results\n              const resultText = rows.length &gt; 0\n                ? JSON.stringify(rows, null, 2)\n                : \"No results found\";\n\n              // Get query info\n              const info = stmt.columns();\n              const columnNames = info.map(col =&gt; col.name);\n\n              return {\n                content: [\n                  {\n                    type: \"text\",\n                    text: `Query executed successfully.\\nDatabase: ${dbPath}\\nColumns: ${columnNames.join(', ')}\\nRows returned: ${rows.length}\\n\\nResults:\\n${resultText}`\n                  }\n                ]\n              };\n\n            } finally {\n              db.close();\n            }\n\n          } catch (error) {\n            throw new Error(\n              `Database query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n        }\n\n        // ... existing tool handlers ...\n      }\n    );\n  }\n\n  // ... rest of the class remains the same ...\n</code></pre> </li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#testing-the-database-query-tool","title":"Testing the Database Query Tool","text":"<p>Step 1: Install SQLite</p> <pre><code># Install sqlite3 command-line tool (if not already installed)\n\n# On macOS:\nbrew install sqlite3\n\n# On Linux (Ubuntu/Debian):\nsudo apt-get update &amp;&amp; sudo apt-get install sqlite3\n\n# On Linux (CentOS/RHEL/Fedora):\nsudo yum install sqlite3    # or sudo dnf install sqlite3\n\n# On Windows (using Chocolatey):\nchoco install sqlite\n\n# On Windows (manual download):\n# Download from: https://www.sqlite.org/download.html\n# Extract sqlite3.exe to a folder in your PATH\n\n# Verify installation:\nsqlite3 --version\n</code></pre> <p></p> <p>Step 2: Create a Sample Database</p> <p>Navigate to your MCP server directory</p> <pre><code>cd /Users/orni/Code-Wizard/MCP_Lab/MCP_Lab/lab_solution/my-first-mcp-server\n</code></pre> <p>Run the database creation command</p> <pre><code>sqlite3 data.db &lt;&lt; 'EOF'\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  email TEXT UNIQUE,\n  age INTEGER,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  price REAL,\n  category TEXT,\n  in_stock BOOLEAN DEFAULT 1\n);\n\nINSERT INTO users (name, email, age) VALUES \n  ('Alice Johnson', 'alice@example.com', 28),\n  ('Bob Smith', 'bob@example.com', 34),\n  ('Charlie Brown', 'charlie@example.com', 22);\n\nINSERT INTO products (name, price, category, in_stock) VALUES \n  ('Laptop', 999.99, 'Electronics', 1),\n  ('Book', 19.99, 'Education', 1),\n  ('Coffee Mug', 12.50, 'Kitchen', 0);\n\n.quit\nEOF\n</code></pre> <p>Verify the database was created</p> <pre><code>sqlite3 data.db \"SELECT name FROM sqlite_master WHERE type='table';\"\n</code></pre> <ul> <li> <p>You should see output like:</p> <pre><code>users\nproducts\n</code></pre> </li> </ul> <p>What this does:</p> <ul> <li>Creates a SQLite database file called <code>data.db</code> in your project directory</li> <li>Creates two tables: <code>users</code> and <code>products</code></li> <li>Inserts sample data into both tables</li> <li>This gives you test data to query with your <code>query_database</code> tool</li> </ul> <p></p> <p>Step 2: Start the MCP Inspector</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p></p> <p>Step 3: Test Database Queries</p> <ol> <li> <p>Simple SELECT query:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM users</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with WHERE clause:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT name, email FROM users WHERE age &gt; 25</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with parameters:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM products WHERE category = ?</code></li> <li>parameters: <code>[\"Electronics\"]</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>Query with LIMIT:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT * FROM users</code></li> <li>limit: <code>2</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> <li> <p>JOIN query:</p> <ul> <li>Tool: <code>query_database</code></li> <li>query: <code>SELECT u.name, p.name as product FROM users u CROSS JOIN products p LIMIT 5</code></li> <li>Click \u201cCall Tool\u201d</li> </ul> </li> </ol> <p></p> <p>Step 4: Test Error Cases</p> <ol> <li> <p>Non-SELECT query:</p> <ul> <li>query: <code>DELETE FROM users WHERE id = 1</code></li> </ul> </li> <li> <p>Invalid SQL syntax:</p> <ul> <li>query: <code>SELECT * FROM nonexistent_table</code></li> </ul> </li> <li> <p>Missing database file:</p> <ul> <li>Rename <code>data.db</code> to <code>data.db.backup</code> and try a query</li> </ul> </li> <li> <p>Empty query:</p> <ul> <li>query: <code>\"\"</code></li> </ul> </li> </ol> <p></p> <p>Step 5: Verify Output</p> <ul> <li> <p>You should see output like:</p> <pre><code>Query executed successfully.\nDatabase: ./data.db\nColumns: id, name, email, age, created_at\nRows returned: 3\n\nResults:\n[\n  {\n    \"id\": 1,\n    \"name\": \"Alice Johnson\",\n    \"email\": \"alice@example.com\",\n    \"age\": 28,\n    \"created_at\": \"2024-01-06 10:30:00\"\n  },\n  ...\n]\n</code></pre> </li> </ul> <p>Troubleshooting:</p> <ul> <li>\u201cDatabase file not found\u201d: Make sure <code>data.db</code> exists in your project root</li> <li>\u201cOnly SELECT queries are allowed\u201d: The tool only allows SELECT statements for security</li> <li>\u201cno such table\u201d: Check your table names in the database</li> <li>\u201csqlite3: command not found\u201d: Install sqlite3 CLI tool</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#key-learning-points_2","title":"Key Learning Points:","text":"<ul> <li>SQL injection prevention using prepared statements</li> <li>Database security with read-only access and query restrictions</li> <li>SQLite operations with better-sqlite3</li> <li>Query parameterization for safe dynamic queries</li> <li>Result formatting and metadata extraction</li> <li>Resource management with proper database connection handling</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#returning-rich-content","title":"Returning Rich Content","text":"<p>MCP supports multiple content types in tool responses, allowing you to return not just text but also images, resources, and combinations of different content types. This enables richer, more interactive responses that can include visual data, file references, and structured information.</p>"},{"location":"Lab03-MCP-Tools/lab/#1-text-content","title":"1. Text Content","text":"<p>Text content is the most common and basic type of response. Use it for any string-based information like analysis results, status messages, or formatted data.</p> <pre><code>return {\n  content: [\n    {\n      type: \"text\",\n      text: \"Simple text response\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Most tool responses will use text content. It\u2019s perfect for:</p> <ul> <li>Status messages and confirmations</li> <li>Formatted data output (JSON, tables, lists)</li> <li>Error messages and explanations</li> <li>Analysis results and summaries</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#2-image-content","title":"2. Image Content","text":"<p>Image content allows you to return visual data directly in the response. The image data must be base64-encoded and include the appropriate MIME type.</p> <pre><code>return {\n  content: [\n    {\n      type: \"image\",\n      data: base64ImageData,\n      mimeType: \"image/png\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Ideal for tools that generate or process visual content:</p> <ul> <li>Charts and graphs from data analysis</li> <li>Screenshots or visual captures</li> <li>Generated diagrams or illustrations</li> <li>Image processing results</li> </ul> <p>Important: Always specify the correct MIME type (image/png, image/jpeg, image/svg+xml, etc.) and ensure the base64 data is properly encoded.</p>"},{"location":"Lab03-MCP-Tools/lab/#3-resource-content","title":"3. Resource Content","text":"<p>Resource content references external resources rather than including their data directly. This is useful for large files or when you want to provide access to resources without embedding them.</p> <pre><code>return {\n  content: [\n    {\n      type: \"resource\",\n      resource: {\n        uri: \"file:///path/to/file.txt\",\n        mimeType: \"text/plain\",\n        text: \"File contents...\"\n      }\n    }\n  ]\n};\n</code></pre> <p>When to use - Best for:</p> <ul> <li>Large files that would make responses too bulky</li> <li>References to external files or URLs</li> <li>When the client should handle the resource directly</li> <li>Providing access to generated files</li> </ul> <p>Note: The <code>text</code> field is optional - you can omit it if the resource content is too large or if you just want to provide a reference.</p>"},{"location":"Lab03-MCP-Tools/lab/#4-multiple-content-items","title":"4. Multiple Content Items","text":"<p>Multiple content items allow you to combine different types of content in a single response. This creates rich, multi-part responses that can include text explanations alongside visual data.</p> <pre><code>return {\n  content: [\n    {\n      type: \"text\",\n      text: \"Analysis complete:\"\n    },\n    {\n      type: \"text\",\n      text: \"Details:\\n- Item 1\\n- Item 2\"\n    },\n    {\n      type: \"image\",\n      data: chartImage,\n      mimeType: \"image/png\"\n    }\n  ]\n};\n</code></pre> <p>When to use - Perfect for comprehensive responses that need multiple components:</p> <ul> <li>Analysis reports with both text summaries and visual charts</li> <li>File processing results with metadata and content preview</li> <li>Multi-step operations with status updates and final results</li> <li>Complex data with both tabular and graphical representations</li> </ul> <p>Tip: Order your content logically - start with text explanations, then show supporting images or resources.</p>"},{"location":"Lab03-MCP-Tools/lab/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Error handling is crucial for robust MCP tools. Different situations require different approaches to handle failures gracefully while providing useful feedback to users. Here are three essential patterns for handling errors effectively.</p>"},{"location":"Lab03-MCP-Tools/lab/#pattern-1-input-validation","title":"Pattern 1: Input Validation","text":"<p>Input validation ensures that tool arguments meet your requirements before processing begins. This prevents runtime errors and provides clear feedback when users provide invalid data.</p> <pre><code>function validateInput(args: any): void {\n  if (!args.filepath || typeof args.filepath !== 'string') {\n    throw new Error(\"filepath must be a non-empty string\");\n  }\n\n  if (args.maxSize &amp;&amp; (args.maxSize &lt; 1 || args.maxSize &gt; 10485760)) {\n    throw new Error(\"maxSize must be between 1 and 10485760 bytes\");\n  }\n}\n</code></pre> <p>When to use - Always validate inputs before processing, even when using JSON Schema validation. This pattern is essential for:</p> <ul> <li>Type checking beyond JSON Schema capabilities</li> <li>Business logic validation (file size limits, path security)</li> <li>Preventing runtime errors from malformed data</li> <li>Providing specific, actionable error messages</li> </ul> <p>Why it matters: Early validation fails fast and gives users clear guidance on how to fix their input.</p>"},{"location":"Lab03-MCP-Tools/lab/#pattern-2-graceful-degradation","title":"Pattern 2: Graceful Degradation","text":"<p>Graceful degradation provides partial functionality when full operation isn\u2019t possible. Instead of failing completely, the tool returns useful information or falls back to alternative approaches.</p> <pre><code>try {\n  const data = await fetchFromAPI(url);\n  return formatSuccess(data);\n} catch (error) {\n  // Log error but return partial results if possible\n  console.error(\"API call failed:\", error);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: \"\u26a0\ufe0f Could not fetch live data. Using cached results...\"\n      }\n    ]\n  };\n}\n</code></pre> <p>When to use - For external dependencies that might be unreliable:</p> <ul> <li>API calls that could timeout or fail</li> <li>Network-dependent operations</li> <li>Services with occasional downtime</li> <li>When partial results are better than no results</li> </ul> <p>Why it matters: Users get some value even when systems are partially broken, improving overall reliability and user experience.</p>"},{"location":"Lab03-MCP-Tools/lab/#pattern-3-detailed-error-context","title":"Pattern 3: Detailed Error Context","text":"<p>Detailed error context provides comprehensive information for debugging while keeping user-facing messages clean. Log full details internally but expose only safe, helpful information to users.</p> <pre><code>catch (error) {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  const errorContext = {\n    tool: name,\n    arguments: args,\n    timestamp: new Date().toISOString(),\n    error: errorMessage\n  };\n\n  console.error(\"[Tool Error]\", JSON.stringify(errorContext));\n\n  throw new Error(\n    `Tool '${name}' failed: ${errorMessage}. Check server logs for details.`\n  );\n}\n</code></pre> <p>When to use - For complex operations where debugging might be needed:</p> <ul> <li>Multi-step processes with potential failure points</li> <li>Operations involving external systems</li> <li>When you need to track error patterns over time</li> <li>Production environments where detailed logging is crucial</li> </ul> <p>Why it matters: Developers can diagnose issues effectively while users get clear, non-technical error messages.</p> <p></p>"},{"location":"Lab03-MCP-Tools/lab/#best-practices-for-error-handling","title":"Best Practices for Error Handling:","text":"<ul> <li>Fail Fast: Validate inputs early and stop processing on critical errors</li> <li>Log Internally: Use <code>console.error()</code> for detailed logging (goes to stderr, not stdout)</li> <li>User-Friendly Messages: Keep error messages clear and actionable</li> <li>Don\u2019t Leak Sensitive Data: Never expose file paths, credentials, or internal details</li> <li>Consistent Format: Use similar error message patterns across tools</li> <li>Recovery Options: When possible, suggest how users can resolve the issue</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#async-operations-and-performance","title":"Async Operations and Performance","text":"<p>MCP tools often need to handle asynchronous operations and optimize performance. Long-running tasks require special handling to prevent timeouts and provide feedback, while expensive operations benefit from caching to improve response times and reduce resource usage.</p>"},{"location":"Lab03-MCP-Tools/lab/#long-running-operations","title":"Long-Running Operations","text":"<p>Long-running operations need monitoring and progress feedback to prevent timeouts and keep users informed. Use logging and timing to track operation progress and provide completion status.</p> <pre><code>if (name === \"analyze_large_file\") {\n  const filepath = args.filepath as string;\n\n  // For very long operations, consider streaming or progress updates\n  console.error(`[INFO] Starting analysis of ${filepath}...`);\n\n  try {\n    const startTime = Date.now();\n\n    // Perform analysis\n    const result = await performLongAnalysis(filepath);\n\n    const duration = Date.now() - startTime;\n    console.error(`[INFO] Analysis completed in ${duration}ms`);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Analysis Results (completed in ${duration}ms):\\n\\n${result}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    console.error(`[ERROR] Analysis failed after ${Date.now() - startTime}ms`);\n    throw error;\n  }\n}\n</code></pre> <p>When to use - For operations that take more than a few seconds:</p> <ul> <li>Large file processing or analysis</li> <li>Complex computations</li> <li>External API calls with potential delays</li> <li>Batch operations on multiple items</li> </ul> <p>Why it matters: Prevents timeouts, provides user feedback, enables monitoring and debugging of slow operations.</p>"},{"location":"Lab03-MCP-Tools/lab/#caching-results","title":"Caching Results","text":"<p>Caching results stores expensive operation results to avoid redundant computation. Use time-based expiration and proper cache keys for efficient reuse of results.</p> <pre><code>class CachedMCPServer {\n  private cache: Map&lt;string, { data: any; timestamp: number }&gt;;\n  private cacheTTL: number = 60000; // 1 minute\n\n  constructor() {\n    this.cache = new Map();\n  }\n\n  private getCacheKey(toolName: string, args: any): string {\n    return `${toolName}:${JSON.stringify(args)}`;\n  }\n\n  private getCached(key: string): any | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n\n    if (Date.now() - cached.timestamp &gt; this.cacheTTL) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return cached.data;\n  }\n\n  private setCache(key: string, data: any): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n}\n</code></pre> <p>When to use - For expensive operations that return consistent results:</p> <ul> <li>API calls to external services</li> <li>Complex calculations or data processing</li> <li>Database queries with static data</li> <li>File analysis that doesn\u2019t change frequently</li> </ul> <p>Why it matters: Dramatically improves response times, reduces resource usage, and provides better user experience for repeated requests.</p>"},{"location":"Lab03-MCP-Tools/lab/#best-practices-for-async-operations-and-performance","title":"Best Practices for Async Operations and Performance:","text":"<ul> <li>Monitor Execution Time: Log start/end times for operations over 1 second</li> <li>Set Reasonable Timeouts: Use appropriate timeouts for external calls (5-30 seconds)</li> <li>Cache Strategically: Cache expensive operations but consider data freshness</li> <li>Use Streaming: For very large responses, consider streaming or pagination</li> <li>Resource Cleanup: Always clean up connections, file handles, and memory</li> <li>Progress Feedback: For long operations, provide progress updates via logging</li> <li>Memory Management: Be mindful of memory usage in long-running processes</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#tool-composition","title":"Tool Composition","text":"<p>Tool composition is the art of designing MCP tools that work seamlessly together, allowing LLMs to chain multiple tools to accomplish complex tasks. Well-composed tools create a powerful ecosystem where each tool handles a specific responsibility while enabling sophisticated workflows through intelligent combination.</p>"},{"location":"Lab03-MCP-Tools/lab/#example-multi-step-analysis","title":"Example: Multi-Step Analysis","text":"<p>Multi-step analysis demonstrates how simple, focused tools can be combined to perform complex data processing workflows. Each tool has a clear responsibility and can be used independently or as part of larger operations.</p> <pre><code>// Tool 1: List files\n{\n  name: \"list_files\",\n  description: \"List files in a directory\",\n  inputSchema: { ... }\n}\n\n// Tool 2: Read file\n{\n  name: \"read_file\",\n  description: \"Read a specific file\",\n  inputSchema: { ... }\n}\n\n// Tool 3: Analyze content\n{\n  name: \"analyze_text\",\n  description: \"Analyze text content\",\n  inputSchema: { ... }\n}\n</code></pre> <p>When to use - For workflows that require multiple processing steps:</p> <ul> <li>Data analysis pipelines</li> <li>File processing workflows</li> <li>Multi-stage computations</li> <li>Complex research tasks</li> </ul> <p>Why it matters: Breaks down complex problems into manageable, reusable components that can be combined in flexible ways.</p>"},{"location":"Lab03-MCP-Tools/lab/#llm-tool-chaining","title":"LLM Tool Chaining","text":"<p>LLM tool chaining allows AI models to automatically sequence tool calls based on intermediate results. The LLM analyzes outputs from one tool and determines which tool to call next, creating intelligent workflows without explicit programming.</p> <p>The LLM can chain these tools:</p> <ol> <li>List files in directory - Discover available files</li> <li>Read interesting files - Access content based on filenames</li> <li>Analyze their content - Process and extract insights</li> </ol> <p>When to use - When tasks naturally break down into sequential steps:</p> <ul> <li>Research and analysis workflows</li> <li>Data processing pipelines</li> <li>Content generation chains</li> <li>Problem-solving sequences</li> </ul> <p>Why it matters: Enables complex, multi-step reasoning and problem-solving that would be difficult to implement in single tools.</p>"},{"location":"Lab03-MCP-Tools/lab/#testing-composed-tools","title":"Testing Composed Tools","text":"<p>Testing composed tools ensures that individual tools work correctly both in isolation and when chained together. Use comprehensive test suites that cover single-tool usage and multi-tool workflows.</p> <pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Weather Tool', () =&gt; {\n  it('should validate city name', async () =&gt; {\n    await expect(\n      callTool('get_weather', { city: '' })\n    ).rejects.toThrow('City name cannot be empty');\n  });\n\n  it('should handle invalid city', async () =&gt; {\n    await expect(\n      callTool('get_weather', { city: 'InvalidCity12345' })\n    ).rejects.toThrow('not found');\n  });\n\n  it('should return weather data', async () =&gt; {\n    const result = await callTool('get_weather', {\n      city: 'London',\n      units: 'celsius'\n    });\n\n    expect(result.content).toHaveLength(1);\n    expect(result.content[0].text).toContain('Temperature');\n  });\n});\n</code></pre> <p>When to use - For validating tool behavior in different scenarios:</p> <ul> <li>Unit testing individual tools</li> <li>Integration testing tool chains</li> <li>Regression testing after changes</li> <li>Edge case validation</li> </ul> <p>Why it matters: Ensures reliability and predictability when tools are used individually or in combination.</p>"},{"location":"Lab03-MCP-Tools/lab/#best-practices-for-tool-composition","title":"Best Practices for Tool Composition:","text":"<ul> <li>Single Responsibility: Each tool should do one thing well</li> <li>Consistent Interfaces: Use similar parameter patterns across tools</li> <li>Clear Dependencies: Document which tools work well together</li> <li>Error Propagation: Handle failures gracefully in tool chains</li> <li>State Management: Avoid tools that require complex state between calls</li> <li>Flexible Outputs: Design tool outputs to be usable as inputs for other tools</li> <li>Documentation: Clearly explain how tools can be combined</li> <li>Version Compatibility: Ensure tool interfaces remain stable</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#best-practices-checklist","title":"Best Practices Checklist","text":"<p>\u2705 Schema Design</p> <ul> <li>Use descriptive names and descriptions</li> <li>Add examples in descriptions</li> <li>Set reasonable defaults</li> <li>Use enums for constrained values</li> <li>Add min/max for numbers</li> </ul> <p>\u2705 Implementation</p> <ul> <li>Validate all inputs, even with schemas</li> <li>Handle errors gracefully</li> <li>Log to stderr, not stdout</li> <li>Use async/await properly</li> <li>Clean up resources (file handles, connections)</li> </ul> <p>\u2705 Security</p> <ul> <li>Validate and sanitize file paths</li> <li>Use prepared statements for SQL</li> <li>Limit resource usage (file sizes, API calls)</li> <li>Don\u2019t expose sensitive data in errors</li> <li>Implement rate limiting</li> </ul> <p>\u2705 Performance</p> <ul> <li>Cache expensive operations</li> <li>Set reasonable timeouts</li> <li>Limit result sizes</li> <li>Use streaming for large data</li> <li>Monitor execution time</li> </ul> <p>\u2705 User Experience</p> <ul> <li>Provide clear error messages</li> <li>Return structured data when possible</li> <li>Include relevant context in responses</li> <li>Handle edge cases gracefully</li> <li>Document expected behavior</li> </ul>"},{"location":"Lab03-MCP-Tools/lab/#hands-on-exercises","title":"Hands-On Exercises","text":""},{"location":"Lab03-MCP-Tools/lab/#exercise-1-text-processing-tool","title":"Exercise 1: Text Processing Tool","text":"<p>Create a tool that:</p> <ul> <li>Counts words, characters, lines</li> <li>Finds specific patterns</li> <li>Calculates reading time</li> <li>Detects language</li> </ul> \ud83d\udca1 Solution: Text Processing Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"process_text\",\n  description: \"Analyze and process text content with various metrics and operations\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      text: {\n        type: \"string\",\n        description: \"The text content to process\"\n      },\n      operations: {\n        type: \"array\",\n        description: \"Operations to perform\",\n        items: {\n          type: \"string\",\n          enum: [\"count\", \"find_pattern\", \"reading_time\", \"detect_language\"]\n        },\n        default: [\"count\"]\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Regex pattern for find_pattern operation\"\n      }\n    },\n    required: [\"text\"]\n  }\n}\n</code></pre>  Implementation - Add this handler in your \"CallToolRequestSchema\" handler:  <pre><code>if (name === \"process_text\") {\n  try {\n    const text = args.text as string;\n    const operations = (args.operations as string[]) || [\"count\"];\n    const pattern = args.pattern as string;\n\n    let results: string[] = [];\n\n    for (const op of operations) {\n      switch (op) {\n        case \"count\":\n          const lines = text.split('\\n').length;\n          const words = text.split(/\\s+/).filter(w =&gt; w.length &gt; 0).length;\n          const chars = text.length;\n          results.push(`\ud83d\udcca Text Statistics:\\n- Lines: ${lines}\\n- Words: ${words}\\n- Characters: ${chars}`);\n          break;\n\n        case \"find_pattern\":\n          if (!pattern) {\n            results.push(\"\u274c Pattern required for find_pattern operation\");\n            break;\n          }\n          try {\n            const regex = new RegExp(pattern, 'g');\n            const matches = text.match(regex);\n            results.push(`\ud83d\udd0d Pattern Matches (${pattern}):\\nFound ${matches ? matches.length : 0} matches:\\n${matches ? matches.slice(0, 10).join('\\n') : 'None'}`);\n          } catch (e) {\n            results.push(`\u274c Invalid regex pattern: ${pattern}`);\n          }\n          break;\n\n        case \"reading_time\":\n          // Average reading speed: 200 words per minute\n          const wordCount = text.split(/\\s+/).filter(w =&gt; w.length &gt; 0).length;\n          const readingTime = Math.ceil(wordCount / 200);\n          results.push(`\u23f1\ufe0f Reading Time: Approximately ${readingTime} minute${readingTime !== 1 ? 's' : ''} (${wordCount} words at 200 WPM)`);\n          break;\n\n        case \"detect_language\":\n          // Simple language detection based on common words\n          const englishWords = /\\b(the|and|or|but|in|on|at|to|for|of|with|by)\\b/gi;\n          const spanishWords = /\\b(el|la|los|las|y|o|pero|en|sobre|a|para|de|con|por)\\b/gi;\n          const frenchWords = /\\b(le|la|les|et|ou|mais|dans|sur|\u00e0|pour|de|avec|par)\\b/gi;\n\n          const englishMatches = (text.match(englishWords) || []).length;\n          const spanishMatches = (text.match(spanishWords) || []).length;\n          const frenchMatches = (text.match(frenchWords) || []).length;\n\n          const maxMatches = Math.max(englishMatches, spanishMatches, frenchMatches);\n          let detectedLang = \"Unknown\";\n\n          if (maxMatches &gt; 0) {\n            if (englishMatches === maxMatches) detectedLang = \"English\";\n            else if (spanishMatches === maxMatches) detectedLang = \"Spanish\";\n            else if (frenchMatches === maxMatches) detectedLang = \"French\";\n          }\n\n          results.push(`\ud83c\udf0d Detected Language: ${detectedLang} (confidence: ${maxMatches} common words)`);\n          break;\n      }\n    }\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: results.join('\\n\\n')\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(`Text processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n</code></pre>  Testing - Test with different inputs:  <pre><code>// Basic counting\n{ text: \"Hello world\\nThis is a test\", operations: [\"count\"] }\n\n// Pattern matching\n{ text: \"The quick brown fox jumps over the lazy dog\", operations: [\"find_pattern\"], pattern: \"\\\\b\\\\w{4}\\\\b\" }\n\n// Multiple operations\n{ text: \"This is a longer piece of text to analyze for various metrics and patterns.\", operations: [\"count\", \"reading_time\", \"detect_language\"] }\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab/#exercise-2-json-validator-tool","title":"Exercise 2: JSON Validator Tool","text":"<p>Create a tool that:</p> <ul> <li>Validates JSON syntax</li> <li>Validates against JSON Schema</li> <li>Formats/pretty-prints JSON</li> <li>Compares two JSON objects</li> </ul> \ud83d\udca1 Solution: JSON Validator Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"validate_json\",\n  description: \"Validate, format, and compare JSON data\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      json: {\n        type: \"string\",\n        description: \"JSON string to validate or format\"\n      },\n      operation: {\n        type: \"string\",\n        description: \"Operation to perform\",\n        enum: [\"validate\", \"format\", \"schema_validate\", \"compare\"],\n        default: \"validate\"\n      },\n      schema: {\n        type: \"string\",\n        description: \"JSON Schema for schema validation (as JSON string)\"\n      },\n      json2: {\n        type: \"string\",\n        description: \"Second JSON string for comparison\"\n      }\n    },\n    required: [\"json\", \"operation\"]\n  }\n}\n</code></pre>  Implementation - First, install the required dependency:  <pre><code>npm install ajv\n</code></pre>  Add the import:  <pre><code>import Ajv from 'ajv';\n</code></pre>  Add this handler in your \"CallToolRequestSchema\" handler:  <pre><code>if (name === \"validate_json\") {\n  try {\n    const json = args.json as string;\n    const operation = args.operation as string;\n    const schema = args.schema as string;\n    const json2 = args.json2 as string;\n\n    let result = \"\";\n\n    switch (operation) {\n      case \"validate\":\n        try {\n          JSON.parse(json);\n          result = \"\u2705 Valid JSON syntax\";\n        } catch (e) {\n          result = `\u274c Invalid JSON: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"format\":\n        try {\n          const parsed = JSON.parse(json);\n          result = `\ud83d\udcc4 Formatted JSON:\\n\\`\\`\\`json\\n${JSON.stringify(parsed, null, 2)}\\n\\`\\`\\``;\n        } catch (e) {\n          result = `\u274c Cannot format invalid JSON: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"schema_validate\":\n        if (!schema) {\n          result = \"\u274c Schema required for schema validation\";\n          break;\n        }\n        try {\n          const ajv = new Ajv();\n          const parsedJson = JSON.parse(json);\n          const parsedSchema = JSON.parse(schema);\n\n          const validate = ajv.compile(parsedSchema);\n          const valid = validate(parsedJson);\n\n          if (valid) {\n            result = \"\u2705 JSON validates against schema\";\n          } else {\n            result = `\u274c Schema validation failed:\\n${JSON.stringify(validate.errors, null, 2)}`;\n          }\n        } catch (e) {\n          result = `\u274c Schema validation error: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n\n      case \"compare\":\n        if (!json2) {\n          result = \"\u274c Second JSON required for comparison\";\n          break;\n        }\n        try {\n          const obj1 = JSON.parse(json);\n          const obj2 = JSON.parse(json2);\n\n          const differences: string[] = [];\n\n          // Simple comparison - check if objects are equal\n          if (JSON.stringify(obj1) === JSON.stringify(obj2)) {\n            result = \"\u2705 JSON objects are identical\";\n          } else {\n            // Find differences\n            const keys1 = Object.keys(obj1);\n            const keys2 = Object.keys(obj2);\n\n            const added = keys2.filter(k =&gt; !keys1.includes(k));\n            const removed = keys1.filter(k =&gt; !keys2.includes(k));\n            const modified = keys1.filter(k =&gt; keys2.includes(k) &amp;&amp; JSON.stringify(obj1[k]) !== JSON.stringify(obj2[k]));\n\n            if (added.length &gt; 0) differences.push(`Added keys: ${added.join(', ')}`);\n            if (removed.length &gt; 0) differences.push(`Removed keys: ${removed.join(', ')}`);\n            if (modified.length &gt; 0) differences.push(`Modified keys: ${modified.join(', ')}`);\n\n            result = `\u26a0\ufe0f JSON objects differ:\\n${differences.join('\\n')}`;\n          }\n        } catch (e) {\n          result = `\u274c Comparison error: ${e instanceof Error ? e.message : 'Unknown error'}`;\n        }\n        break;\n    }\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: result\n        }\n      ]\n    };\n\n  } catch (error) {\n    throw new Error(`JSON validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n</code></pre>  Testing - Test different operations:  <pre><code>// Validate syntax\n{ json: '{\"name\": \"test\", \"value\": 123}', operation: \"validate\" }\n\n// Format JSON\n{ json: '{\"name\":\"test\",\"value\":123}', operation: \"format\" }\n\n// Schema validation\n{ \n  json: '{\"name\": \"John\", \"age\": 30}', \n  operation: \"schema_validate\",\n  schema: '{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}, \"age\": {\"type\": \"number\"}}}'\n}\n\n// Compare JSON\n{\n  json: '{\"a\": 1, \"b\": 2}',\n  json2: '{\"a\": 1, \"c\": 3}',\n  operation: \"compare\"\n}\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab/#exercise-3-web-scraper-tool","title":"Exercise 3: Web Scraper Tool","text":"<p>Create a tool that:</p> <ul> <li>Fetches web page content</li> <li>Extracts specific elements</li> <li>Returns clean text</li> <li>Handles errors gracefully</li> </ul> \ud83d\udca1 Solution: Web Scraper Tool  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"scrape_web\",\n  description: \"Fetch and extract content from web pages\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      url: {\n        type: \"string\",\n        description: \"URL to scrape\",\n        format: \"uri\"\n      },\n      selector: {\n        type: \"string\",\n        description: \"CSS selector to extract specific elements (optional)\",\n        default: \"body\"\n      },\n      includeText: {\n        type: \"boolean\",\n        description: \"Extract only text content (remove HTML)\",\n        default: true\n      },\n      maxLength: {\n        type: \"number\",\n        description: \"Maximum length of extracted content\",\n        minimum: 100,\n        maximum: 10000,\n        default: 2000\n      },\n      timeout: {\n        type: \"number\",\n        description: \"Request timeout in milliseconds\",\n        minimum: 1000,\n        maximum: 30000,\n        default: 10000\n      }\n    },\n    required: [\"url\"]\n  }\n}\n</code></pre>  Implementation - First, install the required dependencies:  <pre><code>npm install axios cheerio\n</code></pre>  Add the imports:  <pre><code>import axios from 'axios';\nimport * as cheerio from 'cheerio';\n</code></pre>  Add this handler in your `CallToolRequestSchema` handler:  <pre><code>if (name === \"scrape_web\") {\n  try {\n    const url = args.url as string;\n    const selector = (args.selector as string) || \"body\";\n    const includeText = (args.includeText !== false); // default true\n    const maxLength = (args.maxLength as number) || 2000;\n    const timeout = (args.timeout as number) || 10000;\n\n    // Validate URL\n    try {\n      new URL(url);\n    } catch {\n      throw new Error(\"Invalid URL format\");\n    }\n\n    // Fetch the webpage\n    const response = await axios.get(url, {\n      timeout: timeout,\n      headers: {\n        'User-Agent': 'MCP-Web-Scraper/1.0 (Educational Tool)'\n      },\n      maxContentLength: 5 * 1024 * 1024, // 5MB limit\n    });\n\n    // Load HTML into cheerio\n    const $ = cheerio.load(response.data);\n\n    // Extract content based on selector\n    let extractedContent = \"\";\n\n    if (selector === \"body\") {\n      extractedContent = includeText ? $('body').text() : $('body').html() || \"\";\n    } else {\n      const elements = $(selector);\n      if (elements.length === 0) {\n        throw new Error(`No elements found matching selector: ${selector}`);\n      }\n\n      if (includeText) {\n        extractedContent = elements.map((_, el) =&gt; $(el).text()).get().join('\\n\\n');\n      } else {\n        extractedContent = elements.map((_, el) =&gt; $.html(el)).get().join('\\n\\n');\n      }\n    }\n\n    // Clean up the content\n    extractedContent = extractedContent\n      .replace(/\\s+/g, ' ')  // Replace multiple whitespace with single space\n      .replace(/\\n\\s*\\n/g, '\\n')  // Remove empty lines\n      .trim();\n\n    // Truncate if too long\n    if (extractedContent.length &gt; maxLength) {\n      extractedContent = extractedContent.substring(0, maxLength - 3) + \"...\";\n    }\n\n    // Prepare metadata\n    const metadata = {\n      url: url,\n      statusCode: response.status,\n      contentType: response.headers['content-type'],\n      contentLength: response.data.length,\n      extractedLength: extractedContent.length,\n      selector: selector,\n      elementsFound: selector === \"body\" ? 1 : $(selector).length\n    };\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `\ud83c\udf10 Web Scraping Results\\n\\n\ud83d\udcca Metadata:\\n${Object.entries(metadata).map(([k, v]) =&gt; `- ${k}: ${v}`).join('\\n')}\\n\\n\ud83d\udcc4 Extracted Content:\\n${extractedContent}`\n        }\n      ]\n    };\n\n  } catch (error) {\n    if (axios.isAxiosError(error)) {\n      if (error.code === 'ENOTFOUND') {\n        throw new Error(`Could not resolve hostname: ${args.url}`);\n      } else if (error.code === 'ECONNREFUSED') {\n        throw new Error(`Connection refused: ${args.url}`);\n      } else if (error.response) {\n        throw new Error(`HTTP ${error.response.status}: ${error.response.statusText}`);\n      } else if (error.code === 'ETIMEDOUT') {\n        throw new Error(`Request timeout after ${args.timeout || 10000}ms`);\n      } else {\n        throw new Error(`Network error: ${error.message}`);\n      }\n    } else {\n      throw new Error(`Web scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n}\n</code></pre>  Testing - Test with different websites and selectors:  <pre><code>// Basic page scraping\n{ url: \"https://httpbin.org/html\" }\n\n// Extract specific elements\n{ url: \"https://httpbin.org/html\", selector: \"h1\" }\n\n// Get HTML instead of text\n{ url: \"https://httpbin.org/html\", selector: \"p\", includeText: false }\n\n// Test error handling\n{ url: \"https://nonexistent-domain-12345.com\" }\n{ url: \"https://httpbin.org/status/404\" }\n</code></pre>  #### Security Notes  - This tool includes basic security measures but should not be used for production scraping - Always respect robots.txt and terms of service - Consider rate limiting to avoid being blocked - Some websites may block requests without proper headers"},{"location":"Lab03-MCP-Tools/lab/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Well-designed tools have clear schemas with validation</p> <p>\u2705 Always validate inputs, even with JSON Schema</p> <p>\u2705 Return rich content types when appropriate</p> <p>\u2705 Handle errors gracefully with helpful messages</p> <p>\u2705 Consider performance and caching for expensive operations</p> <p>\u2705 Design tools to be composable with others</p> <p>\u2705 Test thoroughly with edge cases</p> <p>\u2705 Security is paramount - validate and sanitize everything</p>"},{"location":"Lab03-MCP-Tools/lab/#next-steps","title":"Next Steps","text":"<p>In Lab 4, you\u2019ll explore MCP Resources. You\u2019ll learn:</p> <ul> <li>What resources are and how they differ from tools</li> <li>Implementing resource URIs and templates</li> <li>Supporting resource subscriptions for live updates</li> <li>Best practices for resource organization</li> <li>Combining tools and resources effectively</li> </ul> <p>You\u2019re becoming an MCP expert! Continue to Lab 4.</p>"},{"location":"Lab03-MCP-Tools/lab3-tasks/","title":"MCP Lab Tasks - Lab 3","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-31-calculator-tool","title":"Exercise 3.1: Calculator Tool","text":"<p>Implement a calculator tool that supports basic arithmetic operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"calculate\") {\n    const { operation, a, b } = args;\n    let result: number;\n\n    switch (operation) {\n      case \"add\":\n        result = a + b;\n        break;\n      case \"subtract\":\n        result = a - b;\n        break;\n      case \"multiply\":\n        result = a * b;\n        break;\n      case \"divide\":\n        if (b === 0) throw new Error(\"Division by zero\");\n        result = a / b;\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-32-file-reader-tool","title":"Exercise 3.2: File Reader Tool","text":"<p>Create a tool that reads and returns file contents.</p> Solution <pre><code>import { readFileSync } from \"fs\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"read_file\") {\n    const { path } = args;\n    try {\n      const content = readFileSync(path, \"utf-8\");\n      return {\n        content: [{ type: \"text\", text: content }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-33-http-request-tool","title":"Exercise 3.3: HTTP Request Tool","text":"<p>Implement a tool that makes HTTP requests.</p> Solution <pre><code>import fetch from \"node-fetch\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"http_request\") {\n    const { url, method = \"GET\", headers = {} } = args;\n\n    try {\n      const response = await fetch(url, { method, headers });\n      const data = await response.text();\n\n      return {\n        content: [\n          { type: \"text\", text: `Status: ${response.status}` },\n          { type: \"text\", text: `Body: ${data}` }\n        ]\n      };\n    } catch (error) {\n      throw new Error(`HTTP request failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-34-json-parser-tool","title":"Exercise 3.4: JSON Parser Tool","text":"<p>Create a tool that parses and validates JSON data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_json\") {\n    const { json_string } = args;\n\n    try {\n      const parsed = JSON.parse(json_string);\n      return {\n        content: [\n          { type: \"text\", text: \"JSON is valid\" },\n          { type: \"text\", text: `Parsed: ${JSON.stringify(parsed, null, 2)}` }\n        ]\n      };\n    } catch (error) {\n      return {\n        content: [{ type: \"text\", text: `Invalid JSON: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-35-string-manipulation-tool","title":"Exercise 3.5: String Manipulation Tool","text":"<p>Implement a tool for common string operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"string_ops\") {\n    const { operation, text } = args;\n    let result: string;\n\n    switch (operation) {\n      case \"uppercase\":\n        result = text.toUpperCase();\n        break;\n      case \"lowercase\":\n        result = text.toLowerCase();\n        break;\n      case \"reverse\":\n        result = text.split('').reverse().join('');\n        break;\n      case \"length\":\n        result = text.length.toString();\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-36-database-query-tool","title":"Exercise 3.6: Database Query Tool","text":"<p>Create a tool that executes simple database queries.</p> Solution <pre><code>import sqlite3 from \"sqlite3\";\n\nconst db = new sqlite3.Database(':memory:');\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"db_query\") {\n    const { query } = args;\n\n    return new Promise((resolve, reject) =&gt; {\n      db.all(query, [], (err, rows) =&gt; {\n        if (err) {\n          reject(new Error(`Database error: ${err.message}`));\n        } else {\n          resolve({\n            content: [{ type: \"text\", text: JSON.stringify(rows, null, 2) }]\n          });\n        }\n      });\n    });\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-37-image-processing-tool","title":"Exercise 3.7: Image Processing Tool","text":"<p>Implement a tool that gets image metadata.</p> Solution <pre><code>import sharp from \"sharp\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"image_info\") {\n    const { image_path } = args;\n\n    try {\n      const metadata = await sharp(image_path).metadata();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Width: ${metadata.width}, Height: ${metadata.height}, Format: ${metadata.format}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Image processing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-38-code-linter-tool","title":"Exercise 3.8: Code Linter Tool","text":"<p>Create a tool that lints JavaScript/TypeScript code.</p> Solution <pre><code>import { ESLint } from \"eslint\";\n\nconst eslint = new ESLint();\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"lint_code\") {\n    const { code, filename = \"temp.js\" } = args;\n\n    try {\n      const results = await eslint.lintText(code, { filePath: filename });\n      const formatter = await eslint.loadFormatter(\"stylish\");\n      const resultText = formatter.format(results);\n\n      return {\n        content: [{ type: \"text\", text: resultText || \"No linting issues found\" }]\n      };\n    } catch (error) {\n      throw new Error(`Linting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-39-weather-api-tool","title":"Exercise 3.9: Weather API Tool","text":"<p>Implement a tool that fetches weather data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"get_weather\") {\n    const { city } = args;\n    const apiKey = process.env.WEATHER_API_KEY;\n\n    if (!apiKey) {\n      throw new Error(\"Weather API key not configured\");\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${city}&amp;appid=${apiKey}&amp;units=metric`\n      );\n\n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Weather in ${city}: ${data.weather[0].description}, ${data.main.temp}\u00b0C`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Weather fetch failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-310-git-operations-tool","title":"Exercise 3.10: Git Operations Tool","text":"<p>Create a tool for basic Git operations.</p> Solution <pre><code>import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"git_status\") {\n    try {\n      const { stdout } = await execAsync(\"git status --porcelain\");\n      return {\n        content: [{ type: \"text\", text: stdout || \"Working directory clean\" }]\n      };\n    } catch (error) {\n      throw new Error(`Git command failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-311-regex-tool","title":"Exercise 3.11: Regex Tool","text":"<p>Implement a tool for regular expression operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"regex_match\") {\n    const { pattern, text, flags = \"\" } = args;\n\n    try {\n      const regex = new RegExp(pattern, flags);\n      const matches = text.match(regex);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: matches ? `Matches found: ${matches.join(\", \")}` : \"No matches found\"\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Regex error: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-312-unit-converter-tool","title":"Exercise 3.12: Unit Converter Tool","text":"<p>Create a tool that converts between different units.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"convert_units\") {\n    const { value, from, to } = args;\n\n    // Simple conversion factors (could be expanded)\n    const conversions: Record&lt;string, Record&lt;string, number&gt;&gt; = {\n      celsius: { fahrenheit: (c) =&gt; c * 9/5 + 32, kelvin: (c) =&gt; c + 273.15 },\n      fahrenheit: { celsius: (f) =&gt; (f - 32) * 5/9, kelvin: (f) =&gt; (f - 32) * 5/9 + 273.15 },\n      meters: { feet: (m) =&gt; m * 3.28084, kilometers: (m) =&gt; m / 1000 },\n      feet: { meters: (f) =&gt; f / 3.28084, kilometers: (f) =&gt; f / 3280.84 }\n    };\n\n    if (conversions[from] &amp;&amp; conversions[from][to]) {\n      const result = conversions[from][to](value);\n      return {\n        content: [{ type: \"text\", text: `${value} ${from} = ${result.toFixed(2)} ${to}` }]\n      };\n    }\n\n    throw new Error(`Conversion from ${from} to ${to} not supported`);\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-313-csv-parser-tool","title":"Exercise 3.13: CSV Parser Tool","text":"<p>Implement a tool that parses CSV data.</p> Solution <pre><code>import { parse } from \"csv-parse/sync\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_csv\") {\n    const { csv_data } = args;\n\n    try {\n      const records = parse(csv_data, {\n        columns: true,\n        skip_empty_lines: true\n      });\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Parsed ${records.length} rows: ${JSON.stringify(records.slice(0, 5), null, 2)}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`CSV parsing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-314-password-generator-tool","title":"Exercise 3.14: Password Generator Tool","text":"<p>Create a tool that generates secure passwords.</p> Solution <pre><code>import { randomBytes } from \"crypto\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_password\") {\n    const { length = 12, include_special = true } = args;\n\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const specialChars = \"!@#$%^&amp;*\";\n\n    let charset = chars;\n    if (include_special) {\n      charset += specialChars;\n    }\n\n    let password = \"\";\n    const bytes = randomBytes(length);\n\n    for (let i = 0; i &lt; length; i++) {\n      password += charset[bytes[i] % charset.length];\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Generated password: ${password}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab03-MCP-Tools/lab3-tasks/#exercise-315-code-formatter-tool","title":"Exercise 3.15: Code Formatter Tool","text":"<p>Implement a tool that formats code using Prettier.</p> Solution <pre><code>import prettier from \"prettier\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"format_code\") {\n    const { code, language = \"javascript\" } = args;\n\n    try {\n      const formatted = await prettier.format(code, {\n        parser: language,\n        semi: true,\n        singleQuote: true\n      });\n\n      return {\n        content: [{ type: \"text\", text: formatted }]\n      };\n    } catch (error) {\n      throw new Error(`Code formatting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/","title":"Lab 4: Working with MCP Resources","text":""},{"location":"Lab04-MCP-Resources/lab/#overview","title":"Overview","text":"<p>In Lab 3, you mastered the art of creating sophisticated MCP tools that perform actions and return rich content. Now it\u2019s time to explore MCP Resources - the passive counterpart to tools that provides contextual data for LLMs to read and reference.</p> <p>Resources are the foundation for giving LLMs access to your knowledge bases, files, databases, and other data sources. Unlike tools that do things, resources are things - they represent the data itself that LLMs can access for context and reasoning.</p>"},{"location":"Lab04-MCP-Resources/lab/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand the fundamental difference between tools and resources</li> <li>Design effective resource URI schemes for different data types</li> <li>Implement static and dynamic resources with proper metadata</li> <li>Create resource templates for parameterized access</li> <li>Build resource subscriptions for real-time updates</li> <li>Apply security best practices for resource access</li> <li>Combine resources with tools for comprehensive MCP servers</li> <li>Test resource implementations thoroughly</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 3 - Implementing MCP Tools</li> <li>Understanding of URI / URL patterns and RESTful design</li> <li>Familiarity with file systems and data structures</li> <li>Basic knowledge of caching and performance optimization</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#tools-vs-resources","title":"Tools vs. Resources","text":""},{"location":"Lab04-MCP-Resources/lab/#the-fundamental-difference","title":"The Fundamental Difference","text":"<p>Before diving into implementation, it\u2019s crucial to understand when to use tools versus resources. They serve different purposes in the MCP ecosystem.</p>"},{"location":"Lab04-MCP-Resources/lab/#tools-active-operations","title":"Tools: Active Operations","text":"<p>Tools perform actions and return results based on parameters.</p> <pre><code>// Tool: Active, parameterized, can have side effects\n{\n  name: \"search_database\",\n  description: \"Search database with custom query\",\n  inputSchema: {\n    properties: {\n      query: { type: \"string\" },\n      limit: { type: \"number\", default: 100 }\n    }\n  }\n}\n</code></pre> <p>When to use tools:</p> <ul> <li>Data changes frequently or needs computation</li> <li>Operations require parameters or user input</li> <li>Actions have side effects (create, update, delete)</li> <li>Results need processing or transformation</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#resources-passive-data","title":"Resources: Passive Data","text":"<p>Resources expose existing data that can be read and referenced.</p> <pre><code>// Resource: Passive, addressable, read-only\n{\n  uri: \"db://users/123/profile\",\n  name: \"User Profile\",\n  description: \"User profile data for ID 123\",\n  mimeType: \"application/json\"\n}\n</code></pre> <p>When to use resources:</p> <ul> <li>Data is relatively static or changes predictably</li> <li>Direct access to structured data is needed</li> <li>Content should be cached or bookmarked</li> <li>Data serves as context for LLM reasoning</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#decision-framework","title":"Decision Framework","text":"Scenario Use Tool Use Resource Why Current weather \u2705 Tool \u274c Resource Data changes constantly API documentation \u274c Tool \u2705 Resource Static reference material Database search \u2705 Tool \u274c Resource Requires query parameters User profile \u274c Tool \u2705 Resource Direct data access needed File contents \u274c Tool \u2705 Resource Static file data Generate report \u2705 Tool \u274c Resource Computation required"},{"location":"Lab04-MCP-Resources/lab/#resource-fundamentals","title":"Resource Fundamentals","text":""},{"location":"Lab04-MCP-Resources/lab/#resource-structure","title":"Resource Structure","text":"<p>Every MCP resource has a consistent structure with metadata that helps LLMs understand what they\u2019re accessing:</p> <pre><code>interface Resource {\n  uri: string;           // Unique identifier (like a URL)\n  name: string;          // Human-readable title\n  description: string;   // What the resource contains\n  mimeType?: string;     // Content type (optional but recommended)\n}\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#resource-content","title":"Resource Content","text":"<p>When a resource is read, it returns structured content:</p> <pre><code>interface ResourceContent {\n  contents: Array&lt;{\n    uri: string;\n    mimeType?: string;\n    text?: string;       // For text content\n    blob?: string;       // For binary content (base64)\n  }&gt;;\n}\n</code></pre> <p>Key Points:</p> <ul> <li>Resources are read-only by convention</li> <li>Content can be text or binary (base64 encoded)</li> <li>Multiple content items can be returned for complex resources</li> <li><code>MIME (Multipurpose Internet Mail Extensions) types</code> help clients handle content appropriately</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#designing-resource-uri-schemes","title":"Designing Resource URI Schemes","text":"<p>Effective URI design is crucial for resource organization and discoverability. A good URI scheme should be:</p> <ul> <li>Hierarchical: Reflects data organization</li> <li>Descriptive: Self-documenting structure</li> <li>Consistent: Follows patterns across similar resources</li> <li>Extensible: Allows for future additions</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#common-uri-patterns","title":"Common URI Patterns","text":""},{"location":"Lab04-MCP-Resources/lab/#file-system-resources","title":"File System Resources","text":"<pre><code>file:///project/src/index.ts\nfile:///docs/api-reference.md\nfile:///config/database.json\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#database-resources","title":"Database Resources","text":"<pre><code>db://users/123/profile\ndb://products/category/electronics\ndb://orders/recent?limit=10\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#api-documentation","title":"API Documentation","text":"<pre><code>api://petstore/v1/swagger.json\napi://github/repos/microsoft/vscode/issues\napi://weather/current/london\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#configuration-resources","title":"Configuration Resources","text":"<pre><code>config://app/settings\nconfig://database/connection\nconfig://logging/level\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#uri-design-best-practices","title":"URI Design Best Practices","text":"<ol> <li>Use descriptive paths: <code>users/active</code> vs <code>u/a</code></li> <li>Include identifiers: <code>orders/123</code> vs <code>current-order</code></li> <li>Support hierarchies: <code>docs/api/v1/endpoints</code></li> <li>Use query parameters moderately: Prefer path segments</li> <li>Be consistent: Same patterns for similar resources</li> </ol>"},{"location":"Lab04-MCP-Resources/lab/#implementing-static-resources","title":"Implementing Static Resources","text":"<p>Static resources represent fixed data that doesn\u2019t change or changes infrequently. They\u2019re perfect for documentation, configuration files, and reference data.</p>"},{"location":"Lab04-MCP-Resources/lab/#complete-static-resource-server","title":"Complete Static Resource Server","text":"<p>Here\u2019s a complete MCP server that exposes static resources:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\n/**\n * MCP Server exposing static file resources\n */\nclass StaticResourceServer {\n  private server: Server;\n  private resourceRoot: string;\n\n  constructor(resourceRoot: string = './resources') {\n    this.resourceRoot = path.resolve(resourceRoot);\n\n    this.server = new Server(\n      {\n        name: \"static-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List available resources\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = await this.discoverResources();\n      return { resources };\n    });\n\n    // Read specific resource\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readResource(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async discoverResources(): Promise&lt;any[]&gt; {\n    const resources: any[] = [];\n\n    try {\n      const files = await this.walkDirectory(this.resourceRoot);\n\n      for (const file of files) {\n        const relativePath = path.relative(this.resourceRoot, file);\n        const uri = `file:///${relativePath.replace(/\\\\/g, '/')}`;\n        const mimeType = this.getMimeType(file);\n\n        resources.push({\n          uri,\n          name: path.basename(file),\n          description: `Static file: ${relativePath}`,\n          mimeType,\n        });\n      }\n    } catch (error) {\n      console.error('Error discovering resources:', error);\n    }\n\n    return resources;\n  }\n\n  private async readResource(uri: string): Promise&lt;any&gt; {\n    // Validate URI format\n    if (!uri.startsWith('file:///')) {\n      throw new Error(`Invalid URI format: ${uri}`);\n    }\n\n    const relativePath = uri.substring('file:///'.length);\n    const filePath = path.join(this.resourceRoot, relativePath);\n\n    // Security: Prevent directory traversal\n    const resolvedPath = path.resolve(filePath);\n    if (!resolvedPath.startsWith(this.resourceRoot)) {\n      throw new Error('Access denied: path outside resource root');\n    }\n\n    try {\n      const content = await fs.readFile(filePath, 'utf8');\n      const mimeType = this.getMimeType(filePath);\n\n      return {\n        uri,\n        mimeType,\n        text: content,\n      };\n    } catch (error) {\n      throw new Error(`Failed to read resource: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private async walkDirectory(dir: string): Promise&lt;string[]&gt; {\n    const files: string[] = [];\n\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (entry.isDirectory()) {\n          // Skip hidden directories and node_modules\n          if (!entry.name.startsWith('.') &amp;&amp; entry.name !== 'node_modules') {\n            files.push(...await this.walkDirectory(fullPath));\n          }\n        } else if (entry.isFile()) {\n          // Only include certain file types\n          const ext = path.extname(entry.name).toLowerCase();\n          if (['.md', '.txt', '.json', '.yaml', '.yml', '.js', '.ts', '.css', '.html'].includes(ext)) {\n            files.push(fullPath);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error walking directory ${dir}:`, error);\n    }\n\n    return files;\n  }\n\n  private getMimeType(filePath: string): string {\n    const ext = path.extname(filePath).toLowerCase();\n\n    const mimeTypes: { [key: string]: string } = {\n      '.md': 'text/markdown',\n      '.txt': 'text/plain',\n      '.json': 'application/json',\n      '.yaml': 'application/yaml',\n      '.yml': 'application/yaml',\n      '.js': 'application/javascript',\n      '.ts': 'application/typescript',\n      '.css': 'text/css',\n      '.html': 'text/html',\n    };\n\n    return mimeTypes[ext] || 'text/plain';\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`Static Resource Server running on stdio (root: ${this.resourceRoot})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new StaticResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#testing-static-resources","title":"Testing Static Resources","text":"<p>Step 1: Create Test Resources</p> <p>First, let\u2019s create some test files that our static resource server can expose. These files will simulate a typical project structure with documentation, configuration, and general project files.</p> <pre><code># Create the directory structure\nmkdir -p resources/docs resources/config\n\n# Create a markdown documentation file\necho \"# API Documentation\\n\\nThis is the API docs.\" &gt; resources/docs/api.md\n\n# Create a JSON configuration file\necho '{\"version\": \"1.0.0\", \"env\": \"development\"}' &gt; resources/config/settings.json\n\n# Create a plain text README file\necho \"Welcome to our project!\" &gt; resources/README.txt\n</code></pre> <p>What this creates:</p> <ul> <li><code>resources/docs/api.md</code> - A markdown file with API documentation</li> <li><code>resources/config/settings.json</code> - A JSON configuration file with version and environment info</li> <li><code>resources/README.txt</code> - A plain text file with project information</li> </ul> <p></p> <p>Step 2: Start the Server</p> <p>Now start your MCP server using the MCP Inspector. </p> <p>This will launch both your server and the testing interface:</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>What to expect:</p> <ul> <li>The MCP Inspector window should open in your browser</li> <li>Your server will start and connect via <code>stdio</code> transport</li> <li>You should see connection confirmation in the terminal</li> <li>The inspector interface will show tabs for Resources, Tools, etc.</li> </ul> <p></p> <p>Step 3: Test Resource Discovery</p> <p>In the MCP Inspector, navigate to the Resources tab to see what resources your server is exposing.</p> <ul> <li> <p>The MCP Inspector should show resources like:</p> <ul> <li><code>file:///docs/api.md</code> - Your API documentation file</li> <li><code>file:///config/settings.json</code> - Your configuration file</li> <li><code>file:///README.txt</code> - Your project README</li> </ul> </li> </ul> <p>What to verify:</p> <ul> <li>All three resources should be listed</li> <li>Each resource should have a descriptive name and description</li> <li>MIME types should be correctly detected (text/markdown, application/json, text/plain)</li> <li>URIs should follow the <code>file://</code> scheme with proper paths</li> </ul> <p></p> <p>Step 4: Test Resource Reading</p> <p>Click on each resource in the list to read its content and verify proper handling.</p> <ul> <li> <p>Click on <code>file:///docs/api.md</code>:</p> <ul> <li>Should display: \u201c# API Documentation\\n\\nThis is the API docs.\u201d</li> <li>MIME type should be: text/markdown</li> </ul> </li> <li> <p>Click on <code>file:///config/settings.json</code>:</p> <ul> <li>Should display: {\u201cversion\u201d: \u201c1.0.0\u201d, \u201cenv\u201d: \u201cdevelopment\u201d}</li> <li>MIME type should be: application/json</li> </ul> </li> <li> <p>Click on <code>file:///README.txt</code>:</p> <ul> <li>Should display: \u201cWelcome to our project!\u201d</li> <li>MIME type should be: text/plain</li> </ul> </li> </ul> <p>Error Testing:</p> <ul> <li>Try reading a non-existent resource like <code>file:///does-not-exist.txt</code></li> <li>Should show an appropriate error message</li> <li>Verify the server handles invalid URIs gracefully</li> </ul> <p>What to learn:</p> <ul> <li>Resources provide direct access to file content</li> <li>MIME types help clients handle different content types</li> <li>Error handling is important for robust resource servers</li> <li>The inspector provides a complete testing environment</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#implementing-dynamic-resources","title":"Implementing Dynamic Resources","text":"<p>Dynamic resources generate content on-demand based on parameters or current state. They\u2019re useful for live data, computed views, and parameterized access.</p>"},{"location":"Lab04-MCP-Resources/lab/#resource-templates","title":"Resource Templates","text":"<p>Resource templates allow parameterized URIs using <code>{parameter}</code> syntax:</p> <pre><code>// Template definition\n{\n  uriTemplate: \"db://users/{userId}/profile\",\n  name: \"User Profile\",\n  description: \"Profile data for a specific user\",\n  mimeType: \"application/json\"\n}\n\n// Generated URIs\n\"db://users/123/profile\"\n\"db://users/456/profile\"\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#complete-dynamic-resource-server","title":"Complete Dynamic Resource Server","text":"<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * MCP Server with dynamic resources and templates\n */\nclass DynamicResourceServer {\n  private server: Server;\n\n  // Mock data store\n  private users = [\n    { id: 1, name: \"Alice Johnson\", email: \"alice@example.com\", role: \"admin\" },\n    { id: 2, name: \"Bob Smith\", email: \"bob@example.com\", role: \"user\" },\n    { id: 3, name: \"Charlie Brown\", email: \"charlie@example.com\", role: \"user\" },\n  ];\n\n  private products = [\n    { id: 1, name: \"Laptop\", price: 999.99, category: \"Electronics\" },\n    { id: 2, name: \"Book\", price: 19.99, category: \"Education\" },\n    { id: 3, name: \"Coffee Mug\", price: 12.50, category: \"Kitchen\" },\n  ];\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"dynamic-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List resource templates\n    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () =&gt; {\n      const templates: ResourceTemplate[] = [\n        {\n          uriTemplate: \"db://users/{userId}/profile\",\n          name: \"User Profile\",\n          description: \"Profile information for a specific user\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://products/{productId}/details\",\n          name: \"Product Details\",\n          description: \"Detailed information about a product\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://stats/{category}/summary\",\n          name: \"Category Statistics\",\n          description: \"Statistical summary for a product category\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resourceTemplates: templates };\n    });\n\n    // List available resources (dynamic)\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources: any[] = [];\n\n      // Add user resources\n      for (const user of this.users) {\n        resources.push({\n          uri: `db://users/${user.id}/profile`,\n          name: `User: ${user.name}`,\n          description: `Profile for ${user.name}`,\n          mimeType: \"application/json\",\n        });\n      }\n\n      // Add product resources\n      for (const product of this.products) {\n        resources.push({\n          uri: `db://products/${product.id}/details`,\n          name: `Product: ${product.name}`,\n          description: `${product.category} - $${product.price}`,\n          mimeType: \"application/json\",\n        });\n      }\n\n      // Add category stats\n      const categories = [...new Set(this.products.map(p =&gt; p.category))];\n      for (const category of categories) {\n        resources.push({\n          uri: `db://stats/${category}/summary`,\n          name: `${category} Statistics`,\n          description: `Summary statistics for ${category}`,\n          mimeType: \"application/json\",\n        });\n      }\n\n      return { resources };\n    });\n\n    // Read specific resource\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.generateResourceContent(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async generateResourceContent(uri: string): Promise&lt;any&gt; {\n    const parts = uri.split('/');\n\n    if (parts[0] === 'db:' &amp;&amp; parts[1] === '') {\n      const type = parts[2];\n      const id = parts[3];\n      const action = parts[4];\n\n      switch (type) {\n        case 'users':\n          if (action === 'profile') {\n            const user = this.users.find(u =&gt; u.id === parseInt(id));\n            if (!user) throw new Error(`User ${id} not found`);\n\n            return {\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                user,\n                metadata: {\n                  lastUpdated: new Date().toISOString(),\n                  source: \"dynamic-resource-server\"\n                }\n              }, null, 2),\n            };\n          }\n          break;\n\n        case 'products':\n          if (action === 'details') {\n            const product = this.products.find(p =&gt; p.id === parseInt(id));\n            if (!product) throw new Error(`Product ${id} not found`);\n\n            return {\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify({\n                product,\n                metadata: {\n                  lastUpdated: new Date().toISOString(),\n                  inStock: Math.random() &gt; 0.3 // Simulate stock status\n                }\n              }, null, 2),\n            };\n          }\n          break;\n\n        case 'stats':\n          if (action === 'summary') {\n            const category = id;\n            const categoryProducts = this.products.filter(p =&gt; p.category === category);\n\n            if (categoryProducts.length === 0) {\n              throw new Error(`Category '${category}' not found`);\n            }\n\n            const stats = {\n              category,\n              totalProducts: categoryProducts.length,\n              averagePrice: categoryProducts.reduce((sum, p) =&gt; sum + p.price, 0) / categoryProducts.length,\n              priceRange: {\n                min: Math.min(...categoryProducts.map(p =&gt; p.price)),\n                max: Math.max(...categoryProducts.map(p =&gt; p.price)),\n              },\n              generatedAt: new Date().toISOString(),\n            };\n\n            return {\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify(stats, null, 2),\n            };\n          }\n          break;\n      }\n    }\n\n    throw new Error(`Unknown resource URI: ${uri}`);\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Dynamic Resource Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new DynamicResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#testing-dynamic-resources","title":"Testing Dynamic Resources","text":"<p>Step 1: Start the Server</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>Step 2: Test Resource Templates</p> <ul> <li>Check that templates are listed: <code>db://users/{userId}/profile</code>, etc.</li> </ul> <p>Step 3: Test Resource Discovery</p> <ul> <li>Should show individual resources for users, products, and categories</li> </ul> <p>Step 4: Test Resource Reading</p> <ul> <li>Try <code>db://users/1/profile</code> - should return user data</li> <li>Try <code>db://products/2/details</code> - should return product data</li> <li>Try <code>db://stats/Electronics/summary</code> - should return category stats</li> <li>Test invalid URIs to verify error handling</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#resource-subscriptions-for-live-updates","title":"Resource Subscriptions for Live Updates","text":"<p>Resource subscriptions enable real-time updates when resource content changes. This is essential for live data, monitoring dashboards, and collaborative environments.</p>"},{"location":"Lab04-MCP-Resources/lab/#subscription-implementation","title":"Subscription Implementation","text":"<pre><code>// Enable subscriptions in server capabilities\n{\n  capabilities: {\n    resources: {\n      subscribe: true  // Enable subscription support\n    },\n  },\n}\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#complete-subscription-server","title":"Complete Subscription Server","text":"<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  SubscribeRequestSchema,\n  UnsubscribeRequestSchema,\n  ResourceUpdatedNotificationSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * MCP Server with resource subscriptions for live updates\n */\nclass SubscriptionResourceServer {\n  private server: Server;\n  private subscribers: Map&lt;string, Set&lt;string&gt;&gt; = new Map(); // uri -&gt; sessionIds\n  private updateInterval: NodeJS.Timeout | null = null;\n\n  // Simulated live data\n  private metrics = {\n    activeUsers: 42,\n    serverLoad: 0.65,\n    responseTime: 120,\n    errorRate: 0.02,\n  };\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"subscription-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {\n            subscribe: true,\n          },\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n    this.startMetricsSimulation();\n  }\n\n  private setupHandlers(): void {\n    // List resources\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      return {\n        resources: [\n          {\n            uri: \"metrics://server/active-users\",\n            name: \"Active Users\",\n            description: \"Current number of active users\",\n            mimeType: \"application/json\",\n          },\n          {\n            uri: \"metrics://server/load\",\n            name: \"Server Load\",\n            description: \"Current server load percentage\",\n            mimeType: \"application/json\",\n          },\n          {\n            uri: \"metrics://server/response-time\",\n            name: \"Response Time\",\n            description: \"Average response time in milliseconds\",\n            mimeType: \"application/json\",\n          },\n          {\n            uri: \"metrics://server/error-rate\",\n            name: \"Error Rate\",\n            description: \"Current error rate percentage\",\n            mimeType: \"application/json\",\n          },\n        ],\n      };\n    });\n\n    // Read resource\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = this.getMetricContent(uri);\n      return { contents: [content] };\n    });\n\n    // Subscribe to resource updates\n    this.server.setRequestHandler(SubscribeRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n\n      if (!this.subscribers.has(uri)) {\n        this.subscribers.set(uri, new Set());\n      }\n\n      // In a real implementation, you'd get the session ID from the request\n      // For this example, we'll use a mock session ID\n      const sessionId = \"mock-session\";\n      this.subscribers.get(uri)!.add(sessionId);\n\n      console.error(`Subscribed to ${uri} (session: ${sessionId})`);\n\n      return {};\n    });\n\n    // Unsubscribe from resource updates\n    this.server.setRequestHandler(UnsubscribeRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const sessionId = \"mock-session\"; // Would come from request in real implementation\n\n      if (this.subscribers.has(uri)) {\n        this.subscribers.get(uri)!.delete(sessionId);\n\n        if (this.subscribers.get(uri)!.size === 0) {\n          this.subscribers.delete(uri);\n        }\n      }\n\n      console.error(`Unsubscribed from ${uri} (session: ${sessionId})`);\n\n      return {};\n    });\n  }\n\n  private getMetricContent(uri: string): any {\n    const metricName = uri.split('/').pop();\n\n    if (!metricName || !(metricName in this.metrics)) {\n      throw new Error(`Unknown metric: ${metricName}`);\n    }\n\n    const value = (this.metrics as any)[metricName];\n\n    return {\n      uri,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        metric: metricName,\n        value,\n        timestamp: new Date().toISOString(),\n        unit: this.getMetricUnit(metricName),\n      }, null, 2),\n    };\n  }\n\n  private getMetricUnit(metricName: string): string {\n    const units: { [key: string]: string } = {\n      activeUsers: \"users\",\n      serverLoad: \"percentage\",\n      responseTime: \"milliseconds\",\n      errorRate: \"percentage\",\n    };\n    return units[metricName] || \"unit\";\n  }\n\n  private startMetricsSimulation(): void {\n    // Simulate changing metrics every 5 seconds\n    this.updateInterval = setInterval(() =&gt; {\n      // Randomly update metrics\n      this.metrics.activeUsers += Math.floor(Math.random() * 10) - 5;\n      this.metrics.activeUsers = Math.max(0, this.metrics.activeUsers);\n\n      this.metrics.serverLoad = Math.random() * 0.5 + 0.3; // 0.3 to 0.8\n      this.metrics.responseTime = 100 + Math.random() * 100; // 100-200ms\n      this.metrics.errorRate = Math.random() * 0.05; // 0-5%\n\n      // Notify subscribers of updates\n      this.notifySubscribers();\n    }, 5000);\n  }\n\n  private notifySubscribers(): void {\n    for (const [uri, sessionIds] of this.subscribers) {\n      if (sessionIds.size &gt; 0) {\n        // Send notification to all subscribers of this resource\n        this.server.notification(ResourceUpdatedNotificationSchema, {\n          uri,\n        });\n\n        console.error(`Notified ${sessionIds.size} subscribers of ${uri} update`);\n      }\n    }\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      if (this.updateInterval) {\n        clearInterval(this.updateInterval);\n      }\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Subscription Resource Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new SubscriptionResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#testing-subscriptions","title":"Testing Subscriptions","text":"<p>Step 1: Start the Server</p> <pre><code>npx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre> <p>Step 2: Test Basic Resource Reading</p> <ul> <li>Read metrics like <code>metrics://server/active-users</code></li> <li>Verify they return current values</li> </ul> <p>Step 3: Test Subscriptions</p> <ul> <li> <p>Subscribe to a metric resource:</p> <ul> <li>In the MCP Inspector Resources tab, find a metric resource (e.g., <code>metrics://server/active-users</code>)</li> <li>Click the \u201cSubscribe\u201d button next to the resource</li> <li>You should see a confirmation that subscription was successful</li> </ul> </li> <li> <p>Watch the MCP Inspector for update notifications every 5 seconds:</p> <ul> <li>Keep the Resources tab open</li> <li>Look for notification messages in the inspector interface</li> <li>The metric values should update automatically every 5 seconds</li> <li>You can also check the console/logs for subscription update messages</li> </ul> </li> <li> <p>Unsubscribe and verify notifications stop:</p> <ul> <li>Click the \u201cUnsubscribe\u201d button for the same resource</li> <li>Confirm that update notifications cease</li> <li>The metric values should stop updating in the interface</li> </ul> </li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#security-and-access-control","title":"Security and Access Control","text":"<p>Resource security is critical, especially when exposing sensitive data or system information.</p>"},{"location":"Lab04-MCP-Resources/lab/#access-control-patterns","title":"Access Control Patterns","text":""},{"location":"Lab04-MCP-Resources/lab/#1-path-based-authorization","title":"1. Path-Based Authorization","text":"<pre><code>private checkResourceAccess(uri: string, userId?: string): boolean {\n  // Allow access to own profile\n  if (uri.startsWith(`users/${userId}/`)) {\n    return true;\n  }\n\n  // Restrict admin resources\n  if (uri.startsWith('admin/') &amp;&amp; !this.isAdmin(userId)) {\n    return false;\n  }\n\n  // Public resources\n  if (uri.startsWith('public/')) {\n    return true;\n  }\n\n  return false;\n}\n</code></pre> <p>How it works: This method checks if a user has permission to access a resource based on the URI path. It grants access to user-specific resources (like their own profile), restricts admin-only resources unless the user has admin privileges, allows public resources for everyone, and denies access by default for any other paths.</p> <p></p>"},{"location":"Lab04-MCP-Resources/lab/#2-content-filtering","title":"2. Content Filtering","text":"<pre><code>private filterSensitiveContent(content: any, userRole: string): any {\n  if (userRole !== 'admin') {\n    // Remove sensitive fields for non-admin users\n    const { password, ssn, ...filtered } = content;\n    return filtered;\n  }\n  return content;\n}\n</code></pre> <p>How it works: This function removes sensitive information from resource content based on user roles. For non-admin users, it uses object destructuring to exclude sensitive fields like passwords and social security numbers, returning a filtered version of the data. Admin users see the complete, unfiltered content.</p> <p></p>"},{"location":"Lab04-MCP-Resources/lab/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code>private rateLimiter = new Map&lt;string, { count: number; resetTime: number }&gt;();\n\nprivate checkRateLimit(identifier: string, maxRequests: number = 100): boolean {\n  const now = Date.now();\n  const windowMs = 60000; // 1 minute\n\n  const record = this.rateLimiter.get(identifier);\n\n  if (!record || now &gt; record.resetTime) {\n    this.rateLimiter.set(identifier, { count: 1, resetTime: now + windowMs });\n    return true;\n  }\n\n  if (record.count &gt;= maxRequests) {\n    return false;\n  }\n\n  record.count++;\n  return true;\n}\n</code></pre> <p>How it works: This implements a sliding window rate limiter using a Map to track request counts per identifier (like user ID or IP address). It allows up to <code>maxRequests</code> (default 100) within a 1-minute window. When the limit is exceeded, it returns false to block the request. The window resets automatically after the time period expires.</p>"},{"location":"Lab04-MCP-Resources/lab/#combining-resources-with-tools","title":"Combining Resources with Tools","text":"<p>The most powerful MCP servers combine resources and tools to provide a comprehensive functionality!</p>"},{"location":"Lab04-MCP-Resources/lab/#complete-hybrid-server","title":"Complete Hybrid Server","text":"<p>The following example demonstrates a server that combines both resources and tools, showing how they work together to provide comprehensive functionality. </p> <p>The server maintains a document store that can be both read as resources and modified through tools.</p> Hybrid Server Class<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListToolsRequestSchema,\n  CallToolRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * MCP Server combining resources and tools\n */\nclass HybridServer {\n  private server: Server;\n  private documents: Map&lt;string, any&gt; = new Map();\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"hybrid-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},  // Enable resource capabilities\n          tools: {},      // Enable tool capabilities\n        },\n      }\n    );\n\n    // Initialize some sample documents\n    this.documents.set(\"doc1\", {\n      id: \"doc1\",\n      title: \"Getting Started Guide\",\n      content: \"This is a comprehensive guide to getting started...\",\n      tags: [\"tutorial\", \"beginner\"],\n      created: new Date().toISOString(),\n    });\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n</code></pre> <p>Key setup points:</p> <ul> <li>The server declares both <code>resources: {}</code> and <code>tools: {}</code> capabilities</li> <li>A Map is used to store documents in memory</li> <li>Sample data is initialized to demonstrate functionality</li> </ul> <p></p> Setup Handlers Method<pre><code>  private setupHandlers(): void {\n    // Resource handlers - provide read-only access to documents\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = Array.from(this.documents.entries()).map(([id, doc]) =&gt; ({\n        uri: `docs://documents/${id}`,\n        name: doc.title,\n        description: `Document: ${doc.title}`,\n        mimeType: \"application/json\",\n      }));\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = this.readDocument(uri);\n      return { contents: [content] };\n    });\n\n    // Tool handlers - provide write operations for documents\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"create_document\",\n            description: \"Create a new document\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                title: { type: \"string\" },\n                content: { type: \"string\" },\n                tags: {\n                  type: \"array\",\n                  items: { type: \"string\" },\n                  default: [],\n                },\n              },\n              required: [\"title\", \"content\"],\n            },\n          },\n          {\n            name: \"search_documents\",\n            description: \"Search documents by content or tags\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                query: { type: \"string\" },\n                tag: { type: \"string\" },\n                limit: { type: \"number\", default: 10 },\n              },\n            },\n          },\n          {\n            name: \"update_document\",\n            description: \"Update an existing document\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                id: { type: \"string\" },\n                title: { type: \"string\" },\n                content: { type: \"string\" },\n                tags: { type: \"array\", items: { type: \"string\" } },\n              },\n              required: [\"id\"],\n            },\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"create_document\":\n          return this.createDocument(args);\n\n        case \"search_documents\":\n          return this.searchDocuments(args);\n\n        case \"update_document\":\n          return this.updateDocument(args);\n\n        default:\n          throw new Error(`Unknown tool: ${name}`);\n      }\n    });\n  }\n</code></pre> <p>Resource vs Tool handlers:</p> <ul> <li>Resources expose existing documents for reading (<code>docs://documents/{id}</code>)</li> <li>Tools provide operations to create, search, and update documents</li> <li>Resources are passive (read-only), tools are active (perform actions)</li> </ul> <p></p> Read Document Method<pre><code>  private readDocument(uri: string): any {\n    const match = uri.match(/^docs:\\/\\/documents\\/(.+)$/);\n    if (!match) throw new Error(`Invalid document URI: ${uri}`);\n\n    const id = match[1];\n    const doc = this.documents.get(id);\n\n    if (!doc) throw new Error(`Document not found: ${id}`);\n\n    return {\n      uri,\n      mimeType: \"application/json\",\n      text: JSON.stringify(doc, null, 2),\n    };\n  }\n</code></pre> <p>Resource reading: Parses the URI to extract the document ID, retrieves the document from the Map, and returns it as JSON content.</p> <p></p> Create Document Method<pre><code>  private createDocument(args: any): any {\n    const id = `doc${Date.now()}`;\n    const doc = {\n      id,\n      title: args.title,\n      content: args.content,\n      tags: args.tags || [],\n      created: new Date().toISOString(),\n      modified: new Date().toISOString(),\n    };\n\n    this.documents.set(id, doc);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Document created successfully!\\n\\nID: ${id}\\nTitle: ${doc.title}\\nURI: docs://documents/${id}`,\n        },\n      ],\n    };\n  }\n</code></pre> <p>Tool implementation: Creates a new document with a timestamp-based ID, stores it in the Map, and returns success information including the new document\u2019s URI.</p> <p></p> Search Documents Method<pre><code>  private searchDocuments(args: any): any {\n    let results = Array.from(this.documents.values());\n\n    if (args.query) {\n      const query = args.query.toLowerCase();\n      results = results.filter(doc =&gt;\n        doc.title.toLowerCase().includes(query) ||\n        doc.content.toLowerCase().includes(query)\n      );\n    }\n\n    if (args.tag) {\n      results = results.filter(doc =&gt; doc.tags.includes(args.tag));\n    }\n\n    const limit = args.limit || 10;\n    results = results.slice(0, limit);\n\n    const formatted = results.map(doc =&gt; ({\n      id: doc.id,\n      title: doc.title,\n      tags: doc.tags,\n      uri: `docs://documents/${doc.id}`,\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Found ${results.length} documents:\\n\\n${formatted.map(doc =&gt;\n            `\ud83d\udcc4 ${doc.title} (${doc.tags.join(', ')})\\n   URI: ${doc.uri}`\n          ).join('\\n\\n')}`,\n        },\n      ],\n    };\n  }\n</code></pre> <p>Search tool: Filters documents by query string or tag, limits results, and returns formatted text output with document URIs for easy access.</p> <p></p> Update Document Method<pre><code>  private updateDocument(args: any): any {\n    const doc = this.documents.get(args.id);\n    if (!doc) throw new Error(`Document not found: ${args.id}`);\n\n    if (args.title) doc.title = args.title;\n    if (args.content) doc.content = args.content;\n    if (args.tags) doc.tags = args.tags;\n    doc.modified = new Date().toISOString();\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Document updated successfully!\\n\\nID: ${doc.id}\\nTitle: ${doc.title}\\nModified: ${doc.modified}`,\n        },\n      ],\n    };\n  }\n</code></pre> <p>Update tool: Modifies existing document fields and updates the modification timestamp, providing feedback about the changes made.</p> <p></p> <p>How resources and tools complement each other:</p> <ul> <li>Resources provide passive access: LLMs can read documents at <code>docs://documents/{id}</code></li> <li>Tools enable active operations: LLMs can create, search, and update documents</li> <li>Integration: Tools can reference resources in their responses (e.g., \u201cRead the new document at docs://documents/123\u201d)</li> <li>Workflow: Create documents with tools, then read them as resources for context</li> </ul>"},{"location":"Lab04-MCP-Resources/lab/#hands-on-exercises","title":"Hands-On Exercises","text":""},{"location":"Lab04-MCP-Resources/lab/#exercise-1-file-system-resource-server","title":"Exercise 1: File System Resource Server","text":"<p>Create a tool that:</p> <ul> <li>Exposes a directory as MCP resources</li> <li>Supports different file types (text, JSON, Markdown)</li> <li>Implements proper security (no directory traversal)</li> <li>Includes file metadata (size, modified date)</li> </ul> \ud83d\udca1 Solution: File System Resource Server  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"create_file_resource_server\",\n  description: \"Create an MCP server that exposes a directory as resources\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      directory: {\n        type: \"string\",\n        description: \"Directory path to expose as resources\",\n        default: \"./files\"\n      },\n      allowedExtensions: {\n        type: \"array\",\n        description: \"File extensions to include\",\n        items: { type: \"string\" },\n        default: [\".md\", \".txt\", \".json\", \".yaml\", \".yml\"]\n      },\n      maxFileSize: {\n        type: \"number\",\n        description: \"Maximum file size in bytes\",\n        default: 1048576\n      }\n    },\n    required: [\"directory\"]\n  }\n}\n</code></pre>  Implementation:  <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nclass FileSystemResourceServer {\n  private server: Server;\n  private rootDir: string;\n  private allowedExtensions: string[];\n  private maxFileSize: number;\n\n  constructor(rootDir: string = './files', allowedExtensions: string[] = ['.md', '.txt', '.json', '.yaml', '.yml'], maxFileSize: number = 1048576) {\n    this.rootDir = path.resolve(rootDir);\n    this.allowedExtensions = allowedExtensions;\n    this.maxFileSize = maxFileSize;\n\n    this.server = new Server(\n      {\n        name: \"filesystem-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = await this.discoverFiles();\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readFile(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async discoverFiles(): Promise&lt;any[]&gt; {\n    const resources: any[] = [];\n\n    try {\n      const files = await this.walkDirectory(this.rootDir);\n\n      for (const file of files) {\n        const relativePath = path.relative(this.rootDir, file);\n        const uri = `file:///${relativePath.replace(/\\\\/g, '/')}`;\n        const stats = await fs.stat(file);\n        const mimeType = this.getMimeType(file);\n\n        resources.push({\n          uri,\n          name: path.basename(file),\n          description: `File: ${relativePath} (${this.formatFileSize(stats.size)})`,\n          mimeType,\n        });\n      }\n    } catch (error) {\n      console.error('Error discovering files:', error);\n    }\n\n    return resources;\n  }\n\n  private async readFile(uri: string): Promise&lt;any&gt; {\n    if (!uri.startsWith('file:///')) {\n      throw new Error(`Invalid URI format: ${uri}`);\n    }\n\n    const relativePath = uri.substring('file:///'.length);\n    const filePath = path.join(this.rootDir, relativePath);\n\n    // Security: Prevent directory traversal\n    const resolvedPath = path.resolve(filePath);\n    if (!resolvedPath.startsWith(this.rootDir)) {\n      throw new Error('Access denied: path outside allowed directory');\n    }\n\n    // Check if file extension is allowed\n    const ext = path.extname(filePath).toLowerCase();\n    if (!this.allowedExtensions.includes(ext)) {\n      throw new Error(`File type not allowed: ${ext}`);\n    }\n\n    try {\n      const stats = await fs.stat(filePath);\n\n      // Check file size\n      if (stats.size &gt; this.maxFileSize) {\n        throw new Error(`File too large: ${stats.size} bytes (max: ${this.maxFileSize})`);\n      }\n\n      const content = await fs.readFile(filePath, 'utf8');\n      const mimeType = this.getMimeType(filePath);\n\n      return {\n        uri,\n        mimeType,\n        text: content,\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private async walkDirectory(dir: string): Promise&lt;string[]&gt; {\n    const files: string[] = [];\n\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (entry.isDirectory()) {\n          // Skip hidden directories\n          if (!entry.name.startsWith('.')) {\n            files.push(...await this.walkDirectory(fullPath));\n          }\n        } else if (entry.isFile()) {\n          const ext = path.extname(entry.name).toLowerCase();\n          if (this.allowedExtensions.includes(ext)) {\n            files.push(fullPath);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error walking directory ${dir}:`, error);\n    }\n\n    return files;\n  }\n\n  private getMimeType(filePath: string): string {\n    const ext = path.extname(filePath).toLowerCase();\n    const mimeTypes: { [key: string]: string } = {\n      '.md': 'text/markdown',\n      '.txt': 'text/plain',\n      '.json': 'application/json',\n      '.yaml': 'application/yaml',\n      '.yml': 'application/yaml',\n    };\n    return mimeTypes[ext] || 'text/plain';\n  }\n\n  private formatFileSize(bytes: number): string {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n\n    while (size &gt;= 1024 &amp;&amp; unitIndex &lt; units.length - 1) {\n      size /= 1024;\n      unitIndex++;\n    }\n\n    return `${size.toFixed(1)} ${units[unitIndex]}`;\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`File System Resource Server running (root: ${this.rootDir})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new FileSystemResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>  Testing - Create test files and test the server:  <pre><code>mkdir -p files/docs files/data\necho \"# API Documentation\" &gt; files/docs/api.md\necho '{\"version\": \"1.0.0\"}' &gt; files/data/config.json\necho \"Simple text file\" &gt; files/docs/notes.txt\n</code></pre>  Test with MCP Inspector to verify file discovery and reading."},{"location":"Lab04-MCP-Resources/lab/#exercise-2-rest-api-resource-server","title":"Exercise 2: REST API Resource Server","text":"<p>Create a tool that:</p> <ul> <li>Exposes REST API endpoints as resources</li> <li>Supports query parameters in URIs</li> <li>Handles authentication and rate limiting</li> <li>Caches responses appropriately</li> </ul> \ud83d\udca1 Solution: REST API Resource Server  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"create_api_resource_server\",\n  description: \"Create an MCP server that exposes REST API endpoints as resources\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      baseUrl: {\n        type: \"string\",\n        description: \"Base URL of the API to expose\",\n        format: \"uri\"\n      },\n      apiKey: {\n        type: \"string\",\n        description: \"API key for authentication\"\n      },\n      cacheEnabled: {\n        type: \"boolean\",\n        description: \"Enable response caching\",\n        default: true\n      },\n      cacheTTL: {\n        type: \"number\",\n        description: \"Cache TTL in seconds\",\n        default: 300\n      },\n      rateLimit: {\n        type: \"number\",\n        description: \"Requests per minute limit\",\n        default: 60\n      }\n    },\n    required: [\"baseUrl\"]\n  }\n}\n</code></pre>  Implementation  <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport axios, { AxiosResponse } from 'axios';\n\ninterface CacheEntry {\n  data: any;\n  timestamp: number;\n  ttl: number;\n}\n\nclass APIResourceServer {\n  private server: Server;\n  private baseUrl: string;\n  private apiKey?: string;\n  private cache: Map&lt;string, CacheEntry&gt; = new Map();\n  private cacheEnabled: boolean;\n  private cacheTTL: number;\n  private rateLimit: number;\n  private requestCounts: Map&lt;string, { count: number; resetTime: number }&gt; = new Map();\n\n  constructor(baseUrl: string, apiKey?: string, cacheEnabled: boolean = true, cacheTTL: number = 300, rateLimit: number = 60) {\n    this.baseUrl = baseUrl.replace(/\\/$/, ''); // Remove trailing slash\n    this.apiKey = apiKey;\n    this.cacheEnabled = cacheEnabled;\n    this.cacheTTL = cacheTTL;\n    this.rateLimit = rateLimit;\n\n    this.server = new Server(\n      {\n        name: \"api-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n    this.startCacheCleanup();\n  }\n\n  private setupHandlers(): void {\n    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () =&gt; {\n      const templates: ResourceTemplate[] = [\n        {\n          uriTemplate: \"api://users/{userId}\",\n          name: \"User Profile\",\n          description: \"User profile data from API\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"api://posts/{postId}\",\n          name: \"Post Details\",\n          description: \"Post details from API\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"api://search?q={query}&amp;type={type}\",\n          name: \"Search Results\",\n          description: \"Search API results\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resourceTemplates: templates };\n    });\n\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      // For demonstration, we'll provide some example resources\n      // In a real implementation, you might fetch these from the API\n      const resources = [\n        {\n          uri: \"api://status\",\n          name: \"API Status\",\n          description: \"Current API status and health\",\n          mimeType: \"application/json\",\n        },\n        {\n          uri: \"api://info\",\n          name: \"API Information\",\n          description: \"API metadata and capabilities\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.fetchAPIResource(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async fetchAPIResource(uri: string): Promise&lt;any&gt; {\n    // Check rate limit\n    if (!this.checkRateLimit()) {\n      throw new Error(\"Rate limit exceeded. Please try again later.\");\n    }\n\n    // Check cache first\n    if (this.cacheEnabled) {\n      const cached = this.getCached(uri);\n      if (cached) {\n        return {\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify({\n            ...cached,\n            cached: true,\n            cacheAge: Math.floor((Date.now() - cached._cacheTimestamp) / 1000),\n          }, null, 2),\n        };\n      }\n    }\n\n    try {\n      const apiPath = this.uriToAPIPath(uri);\n      const url = `${this.baseUrl}${apiPath}`;\n\n      const headers: any = {\n        'User-Agent': 'MCP-API-Resource-Server/1.0',\n      };\n\n      if (this.apiKey) {\n        headers['Authorization'] = `Bearer ${this.apiKey}`;\n        // Or: headers['X-API-Key'] = this.apiKey;\n      }\n\n      const response: AxiosResponse = await axios.get(url, {\n        headers,\n        timeout: 10000,\n      });\n\n      const data = {\n        ...response.data,\n        _metadata: {\n          statusCode: response.status,\n          url: url,\n          fetchedAt: new Date().toISOString(),\n          contentType: response.headers['content-type'],\n        }\n      };\n\n      // Cache the response\n      if (this.cacheEnabled) {\n        this.setCache(uri, data);\n      }\n\n      return {\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(data, null, 2),\n      };\n\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        if (error.response) {\n          throw new Error(`API Error ${error.response.status}: ${error.response.statusText}`);\n        } else if (error.code === 'ECONNREFUSED') {\n          throw new Error(`Cannot connect to API: ${this.baseUrl}`);\n        } else {\n          throw new Error(`Network error: ${error.message}`);\n        }\n      } else {\n        throw new Error(`Failed to fetch API resource: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      }\n    }\n  }\n\n  private uriToAPIPath(uri: string): string {\n    if (!uri.startsWith('api://')) {\n      throw new Error(`Invalid API URI: ${uri}`);\n    }\n\n    const path = uri.substring('api://'.length);\n\n    // Handle special cases\n    if (path === 'status') return '/status';\n    if (path === 'info') return '/info';\n\n    // Handle template URIs\n    if (path.startsWith('users/')) {\n      const userId = path.substring('users/'.length);\n      return `/users/${userId}`;\n    }\n\n    if (path.startsWith('posts/')) {\n      const postId = path.substring('posts/'.length);\n      return `/posts/${postId}`;\n    }\n\n    if (path.startsWith('search?')) {\n      // Convert query parameters\n      const queryString = path.substring('search?'.length);\n      return `/search?${queryString}`;\n    }\n\n    // Default: use path as-is\n    return `/${path}`;\n  }\n\n  private checkRateLimit(): boolean {\n    const now = Date.now();\n    const windowMs = 60000; // 1 minute\n    const key = 'global'; // In a real app, use user/session ID\n\n    const record = this.requestCounts.get(key);\n\n    if (!record || now &gt; record.resetTime) {\n      this.requestCounts.set(key, { count: 1, resetTime: now + windowMs });\n      return true;\n    }\n\n    if (record.count &gt;= this.rateLimit) {\n      return false;\n    }\n\n    record.count++;\n    return true;\n  }\n\n  private getCached(uri: string): any | null {\n    const cached = this.cache.get(uri);\n    if (!cached) return null;\n\n    if (Date.now() - cached.timestamp &gt; cached.ttl * 1000) {\n      this.cache.delete(uri);\n      return null;\n    }\n\n    return cached.data;\n  }\n\n  private setCache(uri: string, data: any): void {\n    this.cache.set(uri, {\n      data: { ...data, _cacheTimestamp: Date.now() },\n      timestamp: Date.now(),\n      ttl: this.cacheTTL,\n    });\n  }\n\n  private startCacheCleanup(): void {\n    // Clean up expired cache entries every 5 minutes\n    setInterval(() =&gt; {\n      const now = Date.now();\n      for (const [uri, entry] of this.cache.entries()) {\n        if (now - entry.timestamp &gt; entry.ttl * 1000) {\n          this.cache.delete(uri);\n        }\n      }\n    }, 5 * 60 * 1000);\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`API Resource Server running (API: ${this.baseUrl})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  // Example: JSONPlaceholder API\n  const server = new APIResourceServer('https://jsonplaceholder.typicode.com');\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>  Testing - Test the server with the JSONPlaceholder API:  <pre><code># Start the server\nnpx @modelcontextprotocol/inspector tsx src/index.ts\n</code></pre>  Test these resources in the MCP Inspector:  <pre><code>// API status\n{ uri: \"api://status\" }\n\n// API info\n{ uri: \"api://info\" }\n\n// User profiles (using templates)\n{ uri: \"api://users/1\" }\n{ uri: \"api://users/2\" }\n\n// Posts\n{ uri: \"api://posts/1\" }\n\n// Search (if supported by API)\n{ uri: \"api://search?q=lorem&amp;type=post\" }\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#exercise-3-database-resource-server","title":"Exercise 3: Database Resource Server","text":"<p>Create a tool that:</p> <ul> <li>Exposes database tables as resources</li> <li>Supports parameterized queries via URI templates</li> <li>Implements read-only access for security</li> <li>Provides metadata about table schemas</li> </ul> \ud83d\udca1 Solution: Database Resource Server  Tool Schema - Add this to your tools array:  <pre><code>{\n  name: \"create_database_resource_server\",\n  description: \"Create an MCP server that exposes database tables as resources\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      databasePath: {\n        type: \"string\",\n        description: \"Path to SQLite database file\",\n        default: \"./data.db\"\n      },\n      allowedTables: {\n        type: \"array\",\n        description: \"Tables to expose as resources\",\n        items: { type: \"string\" },\n        default: []\n      },\n      readOnly: {\n        type: \"boolean\",\n        description: \"Enforce read-only access\",\n        default: true\n      },\n      maxRows: {\n        type: \"number\",\n        description: \"Maximum rows to return per query\",\n        default: 1000\n      }\n    },\n    required: [\"databasePath\"]\n  }\n}\n</code></pre>  Implementation  <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport Database from 'better-sqlite3';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\ninterface TableInfo {\n  name: string;\n  columns: Array&lt;{\n    name: string;\n    type: string;\n    notnull: number;\n    pk: number;\n  }&gt;;\n  rowCount: number;\n}\n\nclass DatabaseResourceServer {\n  private server: Server;\n  private dbPath: string;\n  private allowedTables: string[];\n  private readOnly: boolean;\n  private maxRows: number;\n  private db: Database.Database | null = null;\n\n  constructor(dbPath: string = './data.db', allowedTables: string[] = [], readOnly: boolean = true, maxRows: number = 1000) {\n    this.dbPath = path.resolve(dbPath);\n    this.allowedTables = allowedTables;\n    this.readOnly = readOnly;\n    this.maxRows = maxRows;\n\n    this.server = new Server(\n      {\n        name: \"database-resource-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () =&gt; {\n      const templates: ResourceTemplate[] = [\n        {\n          uriTemplate: \"db://tables/{tableName}/schema\",\n          name: \"Table Schema\",\n          description: \"Schema information for a database table\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://tables/{tableName}/data?limit={limit}&amp;offset={offset}\",\n          name: \"Table Data\",\n          description: \"Data from a database table with pagination\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://tables/{tableName}/records/{id}\",\n          name: \"Table Record\",\n          description: \"Specific record from a database table\",\n          mimeType: \"application/json\",\n        },\n        {\n          uriTemplate: \"db://query?sql={sql}&amp;params={params}\",\n          name: \"Custom Query\",\n          description: \"Execute a custom SELECT query\",\n          mimeType: \"application/json\",\n        },\n      ];\n\n      return { resourceTemplates: templates };\n    });\n\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources: any[] = [];\n\n      try {\n        await this.ensureDatabase();\n        const tables = this.getTableInfo();\n\n        for (const table of tables) {\n          // Table schema resource\n          resources.push({\n            uri: `db://tables/${table.name}/schema`,\n            name: `${table.name} Schema`,\n            description: `Schema for table ${table.name} (${table.columns.length} columns)`,\n            mimeType: \"application/json\",\n          });\n\n          // Table data resource\n          resources.push({\n            uri: `db://tables/${table.name}/data?limit=100`,\n            name: `${table.name} Data`,\n            description: `Data from table ${table.name} (${table.rowCount} rows)`,\n            mimeType: \"application/json\",\n          });\n        }\n\n        // Database info resource\n        resources.push({\n          uri: \"db://info\",\n          name: \"Database Info\",\n          description: \"Database metadata and statistics\",\n          mimeType: \"application/json\",\n        });\n\n      } catch (error) {\n        console.error('Error listing resources:', error);\n      }\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readDatabaseResource(uri);\n      return { contents: [content] };\n    });\n  }\n\n  private async ensureDatabase(): Promise&lt;void&gt; {\n    if (this.db) return;\n\n    // Check if database file exists\n    try {\n      await fs.access(this.dbPath, fs.constants.R_OK);\n    } catch {\n      throw new Error(`Database file not found: ${this.dbPath}`);\n    }\n\n    // Open database in read-only mode if specified\n    this.db = new Database(this.dbPath, { readonly: this.readOnly });\n  }\n\n  private getTableInfo(): TableInfo[] {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tables: TableInfo[] = [];\n\n    // Get all tables\n    const tableNames = this.db.prepare(`\n      SELECT name FROM sqlite_master \n      WHERE type='table' AND name NOT LIKE 'sqlite_%'\n    `).all() as Array&lt;{ name: string }&gt;;\n\n    for (const { name } of tableNames) {\n      // Check if table is allowed\n      if (this.allowedTables.length &gt; 0 &amp;&amp; !this.allowedTables.includes(name)) {\n        continue;\n      }\n\n      // Get column info\n      const columns = this.db.prepare(`PRAGMA table_info(${name})`).all() as any[];\n\n      // Get row count\n      const rowCount = (this.db.prepare(`SELECT COUNT(*) as count FROM ${name}`).get() as any).count;\n\n      tables.push({\n        name,\n        columns: columns.map(col =&gt; ({\n          name: col.name,\n          type: col.type,\n          notnull: col.notnull,\n          pk: col.pk,\n        })),\n        rowCount,\n      });\n    }\n\n    return tables;\n  }\n\n  private async readDatabaseResource(uri: string): Promise&lt;any&gt; {\n    await this.ensureDatabase();\n\n    if (!uri.startsWith('db://')) {\n      throw new Error(`Invalid database URI: ${uri}`);\n    }\n\n    const path = uri.substring('db://'.length);\n\n    if (path === 'info') {\n      return this.getDatabaseInfo();\n    }\n\n    if (path.startsWith('tables/')) {\n      return this.readTableResource(path.substring('tables/'.length));\n    }\n\n    if (path.startsWith('query?')) {\n      return this.executeCustomQuery(path.substring('query?'.length));\n    }\n\n    throw new Error(`Unknown database resource: ${uri}`);\n  }\n\n  private getDatabaseInfo(): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tables = this.getTableInfo();\n    const dbStats = this.db.prepare(`\n      SELECT \n        COUNT(*) as tableCount,\n        SUM(\n          (SELECT COUNT(*) FROM sqlite_master WHERE type='index') +\n          (SELECT COUNT(*) FROM pragma_table_info(name))\n        ) as totalColumns\n      FROM sqlite_master \n      WHERE type='table' AND name NOT LIKE 'sqlite_%'\n    `).get() as any;\n\n    return {\n      uri: \"db://info\",\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        database: {\n          path: this.dbPath,\n          readOnly: this.readOnly,\n          tableCount: dbStats.tableCount,\n          totalColumns: dbStats.totalColumns,\n        },\n        tables: tables.map(t =&gt; ({\n          name: t.name,\n          columns: t.columns.length,\n          rows: t.rowCount,\n          primaryKey: t.columns.find(c =&gt; c.pk)?.name,\n        })),\n        server: {\n          maxRows: this.maxRows,\n          allowedTables: this.allowedTables.length &gt; 0 ? this.allowedTables : 'all',\n        },\n      }, null, 2),\n    };\n  }\n\n  private readTableResource(tablePath: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const parts = tablePath.split('/');\n    const tableName = parts[0];\n    const action = parts[1];\n\n    // Validate table access\n    if (this.allowedTables.length &gt; 0 &amp;&amp; !this.allowedTables.includes(tableName)) {\n      throw new Error(`Access denied to table: ${tableName}`);\n    }\n\n    switch (action) {\n      case 'schema':\n        return this.getTableSchema(tableName);\n\n      case 'data':\n        const url = new URL(`db://tables/${tablePath}`);\n        const limit = parseInt(url.searchParams.get('limit') || '100');\n        const offset = parseInt(url.searchParams.get('offset') || '0');\n        return this.getTableData(tableName, limit, offset);\n\n      case 'records':\n        const recordId = parts[2];\n        return this.getTableRecord(tableName, recordId);\n\n      default:\n        throw new Error(`Unknown table action: ${action}`);\n    }\n  }\n\n  private getTableSchema(tableName: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const tables = this.getTableInfo();\n    const table = tables.find(t =&gt; t.name === tableName);\n\n    if (!table) {\n      throw new Error(`Table not found: ${tableName}`);\n    }\n\n    return {\n      uri: `db://tables/${tableName}/schema`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        table: tableName,\n        columns: table.columns,\n        rowCount: table.rowCount,\n        indexes: this.getTableIndexes(tableName),\n      }, null, 2),\n    };\n  }\n\n  private getTableData(tableName: string, limit: number, offset: number): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    // Validate limits\n    const actualLimit = Math.min(limit, this.maxRows);\n    const actualOffset = Math.max(0, offset);\n\n    const query = `SELECT * FROM ${tableName} LIMIT ? OFFSET ?`;\n    const rows = this.db.prepare(query).all(actualLimit, actualOffset) as any[];\n\n    return {\n      uri: `db://tables/${tableName}/data?limit=${actualLimit}&amp;offset=${actualOffset}`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        table: tableName,\n        query: {\n          limit: actualLimit,\n          offset: actualOffset,\n          totalRows: rows.length,\n        },\n        data: rows,\n      }, null, 2),\n    };\n  }\n\n  private getTableRecord(tableName: string, recordId: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    // Get primary key column\n    const columns = this.db.prepare(`PRAGMA table_info(${tableName})`).all() as any[];\n    const pkColumn = columns.find(col =&gt; col.pk === 1);\n\n    if (!pkColumn) {\n      throw new Error(`No primary key found for table: ${tableName}`);\n    }\n\n    const query = `SELECT * FROM ${tableName} WHERE ${pkColumn.name} = ?`;\n    const row = this.db.prepare(query).get(recordId);\n\n    if (!row) {\n      throw new Error(`Record not found: ${tableName}.${pkColumn.name} = ${recordId}`);\n    }\n\n    return {\n      uri: `db://tables/${tableName}/records/${recordId}`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        table: tableName,\n        primaryKey: {\n          column: pkColumn.name,\n          value: recordId,\n        },\n        data: row,\n      }, null, 2),\n    };\n  }\n\n  private executeCustomQuery(queryString: string): any {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const url = new URL(`db://query?${queryString}`);\n    const sql = url.searchParams.get('sql');\n    const params = url.searchParams.get('params');\n\n    if (!sql) {\n      throw new Error('SQL parameter required for custom query');\n    }\n\n    // Security: Only allow SELECT queries\n    if (!sql.trim().toUpperCase().startsWith('SELECT')) {\n      throw new Error('Only SELECT queries are allowed for security');\n    }\n\n    let queryParams: any[] = [];\n    if (params) {\n      try {\n        queryParams = JSON.parse(params);\n      } catch {\n        throw new Error('Invalid params JSON');\n      }\n    }\n\n    const stmt = this.db.prepare(sql + ' LIMIT ?');\n    const rows = stmt.all(...queryParams, this.maxRows);\n\n    return {\n      uri: `db://query?sql=${encodeURIComponent(sql)}&amp;params=${encodeURIComponent(JSON.stringify(queryParams))}`,\n      mimeType: \"application/json\",\n      text: JSON.stringify({\n        query: sql,\n        parameters: queryParams,\n        resultCount: rows.length,\n        data: rows,\n      }, null, 2),\n    };\n  }\n\n  private getTableIndexes(tableName: string): any[] {\n    if (!this.db) return [];\n\n    try {\n      return this.db.prepare(`\n        SELECT name, sql \n        FROM sqlite_master \n        WHERE type='index' AND tbl_name=?\n      `).all(tableName) as any[];\n    } catch {\n      return [];\n    }\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      if (this.db) {\n        this.db.close();\n      }\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(`Database Resource Server running (DB: ${this.dbPath})`);\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new DatabaseResourceServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>  Testing - First, create a test database:  <pre><code>sqlite3 test.db &lt;&lt; 'EOF'\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  email TEXT UNIQUE,\n  age INTEGER,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  price REAL,\n  category TEXT,\n  in_stock BOOLEAN DEFAULT 1\n);\n\nINSERT INTO users (name, email, age) VALUES \n  ('Alice Johnson', 'alice@example.com', 28),\n  ('Bob Smith', 'bob@example.com', 34);\n\nINSERT INTO products (name, price, category, in_stock) VALUES \n  ('Laptop', 999.99, 'Electronics', 1),\n  ('Book', 19.99, 'Education', 1);\n\n.quit\nEOF\n</code></pre>  Test the server:  <pre><code>// Database info\n{ uri: \"db://info\" }\n\n// Table schemas\n{ uri: \"db://tables/users/schema\" }\n{ uri: \"db://tables/products/schema\" }\n\n// Table data\n{ uri: \"db://tables/users/data?limit=10\" }\n{ uri: \"db://tables/products/data?limit=10\" }\n\n// Specific records\n{ uri: \"db://tables/users/records/1\" }\n{ uri: \"db://tables/products/records/2\" }\n\n// Custom query\n{ uri: \"db://query?sql=SELECT * FROM users WHERE age &gt; ?&amp;params=[25]\" }\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Resources provide passive data access for LLMs</p> <p>\u2705 Tools perform active operations with side effects</p> <p>\u2705 URI schemes should be hierarchical and descriptive</p> <p>\u2705 Templates enable parameterized resource access</p> <p>\u2705 Subscriptions support real-time data updates</p> <p>\u2705 Security is critical for resource access control</p> <p>\u2705 Caching improves performance for static resources</p> <p>\u2705 Hybrid servers combine resources and tools effectively</p>"},{"location":"Lab04-MCP-Resources/lab/#next-steps","title":"Next Steps","text":"<p>In Lab 5, you\u2019ll complete your MCP mastery by learning about Prompts:</p> <ul> <li>Creating reusable prompt templates</li> <li>Embedding resources in prompts</li> <li>Supporting prompt arguments</li> <li>Building complete, production-ready MCP servers</li> </ul> <p>Ready to add prompts to your MCP toolkit? Continue to Lab 5!</p>"},{"location":"Lab04-MCP-Resources/lab4-tasks/","title":"MCP Lab Tasks - Lab 4","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-41-static-text-resource","title":"Exercise 4.1: Static Text Resource","text":"<p>Create a simple text resource that returns static content.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://static/welcome\") {\n    return {\n      contents: [{\n        uri: \"mcp://static/welcome\",\n        mimeType: \"text/plain\",\n        text: \"Welcome to MCP Resources!\"\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-42-file-system-resource","title":"Exercise 4.2: File System Resource","text":"<p>Implement a resource that reads files from the file system.</p> Solution <pre><code>import { readFileSync } from \"fs\";\nimport { extname } from \"path\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"file://\")) {\n    const filePath = uri.replace(\"file://\", \"\");\n\n    try {\n      const content = readFileSync(filePath, \"utf-8\");\n      const mimeType = getMimeType(filePath);\n\n      return {\n        contents: [{\n          uri,\n          mimeType,\n          text: content\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n});\n\nfunction getMimeType(filePath: string): string {\n  const ext = extname(filePath).toLowerCase();\n  const mimeTypes: Record&lt;string, string&gt; = {\n    '.txt': 'text/plain',\n    '.json': 'application/json',\n    '.js': 'application/javascript',\n    '.ts': 'application/typescript',\n    '.md': 'text/markdown'\n  };\n  return mimeTypes[ext] || 'text/plain';\n}\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-43-dynamic-resource","title":"Exercise 4.3: Dynamic Resource","text":"<p>Create a resource that generates content dynamically.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://dynamic/time\")) {\n    const now = new Date();\n    const timeString = now.toISOString();\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify({\n          timestamp: timeString,\n          unix: Math.floor(now.getTime() / 1000)\n        })\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-44-database-resource","title":"Exercise 4.4: Database Resource","text":"<p>Implement a resource that queries a database.</p> Solution <pre><code>import sqlite3 from \"sqlite3\";\n\nconst db = new sqlite3.Database(':memory:');\n\n// Initialize database\ndb.serialize(() =&gt; {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')\");\n  db.run(\"INSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com')\");\n});\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://db/users\") {\n    return new Promise((resolve, reject) =&gt; {\n      db.all(\"SELECT * FROM users\", [], (err, rows) =&gt; {\n        if (err) {\n          reject(new Error(`Database error: ${err.message}`));\n        } else {\n          resolve({\n            contents: [{\n              uri,\n              mimeType: \"application/json\",\n              text: JSON.stringify(rows, null, 2)\n            }]\n          });\n        }\n      });\n    });\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-45-api-resource","title":"Exercise 4.5: API Resource","text":"<p>Create a resource that fetches data from an external API.</p> Solution <pre><code>import fetch from \"node-fetch\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://api/github/\")) {\n    const repo = uri.replace(\"mcp://api/github/\", \"\");\n\n    try {\n      const response = await fetch(`https://api.github.com/repos/${repo}`);\n      const data = await response.json();\n\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify({\n            name: data.name,\n            description: data.description,\n            stars: data.stargazers_count,\n            language: data.language\n          }, null, 2)\n        }]\n      };\n    } catch (error) {\n      throw new Error(`API request failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-46-configuration-resource","title":"Exercise 4.6: Configuration Resource","text":"<p>Implement a resource that provides configuration data.</p> Solution <pre><code>const config = {\n  app: {\n    name: \"MCP Server\",\n    version: \"1.0.0\",\n    environment: process.env.NODE_ENV || \"development\"\n  },\n  database: {\n    host: process.env.DB_HOST || \"localhost\",\n    port: parseInt(process.env.DB_PORT || \"5432\")\n  },\n  features: {\n    tools: true,\n    resources: true,\n    prompts: false\n  }\n};\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://config/app\") {\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(config, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-47-log-resource","title":"Exercise 4.7: Log Resource","text":"<p>Create a resource that provides access to application logs.</p> Solution <pre><code>import { readFileSync } from \"fs\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://logs/application\") {\n    try {\n      const logs = readFileSync(\"app.log\", \"utf-8\");\n      return {\n        contents: [{\n          uri,\n          mimeType: \"text/plain\",\n          text: logs\n        }]\n      };\n    } catch (error) {\n      // Return empty logs if file doesn't exist\n      return {\n        contents: [{\n          uri,\n          mimeType: \"text/plain\",\n          text: \"No logs available\"\n        }]\n      };\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-48-metrics-resource","title":"Exercise 4.8: Metrics Resource","text":"<p>Implement a resource that provides system metrics.</p> Solution <pre><code>import { cpus, freemem, totalmem } from \"os\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://metrics/system\") {\n    const metrics = {\n      cpu: {\n        cores: cpus().length,\n        model: cpus()[0].model\n      },\n      memory: {\n        free: freemem(),\n        total: totalmem(),\n        used: totalmem() - freemem(),\n        usagePercent: ((totalmem() - freemem()) / totalmem() * 100).toFixed(2)\n      },\n      uptime: process.uptime()\n    };\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(metrics, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-49-template-resource","title":"Exercise 4.9: Template Resource","text":"<p>Create a resource that renders templates with data.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://template/\")) {\n    const templateName = uri.replace(\"mcp://template/\", \"\");\n    const templates: Record&lt;string, string&gt; = {\n      welcome: \"Hello {{name}}! Welcome to {{app}}.\",\n      status: \"Service {{service}} is {{status}}.\"\n    };\n\n    const template = templates[templateName];\n    if (!template) {\n      throw new Error(`Template '${templateName}' not found`);\n    }\n\n    // Simple template rendering (in real app, use a proper template engine)\n    const rendered = template\n      .replace(\"{{name}}\", \"User\")\n      .replace(\"{{app}}\", \"MCP Server\")\n      .replace(\"{{service}}\", \"Database\")\n      .replace(\"{{status}}\", \"running\");\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"text/plain\",\n        text: rendered\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-410-cache-resource","title":"Exercise 4.10: Cache Resource","text":"<p>Implement a resource with caching capabilities.</p> Solution <pre><code>const cache = new Map&lt;string, { data: any; timestamp: number }&gt;();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://cache/random\") {\n    const cached = cache.get(uri);\n    const now = Date.now();\n\n    if (cached &amp;&amp; (now - cached.timestamp) &lt; CACHE_TTL) {\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify({ value: cached.data, cached: true }, null, 2)\n        }]\n      };\n    }\n\n    // Generate new random value\n    const randomValue = Math.random();\n    cache.set(uri, { data: randomValue, timestamp: now });\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify({ value: randomValue, cached: false }, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-411-directory-listing-resource","title":"Exercise 4.11: Directory Listing Resource","text":"<p>Create a resource that lists directory contents.</p> Solution <pre><code>import { readdirSync, statSync } from \"fs\";\nimport { join } from \"path\";\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri.startsWith(\"mcp://fs/dir/\")) {\n    const dirPath = uri.replace(\"mcp://fs/dir/\", \"/\");\n\n    try {\n      const items = readdirSync(dirPath).map(item =&gt; {\n        const fullPath = join(dirPath, item);\n        const stats = statSync(fullPath);\n\n        return {\n          name: item,\n          type: stats.isDirectory() ? \"directory\" : \"file\",\n          size: stats.size,\n          modified: stats.mtime.toISOString()\n        };\n      });\n\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify(items, null, 2)\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to list directory: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-412-environment-resource","title":"Exercise 4.12: Environment Resource","text":"<p>Implement a resource that provides environment information.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://env/variables\") {\n    const envVars = Object.keys(process.env)\n      .filter(key =&gt; !key.includes(\"SECRET\") &amp;&amp; !key.includes(\"PASSWORD\"))\n      .reduce((obj, key) =&gt; {\n        obj[key] = process.env[key];\n        return obj;\n      }, {} as Record&lt;string, string | undefined&gt;);\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(envVars, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-413-health-check-resource","title":"Exercise 4.13: Health Check Resource","text":"<p>Create a resource that provides health status.</p> Solution <pre><code>server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://health/status\") {\n    const health = {\n      status: \"healthy\",\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      memory: process.memoryUsage(),\n      version: process.version\n    };\n\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(health, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-414-version-resource","title":"Exercise 4.14: Version Resource","text":"<p>Implement a resource that provides version information.</p> Solution <pre><code>const packageInfo = {\n  name: \"mcp-server\",\n  version: \"1.0.0\",\n  description: \"Model Context Protocol Server\",\n  dependencies: {\n    \"@modelcontextprotocol/sdk\": \"^0.4.0\"\n  }\n};\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://version/info\") {\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(packageInfo, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab04-MCP-Resources/lab4-tasks/#exercise-415-documentation-resource","title":"Exercise 4.15: Documentation Resource","text":"<p>Create a resource that serves documentation.</p> Solution <pre><code>const documentation = {\n  title: \"MCP Server Documentation\",\n  version: \"1.0.0\",\n  endpoints: {\n    tools: \"/tools\",\n    resources: \"/resources\",\n    prompts: \"/prompts\"\n  },\n  examples: {\n    tool_call: {\n      method: \"tools/call\",\n      params: {\n        name: \"example_tool\",\n        arguments: { param: \"value\" }\n      }\n    }\n  }\n};\n\nserver.setRequestHandler(\"resources/read\", async (request) =&gt; {\n  const { uri } = request.params;\n\n  if (uri === \"mcp://docs/api\") {\n    return {\n      contents: [{\n        uri,\n        mimeType: \"application/json\",\n        text: JSON.stringify(documentation, null, 2)\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/","title":"Lab 5: MCP Prompts and Complete Integration","text":""},{"location":"Lab05-MCP-Prompts/lab/#overview","title":"Overview","text":"<p>Congratulations on reaching the final lab!</p> <p>As you have already mastered tools and resources, now it\u2019s time to complete your MCP expertise with Prompts.</p> <p>Prompts are reusable templates that help users and LLMs perform common tasks consistently and effectively. They can embed resources, accept arguments, and create structured workflows that combine the best of human expertise with AI capabilities.</p> <p>In this lab, you\u2019ll learn how to create sophisticated prompt templates, integrate them with resources and tools, and build complete, production-ready MCP servers that showcase all three capabilities working together.</p>"},{"location":"Lab05-MCP-Prompts/lab/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand the role of prompts in MCP ecosystems</li> <li>Create static and dynamic prompt templates</li> <li>Embed resources and arguments in prompts</li> <li>Implement prompt handlers with proper validation</li> <li>Build complete MCP servers combining all capabilities</li> <li>Apply production best practices for deployment</li> <li>Debug and troubleshoot complex MCP integrations</li> <li>Create reusable prompt libraries for common tasks</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 4 - Implementing MCP Resources</li> <li>Understanding of prompt engineering concepts</li> <li>Familiarity with template systems and variable substitution</li> <li>Experience with complex application architecture</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#what-makes-prompts-special","title":"What Makes Prompts Special?","text":"<p>Prompts in MCP are more than just text templates - they\u2019re structured, reusable AI workflows that:</p> <ul> <li>Standardize common tasks across different users and contexts</li> <li>Combine expertise from domain specialists with AI capabilities</li> <li>Integrate resources to provide rich context automatically</li> <li>Accept parameters to customize behavior dynamically</li> <li>Create consistency in AI interactions and outputs</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#when-to-use-prompts-vs-tools","title":"When to Use Prompts vs. Tools","text":"Use Case Use Prompt Use Tool Why Code review \u2705 Prompt \u274c Tool Needs structured guidance and context Data analysis \u2705 Prompt \u274c Tool Requires analytical reasoning framework Content writing \u2705 Prompt \u274c Tool Benefits from style guides and examples API calls \u274c Prompt \u2705 Tool Direct action with predictable results Calculations \u274c Prompt \u2705 Tool Mathematical precision required Research synthesis \u2705 Prompt \u274c Tool Complex reasoning and integration needed"},{"location":"Lab05-MCP-Prompts/lab/#prompt-architecture","title":"Prompt Architecture","text":"<pre><code>interface Prompt {\n  name: string;              // Unique identifier\n  description: string;       // What the prompt does\n  arguments?: Argument[];    // Optional parameters\n  messages: Message[];       // The actual prompt content\n}\n\ninterface Argument {\n  name: string;              // Parameter name\n  description: string;       // What it controls\n  required?: boolean;        // Is it mandatory?\n}\n\ninterface Message {\n  role: \"user\" | \"assistant\"; // Who says this\n  content: Content;          // The message content\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#project-setup","title":"Project Setup","text":""},{"location":"Lab05-MCP-Prompts/lab/#step-1-create-your-project","title":"Step 1: Create Your Project","text":"<p>Let\u2019s start by creating a new MCP server project for prompts:</p> <pre><code>mkdir my-mcp-prompts-server  # &lt;-- next to the directory created in previous labs\ncd my-mcp-prompts-server\nnpm init -y\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<pre><code># Core MCP SDK\nnpm install @modelcontextprotocol/sdk\n\n# TypeScript and development tools\nnpm install -D typescript @types/node tsx\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#step-3-configure-typescript","title":"Step 3: Configure TypeScript","text":"<p>Create a <code>tsconfig.json</code> file with the following content inside the <code>my-mcp-prompts-server</code> directory you have just created:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#step-4-create-project-structure","title":"Step 4: Create Project Structure","text":"<pre><code>mkdir src     # &lt;-- inside \"my-mcp-prompts-server\" directory\ntouch src/index.ts   # and leave it empty for now\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#creating-your-first-prompt-server","title":"Creating Your First Prompt Server","text":""},{"location":"Lab05-MCP-Prompts/lab/#step-1-basic-server-setup","title":"Step 1: Basic Server Setup","text":"<p>Let\u2019s create a basic MCP server that exposes prompts. Paste the following inside <code>src/index.ts</code>:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass PromptServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"mcp-prompts-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List available prompts\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"hello-prompt\",\n            description: \"A simple greeting prompt\",\n          },\n          {\n            name: \"code-review\",\n            description: \"Comprehensive code review with best practices\",\n            arguments: [\n              {\n                name: \"language\",\n                description: \"Programming language (e.g., typescript, python)\",\n                required: true,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    // Get specific prompt\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generatePrompt(name, args || {});\n    });\n  }\n\n  private generatePrompt(name: string, args: Record&lt;string, any&gt;): any {\n    switch (name) {\n      case \"hello-prompt\":\n        return {\n          description: \"A simple greeting prompt\",\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: \"Hello! Please introduce yourself and explain what you can help me with today.\",\n              },\n            },\n          ],\n        };\n\n      case \"code-review\":\n        const language = args.language || \"typescript\";\n        return {\n          description: `Code review for ${language}`,\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: `Please perform a comprehensive code review of the following ${language} code. Focus on:\n\n## Code Quality &amp; Best Practices\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify later?\n- **Performance**: Are there any obvious performance issues?\n- **Error Handling**: Are errors handled appropriately?\n\n## ${language.toUpperCase()}-Specific Checks\n- Follow ${language} conventions and best practices\n- Use appropriate design patterns\n- Ensure proper type safety (if applicable)\n\nPlease provide specific, actionable feedback with examples where possible.`,\n              },\n            },\n          ],\n        };\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Prompt Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new PromptServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#step-2-test-your-server","title":"Step 2: Test Your Server","text":"<p>Build and run the server:</p> <pre><code>npm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre> <p>The MCP Inspector will launch a web interface.</p> <p></p> <p>Test the prompts in the MCP Inspector UI:</p> <ol> <li> <p>List prompts: Click the \u201cPrompts\u201d tab, then click \u201cList Prompts\u201d to see your two prompts (\u201chello-prompt\u201d and \u201ccode-review\u201d).</p> </li> <li> <p>Get hello-prompt: In the same section, select \u201cGet Prompt\u201d, enter \u201chello-prompt\u201d as the name, and submit to see the greeting prompt content.</p> </li> <li> <p>Get code-review: Select \u201cGet Prompt\u201d, enter \u201ccode-review\u201d as the name, and optionally provide arguments like {\u201clanguage\u201d: \u201ctypescript\u201d} in the arguments field, then submit to see the code review prompt.</p> </li> </ol>"},{"location":"Lab05-MCP-Prompts/lab/#step-3-adding-arguments-and-validation","title":"Step 3: Adding Arguments and Validation","text":"<p>Let\u2019s enhance our server with better argument handling. Update your existing <code>src/index.ts</code> file to add more arguments to the code-review prompt and include helper methods for dynamic content generation.</p> <p>Update the code-review prompt definition in the <code>ListPromptsRequestSchema</code> handler:</p> <pre><code>// Update the code-review prompt definition\n{\n  name: \"code-review\",\n  description: \"Comprehensive code review with best practices\",\n  arguments: [\n    {\n      name: \"language\",\n      description: \"Programming language (e.g., typescript, python, java)\",\n      required: true,\n    },\n    {\n      name: \"complexity\",\n      description: \"Code complexity level (beginner, intermediate, advanced)\",\n      required: false,\n    },\n    {\n      name: \"focus\",\n      description: \"Review focus areas (comma-separated: quality,security,performance)\",\n      required: false,\n    },\n  ],\n}\n</code></pre> <p></p> <p>Update the prompt generation:</p> <pre><code>case \"code-review\":\n  const language = args.language || \"typescript\";\n  const complexity = args.complexity || \"intermediate\";\n  const focus = args.focus || \"quality\";\n\n  return {\n    description: `Code review for ${language} (${complexity} level, focus: ${focus})`,\n    messages: [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Please perform a comprehensive code review of the following ${language} code.\n\n**Complexity Level:** ${complexity}\n**Focus Areas:** ${focus}\n\n## Review Guidelines\n\n### Code Quality &amp; Best Practices\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify later?\n- **Performance**: Are there any obvious performance issues?\n\n### ${complexity.charAt(0).toUpperCase() + complexity.slice(1)} Level Expectations\n${this.getComplexityExpectations(complexity)}\n\n### Focus Area: ${focus.toUpperCase()}\n${this.getFocusAreaGuidance(focus)}\n\nPlease provide specific, actionable feedback with examples where possible.`,\n        },\n      },\n    ],\n  };\n</code></pre> <p></p> <p>Add helper methods:</p> <pre><code>private getComplexityExpectations(level: string): string {\n  const expectations: { [key: string]: string } = {\n    beginner: `- Clear, self-documenting code\\n- Basic error handling\\n- Simple, understandable logic`,\n    intermediate: `- Good separation of concerns\\n- Comprehensive error handling\\n- Appropriate design patterns\\n- Unit test coverage`,\n    advanced: `- High performance and scalability\\n- Complex architectural patterns\\n- Extensive testing (unit, integration, e2e)\\n- Advanced optimization techniques`,\n  };\n  return expectations[level] || \"- Standard coding practices\";\n}\n\nprivate getFocusAreaGuidance(focus: string): string {\n  const guidance: { [key: string]: string } = {\n    quality: `**Code Quality Focus:**\n- Code readability and maintainability\n- Consistent naming conventions\n- Proper code organization\n- Documentation quality`,\n    security: `**Security Focus:**\n- Input validation and sanitization\n- Authentication and authorization\n- Data protection practices\n- Common vulnerability patterns`,\n    performance: `**Performance Focus:**\n- Algorithm efficiency\n- Memory usage optimization\n- Database query optimization\n- Caching strategies`,\n  };\n  return guidance[focus] || \"- General best practices\";\n}\n</code></pre> <p></p> <p>Here\u2019s the complete updated <code>src/index.ts</code> with all the above enhancements, just for review purposes:</p> <pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass PromptServer {\n  private server: Server;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"mcp-prompts-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private setupHandlers(): void {\n    // List available prompts\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"hello-prompt\",\n            description: \"A simple greeting prompt\",\n          },\n          {\n            name: \"code-review\",\n            description: \"Comprehensive code review with best practices\",\n            arguments: [\n              {\n                name: \"language\",\n                description: \"Programming language (e.g., typescript, python, java)\",\n                required: true,\n              },\n              {\n                name: \"complexity\",\n                description: \"Code complexity level (beginner, intermediate, advanced)\",\n                required: false,\n              },\n              {\n                name: \"focus\",\n                description: \"Review focus areas (comma-separated: quality,security,performance)\",\n                required: false,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    // Get specific prompt\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generatePrompt(name, args || {});\n    });\n  }\n\n  private generatePrompt(name: string, args: Record&lt;string, any&gt;): any {\n    switch (name) {\n      case \"hello-prompt\":\n        return {\n          description: \"A simple greeting prompt\",\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: \"Hello! Please introduce yourself and explain what you can help me with today.\",\n              },\n            },\n          ],\n        };\n\n      case \"code-review\":\n        const language = args.language || \"typescript\";\n        const complexity = args.complexity || \"intermediate\";\n        const focus = args.focus || \"quality\";\n\n        return {\n          description: `Code review for ${language} (${complexity} level, focus: ${focus})`,\n          messages: [\n            {\n              role: \"user\",\n              content: {\n                type: \"text\",\n                text: `Please perform a comprehensive code review of the following ${language} code.\n\n**Complexity Level:** ${complexity}\n**Focus Areas:** ${focus}\n\n## Review Guidelines\n\n### Code Quality &amp; Best Practices\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify later?\n- **Performance**: Are there any obvious performance issues?\n\n### ${complexity.charAt(0).toUpperCase() + complexity.slice(1)} Level Expectations\n${this.getComplexityExpectations(complexity)}\n\n### Focus Area: ${focus.toUpperCase()}\n${this.getFocusAreaGuidance(focus)}\n\nPlease provide specific, actionable feedback with examples where possible.`,\n              },\n            },\n          ],\n        };\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private getComplexityExpectations(level: string): string {\n    const expectations: { [key: string]: string } = {\n      beginner: `- Clear, self-documenting code\\n- Basic error handling\\n- Simple, understandable logic`,\n      intermediate: `- Good separation of concerns\\n- Comprehensive error handling\\n- Appropriate design patterns\\n- Unit test coverage`,\n      advanced: `- High performance and scalability\\n- Complex architectural patterns\\n- Extensive testing (unit, integration, e2e)\\n- Advanced optimization techniques`,\n    };\n    return expectations[level] || \"- Standard coding practices\";\n  }\n\n  private getFocusAreaGuidance(focus: string): string {\n    const guidance: { [key: string]: string } = {\n      quality: `**Code Quality Focus:**\n- Code readability and maintainability\n- Consistent naming conventions\n- Proper code organization\n- Documentation quality`,\n      security: `**Security Focus:**\n- Input validation and sanitization\n- Authentication and authorization\n- Data protection practices\n- Common vulnerability patterns`,\n      performance: `**Performance Focus:**\n- Algorithm efficiency\n- Memory usage optimization\n- Database query optimization\n- Caching strategies`,\n    };\n    return guidance[focus] || \"- General best practices\";\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Prompt Server running on stdio\");\n  }\n}\n\n// Main entry point\nasync function main() {\n  const server = new PromptServer();\n  await server.start();\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n</code></pre> <p></p>"},{"location":"Lab05-MCP-Prompts/lab/#test-enhanced-prompts","title":"Test Enhanced Prompts","text":"<p>Test with different arguments:</p> <ol> <li> <p>Basic code review (with default values):    <pre><code>{ name: \"code-review\", arguments: { language: \"typescript\" } }\n</code></pre>    Expected: Returns a prompt with intermediate complexity and quality focus.</p> </li> <li> <p>Advanced code review with focus:    <pre><code>{\n  name: \"code-review\",\n  arguments: {\n    language: \"python\",\n    complexity: \"advanced\",\n    focus: \"security\"\n  }\n}\n</code></pre>    Expected: Returns a prompt with advanced complexity expectations and security focus guidance.</p> </li> </ol> <p>How to test in MCP Inspector:</p> <ol> <li> <p>Start the server: <pre><code>cd my-mcp-prompts-server\nnpm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre></p> </li> <li> <p>Inside MCP Inspector UI, navigate to Prompts:</p> <ul> <li>Click on the \u201cPrompts\u201d tab in the Inspector interface</li> </ul> </li> <li> <p>Test List Prompts:</p> <ul> <li>Click \u201cList Prompts\u201d button</li> <li>Verify you see \u201chello-prompt\u201d and \u201ccode-review\u201d with the updated arguments</li> </ul> </li> <li> <p>Test Get Prompt - Basic:</p> <ul> <li>Select \u201cGet Prompt\u201d from the dropdown or click the button</li> <li>Enter <code>code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"language\": \"typescript\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes intermediate complexity and quality focus</li> </ul> </li> <li> <p>Test Get Prompt - Advanced:</p> <ul> <li>Select \u201cGet Prompt\u201d again</li> <li>Enter <code>code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter:     <pre><code>{\n  \"language\": \"python\",\n  \"complexity\": \"advanced\",\n  \"focus\": \"security\"\n}\n</code></pre></li> <li>Click \u201cSend Request\u201d</li> <li>Verify the prompt content includes advanced expectations and security guidance</li> </ul> </li> <li> <p>Test without arguments:</p> <ul> <li>Try <code>code-review</code> with no arguments</li> <li>Should use defaults: typescript, intermediate, quality</li> </ul> </li> </ol> <p>Expected Results:</p> <ul> <li>The prompt description should reflect the arguments (e.g., \u201cCode review for python (advanced level, focus: security)\u201d)</li> <li>The prompt content should include the appropriate complexity expectations and focus area guidance</li> <li>Helper methods should dynamically insert the correct text based on arguments</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#integrating-resources-with-prompts","title":"Integrating Resources with Prompts","text":"<p>Prompts become more powerful when integrated with resources! </p> <p>This allows prompts to dynamically include contextual information from your knowledge base, documentation, or data sources, creating richer and more informed AI interactions.</p>"},{"location":"Lab05-MCP-Prompts/lab/#step-1-add-resource-support","title":"Step 1: Add Resource Support","text":"<p>Create a new project for the resource-prompt server:</p> <pre><code># Create new directory next to your previous server\nmkdir my-resource-prompt-server  # &lt;-- next to the directory created previously\ncd my-resource-prompt-server\n\n# Initialize and install dependencies\nnpm init -y\nnpm install @modelcontextprotocol/sdk\nnpm install -D typescript @types/node tsx\n\n# Create TypeScript config (same as before)\ncat &gt; tsconfig.json &lt;&lt; 'EOF'\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\nEOF\n\n# Create directory structure\nmkdir src # &lt;-- inside \"my-resource-prompt-server\" directory\n</code></pre> <p></p> <p>Now create the server file <code>src/index.ts</code> with the following content that combines prompts with resources:</p> <pre><code>import {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass ResourcePromptServer {\n  private server: Server;\n  private knowledgeBase: Map&lt;string, any&gt; = new Map();\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"resource-prompt-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n          resources: {},\n        },\n      }\n    );\n\n    this.initializeKnowledgeBase();\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private initializeKnowledgeBase(): void {\n    this.knowledgeBase.set(\"best-practices\", {\n      title: \"Development Best Practices\",\n      content: `\n## Code Quality\n- Write self-documenting code\n- Use meaningful variable names\n- Keep functions small and focused\n\n## Testing\n- Write unit tests for all functions\n- Include integration tests\n- Test edge cases and error conditions\n      `,\n    });\n\n    this.knowledgeBase.set(\"security-guidelines\", {\n      title: \"Security Guidelines\",\n      content: `\n## Input Validation\n- Validate all user inputs\n- Use parameterized queries\n- Sanitize HTML content\n\n## Authentication\n- Use strong password policies\n- Implement multi-factor authentication\n      `,\n    });\n  }\n\n  private setupHandlers(): void {\n    // Resource handlers\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = Array.from(this.knowledgeBase.entries()).map(([key, doc]) =&gt; ({\n        uri: `kb://articles/${key}`,\n        name: doc.title,\n        description: `Knowledge base: ${doc.title}`,\n        mimeType: \"text/markdown\",\n      }));\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = this.readKnowledgeBase(uri);\n      return { contents: [content] };\n    });\n\n    // Prompt handlers\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"contextual-code-review\",\n            description: \"Code review with integrated best practices\",\n            arguments: [\n              {\n                name: \"language\",\n                description: \"Programming language\",\n                required: true,\n              },\n              {\n                name: \"focusAreas\",\n                description: \"Focus areas (comma-separated)\",\n                required: false,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generatePrompt(name, args || {});\n    });\n  }\n\n  private readKnowledgeBase(uri: string): any {\n    const match = uri.match(/^kb:\\/\\/articles\\/(.+)$/);\n    if (!match) throw new Error(`Invalid knowledge base URI: ${uri}`);\n\n    const key = match[1];\n    const article = this.knowledgeBase.get(key);\n\n    if (!article) throw new Error(`Article not found: ${key}`);\n\n    return {\n      uri,\n      mimeType: \"text/markdown\",\n      text: article.content,\n    };\n  }\n\n  private generatePrompt(name: string, args: Record&lt;string, any&gt;): any {\n    switch (name) {\n      case \"contextual-code-review\":\n        return this.createContextualCodeReviewPrompt(args);\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private createContextualCodeReviewPrompt(args: Record&lt;string, any&gt;): any {\n    const language = args.language || \"typescript\";\n    const focusAreas = args.focusAreas ? args.focusAreas.split(',').map((s: string) =&gt; s.trim()) : [\"quality\"];\n\n    // Fetch relevant knowledge base articles\n    let contextContent = \"\";\n\n    if (focusAreas.includes(\"quality\")) {\n      const bestPractices = this.knowledgeBase.get(\"best-practices\");\n      if (bestPractices) {\n        contextContent += `\\n## Development Best Practices\\n${bestPractices.content}`;\n      }\n    }\n\n    if (focusAreas.includes(\"security\")) {\n      const securityGuidelines = this.knowledgeBase.get(\"security-guidelines\");\n      if (securityGuidelines) {\n        contextContent += `\\n## Security Guidelines\\n${securityGuidelines.content}`;\n      }\n    }\n\n    return {\n      description: `Contextual code review for ${language} with focus on: ${focusAreas.join(', ')}`,\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Please perform a comprehensive code review of the following ${language} code. Use the integrated knowledge base context to provide informed recommendations.\n\n## Review Context\n${contextContent}\n\n## Code to Review\n[Insert code here]\n\n## Review Focus Areas\n${focusAreas.map(area =&gt; `- **${area.charAt(0).toUpperCase() + area.slice(1)}**: Apply relevant guidelines from the context above`).join('\\n')}\n\n## Review Structure\n1. **Summary**: Overall assessment and key findings\n2. **Strengths**: What the code does well\n3. **Areas for Improvement**: Specific recommendations with context references\n4. **Action Items**: Prioritized list of recommended changes\n\nPlease reference specific guidelines from the provided context and explain how they apply to this code.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Resource-Prompt Server running on stdio\");\n  }\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#step-2-test-resource-integration","title":"Step 2: Test Resource Integration","text":"<p>Build and run the resource-prompt server:</p> <pre><code>cd my-resource-prompt-server\nnpm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre> <p>Test the enhanced server inside the MCP Inspector UI:</p> <ol> <li> <p>Navigate to Resources tab:</p> <ul> <li>Click on the \u201cResources\u201d tab</li> </ul> </li> <li> <p>List resources:</p> <ul> <li>Click \u201cList Resources\u201d button</li> <li>Verify you see the knowledge base articles (\u201cDevelopment Best Practices\u201d and \u201cSecurity Guidelines\u201d)</li> </ul> </li> <li> <p>Read a resource:</p> <ul> <li>Select \u201cRead Resource\u201d from the dropdown</li> <li>Enter <code>kb://articles/best-practices</code> in the \u201cURI\u201d field</li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes the full content of the best practices article</li> </ul> </li> <li> <p>Read another resource:</p> <ul> <li>Select \u201cRead Resource\u201d again</li> <li>Enter <code>kb://articles/security-guidelines</code> in the \u201cURI\u201d field</li> <li>Click \u201cSend Request\u201d</li> <li>Verify the security guidelines content is returned</li> </ul> </li> <li> <p>Navigate to Prompts tab:</p> <ul> <li>Click on the \u201cPrompts\u201d tab</li> </ul> </li> <li> <p>List prompts:</p> <ul> <li>Click \u201cList Prompts\u201d button</li> <li>Verify you see the \u201ccontextual-code-review\u201d prompt with its arguments</li> </ul> </li> <li> <p>Get contextual prompt - Basic:</p> <ul> <li>Select \u201cGet Prompt\u201d</li> <li>Enter <code>contextual-code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"language\": \"typescript\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the prompt content includes the best practices from the knowledge base</li> </ul> </li> <li> <p>Get contextual prompt - With focus areas:</p> <ul> <li>Select \u201cGet Prompt\u201d again</li> <li>Enter <code>contextual-code-review</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter:     <pre><code>{\n  \"language\": \"python\",\n  \"focusAreas\": \"quality,security\"\n}\n</code></pre></li> <li>Click \u201cSend Request\u201d</li> <li>Verify the prompt includes both best practices and security guidelines from the knowledge base</li> </ul> </li> </ol> <p></p> <p>Expected Results:</p> <ul> <li>Resources should list the knowledge base articles with proper URIs and descriptions</li> <li>Reading resources should return the full markdown content of each article</li> <li>Prompts should dynamically include relevant knowledge base content based on the focus areas argument</li> <li>The contextual prompt should reference specific guidelines from the integrated resources</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#complete-mcp-server-integration","title":"Complete MCP Server Integration","text":"<p>Complete MCP server integration combines all three core capabilities - tools, resources, and prompts - into a single server that can perform complex operations and provide rich, contextual AI interactions.</p>"},{"location":"Lab05-MCP-Prompts/lab/#step-1-combine-all-capabilities","title":"Step 1: Combine All Capabilities","text":"<p>Create a new project for the complete MCP server:</p> <pre><code># Create new directory next to your previous servers\nmkdir my-complete-mcp-server\ncd my-complete-mcp-server\n\n# Initialize and install dependencies\nnpm init -y\nnpm install @modelcontextprotocol/sdk\nnpm install -D typescript @types/node tsx\n\n# Create TypeScript config (same as before)\ncat &gt; tsconfig.json &lt;&lt; 'EOF'\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\nEOF\n\n# Create directory structure\nmkdir src\n</code></pre> <p></p> <p>Now create the server file <code>src/index.ts</code>, that combines tools, resources, and prompts, with the following content:</p> <pre><code>import {\n  ListToolsRequestSchema,\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nclass CompleteMCPServer {\n  private server: Server;\n  private knowledgeBase: Map&lt;string, any&gt; = new Map();\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"complete-mcp-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    this.initializeKnowledgeBase();\n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n\n  private initializeKnowledgeBase(): void {\n    this.knowledgeBase.set(\"development-workflow\", {\n      title: \"Complete Development Workflow\",\n      content: `\n## Development Process\n1. Requirements gathering and analysis\n2. System design and architecture\n3. Implementation with best practices\n4. Code review and quality assurance\n5. Testing and validation\n6. Deployment and monitoring\n7. Maintenance and updates\n      `,\n    });\n  }\n\n  private setupHandlers(): void {\n    // Tool handlers\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"analyze_codebase\",\n            description: \"Analyze codebase structure and provide insights\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                path: { type: \"string\", description: \"Path to analyze\" },\n                analysisType: {\n                  type: \"string\",\n                  enum: [\"structure\", \"complexity\", \"dependencies\"],\n                  default: \"structure\"\n                },\n              },\n              required: [\"path\"],\n            },\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      switch (name) {\n        case \"analyze_codebase\":\n          return this.analyzeCodebase(args);\n\n        default:\n          throw new Error(`Unknown tool: ${name}`);\n      }\n    });\n\n    // Resource handlers\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () =&gt; {\n      const resources = [\n        ...Array.from(this.knowledgeBase.entries()).map(([key, doc]) =&gt; ({\n          uri: `kb://articles/${key}`,\n          name: doc.title,\n          description: `Knowledge: ${doc.title}`,\n          mimeType: \"text/markdown\",\n        })),\n      ];\n\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =&gt; {\n      const uri = request.params.uri;\n      const content = await this.readResource(uri);\n      return { contents: [content] };\n    });\n\n    // Prompt handlers\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () =&gt; {\n      return {\n        prompts: [\n          {\n            name: \"full-development-workflow\",\n            description: \"Complete development workflow with integrated resources\",\n            arguments: [\n              {\n                name: \"projectType\",\n                description: \"Type of project (web, api, mobile)\",\n                required: true,\n              },\n            ],\n          },\n          {\n            name: \"code-quality-assessment\",\n            description: \"Comprehensive code quality assessment using all capabilities\",\n            arguments: [\n              {\n                name: \"codeSample\",\n                description: \"Code to assess\",\n                required: true,\n              },\n            ],\n          },\n        ],\n      };\n    });\n\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n      return this.generateIntegratedPrompt(name, args || {});\n    });\n  }\n\n  private async analyzeCodebase(args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    const targetPath = args.path || \"./\";\n    const analysisType = args.analysisType || \"structure\";\n\n    try {\n      const analysis = await this.performCodeAnalysis(targetPath, analysisType);\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `## Codebase Analysis: ${analysisType.toUpperCase()}\\n\\n${analysis}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Codebase analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private async performCodeAnalysis(targetPath: string, analysisType: string): Promise&lt;string&gt; {\n    // Simplified analysis - in real implementation, use proper code analysis tools\n    return `### Analysis Results\n- **Path**: ${targetPath}\n- **Type**: ${analysisType}\n- **Status**: Analysis completed successfully\n\n### Recommendations\n- Consider organizing files by feature\n- Add proper documentation\n- Implement consistent coding standards`;\n  }\n\n  private async readResource(uri: string): Promise&lt;any&gt; {\n    if (uri.startsWith('kb://')) {\n      return this.readKnowledgeBase(uri);\n    }\n\n    throw new Error(`Unknown resource URI: ${uri}`);\n  }\n\n  private readKnowledgeBase(uri: string): any {\n    const match = uri.match(/^kb:\\/\\/articles\\/(.+)$/);\n    if (!match) throw new Error(`Invalid knowledge base URI: ${uri}`);\n\n    const key = match[1];\n    const article = this.knowledgeBase.get(key);\n\n    if (!article) throw new Error(`Article not found: ${key}`);\n\n    return {\n      uri,\n      mimeType: \"text/markdown\",\n      text: article.content,\n    };\n  }\n\n  private async generateIntegratedPrompt(name: string, args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    switch (name) {\n      case \"full-development-workflow\":\n        return this.createFullWorkflowPrompt(args);\n\n      case \"code-quality-assessment\":\n        return this.createQualityAssessmentPrompt(args);\n\n      default:\n        throw new Error(`Unknown prompt: ${name}`);\n    }\n  }\n\n  private async createFullWorkflowPrompt(args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    const projectType = args.projectType || \"web\";\n\n    const workflowDoc = this.knowledgeBase.get(\"development-workflow\");\n\n    return {\n      description: `Complete ${projectType} development workflow`,\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Guide me through a complete ${projectType} development project.\n\n## Development Workflow Reference\n${workflowDoc ? workflowDoc.content : \"Standard development practices apply\"}\n\n## Project Context\n- **Type**: ${projectType}\n- **Current Phase**: Planning\n\nPlease provide a comprehensive development plan with specific phases, deliverables, and best practices.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async createQualityAssessmentPrompt(args: Record&lt;string, any&gt;): Promise&lt;any&gt; {\n    const codeSample = args.codeSample || \"[Insert code here]\";\n\n    // Use tools to analyze the code\n    const analysisResult = await this.analyzeCodebase({ path: \"./\", analysisType: \"structure\" });\n\n    return {\n      description: \"Comprehensive code quality assessment\",\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Perform a comprehensive code quality assessment of the following code.\n\n## Code to Assess\n\\`\\`\\`\n${codeSample}\n\\`\\`\\`\n\n## Automated Analysis Results\n${analysisResult.content[0].text}\n\n## Assessment Framework\n\n### 1. Code Quality Metrics\n- **Readability**: Is the code easy to understand?\n- **Maintainability**: How easy will this be to modify?\n- **Performance**: Are there any obvious issues?\n\n### 2. Best Practices\n- Does it follow coding standards?\n- Are there appropriate error handling?\n- Is the code well-structured?\n\n### 3. Recommendations\nProvide specific, prioritized recommendations for improvement.\n\nPlease provide a thorough assessment.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"[MCP Error]\", error);\n    };\n\n    process.on(\"SIGINT\", async () =&gt; {\n      await this.server.close();\n      process.exit(0);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"Complete MCP Server running on stdio\");\n  }\n}\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab/#step-2-test-complete-integration","title":"Step 2: Test Complete Integration","text":"<p>Build and run the complete MCP server:</p> <pre><code>cd my-complete-mcp-server\nnpm run build\nnpx @modelcontextprotocol/inspector node dist/index.js\n</code></pre> <p>Test the complete integration inside the MCP Inspector UI:</p> <ol> <li> <p>Navigate to Tools tab:</p> <ul> <li>Click on the \u201cTools\u201d tab</li> </ul> </li> <li> <p>List tools:</p> <ul> <li>Click \u201cList Tools\u201d button</li> <li>Verify you see the \u201canalyze_codebase\u201d tool with its description and input schema</li> </ul> </li> <li> <p>Call tool:</p> <ul> <li>Select \u201cCall Tool\u201d from the dropdown</li> <li>Enter <code>analyze_codebase</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"path\": \"./\", \"analysisType\": \"structure\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes a codebase analysis with recommendations</li> </ul> </li> <li> <p>Navigate to Resources tab:</p> <ul> <li>Click on the \u201cResources\u201d tab</li> </ul> </li> <li> <p>List resources:</p> <ul> <li>Click \u201cList Resources\u201d button</li> <li>Verify you see the knowledge base article (\u201cComplete Development Workflow\u201d)</li> </ul> </li> <li> <p>Read resource:</p> <ul> <li>Select \u201cRead Resource\u201d from the dropdown</li> <li>Enter <code>kb://articles/development-workflow</code> in the \u201cURI\u201d field</li> <li>Click \u201cSend Request\u201d</li> <li>Check that the response includes the full development workflow content</li> </ul> </li> <li> <p>Navigate to Prompts tab:</p> <ul> <li>Click on the \u201cPrompts\u201d tab</li> </ul> </li> <li> <p>List prompts:</p> <ul> <li>Click \u201cList Prompts\u201d button</li> <li>Verify you see the \u201cfull-development-workflow\u201d and \u201ccode-quality-assessment\u201d prompts with their arguments</li> </ul> </li> <li> <p>Get full development workflow prompt:</p> <ul> <li>Select \u201cGet Prompt\u201d</li> <li>Enter <code>full-development-workflow</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"projectType\": \"web\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Check that the prompt content includes the development workflow from the knowledge base</li> </ul> </li> <li> <p>Get code quality assessment prompt:</p> <ul> <li>Select \u201cGet Prompt\u201d again</li> <li>Enter <code>code-quality-assessment</code> in the \u201cName\u201d field</li> <li>In the \u201cArguments\u201d field, enter: <code>{\"codeSample\": \"function test() { return true; }\"}</code></li> <li>Click \u201cSend Request\u201d</li> <li>Verify the prompt includes automated analysis results and assessment framework</li> </ul> </li> </ol> <p></p> <p>Expected Results:</p> <ul> <li>Tools should list the analysis tool with proper schema and description</li> <li>Calling tools should return structured analysis results</li> <li>Resources should list knowledge base articles with proper URIs</li> <li>Reading resources should return the full markdown content</li> <li>Prompts should list integrated prompts with their arguments</li> <li>Getting prompts should dynamically include tool results and resource content</li> <li>The complete integration should demonstrate all three capabilities working together seamlessly</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#hands-on-exercises","title":"Hands-On Exercises","text":""},{"location":"Lab05-MCP-Prompts/lab/#exercise-1-custom-prompt-library","title":"Exercise 1: Custom Prompt Library","text":"<p>Goal: Create a specialized prompt library for a specific domain.</p> <p>Steps:</p> <ol> <li>Choose a domain (e.g., data science, DevOps, content writing)</li> <li>Create 3-5 domain-specific prompts</li> <li>Add appropriate arguments for customization</li> <li>Include domain-specific resources</li> <li>Test with the MCP Inspector</li> </ol> <p>Requirements:</p> <ul> <li>At least one prompt with required arguments</li> <li>At least one prompt with optional arguments</li> <li>Include resource integration</li> <li>Proper error handling</li> </ul> Solution  Choose data science domain.  Create 3 domain-specific prompts: data-exploration, model-training, visualization.  Add arguments: dataset (required), focus (optional).  Include domain-specific resources: data science best practices.  Example code structure: <pre><code>// In ListPromptsRequestSchema handler\n{\n  name: \"data-exploration\",\n  description: \"Guide for exploratory data analysis\",\n  arguments: [\n    {\n      name: \"dataset\",\n      description: \"Dataset description\",\n      required: true,\n    },\n    {\n      name: \"focus\",\n      description: \"Analysis focus (distribution, correlation, outliers)\",\n      required: false,\n    },\n  ],\n},\n{\n  name: \"model-training\",\n  description: \"Guide for machine learning model training\",\n  arguments: [\n    {\n      name: \"algorithm\",\n      description: \"ML algorithm (linear, tree, neural)\",\n      required: true,\n    },\n    {\n      name: \"target\",\n      description: \"Target variable\",\n      required: false,\n    },\n  ],\n},\n{\n  name: \"data-visualization\",\n  description: \"Guide for creating effective data visualizations\",\n  arguments: [\n    {\n      name: \"chartType\",\n      description: \"Type of chart (bar, line, scatter)\",\n      required: true,\n    },\n  ],\n}\n\n// In generatePrompt method\ncase \"data-exploration\":\n  const dataset = args.dataset || \"dataset\";\n  const focus = args.focus || \"distribution\";\n  return {\n    description: `Data exploration for ${dataset} focusing on ${focus}`,\n    messages: [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Perform exploratory data analysis on the ${dataset} dataset.\n\nFocus areas: ${focus}\n\nGuidelines:\n- Examine data structure and types\n- Check for missing values and outliers\n- Analyze distributions and correlations\n- Generate summary statistics\n\nProvide insights and recommendations.`,\n        },\n      },\n    ],\n  };\n\n// Add resources in initializeKnowledgeBase\nthis.knowledgeBase.set(\"data-science-practices\", {\n  title: \"Data Science Best Practices\",\n  content: `\nData Quality\n- Validate data integrity\n- Handle missing values appropriately\n- Check for data consistency\n\nAnalysis Process\n- Start with descriptive statistics\n- Use visualizations for insights\n- Test hypotheses systematically\n  `,\n});\n</code></pre>  Test with MCP Inspector by listing prompts, getting prompts with different arguments, and verifying resource integration."},{"location":"Lab05-MCP-Prompts/lab/#exercise-2-multi-step-workflow-prompt","title":"Exercise 2: Multi-Step Workflow Prompt","text":"<p>Goal: Create a prompt that guides users through complex, multi-step processes.</p> <p>Steps:</p> <ol> <li>Design a multi-step workflow (e.g., code review \u2192 testing \u2192 deployment)</li> <li>Create prompts for each step</li> <li>Add logic to chain prompts together</li> <li>Include progress tracking</li> <li>Test the complete workflow</li> </ol> <p>Requirements:</p> <ul> <li>Clear step progression</li> <li>State management between steps</li> <li>Error handling and recovery</li> <li>Progress indicators</li> </ul> Solution  Design a code review to deployment workflow with steps: review, testing, deployment.  Create prompts for each step with currentStep argument.  Add logic to chain prompts and track progress.  Example code structure:  <pre><code>// In ListPromptsRequestSchema handler\n{\n  name: \"workflow-step\",\n  description: \"Multi-step development workflow guidance\",\n  arguments: [\n    {\n      name: \"currentStep\",\n      description: \"Current workflow step (review, testing, deployment)\",\n      required: true,\n    },\n    {\n      name: \"projectType\",\n      description: \"Type of project\",\n      required: false,\n    },\n  ],\n}\n\n// In generatePrompt method\ncase \"workflow-step\":\n  const step = args.currentStep || \"review\";\n  const projectType = args.projectType || \"web\";\n  const workflowSteps = [\"review\", \"testing\", \"deployment\"];\n  const currentIndex = workflowSteps.indexOf(step);\n\n  return {\n    description: `${projectType} development workflow - Step ${currentIndex + 1}: ${step}`,\n    messages: [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Guide for ${projectType} project ${step} phase.\n\nProgress: Step ${currentIndex + 1} of ${workflowSteps.length}\nPrevious steps: ${workflowSteps.slice(0, currentIndex).join(', ') || 'None'}\nNext steps: ${workflowSteps.slice(currentIndex + 1).join(', ') || 'Complete'}\n\n${this.getStepGuidance(step, projectType)}\n\nProvide detailed guidance and check completion criteria before proceeding.`,\n        },\n      },\n    ],\n  };\n\n// Helper method\nprivate getStepGuidance(step: string, projectType: string): string {\n  const guidance: { [key: string]: { [key: string]: string } } = {\n    review: {\n      web: \"Code Review Guidelines:\\n- Check code quality and standards\\n- Verify security practices\\n- Review performance considerations\\n- Validate functionality\",\n      api: \"API Review Guidelines:\\n- Check endpoint design\\n- Validate error handling\\n- Review authentication\\n- Test API contracts\",\n    },\n    testing: {\n      web: \"Testing Guidelines:\\n- Unit test coverage\\n- Integration testing\\n- User acceptance testing\\n- Performance testing\",\n      api: \"API Testing Guidelines:\\n- Endpoint testing\\n- Load testing\\n- Security testing\\n- Contract testing\",\n    },\n    deployment: {\n      web: \"Deployment Guidelines:\\n- Environment configuration\\n- Database migrations\\n- Rollback procedures\\n- Monitoring setup\",\n      api: \"API Deployment Guidelines:\\n- API gateway configuration\\n- Version management\\n- Documentation publishing\\n- Client notifications\",\n    },\n  };\n  return guidance[step]?.[projectType] || \"Follow standard practices for this step.\";\n}\n</code></pre>  Test the workflow by calling the prompt with different currentStep values and verifying step progression and guidance."},{"location":"Lab05-MCP-Prompts/lab/#exercise-3-production-ready-server","title":"Exercise 3: Production-Ready Server","text":"<p>Goal: Create a production-ready MCP server with all capabilities.</p> <p>Steps:</p> <ol> <li>Implement comprehensive error handling</li> <li>Add logging and monitoring</li> <li>Include health checks</li> <li>Add configuration management</li> <li>Implement rate limiting</li> <li>Create deployment scripts</li> </ol> <p>Requirements:</p> <ul> <li>Structured logging</li> <li>Health check endpoints</li> <li>Configuration validation</li> <li>Graceful shutdown</li> <li>Performance monitoring</li> </ul> Solution  Implement comprehensive error handling, logging, health checks, configuration management, rate limiting, and deployment scripts.  Example code structure:  <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nclass ProductionMCPServer {\n  private server: Server;\n  private config: any;\n  private requestCount = 0;\n  private startTime = Date.now();\n\n  constructor(configPath?: string) {\n    this.config = this.loadConfiguration(configPath);\n    this.server = new Server(\n      {\n        name: this.config.name,\n        version: this.config.version,\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    this.setupLogging();\n    this.setupHandlers();\n    this.setupErrorHandling();\n    this.setupHealthChecks();\n  }\n\n  private loadConfiguration(configPath?: string): any {\n    // Load from file or environment\n    return {\n      name: \"production-mcp-server\",\n      version: \"1.0.0\",\n      port: process.env.PORT || 3000,\n      logLevel: process.env.LOG_LEVEL || \"info\",\n      rateLimit: parseInt(process.env.RATE_LIMIT || \"100\"),\n    };\n  }\n\n  private setupLogging(): void {\n    // Use a proper logging library in production\n    console.log = this.createLogger(\"info\");\n    console.error = this.createLogger(\"error\");\n  }\n\n  private createLogger(level: string): (...args: any[]) =&gt; void {\n    return (...args: any[]) =&gt; {\n      const timestamp = new Date().toISOString();\n      process.stderr.write(`[${timestamp}] ${level.toUpperCase()}: ${args.join(' ')}\\n`);\n    };\n  }\n\n  private setupHandlers(): void {\n    // Add rate limiting to handlers\n    this.server.setRequestHandler(ListToolsRequestSchema, this.rateLimitedHandler(async () =&gt; {\n      return { tools: [] };\n    }));\n\n    // Add other handlers similarly\n  }\n\n  private rateLimitedHandler(handler: Function): Function {\n    return async (request: any) =&gt; {\n      this.requestCount++;\n      if (this.requestCount &gt; this.config.rateLimit) {\n        throw new Error(\"Rate limit exceeded\");\n      }\n      return handler(request);\n    };\n  }\n\n  private setupHealthChecks(): void {\n    // Add health check endpoint (if using HTTP transport)\n    // For stdio, we can add a special tool\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      if (request.params.name === \"health_check\") {\n        return {\n          content: [{\n            type: \"text\",\n            text: JSON.stringify({\n              status: \"healthy\",\n              uptime: Date.now() - this.startTime,\n              requestCount: this.requestCount,\n            }),\n          }],\n        };\n      }\n      // Handle other tools\n    });\n  }\n\n  private setupErrorHandling(): void {\n    this.server.onerror = (error) =&gt; {\n      console.error(\"Server error:\", error);\n      // Send to monitoring service\n    };\n\n    process.on(\"SIGTERM\", async () =&gt; {\n      console.log(\"Received SIGTERM, shutting down gracefully\");\n      await this.server.close();\n      process.exit(0);\n    });\n\n    process.on(\"uncaughtException\", (error) =&gt; {\n      console.error(\"Uncaught exception:\", error);\n      process.exit(1);\n    });\n  }\n\n  async start(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.log(\"Production MCP Server running on stdio\");\n  }\n}\n\n// Deployment script (deploy.sh)\n#!/bin/bash\nnpm run build\nnpm run test\ndocker build -t mcp-server .\ndocker run -p 3000:3000 mcp-server\n</code></pre>  Test by running the server, checking logs, calling health check tool, and verifying graceful shutdown."},{"location":"Lab05-MCP-Prompts/lab/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Prompts create reusable AI workflows with structured guidance</p> <p>\u2705 Resource integration provides contextually rich prompt experiences</p> <p>\u2705 Arguments make prompts flexible and customizable</p> <p>\u2705 Complete servers combine tools, resources, and prompts effectively</p> <p>\u2705 Dynamic prompts adapt to current data and context</p> <p>\u2705 Production readiness requires comprehensive error handling and monitoring</p> <p>\u2705 Workflow orchestration enables complex, multi-step AI processes</p> <p>\u2705 Domain specialization creates powerful, focused AI capabilities</p>"},{"location":"Lab05-MCP-Prompts/lab/#next-steps","title":"Next Steps","text":"<p>Congratulations! </p> <p>You\u2019ve completed the comprehensive MCP learning series. </p> <p>You now posses the knowledge and skills to:</p> <p>\u2705 Build complete MCP servers with all three capabilities</p> <p>\u2705 Create sophisticated AI workflows and integrations</p> <p>\u2705 Deploy production-ready MCP solutions</p> <p>\u2705 Contribute to the MCP ecosystem</p>"},{"location":"Lab05-MCP-Prompts/lab/#whats-next","title":"What\u2019s Next?","text":""},{"location":"Lab05-MCP-Prompts/lab/#further-experimentation","title":"Further experimentation","text":"<p>Go ahead and experiment further with MCP un the MCP Lab Tasks section, filled with hands-on exercises to deepen your understanding of MCP capabilities.</p>"},{"location":"Lab05-MCP-Prompts/lab/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>MCP Extensions: Custom protocol extensions</li> <li>Multi-server Coordination: Server orchestration</li> <li>Performance Optimization: Scaling MCP servers</li> <li>Security Hardening: Advanced security patterns</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Code Analysis Tools: Automated code review and improvement</li> <li>DevOps Automation: Infrastructure and deployment automation</li> <li>Data Science Workflows: AI-assisted data analysis</li> <li>Content Creation: AI-powered content generation pipelines</li> </ul>"},{"location":"Lab05-MCP-Prompts/lab/#community-engagement","title":"Community Engagement","text":"<ul> <li>Contribute to MCP: Join the open-source development</li> <li>Share Your Servers: Publish your MCP servers</li> <li>Build Integrations: Create MCP clients and tools</li> <li>Teach Others: Help grow the MCP community</li> </ul> <p>Your MCP journey has just begun! </p> <p>The protocol provides endless possibilities for AI-human collaboration.</p> <p>Go forth and build amazing things!</p>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/","title":"MCP Lab Tasks - Lab 5","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-51-simple-prompt-template","title":"Exercise 5.1: Simple Prompt Template","text":"<p>Create a basic prompt template that generates greetings.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"greeting\") {\n    const { name: userName = \"World\" } = args || {};\n\n    return {\n      description: \"A friendly greeting prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Hello ${userName}! How are you doing today?`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-52-code-review-prompt","title":"Exercise 5.2: Code Review Prompt","text":"<p>Implement a prompt for code review assistance.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"code_review\") {\n    const { code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Code review assistant prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Please review the following ${language} code for:\\n- Code quality and best practices\\n- Potential bugs or issues\\n- Performance considerations\\n- Security concerns\\n\\nCode:\\n${code}\\n\\nPlease provide specific feedback and suggestions for improvement.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-53-sql-query-builder-prompt","title":"Exercise 5.3: SQL Query Builder Prompt","text":"<p>Create a prompt that helps build SQL queries.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"sql_builder\") {\n    const { table, columns, conditions } = args || {};\n\n    return {\n      description: \"SQL query building assistant\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Help me build an SQL query with the following requirements:\\n- Table: ${table || \"users\"}\\n- Columns: ${columns || \"name, email, created_at\"}\\n- Conditions: ${conditions || \"active = true\"}\\n\\nPlease provide the SQL query and explain what it does.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-54-documentation-generator-prompt","title":"Exercise 5.4: Documentation Generator Prompt","text":"<p>Implement a prompt that generates documentation.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_docs\") {\n    const { code, language = \"typescript\" } = args || {};\n\n    return {\n      description: \"Documentation generator prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Generate comprehensive documentation for the following ${language} code:\\n\\n${code}\\n\\nPlease include:\\n1. Function/class purpose\\n2. Parameters and return types\\n3. Usage examples\\n4. Important notes or caveats`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-55-error-analysis-prompt","title":"Exercise 5.5: Error Analysis Prompt","text":"<p>Create a prompt for analyzing error messages.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"error_analysis\") {\n    const { error_message, code_context } = args || {};\n\n    return {\n      description: \"Error analysis and debugging prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `I'm encountering this error:\\n\\n${error_message}\\n\\nCode context:\\n${code_context || \"No context provided\"}\\n\\nPlease help me:\\n1. Understand what this error means\\n2. Identify the likely cause\\n3. Suggest how to fix it\\n4. Provide preventive measures for similar errors`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-56-api-design-prompt","title":"Exercise 5.6: API Design Prompt","text":"<p>Implement a prompt for API design assistance.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"api_design\") {\n    const { resource, operations } = args || {};\n\n    return {\n      description: \"API design assistant prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Design a REST API for managing ${resource || \"users\"} with the following operations:\\n${operations || \"CRUD operations (Create, Read, Update, Delete)\"}\\n\\nPlease provide:\\n1. Endpoint definitions with HTTP methods\\n2. Request/response schemas\\n3. Error handling approach\\n4. Best practices recommendations`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-57-test-case-generator-prompt","title":"Exercise 5.7: Test Case Generator Prompt","text":"<p>Create a prompt that generates test cases.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_tests\") {\n    const { function_code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Test case generator prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Generate comprehensive test cases for this ${language} function:\\n\\n${function_code}\\n\\nPlease provide:\\n1. Unit tests for normal operation\\n2. Edge cases and error conditions\\n3. Integration test scenarios\\n4. Test framework code (Jest/Mocha for JS, pytest for Python, etc.)`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-58-performance-optimization-prompt","title":"Exercise 5.8: Performance Optimization Prompt","text":"<p>Implement a prompt for performance analysis.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"performance_tips\") {\n    const { code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Performance optimization prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Analyze this ${language} code for performance issues:\\n\\n${code}\\n\\nPlease identify:\\n1. Performance bottlenecks\\n2. Memory leaks or inefficiencies\\n3. Optimization opportunities\\n4. Recommended improvements with code examples`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-59-security-audit-prompt","title":"Exercise 5.9: Security Audit Prompt","text":"<p>Create a prompt for security code review.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"security_audit\") {\n    const { code, language = \"javascript\" } = args || {};\n\n    return {\n      description: \"Security audit prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Perform a security audit on this ${language} code:\\n\\n${code}\\n\\nCheck for:\\n1. Input validation vulnerabilities\\n2. Authentication/authorization issues\\n3. SQL injection or XSS vulnerabilities\\n4. Secure coding practices\\n5. Data exposure risks\\n\\nProvide specific recommendations for each issue found.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-510-database-schema-design-prompt","title":"Exercise 5.10: Database Schema Design Prompt","text":"<p>Implement a prompt for database design.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"db_schema\") {\n    const { entities, relationships } = args || {};\n\n    return {\n      description: \"Database schema design prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Design a database schema for:\\nEntities: ${entities || \"users, posts, comments\"}\\nRelationships: ${relationships || \"users have many posts, posts have many comments\"}\\n\\nPlease provide:\\n1. Table definitions with columns and types\\n2. Primary and foreign key relationships\\n3. Indexes for performance\\n4. Sample SQL DDL statements`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-511-refactoring-prompt","title":"Exercise 5.11: Refactoring Prompt","text":"<p>Create a prompt for code refactoring suggestions.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"refactor_code\") {\n    const { code, language = \"javascript\", issues } = args || {};\n\n    return {\n      description: \"Code refactoring prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Refactor this ${language} code to improve:\\n- Readability and maintainability\\n- Performance\\n- Following best practices\\n${issues ? `- Address these specific issues: ${issues}` : \"\"}\\n\\nOriginal code:\\n${code}\\n\\nPlease provide the refactored version with explanations of the changes.`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-512-deployment-strategy-prompt","title":"Exercise 5.12: Deployment Strategy Prompt","text":"<p>Implement a prompt for deployment planning.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"deployment_plan\") {\n    const { app_type, environment } = args || {};\n\n    return {\n      description: \"Deployment strategy prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Create a deployment strategy for a ${app_type || \"web application\"} to ${environment || \"production\"}.\\n\\nPlease include:\\n1. Infrastructure requirements\\n2. CI/CD pipeline setup\\n3. Environment configuration\\n4. Monitoring and logging\\n5. Rollback procedures\\n6. Scaling considerations`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-513-interview-question-generator-prompt","title":"Exercise 5.13: Interview Question Generator Prompt","text":"<p>Create a prompt that generates technical interview questions.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"interview_questions\") {\n    const { topic, level = \"intermediate\" } = args || {};\n\n    return {\n      description: \"Technical interview question generator\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Generate ${level} level interview questions for ${topic || \"JavaScript development\"}.\\n\\nPlease provide:\\n1. 5 conceptual questions\\n2. 3 coding problems with solutions\\n3. 2 system design questions\\n4. Expected answers or evaluation criteria for each`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-514-code-explanation-prompt","title":"Exercise 5.14: Code Explanation Prompt","text":"<p>Implement a prompt for explaining complex code.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"explain_code\") {\n    const { code, language = \"javascript\", audience = \"intermediate\" } = args || {};\n\n    return {\n      description: \"Code explanation prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Explain this ${language} code to an ${audience} developer:\\n\\n${code}\\n\\nPlease break down:\\n1. What the code does overall\\n2. Key components and their purposes\\n3. How the pieces fit together\\n4. Important concepts or patterns used\\n5. Potential improvements or alternatives`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab05-MCP-Prompts/lab5-tasks/#exercise-515-requirements-analysis-prompt","title":"Exercise 5.15: Requirements Analysis Prompt","text":"<p>Create a prompt for analyzing project requirements.</p> Solution <pre><code>server.setRequestHandler(\"prompts/get\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"requirements_analysis\") {\n    const { requirements, constraints } = args || {};\n\n    return {\n      description: \"Requirements analysis prompt\",\n      messages: [{\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Analyze these project requirements:\\n\\n${requirements || \"Build a user management system with authentication, profiles, and admin features.\"}\\n\\nConstraints: ${constraints || \"Must be web-based, support 1000 concurrent users, comply with GDPR.\"}\\n\\nPlease provide:\\n1. Functional requirements breakdown\\n2. Non-functional requirements\\n3. Technical feasibility assessment\\n4. Recommended technology stack\\n5. High-level architecture suggestions\\n6. Potential risks and mitigation strategies`\n        }\n      }]\n    };\n  }\n\n  throw new Error(`Unknown prompt: ${name}`);\n});\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/","title":"Complete MCP Server - Hands-On Lab","text":""},{"location":"Lab06-MCP-Workflow/lab/#mcp-server-structure-lab","title":"MCP Server Structure Lab","text":""},{"location":"Lab06-MCP-Workflow/lab/#lab-objective","title":"Lab Objective","text":"<ul> <li>In this hands-on lab, you\u2019ll build a complete MCP (Model Context Protocol) server from scratch.</li> <li>You\u2019ll learn how each component works by implementing it yourself, understanding why each piece is necessary, and seeing the complete architecture come together.</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher installed</li> <li>Basic understanding of Python programming</li> <li>Terminal/command line access</li> <li>Text editor or IDE</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#getting-started","title":"Getting Started","text":""},{"location":"Lab06-MCP-Workflow/lab/#step-1-create-your-project-file","title":"Step 1: Create Your Project File","text":"<ol> <li>Create a new file called <code>mcp_server.py</code></li> <li>Open it in your favorite text editor</li> <li>We\u2019ll build this server step by step!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#step-01-adding-imports","title":"Step 01: Adding Imports","text":"<ul> <li>Before we write any code, we need to understand what libraries we\u2019re using and why.</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#asyncio-asynchronous-io","title":"<code>asyncio</code> - Asynchronous I/O","text":"<p>asyncio</p>"},{"location":"Lab06-MCP-Workflow/lab/#definition","title":"Definition:","text":"<ul> <li><code>asyncio</code> is a Python library for writing concurrent code using the async/await syntax.</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#why","title":"Why:","text":"<ul> <li>Enables asynchronous programming in Python</li> <li>MCP servers handle multiple concurrent operations (I/O, requests) without blocking</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#usage","title":"Usage:","text":"<ul> <li><code>async</code>/<code>await</code> keywords, event loops, concurrent task execution</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#json-javascript-object-notation","title":"<code>json</code> - JavaScript Object Notation","text":"<p>json</p>"},{"location":"Lab06-MCP-Workflow/lab/#definition_1","title":"Definition:","text":"<ul> <li>JSON encoding/decoding for data serialization</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#why_1","title":"Why:","text":"<ul> <li>MCP uses JSON-RPC protocol; resources return JSON data</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#usage_1","title":"Usage:","text":"<ul> <li><code>json.dumps()</code> to serialize Python dicts, <code>json.loads()</code> to parse</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#typing-type-hints","title":"<code>typing</code> - Type Hints","text":"<p>typing</p>"},{"location":"Lab06-MCP-Workflow/lab/#definition_2","title":"Definition:","text":"<ul> <li>Type hints for better code documentation and IDE support</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#why_2","title":"Why:","text":"<ul> <li>Makes code more maintainable and catches type errors early</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#usage_2","title":"Usage:","text":"<ul> <li>Function parameters, return types (Any = any type, Optional = can be None)</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#mcpserver-core-mcp-server","title":"<code>mcp.server</code> - Core MCP Server","text":"<p>mcp.server</p>"},{"location":"Lab06-MCP-Workflow/lab/#definition_3","title":"Definition:","text":"<ul> <li>Core MCP Server class - the foundation of our server</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#why_3","title":"Why:","text":"<ul> <li>Provides all MCP protocol implementation and lifecycle management</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#usage_3","title":"Usage:","text":"<ul> <li>Create server instance, register handlers, manage connections</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#mcpserverstdio-standard-io-transport","title":"<code>mcp.server.stdio</code> - Standard I/O Transport","text":"<p>mcp.server.stdio</p>"},{"location":"Lab06-MCP-Workflow/lab/#definition_4","title":"Definition:","text":"<ul> <li>Standard Input/Output transport layer for MCP</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#why_4","title":"Why:","text":"<ul> <li>MCP servers communicate via stdio (standard in/out streams)</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#usage_4","title":"Usage:","text":"<ul> <li>Connects server to clients through stdin/stdout pipes</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#mcptypes-protocol-types","title":"<code>mcp.types</code> - Protocol Types","text":"<p>mcp.types</p>"},{"location":"Lab06-MCP-Workflow/lab/#definition_5","title":"Definition:","text":"<ul> <li>MCP protocol type definitions for structured data</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#why_5","title":"Why:","text":"<ul> <li>Type-safe definitions for all MCP primitives (tools, resources, prompts)</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#usage_5","title":"Usage:","text":"<ul> <li>Tool = executable functions, Resource = readable data, Prompt = templates, TextContent = text responses</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#sys-system-functions","title":"<code>sys</code> - System Functions","text":"<p>sys</p>"},{"location":"Lab06-MCP-Workflow/lab/#definition_6","title":"Definition:","text":"<ul> <li>System-specific parameters and functions</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#why_6","title":"Why:","text":"<ul> <li>Handle system exits, command-line arguments, and stdio streams</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#usage_6","title":"Usage:","text":"<ul> <li><code>sys.exit()</code> for graceful shutdown, <code>sys.stdin</code>/<code>stdout</code> for I/O</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#step-02-skeleton-code","title":"Step 02: Skeleton Code","text":""},{"location":"Lab06-MCP-Workflow/lab/#skeleton-01-imports","title":"Skeleton 01: <code>Imports</code>","text":"<ul> <li>Set the following imports inside the <code>mcp_server.py</code>:</li> </ul> <pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n</code></pre> <ul> <li>Create the <code>requirements.txt</code> file with the following content:</li> </ul> <pre><code>mcp\n</code></pre> <ul> <li>Install the MCP library:</li> </ul> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-02-class","title":"Skeleton 02: <code>Class</code>","text":"<ul> <li>Add thislass definition after the imports in your <code>mcp_server.py</code> file:</li> </ul> <pre><code>class CompleteMCPServer:\n    \"\"\"\n    A comprehensive MCP Server implementation showcasing all\n    - Enables clients to get ready-to-use prompts\n    - Connects prompt templates to actual content\n    protocol features.\n\n  This class demonstrates:\n\n    - Server initialization\n    - Tool registration and execution\n    - Resource management\n    - Prompt templates\n    - Defines the behavior of each prompt\n    - Handlers make prompts functional\n\n    - Request handling\n  \"\"\"\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-03-constructor","title":"Skeleton 03: <code>Constructor</code>","text":""},{"location":"Lab06-MCP-Workflow/lab/#method__init__-constructor","title":"Method<code>__init__</code> (Constructor)","text":"<p>Capabilities:</p> <pre><code>- Initializes the MCP Server instance\n- Creates the server object with name and version\n- Sets up the foundation for all MCP operations\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Prepares data structures for tools, resources, and prompts</li> </ul> <p>Why This Runs First:</p> <pre><code>- Constructor must run before any other methods\n- Creates the server object that all other methods will use\n- Defines the behavior of each prompt\n- Handlers make prompts functional\n</code></pre> <ul> <li>No other operations can occur without this initialization</li> <li>Sets up the basic state of the server</li> </ul> <ul> <li>Add this class definition after inside your <code>CompleteMCPServer</code> class:</li> </ul> <pre><code>def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#code-break-down","title":"Code break down:","text":"<ul> <li><code>Server(\"complete-mcp-server\")</code> creates the MCP server with a name</li> <li><code>self.data_store = {}</code> creates an empty dictionary for storing data</li> <li>This object will be used throughout all other methods</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-04-register-tools","title":"Skeleton 04: Register Tools","text":""},{"location":"Lab06-MCP-Workflow/lab/#methodregister_tools","title":"Method<code>register_tools</code>","text":"<p>Capabilities:</p> <pre><code>- Registers all available tools with the MCP server\n- Defines tool schemas (name, description, parameters)\n- Makes tools discoverable to clients\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Sets up the tool execution infrastructure</li> </ul> <p>Why This Runs Second:</p> <pre><code>- After server initialization, we need to define what tools are available\n- Defines the behavior of each prompt\n- Handlers make prompts functional\n</code></pre> <ul> <li>Tools must be registered before they can be called</li> <li>Defines the capabilities clients can invoke</li> </ul> <p>What is a Tool?</p> <ul> <li>A tool is an executable function that clients can invoke.</li> <li>Think of it like an API endpoint that performs an action.</li> <li>Tools have names, descriptions, and input parameters.</li> <li>Clients can discover and call these tools to perform operations.</li> <li>Examples: calculator, data storage, text processing</li> <li>Tools are central to MCP\u2019s functionality.</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n        \"\"\"\n        Return the list of available tools.\n        This is called when clients want to discover what tools are available.\n        \"\"\"\n        return [\n            Tool(\n                name=\"calculate\",\n                description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"operation\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                            \"description\": \"The operation to perform\"\n                        },\n                        \"a\": {\n                            \"type\": \"number\",\n                            \"description\": \"First number\"\n                        },\n                        \"b\": {\n                            \"type\": \"number\",\n                            \"description\": \"Second number\"\n                        }\n                    },\n                    \"required\": [\"operation\", \"a\", \"b\"]\n                }\n            ),\n            Tool(\n                name=\"store_data\",\n                description=\"Store a key-value pair in the server's data store\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"key\": {\n                            \"type\": \"string\",\n                            \"description\": \"The key to store\"\n                        },\n                        \"value\": {\n                            \"type\": \"string\",\n                            \"description\": \"The value to store\"\n                        }\n                    },\n                    \"required\": [\"key\", \"value\"]\n                }\n            ),\n            Tool(\n                name=\"retrieve_data\",\n                description=\"Retrieve a value from the server's data store\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"key\": {\n                            \"type\": \"string\",\n                            \"description\": \"The key to retrieve\"\n                        }\n                    },\n                    \"required\": [\"key\"]\n                }\n            ),\n            Tool(\n                name=\"echo\",\n                description=\"Echo back the input text\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"text\": {\n                            \"type\": \"string\",\n                            \"description\": \"Text to echo back\"\n                        }\n                    },\n                    \"required\": [\"text\"]\n                }\n            )\n        ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.list_tools()</code> decorator registers a handler for tool listing</li> <li>Each <code>Tool</code> object defines the tool\u2019s name, description, and input schema</li> <li>The <code>inputSchema</code> uses JSON Schema format to validate inputs</li> <li>When a client calls <code>list_tools()</code>, they get this list</li> <li>This makes the tools discoverable and usable by clients</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#hands-on-exercise","title":"Hands-On Exercise:","text":"<ul> <li>Add a new tool called <code>greeting</code> that takes a string input <code>name</code> and returns a greeting message.</li> <li>Define its name, description, and input schema similar to the other tools.</li> <li>Test it later when we implement tool handlers.</li> <li>Hint: Use the existing tools as a reference for structure.</li> <li>After adding, your <code>list_tools</code> method should include the new <code>greeting</code> tool.</li> <li>This exercise helps you understand how to define and register new tools in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Greeting Tool <pre><code>Tool(\n    name=\"greeting\",\n    description=\"Return a greeting message for the given name\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\n                \"type\": \"string\",\n                \"description\": \"The name to greet\"\n            }\n        },\n        \"required\": [\"name\"]\n    }\n)\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-05-tools-handlers","title":"Skeleton 05: Tool(s) Handlers","text":""},{"location":"Lab06-MCP-Workflow/lab/#methodregister_tool_handlers","title":"Method<code>register_tool_handlers</code>","text":"<p>Capabilities:</p> <pre><code>- Implements the actual logic for each tool\n- Handles tool execution requests from clients\n- Processes input parameters and returns results\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Provides error handling for tool execution</li> <li>Enables dynamic tool functionality</li> </ul> <p>Why This Runs Third:</p> <pre><code>- After tools are registered, we need to define what happens when\n- Defines the behavior of each prompt\n- Handlers make prompts functional\neach tool is called\n</code></pre> <ul> <li>Without handlers, tools are just definitions with no action</li> <li>Tools need implementation before they can be executed</li> <li>Connects tool schemas to actual functionality</li> <li>Defines the behavior of each tool</li> <li>Handlers make tools operational</li> <li>Clients rely on these handlers to perform tasks</li> <li>This is where the server\u2019s capabilities come to life</li> <li>Handlers are essential for a functional MCP server</li> <li>They bridge the gap between tool definition and execution</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n        \"\"\"\n        Handle tool execution requests.\n        This is called when a client wants to execute a tool.\n        \"\"\"\n        if name == \"calculate\":\n            operation = arguments.get(\"operation\")\n            a = arguments.get(\"a\")\n            b = arguments.get(\"b\")\n\n            if operation == \"add\":\n                result = a + b\n            elif operation == \"subtract\":\n                result = a - b\n            elif operation == \"multiply\":\n                result = a * b\n            elif operation == \"divide\":\n                if b == 0:\n                    return [TextContent(\n                        type=\"text\",\n                        text=\"Error: Cannot divide by zero\"\n                    )]\n                result = a / b\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown operation '{operation}'\"\n                )]\n\n            return [TextContent(\n                type=\"text\",\n                text=f\"Result: {a} {operation} {b} = {result}\"\n            )]\n\n        elif name == \"store_data\":\n            key = arguments.get(\"key\")\n            value = arguments.get(\"value\")\n            self.data_store[key] = value\n            return [TextContent(\n                type=\"text\",\n                text=f\"Stored: {key} = {value}\"\n            )]\n\n        elif name == \"retrieve_data\":\n            key = arguments.get(\"key\")\n            value = self.data_store.get(key)\n            if value is None:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Key '{key}' not found\"\n                )]\n            return [TextContent(\n                type=\"text\",\n                text=f\"Retrieved: {key} = {value}\"\n            )]\n\n        elif name == \"echo\":\n            text = arguments.get(\"text\")\n            return [TextContent(\n                type=\"text\",\n                text=f\"Echo: {text}\"\n            )]\n\n        else:\n            return [TextContent(\n                type=\"text\",\n                text=f\"Error: Unknown tool '{name}'\"\n            )]\n\n    print(\"Tool handlers implemented\")\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.call_tool()</code> decorator registers the execution handler</li> <li>Each tool\u2019s logic is in an <code>if/elif</code> block</li> <li>Results are wrapped in <code>TextContent</code> objects</li> <li>Error handling is included for edge cases (like division by zero)</li> <li>When a client calls a tool, this handler processes the request and returns the output</li> <li>This makes the tools functional and usable by clients</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#hands-on-exercise_1","title":"Hands-On Exercise:","text":"<ul> <li>Implement the handler logic for the <code>greeting</code> tool you added earlier.</li> <li>The tool should take the <code>name</code> parameter and return a greeting message like \u201cHello, {name}!\u201d.</li> <li>Test it later when we run the server.</li> <li>Hint: Follow the structure of the other tool handlers.</li> <li>After adding, your <code>call_tool</code> method should include the new <code>greeting</code> tool logic.</li> <li>This exercise helps you understand how to implement tool functionality in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Greeting Tool Handler <pre><code>elif name == \"greeting\":\n    name = arguments.get(\"name\")\n    return [TextContent(\n        type=\"text\",\n        text=f\"Hello, {name}!\"\n    )]\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-06-register-resources","title":"Skeleton 06: Register Resources","text":""},{"location":"Lab06-MCP-Workflow/lab/#methodregister_resources","title":"Method<code>register_resources</code>","text":"<p>Capabilities:</p> <pre><code>- Registers resources that clients can access\n- Defines resource URIs and metadata\n- Makes static and dynamic content available\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Enables resource discovery and retrieval</li> <li>Provides additional data for clients</li> <li>Supports richer interactions with the server</li> <li>Expands server capabilities beyond tools</li> <li> <p>Facilitates data sharing and information access</p> </li> <li> <p>Defines the behavior of each prompt</p> </li> <li>Handlers make prompts functional</li> </ul> <p>Why This Runs Fourth:   - After tools are set up, we add resources which provide additional data   - Resources are complementary to tools   - Provides data that tools might reference</p> <p>What is a Resource?</p> <ul> <li>A resource is readable data or content.</li> <li>Think of it like a file or endpoint you can read from (but not execute).</li> <li>Resources have URIs (like URLs) and metadata (name, description, MIME type).</li> <li>Clients can discover and read these resources.</li> <li>Examples: server info, data store contents, welcome message</li> <li>Resources enhance the server\u2019s functionality by providing static or dynamic data.</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n        \"\"\"\n        Return the list of available resources.\n        This is called when clients want to discover what resources are available.\n        \"\"\"\n        return [\n            Resource(\n                uri=\"resource://server-info\",\n                name=\"Server Information\",\n                description=\"Information about this MCP server\",\n                mimeType=\"application/json\"\n            ),\n            Resource(\n                uri=\"resource://data-store\",\n                name=\"Data Store\",\n                description=\"Current contents of the data store\",\n                mimeType=\"application/json\"\n            ),\n            Resource(\n                uri=\"resource://welcome\",\n                name=\"Welcome Message\",\n                description=\"Welcome message and server capabilities\",\n                mimeType=\"text/plain\"\n            )\n        ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.list_resources()</code> decorator registers the resource listing handler</li> <li>Each <code>Resource</code> defines a URI (like a URL), name, description, and MIME type</li> <li>URIs use the <code>resource://</code> scheme to identify resources</li> <li>When a client calls <code>list_resources()</code>, they get this list</li> <li>This makes the resources discoverable and accessible by clients</li> <li>Resources provide additional data that clients can read</li> <li>Enhances the server\u2019s capabilities beyond just tools</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#hands-on-exercise_2","title":"Hands-On Exercise:","text":"<ul> <li>Add a new resource called <code>server-author</code> that return your name as the author of the server.</li> <li>Define its URI, name, description, and MIME type similar to the other resources.</li> <li>Test it later when we implement resource handlers.</li> <li>Hint: Use the existing resources as a reference for structure.</li> <li>After adding, your <code>list_resources</code> method should include the new <code>server-author</code> resource.</li> <li>This exercise helps you understand how to define and register new resources in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Server Stats Resource <pre><code>Resource(\n    uri=\"resource://server-author\",\n    name=\"Server Author\",\n    description=\"Author of the MCP server\",\n    mimeType=\"text/plain\"\n)\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-07-resource-handlers","title":"Skeleton 07: Resource Handlers","text":""},{"location":"Lab06-MCP-Workflow/lab/#methodregister_resource_handlers","title":"Method<code>register_resource_handlers</code>","text":"<p>Capabilities:</p> <pre><code>- Implements resource retrieval logic\n- Returns actual content for each resource\n- Handles dynamic resource generation\n- Enables clients to get ready-to-use prompts\n- Connects prompt templates to actual content\n</code></pre> <ul> <li>Provides resource access control</li> <li>Enables clients to read server data</li> <li>Supports various content types (JSON, text)</li> <li>Facilitates data sharing with clients</li> <li>Connects resource definitions to actual data</li> <li>Enhances server usability and information access</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> </ul> <p>Why This Runs Fifth:</p> <ul> <li>After resources are registered, we need to implement what content is returned</li> <li>Resources need implementation to return actual data</li> <li>Connects resource URIs to actual content</li> <li>Defines the behavior of each resource</li> <li>Handlers make resources accessible</li> <li>Clients rely on these handlers to read data</li> <li>This is where resource definitions become functional</li> <li>Handlers are essential for a usable MCP server</li> <li>They bridge the gap between resource definition and content delivery</li> <li>Without handlers, resources are just placeholders with no data</li> <li>Handlers bring resources to life</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n        async def read_resource(uri: Any) -&gt; str:\n        \"\"\"\n        Handle resource read requests.\n        This is called when a client wants to read a resource.\n        \"\"\"\n        # Extract the URI string from the AnyUrl object\n        uri_str = str(uri)\n\n        if uri_str == \"resource://server-info\":\n            info = {\n                \"name\": \"complete-mcp-server\",\n                \"version\": \"1.0.0\",\n                \"description\": \"A comprehensive MCP server implementation\",\n                \"capabilities\": {\n                    \"tools\": 4,\n                    \"resources\": 3,\n                    \"prompts\": 2\n                }\n            }\n            return json.dumps(info, indent=2)\n\n        elif uri_str == \"resource://data-store\":\n            return json.dumps(self.data_store, indent=2)\n\n        elif uri_str == \"resource://welcome\":\n            return \"\"\"Welcome to the Complete MCP Server!\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.read_resource()</code> decorator registers the read handler</li> <li>Each resource URI returns appropriate content</li> <li>JSON resources use <code>json.dumps()</code> to serialize data</li> <li>Plain text resources return strings directly</li> <li>When a client reads a resource, this handler processes the request and returns the content</li> <li>This makes the resources functional and usable by clients</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#hands-on-exercise_3","title":"Hands-On Exercise:","text":"<ul> <li>Implement the handler logic for the <code>server-author</code> resource you added earlier.</li> <li>The resource should return your name as plain text.</li> <li>Test it later when we run the server.</li> <li>Hint: Follow the structure of the other resource handlers.</li> <li>After adding, your <code>read_resource</code> method should include the new <code>server-author</code> resource logic.</li> <li>This exercise helps you understand how to implement resource functionality in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Server Author Resource Handler <pre><code>elif uri_str == \"resource://server-author\":\n    return \"Author: Your Name Here\"\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#handle-errors","title":"Handle Errors","text":"<ul> <li>Add Error Handling for Unknown Resources</li> <li>Add this at the end of the <code>read_resource</code> method to handle unknown resources:</li> </ul> <pre><code>        else:\n            raise ValueError(f\"Unknown resource: {uri_str}\")\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-08-register-prompts","title":"Skeleton 08: Register Prompts","text":""},{"location":"Lab06-MCP-Workflow/lab/#method-register_prompts","title":"Method <code>register_prompts</code>","text":"<p>Capabilities:</p> <ul> <li>Registers prompt templates for clients</li> <li>Defines structured prompts with parameters</li> <li>Enables prompt discovery</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> <li>Provides reusable prompt patterns</li> <li>Facilitates advanced AI interactions</li> <li>Supports dynamic prompt generation</li> </ul> <p>Why This Runs Sixth:</p> <ul> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> <li>After tools and resources, prompts add higher-level interaction patterns</li> <li>Prompts build on available tools and resources</li> <li>Provides templates for AI assistants</li> </ul> <p>What is a Prompt?</p> <ul> <li>A prompt is a template that guides AI assistants on how to use the server\u2019s tools and resources effectively.</li> <li>Prompts have names, descriptions, and parameters.</li> <li>Clients can discover and request prompts.</li> <li>Examples: code review prompt, data analysis prompt</li> <li>Prompts enhance the server\u2019s capabilities by providing structured interaction patterns.</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>def register_prompts(self):\n    \"\"\"Register prompt templates for clients.\"\"\"\n\n    @self.server.list_prompts()\n    async def list_prompts() -&gt; list[Prompt]:\n        \"\"\"\n        Return the list of available prompts.\n        This is called when clients want to discover what prompts are available.\n        \"\"\"\n        return [\n            Prompt(\n                name=\"analyze-data\",\n                description=\"Analyze data stored in the server\",\n                arguments=[\n                    {\n                        \"name\": \"key\",\n                        \"description\": \"The key of the data to analyze\",\n                        \"required\": True\n                    }\n                ]\n            ),\n            Prompt(\n                name=\"calculate-scenario\",\n                description=\"Walk through a calculation scenario\",\n                arguments=[\n                    {\n                        \"name\": \"operation\",\n                        \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n                        \"required\": True\n                    }\n                ]\n            )\n        ]\n\n    print(\"Prompts registered: analyze-data, calculate-scenario\")\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.list_prompts()</code> decorator registers the prompt listing handler</li> <li>Each <code>Prompt</code> defines a name, description, and arguments</li> <li>Arguments specify what parameters the prompt template needs</li> <li>When a client calls <code>list_prompts()</code>, they get this list</li> <li>This makes the prompts discoverable and usable by clients</li> <li>Prompts provide structured templates for AI interactions</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#hands-on-exercise_4","title":"Hands-On Exercise:","text":"<ul> <li>Add a new prompt called <code>greet-user</code> that prompts the AI to greet a user by name.</li> <li>Define its name, description, and arguments similar to the other prompts.</li> <li>Test it later when we implement prompt handlers.</li> <li>Hint: Use the existing prompts as a reference for structure.</li> <li>After adding, your <code>list_prompts</code> method should include the new <code>greet-user</code> prompt.</li> <li>This exercise helps you understand how to define and register new prompts in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Greet User Prompt <pre><code>Prompt(\n    name=\"greet-user\",\n    description=\"Prompt the AI to greet a user by name\",\n    arguments=[\n        {\n            \"name\": \"name\",\n            \"description\": \"The name of the user to greet\",\n            \"required\": True\n        }\n    ]\n)\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-09-prompt-handlers","title":"Skeleton 09: Prompt Handlers","text":""},{"location":"Lab06-MCP-Workflow/lab/#method-register_prompt_handlers","title":"Method: <code>register_prompt_handlers</code>","text":"<p>Capabilities:</p> <ul> <li>Implements prompt generation logic</li> <li>Returns formatted prompts with embedded context</li> <li>Handles prompt parameters and customization</li> <li>Provides dynamic prompt content</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> </ul> <p>Why This Runs Seventh:</p> <ul> <li>After prompts are registered, we implement the logic that generates prompt content</li> <li>Prompts need implementation to generate actual text</li> <li>Connects prompt templates to actual content</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>def register_prompt_handlers(self):\n    \"\"\"Implement prompt generation logic.\"\"\"\n\n    @self.server.get_prompt()\n    async def get_prompt(name: str, arguments: dict) -&gt; list[TextContent]:\n        \"\"\"\n        Handle prompt generation requests.\n        This is called when a client wants to get a prompt.\n        \"\"\"\n        if name == \"analyze-data\":\n            key = arguments.get(\"key\", \"unknown\")\n            value = self.data_store.get(key, \"not found\")\n\n            prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            elif name == \"calculate-scenario\":\n                operation = arguments.get(\"operation\", \"add\")\n\n                prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n                return [TextContent(type=\"text\", text=prompt_text)]\n\n            else:\n                return [TextContent(\n                    type=\"text\",\n                    text=f\"Error: Unknown prompt '{name}'\"\n                )]\n\n        print(\"Prompt handlers implemented\")\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li>The <code>@self.server.get_prompt()</code> decorator registers the prompt generation handler</li> <li>Each prompt returns formatted text based on the parameters</li> <li>Prompts can reference tools and resources</li> <li>Dynamic content is generated based on current server state</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#hands-on","title":"Hands On:","text":"<ul> <li>Implement the handler logic for the <code>greet-user</code> prompt you added earlier.</li> <li>The prompt should return a greeting message using the provided <code>name</code> parameter.</li> <li>Test it later when we run the server.</li> <li>Hint: Follow the structure of the other prompt handlers.</li> <li>After adding, your <code>get_prompt</code> method should include the new <code>greet-user</code> prompt logic.</li> <li>This exercise helps you understand how to implement prompt functionality in the MCP server.</li> <li>Try to implement it on your own before looking at the solution below!</li> </ul> Solution for Greet User Prompt Handler <pre><code>elif name == \"greet-user\":\n    name = arguments.get(\"name\", \"Guest\")\n    prompt_text = f\"Hello, {name}! Welcome to the Complete MCP Server. How can I assist you today?\"\n    return [TextContent(type=\"text\", text=prompt_text)]\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-10-lifecycle-handlers","title":"Skeleton 10: Lifecycle Handlers","text":""},{"location":"Lab06-MCP-Workflow/lab/#method-setup_lifecycle_handlers","title":"Method: <code>setup_lifecycle_handlers</code>","text":"<p>Capabilities:</p> <ul> <li>Handles server initialization events</li> <li>Manages server shutdown procedures</li> <li>Logs server lifecycle events</li> <li>Ensures clean startup and teardown</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> <li>Maintains server stability and reliability</li> </ul> <p>Why This Runs Eighth:</p> <ul> <li>After all features are configured, we set up lifecycle management</li> <li>Lifecycle handlers need complete server setup</li> <li>Prepares server for actual runtime operations</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> <li>Ensures proper resource management during startup/shutdown</li> <li>Critical for long-running server processes</li> <li>Helps prevent resource leaks and data corruption</li> </ul> <p>Why Servers Need Shutdown Procedures:</p> <ul> <li>Release system resources (memory, file handles, connections)</li> <li>Save any pending data or state to disk</li> <li>Close network connections gracefully</li> <li>Notify connected clients of server shutdown</li> <li>Clean up temporary files and caches</li> <li>Log final statistics and status</li> <li>Prevent data corruption from abrupt termination</li> <li>Allow pending operations to complete</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>def setup_lifecycle_handlers(self):\n    \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n    print(\"Lifecycle management configured\")\n</code></pre> <p>Note</p> <ul> <li>Note: MCP servers typically don\u2019t have explicit lifecycle hooks</li> <li>This is a conceptual method showing where such logic would go</li> </ul> <p>Tip</p> <ul> <li>You can implement custom startup/shutdown logic here if needed</li> <li>Use this as a placeholder for lifecycle management</li> <li>The actual \u201clifecycle\u201d of the server is managed implicitly by:</li> <li>Startup: When <code>asyncio.run(main())</code> is called and <code>server.run()</code> begins the event loop.</li> <li>Shutdown: When the process receives a signal (like <code>KeyboardInterrupt / Ctrl+C</code>), which is caught in the if <code>__name__ == \"__main__\":</code> block to exit gracefully.</li> </ul> <p>What\u2019s Happening:</p> <ul> <li>MCP servers use the standard Python lifecycle</li> <li>Cleanup happens when the server process exits</li> <li>You can use <code>try/except/finally</code> blocks in the main function for cleanup</li> <li>This method is a placeholder for lifecycle logic</li> <li>In real-world servers, you might add logging or resource management here</li> <li>This prepares the server for stable operation</li> <li>Enhances reliability during startup and shutdown</li> <li>Critical for production-grade servers</li> <li>Though MCP lacks explicit lifecycle hooks, this method indicates where such logic would be placed</li> <li>It serves as a reminder to consider lifecycle management in server design</li> <li>Helps maintain server health over long runtimes</li> <li>Prepares for future enhancements that may introduce lifecycle events</li> <li>Ensures the server is robust and reliable</li> <li>Maintains server integrity during its lifecycle</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-11-run-the-server","title":"Skeleton 11: Run the Server","text":""},{"location":"Lab06-MCP-Workflow/lab/#method-run","title":"Method: <code>run</code>","text":"<ul> <li>This is the final method to add to your class.</li> <li>It starts the MCP server and begins listening for client requests.</li> </ul> <p>Capabilities:</p> <ul> <li>Starts the MCP server</li> <li>Connects to stdio transport</li> <li>Begins listening for client requests</li> <li>Runs the main event loop</li> <li>Enables clients to get ready-to-use prompts</li> <li>Connects prompt templates to actual content</li> <li>Facilitates real-time client-server communication</li> </ul> <p>Why This Runs Last:</p> <ul> <li>All tools, resources, and prompts must be registered first</li> <li>This starts the actual server operation</li> <li>After this, the server is live and accepting requests</li> <li>Defines the behavior of each prompt</li> <li>Handlers make prompts functional</li> <li>This is the final step to make the server operational</li> <li>Without this, the server would not run</li> <li>This method initiates the event loop that processes requests</li> <li>Critical for real-time interactions with clients</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#how-does-mcp-server-start","title":"How does MCP Server Start:","text":"<ol> <li>Create stdio transport: <code>stdio_server()</code></li> <li>Opens stdin (standard input) for receiving messages</li> <li> <p>Opens stdout (standard output) for sending responses</p> </li> <li> <p>Run server with streams: <code>server.run(read_stream, write_stream)</code></p> </li> <li>Listens on stdin for JSON-RPC messages from client</li> <li> <p>Sends JSON-RPC responses back on stdout</p> </li> <li> <p>Event loop processes requests asynchronously</p> </li> <li>Handles multiple concurrent requests</li> <li>Executes tools, returns resources, generates prompts</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#what-is-stdio-standard-inputoutput","title":"What is STDIO (Standard Input/Output)?","text":"Component Description stdio Standard Input/Output streams stdin Channel for receiving data (keyboard, pipe) stdout Channel for sending data (screen, pipe) Usage MCP uses stdio for client-server communication Flow Client stdin \u2192 Server stdout \u2192 Client"},{"location":"Lab06-MCP-Workflow/lab/#alternatives-to-stdio","title":"Alternatives to STDIO:","text":"Component Description HTTP/HTTPS Web-based API (REST or GraphQL) WebSockets Bidirectional real-time communication gRPC High-performance RPC framework Unix Domain Sockets Local inter-process communication TCP/IP Sockets Network communication <p>Why STDIO for MCP?</p> <ul> <li>\u2713 Simple: No network configuration needed</li> <li>\u2713 Secure: Stays within local process boundary</li> <li>\u2713 Universal: Works on all operating systems</li> <li>\u2713 Easy to integrate: Pipe to any process</li> <li>\u2713 Lightweight: Minimal overhead for communication</li> <li>\u2713 Ideal for local AI assistant integrations</li> <li>\u2713 Fits well with command-line tools and scripts</li> <li>\u2713 Perfect for development and testing</li> <li>\u2713 Common in LSP (Language Server Protocol) implementations</li> <li>\u2713 Easy to debug: View raw messages in terminal</li> <li>\u2713 No firewall or network issues</li> <li>\u2713 Works well with containerized environments</li> </ul> <p>Async Event Loop Explained:</p> <ul> <li>Event Loop: Central coordinator for async operations</li> <li>Async/Await: Write concurrent code that looks sequential</li> <li>Non-blocking: Server handles multiple requests simultaneously</li> <li>Efficient: Uses single thread for many connections</li> <li>Scalable: Easily handles growing workloads</li> </ul> <p>How It Works:</p> <ol> <li>Event loop starts and waits for events (<code>messages</code>)</li> <li>When message arrives, creates a Task to handle it</li> <li>While waiting for I/O ( <code>tool execution</code>), processes other tasks</li> <li>When task completes, sends response back to client</li> <li>Continues looping until server shuts down</li> <li>This allows high concurrency with minimal threads</li> </ol> <p>Benefits:</p> <ul> <li>\u2713 Handle 1000s of connections with single thread</li> <li>\u2713 No waiting: Process other requests during I/O</li> <li>\u2713 Memory efficient: No thread per connection</li> <li>\u2713 Scalable: Add more tasks without more threads</li> <li>\u2713 Responsive: Quick handling of many clients</li> <li>\u2713 Ideal for I/O-bound workloads (like MCP servers)</li> <li>\u2713 Simplifies concurrency model</li> <li>\u2713 Reduces complexity of multi-threaded code</li> <li>\u2713 Easier to maintain and debug</li> <li>\u2713 Leverages Python\u2019s async capabilities effectively</li> </ul> <ul> <li>Add this method to your class:</li> </ul> <pre><code>async def run(self):\n    \"\"\"Start the MCP server and begin serving requests.\"\"\"\n    print(\"Starting MCP server...\")\n    print(\"Server is now running and ready to accept connections\")\n\n    async with stdio_server() as (read_stream, write_stream):\n        await self.server.run(\n            read_stream,\n            write_stream,\n            self.server.create_initialization_options()\n        )\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li><code>stdio_server()</code> creates the stdin/stdout transport</li> <li><code>self.server.run()</code> starts the server event loop</li> <li>The server now listens for JSON-RPC messages on stdin</li> <li>Responses are sent back on stdout</li> <li>The server can now handle tool calls, resource reads, and prompt requests</li> <li>This is the final step to make the server operational</li> <li>The server runs indefinitely until interrupted</li> <li>Clients can now connect and interact with the server</li> <li>This method is asynchronous, allowing concurrent request handling</li> <li>The server is now live and ready for use</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-12-rag","title":"Skeleton 12: RAG","text":"<p>What is RAG?</p> <ul> <li>RAG = Retrieval Augmented Generation</li> <li>A technique that enhances AI responses by retrieving relevant information from a knowledge base before generating answers</li> <li>Think of it like giving the AI access to a reference library</li> <li>Combines information retrieval with text generation</li> <li>Enables accurate, context-aware responses based on specific data</li> <li>Examples: Customer support bots, domain-specific Q&amp;A systems, documentation assistants</li> <li>Critical for providing factually accurate responses from your own data sources</li> </ul> <p>Why Add RAG to Your MCP Server?</p> <ul> <li>Makes your server more intelligent and context-aware</li> <li>Allows retrieval of relevant information from local data sources</li> <li>Provides accurate responses based on your specific domain knowledge</li> <li>Enables filtering and querying of structured data</li> <li>Enhances the server\u2019s ability to answer domain-specific questions</li> <li>No heavy vector database dependencies required for simple implementations</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#1-install-dependencies","title":"1. Install Dependencies","text":"<ul> <li>No heavy dependencies (like vector databases) are required for this simple implementation.</li> <li>We will use standard Python libraries.</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#2-update-the-mcp-server","title":"2. Update the MCP Server","text":"<ul> <li>Open your MCP server file and add the following imports and initialization code to set up a simple in-memory users.</li> <li>We will also add a helper function to load data from a CSV file.</li> </ul> <pre><code>import csv\n\n# Initialize an in-memory users\nusers = []\n\ndef load_users(csv_file_path: str):\n    \"\"\"Load users from a CSV file.\"\"\"\n    global users\n    users = []\n\n    try:\n        with open(csv_file_path, 'r', encoding='utf-8') as f:\n            reader = csv.DictReader(f)\n            for i, row in enumerate(reader):\n                # Load all fields from the CSV\n                first_name = row.get('first_name', '')\n                last_name = row.get('last_name', '')\n                age = row.get('age', '')\n                city = row.get('city', '')\n\n                # Create full name and content\n                full_name = f\"{first_name} {last_name}\".strip()\n                content = f\"{full_name} from {city}\" if city else full_name\n\n                # Create user dict with all available fields\n                user = {\n                    \"id\": str(i + 1),\n                    \"first_name\": first_name,\n                    \"last_name\": last_name,\n                    \"full_name\": full_name,\n                    \"content\": content,\n                    \"age\": age,\n                    \"city\": city\n                }\n                users.append(user)\n\n        print(f\"Loaded {len(users)} users from CSV.\")\n    except Exception as e:\n        print(f\"Error loading users: {e}\")\n\n# Load the users\n# Make sure you have a 'users.csv' file in the same directory\n# Format: first_name,last_name,city,age\nload_users(\"users.csv\")\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#3-register-the-rag-tools","title":"3. Register the RAG Tool(s)","text":"<ul> <li>Add new tools to your MCP server that allow the agent to query this collection using simple keyword matching.</li> <li>Here are two example tools: one to filter users by city and another to filter users by age.</li> <li>Add these tool definitions to the list in your <code>register_tools</code> method (inside the <code>list_tools</code> return array):</li> </ul> <pre><code>Tool(\n    name=\"filter_users_by_city\",\n    description=\"Filter and return users who live in a specific city\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"city\": {\n                \"type\": \"string\",\n                \"description\": \"The city to filter users by\"\n            }\n        },\n        \"required\": [\"city\"]\n    }\n),\nTool(\n    name=\"filter_users_by_age\",\n    description=\"Filter and return users who are older than the specified minimum age\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"min_age\": {\n                \"type\": \"number\",\n                \"description\": \"The minimum age to filter users by\"\n            }\n        },\n        \"required\": [\"min_age\"]\n    }\n)\n</code></pre> <ul> <li>Then add the corresponding handlers in your <code>register_tool_handlers</code> method (inside the <code>call_tool</code> function):</li> </ul> <pre><code>elif name == \"filter_users_by_city\":\n    city = arguments.get(\"city\", \"\")\n    filtered_users = []\n    target_city = city.lower().strip()\n\n    for user in users:\n        # Get city from user dict\n        u_city = user.get(\"city\", \"\").lower().strip()\n\n        if u_city == target_city:\n            full_name = user.get('full_name', 'Unknown')\n            age = user.get('age', 'N/A')\n            filtered_users.append(f\"User {user.get('id')}: {full_name}, Age: {age}, City: {user.get('city')}\")\n\n    if not filtered_users:\n        result = f\"No users found in {city}.\"\n    else:\n        result = \"\\n\".join(filtered_users)\n\n    return [TextContent(type=\"text\", text=result)]\n\nelif name == \"filter_users_by_age\":\n    min_age = int(arguments.get(\"min_age\", 0))\n    filtered_users = []\n\n    for user in users:\n        # Get age from user dict\n        u_age = user.get(\"age\", \"\")\n\n        # Skip if no age\n        if not u_age:\n            continue\n\n        try:\n            u_age = int(u_age)\n        except (ValueError, TypeError):\n            continue\n\n        if u_age &gt; min_age:\n            full_name = user.get('full_name', 'Unknown')\n            city = user.get('city', 'Unknown')\n            filtered_users.append(f\"User {user.get('id')}: {full_name}, Age: {u_age}, City: {city}\")\n\n    if not filtered_users:\n        result = f\"No users found older than {min_age}.\"\n    else:\n        result = \"\\n\".join(filtered_users)\n\n    return [TextContent(type=\"text\", text=result)]\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#4-test-the-rag-capabilities","title":"4. Test the RAG Capabilities","text":"<ol> <li>Restart your MCP server.</li> <li>Use the MCP Inspector or Client to call <code>query_users</code> with a question like \u201cWhat is a Pod?\u201d.</li> <li>Verify that the tool returns the specific definition we added to the database.</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#skeleton-13-roots","title":"Skeleton 13: Roots","text":""},{"location":"Lab06-MCP-Workflow/lab/#skeleton-14-main-entry-point","title":"Skeleton 14: Main / Entry Point","text":"<p>What is the Main Entry Point?</p> <ul> <li>The main entry point is the starting point of your Python script</li> <li>It\u2019s the function that orchestrates the entire server setup and execution</li> <li>Think of it like the conductor of an orchestra - it coordinates all the pieces</li> <li>The <code>main()</code> function calls all setup methods in the correct order</li> <li>The <code>if __name__ == \"__main__\"</code> block is what runs when you execute the script directly</li> <li>Examples: Starts server, initializes components, handles graceful shutdown</li> <li>Essential for any Python application that needs to run as a standalone program</li> </ul> <p>Why This is Important:</p> <ul> <li>Ensures all components are initialized in the correct order</li> <li>Provides a clear execution flow that\u2019s easy to understand</li> <li>Handles errors and graceful shutdown (like Ctrl+C)</li> <li>Makes your code modular and testable</li> <li>Standard Python pattern for executable scripts</li> <li>Without this, your server would just be a collection of classes with no way to run</li> </ul> <p>Orchestration Order:</p> <ol> <li>Create server instance (constructor)</li> <li>Register tools</li> <li>Register tool handlers</li> <li>Register resources</li> <li>Register resource handlers</li> <li>Register prompts</li> <li>Register prompt handlers</li> <li>Setup lifecycle handlers</li> <li>Run the server</li> </ol> <ul> <li>Now we need to create the main function that orchestrates everything and the entry point that runs when the script is executed.</li> <li>This is where we call all the setup methods in order and start the server.</li> <li>This is the final piece to complete your MCP server implementation.</li> <li>Let\u2019s add the main function and entry point.</li> </ul> <ul> <li>Add these functions at the end of your file (outside the class):</li> </ul> <pre><code>async def main():\n    \"\"\"\n    Main entry point for the MCP server.\n\n    This function orchestrates the complete server setup and execution:\n    1. Creates server instance (constructor)\n    2. Registers tools\n    3. Registers tool handlers\n    4. Registers resources\n    5. Registers resource handlers\n    6. Registers prompts\n    7. Registers prompt handlers\n    8. Sets up lifecycle handlers\n    9. Runs the server\n    \"\"\"\n    print(\"=\"*80)\n    print(\"\ud83c\udf1f COMPLETE MCP SERVER - STARTING\")\n    print(\"=\"*80)\n\n    # Step 1: Create server instance\n    server = CompleteMCPServer()\n\n    # Step 2: Register tools\n    server.register_tools()\n\n    # Step 3: Register tool handlers\n    server.register_tool_handlers()\n\n    # Step 4: Register resources\n    server.register_resources()\n\n    # Step 5: Register resource handlers\n    server.register_resource_handlers()\n\n    # Step 6: Register prompts\n    server.register_prompts()\n\n    # Step 7: Register prompt handlers\n    server.register_prompt_handlers()\n\n    # Step 8: Setup lifecycle handlers\n    server.setup_lifecycle_handlers()\n\n    print(\"=\"*80)\n    print(\"All components registered successfully!\")\n    print(\"=\"*80)\n\n    # Step 9: Run the server\n    await server.run()\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Entry point when script is run directly.\n\n    This runs when you execute: python mcp_server.py\n    \"\"\"\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\n\ud83d\udc4b Server shutdown complete\")\n        sys.exit(0)\n</code></pre> <p>What\u2019s Happening:</p> <ul> <li>The <code>main()</code> function calls all setup methods in order</li> <li>The <code>if __name__ == \"__main__\"</code> block runs when the script is executed</li> <li><code>asyncio.run(main())</code> starts the async event loop</li> <li><code>KeyboardInterrupt</code> handler allows graceful shutdown with Ctrl+C</li> <li>This is the final orchestration of the MCP server</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#code-review","title":"Code Review","text":"<p>At this point, your <code>mcp_server.py</code> file should have:</p> <ol> <li>All imports at the top</li> <li><code>CompleteMCPServer</code> class with all 9 methods</li> <li><code>main()</code> function</li> <li>Entry point with <code>if __name__ == \"__main__\"</code></li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#testing-with-mcp-inspector","title":"Testing with MCP Inspector","text":"<ul> <li>Now that you\u2019ve built your complete MCP server, it\u2019s time to test it!</li> <li>We\u2019ll use MCP Inspector, a web-based tool for debugging MCP servers.</li> <li>Follow the steps below to install MCP Inspector, run your server, and test all the tools, resources, and prompts you implemented.</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#what-is-mcp-inspector","title":"What is MCP Inspector?","text":"<p>MCP Inspector is a web-based debugging tool for MCP servers. Think of it like a browser developer console for your MCP server - it lets you:</p> <ul> <li>Connect to your server</li> <li>See all available tools, resources, and prompts</li> <li>Execute tools with custom parameters</li> <li>Read resources</li> <li>Generate prompts</li> <li>View JSON-RPC messages</li> <li>Debug server behavior</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#installing-mcp-inspector","title":"Installing MCP Inspector","text":"<p>Open a terminal and run:</p> <pre><code># Install MCP Inspector globally\nnpm install -g @modelcontextprotocol/inspector\n\n# Run the MCP Inspector\nnpx @modelcontextprotocol/inspector python3 \"mcp_server.py\"\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#testing-your-tools","title":"Testing Your Tools","text":"<p>Follow these steps in the MCP Inspector:</p>"},{"location":"Lab06-MCP-Workflow/lab/#test-01-connect-to-the-server","title":"Test 01: Connect to the Server","text":"<ol> <li>Click the \u201cConnect\u201d button at the bottom left of the interface</li> <li>Wait for the connection status to show \u201cConnected\u201d (green indicator)</li> <li>If not connected, set the following:</li> <li>transport: <code>stdio</code></li> <li>Command: <code>python3</code></li> <li>Arguments: <code>mcp_server.py</code></li> <li>Click \u201cConnect\u201d again</li> <li>You should see the server name and version in the top right corner</li> <li>Success!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-02-explore-tools","title":"Test 02: Explore Tools","text":"<ol> <li>Click the \u201cTools\u201d tab in the upper menu</li> <li>Click \u201cList tools\u201d to see all available tools</li> <li>You should see: <code>calculate</code>, <code>store_data</code>, <code>retrieve_data</code>, <code>echo</code> + RAG tools if added</li> <li>If you added the <code>greeting</code> tool, you should see that too!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-03-test-the-calculate-tool","title":"Test 03: Test the Calculate Tool","text":"<ol> <li>Click on \u201ccalculate\u201d in the tools list</li> <li>The tool interface opens on the right side</li> <li>Fill in the parameters:</li> <li>operation: Select \u201cadd\u201d from the dropdown<ul> <li>a: Enter <code>10</code></li> <li>b: Enter <code>5</code></li> </ul> </li> <li>Click \u201cRun Tool\u201d</li> <li>Scroll down to see the result: <code>\"Result: 10 add 5 = 15\"</code></li> <li>Success!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-04-test-the-store-data-tool","title":"Test 04: Test the Store Data Tool","text":"<ol> <li>Click on \u201cstore_data\u201d in the tools list</li> <li>Fill in the parameters:</li> <li>key: Enter <code>username</code></li> <li>value: Enter <code>Alice</code></li> <li>Click \u201cRun Tool\u201d</li> <li>Result: <code>\"Stored: username = Alice\"</code></li> <li>Try storing another key-value pair to see it works!</li> <li>Success!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-05-test-the-retrieve-data-tool","title":"Test 05: Test the Retrieve Data Tool","text":"<ol> <li>Click on \u201cretrieve_data\u201d in the tools list</li> <li>Fill in the parameter:</li> <li>key: Enter <code>username</code></li> <li>Click \u201cRun Tool\u201d</li> <li>Result: <code>\"Retrieved: username = Alice\"</code></li> <li>Try retrieving a non-existent key to see error handling!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-06-test-the-echo-tool","title":"Test 06: Test the Echo Tool","text":"<ol> <li>Click on \u201cecho\u201d in the tools list</li> <li>Fill in the parameter:</li> <li>text: Enter <code>Hello, MCP World!</code></li> <li>Click \u201cRun Tool\u201d</li> <li>Result: <code>\"Echo: Hello, MCP World!\"</code></li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-07-test-resources","title":"Test 07: Test Resources","text":"<ol> <li>Click the \u201cResources\u201d tab in the upper menu</li> <li>Click \u201cList resources\u201d to see all available resources</li> <li>You should see: <code>server-info</code>, <code>data-store</code>, <code>welcome</code></li> <li>If you added the <code>server-author</code> resource, you should see that too!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-resource-server-info","title":"Test Resource: server-info","text":"<ol> <li>Click on \u201cresource://server-info\u201d</li> <li>View the JSON response showing server metadata</li> <li>Notice it shows 4 tools, 3 resources, 2 prompts</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-resource-data-store","title":"Test Resource: data-store","text":"<ol> <li>Click on \u201cresource://data-store\u201d</li> <li>View the current contents of the data store</li> <li>You should see the <code>username: Alice</code> you stored earlier!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-resource-welcome","title":"Test Resource: welcome","text":"<ol> <li>Click on \u201cresource://welcome\u201d</li> <li>View the welcome message explaining server capabilities</li> <li>If you added the <code>server-author</code> resource, click on it to see your name displayed</li> <li>Success!</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-08-testing-your-prompts","title":"Test 08: Testing Your Prompts","text":"<ol> <li>Click the \u201cPrompts\u201d tab in the upper menu</li> <li>Click \u201cList prompts\u201d to see all available prompts</li> <li>You should see: <code>analyze-data</code>, <code>calculate-scenario</code></li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-prompt-calculate-scenario","title":"Test Prompt: calculate-scenario","text":"<ol> <li>Click on \u201ccalculate-scenario\u201d</li> <li>Fill in the argument:</li> <li>operation: Enter <code>multiply</code></li> <li>Click \u201cGet Prompt\u201d</li> <li>View the generated prompt that explains how to use the calculate tool</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#test-prompt-analyze-data","title":"Test Prompt: analyze-data","text":"<ol> <li>Click on \u201canalyze-data\u201d</li> <li>Fill in the argument:</li> <li>key: Enter <code>username</code></li> <li>Click \u201cGet Prompt\u201d</li> <li>View the generated prompt that analyzes the stored data</li> </ol>"},{"location":"Lab06-MCP-Workflow/lab/#understanding-the-inspector-interface","title":"Understanding the Inspector Interface","text":"<p>Left Panel: Navigation</p> <ul> <li>Tools, Resources, Prompts tabs</li> <li>List and select items to test</li> </ul> <p>Right Panel: Details</p> <ul> <li>Shows selected item details</li> <li>Input forms for parameters</li> <li>Execute button</li> <li>Results display</li> </ul> <p>Bottom Panel: JSON-RPC Messages</p> <ul> <li>Shows raw protocol messages</li> <li>Useful for debugging</li> <li>See requests and responses</li> </ul> <p>Connection Status</p> <ul> <li>Top right corner</li> <li>Green = Connected</li> <li>Red = Disconnected</li> <li>Shows server name and version</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#advanced-experiments","title":"Advanced Experiments","text":"<ul> <li>Now that you have a working server, try these challenges:</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#challenge-1-modify-the-calculate-tool","title":"Challenge 1: Modify the Calculate Tool","text":"<p>Add support for:</p> <ul> <li><code>power</code> operation (a^b)</li> <li><code>modulus</code> operation (a % b)</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#challenge-2-add-roots","title":"Challenge 2: Add Roots","text":"<p>Add support for:</p> <ul> <li>Listing files in a directory (referencing client roots)</li> <li>Reading file contents (referencing client roots)</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#bonus-task-hands-on-exercise","title":"Bonus Task: Hands-On Exercise","text":""},{"location":"Lab06-MCP-Workflow/lab/#add-pagination-support-for-listing-users","title":"Add Pagination Support for Listing Users","text":"<p>Objective: Implement a new tool called <code>list_all_users</code> that returns all users with pagination support.</p> <p>Requirements:</p> <ol> <li>Tool Name: <code>list_all_users</code></li> <li>Parameters:</li> <li><code>page</code> (optional, default: 1) - The page number to retrieve</li> <li><code>per_page</code> (optional, default: 10) - Number of users per page</li> <li>Functionality:</li> <li>Return users for the specified page</li> <li>Include metadata: total users, total pages, current page</li> <li>Handle edge cases (invalid page numbers, empty results)</li> </ol> <p>Your Task:</p> <ol> <li>Add the tool definition to <code>register_tools()</code> method</li> <li>Implement the tool handler in <code>register_tool_handlers()</code> method</li> <li>Test your implementation using MCP Inspector</li> </ol> <p>Hints:</p> <ul> <li>Use Python\u2019s list slicing for pagination: <code>users[start:end]</code></li> <li>Calculate start index: <code>(page - 1) * per_page</code></li> <li>Calculate total pages: <code>math.ceil(len(users) / per_page)</code></li> <li>Return both the user list and metadata</li> </ul>"},{"location":"Lab06-MCP-Workflow/lab/#walkthrough-solution","title":"Walkthrough Solution","text":""},{"location":"Lab06-MCP-Workflow/lab/#step-1-add-tool-definition","title":"Step 1: Add Tool Definition","text":"Click here for the solution  Add this to your `register_tools()` method in the tools list:  <pre><code>Tool(\n    name=\"list_all_users\",\n    description=\"List all users with pagination support\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"page\": {\n                \"type\": \"number\",\n                \"description\": \"Page number (default: 1)\",\n                \"default\": 1\n            },\n            \"per_page\": {\n                \"type\": \"number\",\n                \"description\": \"Number of users per page (default: 10)\",\n                \"default\": 10\n            }\n        }\n    }\n)\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#step-2-add-tool-handler","title":"Step 2: Add Tool Handler","text":"Click here for the solution  Add this to your `register_tool_handlers()` method in the `call_tool` function:      <pre><code>elif name == \"list_all_users\":\n    import math\n\n    # Get pagination parameters\n    page = int(arguments.get(\"page\", 1))\n    per_page = int(arguments.get(\"per_page\", 10))\n\n    # Validate parameters\n    if page &lt; 1:\n        page = 1\n    if per_page &lt; 1:\n        per_page = 10\n    if per_page &gt; 100:  # Max limit\n        per_page = 100\n\n    # Calculate pagination\n    total_users = len(users)\n    total_pages = math.ceil(total_users / per_page) if total_users &gt; 0 else 1\n\n    # Ensure page doesn't exceed total pages\n    if page &gt; total_pages:\n        page = total_pages\n\n    # Calculate slice indices\n    start_idx = (page - 1) * per_page\n    end_idx = start_idx + per_page\n\n    # Get paginated users\n    paginated_users = users[start_idx:end_idx]\n\n    # Format output\n    user_list = []\n    for user in paginated_users:\n        full_name = user.get('full_name', 'Unknown')\n        age = user.get('age', 'N/A')\n        city = user.get('city', 'Unknown')\n        user_list.append(f\"User {user.get('id')}: {full_name}, Age: {age}, City: {city}\")\n\n    # Build result with metadata\n    metadata = f\"Page {page} of {total_pages} | Total Users: {total_users} | Showing: {len(paginated_users)}\"\n    result = f\"{metadata}\\n\\n\" + \"\\n\".join(user_list)\n\n    return [TextContent(type=\"text\", text=result)]\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#step-3-test-in-mcp-inspector","title":"Step 3: Test in MCP Inspector","text":"<ol> <li>Restart your MCP server</li> <li>Open MCP Inspector</li> <li>Go to the Tools tab</li> <li>Click on \u201clist_all_users\u201d</li> <li>Test with different parameters:</li> <li>Default (page: 1, per_page: 10)</li> <li>Page 2 with 5 users per page</li> <li>Page 5 with 20 users per page</li> </ol> <p>Expected Output Format:</p> <pre><code>Page 1 of 10 | Total Users: 100 | Showing: 10\n\nUser 1: James Smith, Age: 24, City: New York\nUser 2: Maria Garcia, Age: 31, City: Los Angeles\n...\n</code></pre>"},{"location":"Lab06-MCP-Workflow/lab/#congratulations","title":"Congratulations! \ud83c\udf89","text":"<p>You\u2019ve successfully built a complete MCP server with:</p> <ul> <li>Multiple tools (calculate, data storage, echo, user filters, pagination)</li> <li>Resources (server info, data store, welcome message)</li> <li>Prompts (data analysis, calculation scenarios)</li> <li>RAG capabilities (user filtering and search)</li> <li>Pagination support (bonus feature)</li> </ul> <p>Keep exploring and building more advanced MCP servers!</p>"},{"location":"Lab07-MCP-Ollama/lab/","title":"Complete MCP Server with Ollama Integration - Hands-On Lab","text":""},{"location":"Lab07-MCP-Ollama/lab/#lab-objective","title":"Lab Objective","text":"<ul> <li>In this hands-on lab, you\u2019ll build a complete MCP (Model Context Protocol) server from scratch with Ollama integration.</li> <li>You\u2019ll learn how each component works by implementing it yourself, understanding why each piece is necessary, and seeing the complete architecture come together.</li> <li>You\u2019ll implement advanced tools: Country Information with RAG (Retrieval-Augmented Generation) using separate CSV-based databases for different information types covering all 193 UN member states, File Operations, and Database Query, along with best practices for error handling, async operations, and tool composition.</li> </ul> <p>Important Instructions</p> <ul> <li>This lab is designed to be followed step-by-step.</li> <li>Each code block builds upon the previous ones.</li> <li>Do not copy all code blocks at once, as this may lead to duplicate methods or incorrect structure.</li> <li>Follow the instructions sequentially, updating existing code as indicated.</li> </ul>"},{"location":"Lab07-MCP-Ollama/lab/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>Python 3.10</code> or higher installed</li> <li><code>Ollama</code> installed and running locally with models available (e.g., llama3.2)</li> <li>Basic knowledge of <code>MCP</code> concepts</li> <li>Basic understanding of <code>REST APIs</code> and <code>JSON</code></li> <li>Familiarity with <code>CSV</code> files and data handling</li> <li>Basic understanding of <code>Python</code> programming</li> <li>Terminal / command line (<code>CLI</code>) access</li> <li>Text editor or IDE (<code>VS Code</code> is recommended)</li> </ul>"},{"location":"Lab07-MCP-Ollama/lab/#step-00-getting-started","title":"Step 00: Getting Started","text":"<ol> <li>Create a new file called <code>mcp_ollama.py</code> as your project file, inside the lab\u2019s directory.</li> <li>Open it in your chosen text editor.</li> <li>See the following CSV files, containing data of all 193 UN member states, have been created for you in the lab\u2019s directory (you can open these files in VSCode etc.):</li> </ol> File Columns Description <code>capitals.csv</code> <code>country</code>, <code>capital</code> Capital cities of countries <code>population.csv</code> <code>country</code>, <code>population</code> Population data <code>height.csv</code> <code>country</code>, <code>height</code> Average topographic height in meters <code>foundation_year.csv</code> <code>country</code>, <code>foundation_year</code> Year the country was founded <ol> <li>Important: Ensure all CSV files are in the same directory as your <code>mcp_ollama.py</code> file, as the code loads them from the current working directory.</li> <li>Create a file named <code>requirements.txt</code> with the following content, inside the lab\u2019s directory:</li> </ol> <pre><code>mcp&gt;=0.1.0\nollama&gt;=0.1.0\npandas&gt;=1.3.0\nrequests&gt;=2.25.0\n</code></pre> <ol> <li>Install the dependencies by running the following from the same directory as your <code>requirements.txt</code> file, inside the lab\u2019s directory:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-01-adding-imports","title":"Step 01: Adding Imports","text":"<ul> <li>Before we write any code, we need to understand which Python libraries we\u2019ll be using, and why.</li> </ul>"},{"location":"Lab07-MCP-Ollama/lab/#asyncio-asynchronous-io","title":"<code>asyncio</code> - Asynchronous I/O","text":"<p>asyncio</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition","title":"Definition:","text":"<pre><code>- A library for writing concurrent code using the async/await syntax.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why","title":"Why:","text":"<pre><code>- Enables non-blocking I/O operations, crucial for handling multiple client requests simultaneously without freezing the server.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage","title":"Usage:","text":"<pre><code>- Used for async functions, event loops, and coordinating concurrent tasks in the MCP server.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#json-javascript-object-notation","title":"<code>json</code> - JavaScript Object Notation","text":"<p>json</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_1","title":"Definition:","text":"<pre><code>- A module for parsing and generating JSON data.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_1","title":"Why:","text":"<pre><code>- MCP uses JSON-RPC for communication between clients and servers.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_1","title":"Usage:","text":"<pre><code>- Serializing/deserializing data sent over stdio transport.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#typing-type-hints","title":"<code>typing</code> - Type Hints","text":"<p>typing</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_2","title":"Definition:","text":"<pre><code>- Provides runtime support for type hints.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_2","title":"Why:","text":"<pre><code>- Improves code readability, enables better IDE support, and catches type-related errors early.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_2","title":"Usage:","text":"<pre><code>- Defining function signatures and data structures with proper types.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#mcpserver-core-mcp-server","title":"<code>mcp.server</code> - Core MCP Server","text":"<p>mcp.server</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_3","title":"Definition:","text":"<pre><code>- The main server class for implementing MCP servers.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_3","title":"Why:","text":"<pre><code>- Provides the framework for registering tools, resources, and prompts, and handling client requests.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_3","title":"Usage:","text":"<pre><code>- Creating the server instance and setting up request handlers.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#mcpserverstdio-standard-io-transport","title":"<code>mcp.server.stdio</code> - Standard I/O Transport","text":"<p>mcp.server.stdio</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_4","title":"Definition:","text":"<pre><code>- Transport layer for communication via standard input/output streams.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_4","title":"Why:","text":"<pre><code>- Enables MCP servers to communicate with clients through stdin/stdout, making them easily integrable with various applications.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_4","title":"Usage:","text":"<pre><code>- Establishing the communication channel for the server.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#mcptypes-protocol-types","title":"<code>mcp.types</code> - Protocol Types","text":"<p>mcp.types</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_5","title":"Definition:","text":"<pre><code>- Type definitions for MCP protocol messages and data structures.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_5","title":"Why:","text":"<pre><code>- Ensures type safety and consistency when working with MCP messages.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_5","title":"Usage:","text":"<pre><code>- Defining request/response schemas and content types.\n</code></pre> <p>Key Types Used:</p> <ul> <li><code>Resource</code>: Defines a resource (readable data/content) with URI, name, description, and MIME type</li> <li><code>Tool</code>: Defines a tool (executable function) with name, description, and input schema</li> <li><code>TextContent</code>, <code>ImageContent</code>: Content types for tool/resource responses</li> <li><code>Prompt</code>: Defines a prompt template with name, description, and required arguments</li> <li><code>GetPromptResult</code>: Result structure when retrieving a prompt</li> <li><code>CallToolResult</code>: Result structure when calling a tool</li> <li><code>ListResourcesResult</code>, <code>ListToolsResult</code>, <code>ListPromptsResult</code>: Results when listing available resources/tools/prompts</li> <li><code>ReadResourceResult</code>: Result structure when reading a resource</li> </ul>"},{"location":"Lab07-MCP-Ollama/lab/#sys-system-functions","title":"<code>sys</code> - System Functions","text":"<p>sys</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_6","title":"Definition:","text":"<pre><code>- Provides access to system-specific parameters and functions.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_6","title":"Why:","text":"<pre><code>- Needed for handling command-line arguments and system-level operations.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_6","title":"Usage:","text":"<pre><code>- Accessing stdin/stdout streams and handling program exit.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#requests-http-library","title":"<code>requests</code> - HTTP Library","text":"<p>requests</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_7","title":"Definition:","text":"<pre><code>- A simple HTTP library for making web requests.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_7","title":"Why:","text":"<pre><code>- Used for interacting with external APIs and services.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_7","title":"Usage:","text":"<pre><code>- Making HTTP calls to fetch data from web services.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#sqlite3-sqlite-database","title":"<code>sqlite3</code> - SQLite Database","text":"<p>sqlite3</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_8","title":"Definition:","text":"<pre><code>- Python's built-in SQLite database module.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_8","title":"Why:","text":"<pre><code>- Provides a lightweight, file-based database for data storage and querying.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_8","title":"Usage:","text":"<pre><code>- Executing SQL queries and managing database operations.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#pandas-data-analysis-library","title":"<code>pandas</code> - Data Analysis Library","text":"<p>pandas</p>"},{"location":"Lab07-MCP-Ollama/lab/#definition_9","title":"Definition:","text":"<pre><code>- A powerful data manipulation and analysis library.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#why_9","title":"Why:","text":"<pre><code>- Used for reading CSV files and managing structured data.\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#usage_9","title":"Usage:","text":"<pre><code>- Loading country data from CSV files for RAG retrieval.\n</code></pre> <p>Paste the following imports code inside the <code>mcp_ollama.py</code> file:</p> <pre><code>import asyncio\nimport json\nimport os\nimport sqlite3\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nimport ollama\nimport pandas as pd\nimport requests\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Resource,\n  Tool,\n  TextContent,\n  ImageContent,\n  TextResourceContents,\n  Prompt,\n  GetPromptResult,\n  CallToolResult,\n  ListResourcesResult,\n  ListToolsResult,\n  ReadResourceResult,\n  ListPromptsResult,\n)\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-02-skeleton-code-class","title":"Step 02: Skeleton Code - Class","text":""},{"location":"Lab07-MCP-Ollama/lab/#class-definition","title":"Class Definition","text":"<p>Append this class definition code after the imports in your <code>mcp_ollama.py</code> file:</p> <pre><code>class CompleteOllamaMCPServer:\n  def __init__(self):\n    self.server = Server(\"complete-ollama-mcp-server\")\n    self._setup_handlers()\n\n  def _setup_handlers(self):\n    # Will be implemented in subsequent steps\n    pass\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-03-constructor","title":"Step 03: Constructor","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-__init__-constructor","title":"Method <code>__init__</code> (Constructor)","text":"<p>Capabilities:</p> <ul> <li>Initializes the MCP server with a name</li> <li>Sets up data structures for tools, resources, and prompts</li> <li>Prepares database connection</li> <li>Initializes Ollama client</li> <li>Loads country data from Excel files for RAG retrieval</li> </ul> <p>Why This Runs First:</p> <ul> <li>Establishes the foundation for all server operations</li> <li>Sets up the basic state of the server</li> <li>Ensures all dependencies are ready before registering components</li> </ul> <p>Update the <code>__init__</code> method inside your <code>CompleteOllamaMCPServer</code> class to include the full initialization:</p> <pre><code>  def __init__(self):\n    self.server = Server(\"complete-ollama-mcp-server\")\n    self.db_path = \"data.db\"\n    self.ollama_client = ollama.Client()\n    self.country_data = self._load_country_data()\n    self._setup_handlers()\n\n  def _load_country_data(self):\n    \"\"\"Load country information from CSV files for RAG retrieval.\"\"\"\n    data = {}\n    script_dir = Path(__file__).parent\n    info_types = ['capital', 'population', 'height', 'foundation_year']\n    for info_type in info_types:\n      try:\n        file_path = script_dir / f'{info_type}.csv'\n        df = pd.read_csv(file_path)\n        # Convert country names to lowercase for case-insensitive matching\n        data[info_type] = dict(zip(df['country'].str.lower(), df[info_type]))\n      except Exception as e:\n        print(f\"Error loading {info_type}.csv: {e}\", file=sys.stderr)\n        data[info_type] = {}\n    return data\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-04-register-tools","title":"Step 04: Register Tools","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-list_tools","title":"Method <code>list_tools</code>","text":"<p>Capabilities:</p> <ul> <li>Registers tool definitions for discovery</li> <li>Defines tool schemas and capabilities</li> <li>Makes tools available to clients</li> </ul> <p>Why This Runs Second:</p> <ul> <li>Tools must be registered before they can be called</li> <li>Defines the capabilities clients can invoke</li> </ul> <p>What is a Tool?</p> <ul> <li>A tool is an executable function that clients can invoke.</li> <li>Tools have names, descriptions, and input parameters.</li> <li>Clients can discover and call these tools to perform operations.</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.list_tools()\nasync def list_tools() -&gt; List[Tool]:\n  return [\n    Tool(\n      name=\"country_info\",\n      description=\"Get country information using RAG from CSV databases\",\n      inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n          \"country\": {\n            \"type\": \"string\",\n            \"description\": \"The country name to get information for\"\n          },\n          \"info_types\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"string\", \"enum\": [\"capital\", \"population\", \"height\", \"foundation_year\"]},\n            \"description\": \"Types of information to retrieve\"\n          }\n        },\n        \"required\": [\"country\"]\n      }\n    ),\n    Tool(\n      name=\"read_file\",\n      description=\"Read and analyze file contents with metadata\",\n      inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n          \"filepath\": {\n            \"type\": \"string\",\n            \"description\": \"Absolute path to the file to read\"\n          },\n          \"max_size\": {\n            \"type\": \"number\",\n            \"default\": 1048576,\n            \"description\": \"Maximum file size in bytes (default 1MB)\"\n          },\n          \"encoding\": {\n            \"type\": \"string\",\n            \"default\": \"utf-8\",\n            \"description\": \"File encoding\"\n          }\n        },\n        \"required\": [\"filepath\"]\n      }\n    ),\n    Tool(\n      name=\"query_database\",\n      description=\"Execute SELECT queries on SQLite database\",\n      inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n          \"query\": {\n            \"type\": \"string\",\n            \"description\": \"SELECT SQL query to execute\"\n          },\n          \"database\": {\n            \"type\": \"string\",\n            \"default\": \"data.db\",\n            \"description\": \"Database file path\"\n          }\n        },\n        \"required\": [\"query\"]\n      }\n    )\n  ]\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-05-tool-handlers","title":"Step 05: Tool Handlers","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-call_tool","title":"Method <code>call_tool</code>","text":"<p>Capabilities:</p> <ul> <li>Implements the logic for each tool</li> <li>Handles tool execution and error management</li> <li>Returns formatted results</li> </ul> <p>Why This Runs Third:</p> <ul> <li>Connects tool schemas to actual functionality</li> <li>Makes tools operational</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.call_tool()\nasync def call_tool(name: str, arguments: Dict[str, Any]) -&gt; List[TextContent]:\n  if name == \"country_info\":\n    country = arguments.get(\"country\", \"\").lower()\n    info_types = arguments.get(\"info_types\", [])\n\n    if not country:\n      raise ValueError(\"Country name is required\")\n\n    if not info_types:\n      info_types = [\"capital\", \"population\", \"height\", \"foundation_year\"]\n\n    retrieved_info = {}\n    for info_type in info_types:\n      # Safe access to nested dictionary\n      type_data = self.country_data.get(info_type, {})\n      if country in type_data:\n        retrieved_info[info_type] = type_data[country]\n      else:\n        retrieved_info[info_type] = f\"Information not available (Data loaded: {len(type_data)} records)\"\n\n    # Use Ollama to generate a formatted response\n    prompt = f\"Format the following information about {country.title()} into a nice, readable response: {json.dumps(retrieved_info, indent=2)}\"\n\n    try:\n      # Use llama3.2 as detected on your system\n      response = self.ollama_client.generate(\n        model='llama3.2',\n        prompt=prompt,\n        options={'temperature': 0.7, 'max_tokens': 300}\n      )\n\n      result = response['response'].strip()\n\n      return [TextContent(type=\"text\", text=result)]\n\n    except Exception as e:\n      # Fallback if Ollama fails\n      return [TextContent(type=\"text\", text=f\"Error getting AI response: {str(e)}\\n\\nRaw Data: {retrieved_info}\")]\n\n  elif name == \"read_file\":\n    filepath = arguments.get(\"filepath\", \"\")\n    max_size = arguments.get(\"max_size\", 1048576)\n    encoding = arguments.get(\"encoding\", \"utf-8\")\n\n    if not filepath:\n      raise ValueError(\"File path is required\")\n\n    path = Path(filepath)\n    if not path.exists():\n      raise ValueError(f\"File not found: {filepath}\")\n\n    if not path.is_file():\n      raise ValueError(f\"Path is not a file: {filepath}\")\n\n    file_size = path.stat().st_size\n    if file_size &gt; max_size:\n      raise ValueError(f\"File too large: {file_size} bytes (max: {max_size})\")\n\n    try:\n      with open(path, 'r', encoding=encoding) as f:\n        content = f.read()\n\n      metadata = f\"File: {path.name}\\nSize: {file_size} bytes\\nEncoding: {encoding}\\n\\n\"\n      result = metadata + \"Content:\\n\" + content\n\n      return [TextContent(type=\"text\", text=result)]\n\n    except Exception as e:\n      return [TextContent(type=\"text\", text=f\"Error reading file: {str(e)}\")]\n\n  elif name == \"query_database\":\n    query = arguments.get(\"query\", \"\").strip()\n    database = arguments.get(\"database\", self.db_path)\n\n    if not query:\n      raise ValueError(\"Query is required\")\n\n    if not query.upper().startswith(\"SELECT\"):\n      raise ValueError(\"Only SELECT queries are allowed\")\n\n    try:\n      conn = sqlite3.connect(database)\n      cursor = conn.cursor()\n\n      cursor.execute(query)\n      rows = cursor.fetchall()\n      columns = [desc[0] for desc in cursor.description]\n\n      conn.close()\n\n      if not rows:\n        result = \"No results found.\"\n      else:\n        # Format as table\n        result = \"| \" + \" | \".join(columns) + \" |\\n\"\n        result += \"|\" + \"|\".join([\"---\"] * len(columns)) + \"|\\n\"\n        for row in rows:\n          result += \"| \" + \" | \".join(str(cell) for cell in row) + \" |\\n\"\n\n      return [TextContent(type=\"text\", text=result)]\n\n    except Exception as e:\n      return [TextContent(type=\"text\", text=f\"Database error: {str(e)}\")]\n\n  else:\n    raise ValueError(f\"Unknown tool: {name}\")\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-06-register-resources","title":"Step 06: Register Resources","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-list_resources","title":"Method <code>list_resources</code>","text":"<p>Capabilities:</p> <ul> <li>Registers resource definitions for discovery</li> <li>Provides additional data for clients</li> </ul> <p>Why This Runs Fourth:</p> <ul> <li>Resources enhance the server\u2019s functionality</li> <li>Allows clients to access static or dynamic data</li> </ul> <p>What is a Resource?</p> <ul> <li>A resource is readable data or content.</li> <li>Resources have URIs and metadata.</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.list_resources()\nasync def list_resources() -&gt; List[Resource]:\n  return [\n    Resource(\n      uri=\"resource://server-info\",\n      name=\"Server Information\",\n      description=\"Basic information about this MCP server\",\n      mimeType=\"application/json\"\n    ),\n    Resource(\n      uri=\"resource://ollama-models\",\n      name=\"Available Ollama Models\",\n      description=\"List of available Ollama models\",\n      mimeType=\"application/json\"\n    )\n  ]\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-07-resource-handlers","title":"Step 07: Resource Handlers","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-register_resource_handlers","title":"Method <code>register_resource_handlers</code>","text":"<p>Capabilities:</p> <ul> <li>Implements resource reading logic</li> <li>Handles resource requests and returns content</li> </ul> <p>Why This Runs Fifth:</p> <ul> <li>Connects resource URIs to actual content</li> <li>Makes resources accessible to clients</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.read_resource()\nasync def read_resource(self, uri: str) -&gt; str:\n  uri_str = str(uri).strip()\n\n  # Debug log to help diagnose the mismatch\n  print(f\"DEBUG: Requesting URI: '{uri_str}'\", file=sys.stderr)\n\n  # Allow exact match or match without scheme to be robust\n  if uri_str == \"resource://server-info\" or uri_str.endswith(\"server-info\"):\n    info = {\n      \"name\": \"Complete Ollama MCP Server\",\n      \"version\": \"1.0.0\",\n      \"capabilities\": [\"tools\", \"resources\", \"ollama-integration\"],\n      \"tools\": [\"country_info\", \"read_file\", \"query_database\"],\n      \"country_database\": \"193 UN member states with capitals, populations, topographic heights, and foundation years\"\n    }\n    return json.dumps(info, indent=2)\n\n  elif uri_str == \"resource://ollama-models\" or uri_str.endswith(\"ollama-models\"):\n    try:\n      models = self.ollama_client.list()\n      return json.dumps(models, indent=2)\n    except Exception as e:\n      return json.dumps({\"error\": str(e)}, indent=2)\n\n  else:\n    raise ValueError(f\"Unknown resource: {uri_str}\")\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-08-register-prompts","title":"Step 08: Register Prompts","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-list_prompts","title":"Method <code>list_prompts</code>","text":"<p>Capabilities:</p> <ul> <li>Registers prompt templates</li> <li>Defines structured prompts for AI interactions</li> </ul> <p>Why This Runs Sixth:</p> <ul> <li>Provides structured prompts for AI interactions</li> <li>Enables clients to request specific prompt templates</li> </ul> <p>What is a Prompt?</p> <ul> <li>A prompt is a template that guides AI assistants.</li> <li>Prompts have names, descriptions, and required arguments.</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.list_prompts()\nasync def list_prompts() -&gt; List[Prompt]:\n  return [\n    Prompt(\n      name=\"analyze-country-data\",\n      description=\"Analyze country data and provide insights\",\n      arguments=[\n        {\n          \"name\": \"country\",\n          \"description\": \"Country to analyze\",\n          \"required\": True\n        }\n      ]\n    )\n  ]\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-09-prompt-handlers","title":"Step 09: Prompt Handlers","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-get_prompt","title":"Method <code>get_prompt</code>","text":"<p>Capabilities:</p> <ul> <li>Generates prompt content.</li> <li>Handles prompt requests and returns structured messages.</li> </ul> <p>Why This Runs Seventh:</p> <ul> <li>Connects prompt templates to actual content.</li> <li>Makes prompts usable by clients.</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.get_prompt()\nasync def get_prompt(name: str, arguments: Dict[str, Any]) -&gt; GetPromptResult:\n  if name == \"analyze-country-data\":\n    country = arguments.get(\"country\", \"Unknown Country\")\n    prompt_text = f\"\"\"Analyze the data for {country} and provide insights:\n\n1. Use the country_info tool to get information about the country's capital, population, topographic height, and foundation year\n2. Analyze the retrieved information and provide interesting facts\n3. Consider historical context and geographical significance\n4. Provide recommendations or interesting trivia based on the data\n\nPlease provide a comprehensive country analysis.\"\"\"\n\n    return GetPromptResult(\n      description=f\"Country analysis prompt for {country}\",\n      messages=[\n        {\n          \"role\": \"user\",\n          \"content\": {\n            \"type\": \"text\",\n            \"text\": prompt_text\n          }\n        }\n      ]\n    )\n\n  else:\n    raise ValueError(f\"Unknown prompt: {name}\")\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-10-setup-handlers","title":"Step 10: Setup Handlers","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-_setup_handlers","title":"Method <code>_setup_handlers</code>","text":"<p>Capabilities:</p> <ul> <li>Placeholder for handler setup (decorators handle registration automatically).</li> <li>Adds structure for future setup logic.</li> </ul> <p>Why This Runs:</p> <ul> <li>Ensures the initialization completes properly.</li> <li>Maintains structure for potential future setup logic.</li> </ul> <p>Update the <code>_setup_handlers</code> method in your class (it should already exist from Step 02):</p> <pre><code>def _setup_handlers(self):\n  # Handlers are registered automatically via decorators\n  pass\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-11-run-the-server","title":"Step 11: Run the Server","text":""},{"location":"Lab07-MCP-Ollama/lab/#method-run","title":"Method <code>run</code>","text":"<p>Capabilities:</p> <ul> <li>Starts the MCP server.</li> <li>Handles stdio communication.</li> <li>Manages server lifecycle.</li> </ul> <p>Why This Runs Last:</p> <ul> <li>Initiates the server operation.</li> <li>Begins listening for client requests.</li> </ul> <p>Add this method to your class:</p> <pre><code>async def run(self):\n  async with stdio_server() as (read_stream, write_stream):\n    await self.server.run(read_stream, write_stream, self.server.create_initialization_options())\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#step-12-main-entry-point","title":"Step 12: Main / Entry Point","text":"<p>What is the Main Entry Point?</p> <ul> <li>The starting point of the script.</li> <li>Initializes and runs the MCP server.</li> <li>Ensures the server starts when the script is executed.</li> <li>Uses <code>asyncio.run()</code> to manage the event loop for async operations.</li> </ul> <p>Why this runs at the end:</p> <ul> <li>Ensures all class definitions and methods are in place before starting the server.</li> <li>Provides a clear entry point for execution.</li> <li>Manages the asynchronous nature of the server.</li> </ul> <p>Add this code at the end of your <code>mcp_ollama.py</code> file:</p> <pre><code>async def main():\n  server = CompleteOllamaMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"Lab07-MCP-Ollama/lab/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"Lab07-MCP-Ollama/lab/#pattern-1-input-validation","title":"Pattern 1: Input Validation","text":"<p>Input Validation</p> <p>Definition: Ensures tool arguments meet requirements before processing. Why: Prevents runtime errors and provides clear feedback. Usage: Validate inputs early in tool handlers.</p> <pre><code>if not country:\n  raise ValueError(\"Country name is required\")\n</code></pre> <p>When to use - For all tool inputs and external data:</p> <ul> <li>User-provided parameters and arguments</li> <li>File paths and resource identifiers</li> <li>Network requests and API parameters</li> <li>Database queries and data inputs</li> <li>Any data that could be malformed or malicious</li> </ul> <p>Why it matters: Prevents crashes, security vulnerabilities, and unexpected behavior by catching invalid inputs early with clear error messages.</p>"},{"location":"Lab07-MCP-Ollama/lab/#pattern-2-graceful-degradation","title":"Pattern 2: Graceful Degradation","text":"<p>Graceful Degradation</p> <p>Definition: Provides partial functionality when full operation isn\u2019t possible. Why: Users get some value even when systems fail partially. Usage: Return useful information or fallbacks.</p> <pre><code>try:\n  # Attempt to generate AI response with Ollama\n  response = self.ollama_client.generate(model='llama3.2', prompt=prompt)\n  result = response['response'].strip()\n  return [TextContent(type=\"text\", text=result)]\nexcept Exception as e:\n  # Return partial results with raw data\n  return [TextContent(type=\"text\", text=f\"Error getting AI response: {str(e)}\\n\\nRaw Data: {retrieved_info}\")]\n</code></pre> <p>When to use - For external dependencies that might be unreliable:</p> <ul> <li>API calls that could timeout or fail</li> <li>Network-dependent operations</li> <li>Services with occasional downtime</li> <li>When partial results are better than no results</li> </ul> <p>Why it matters: Users get some value even when systems are partially broken, improving overall reliability and user experience.</p>"},{"location":"Lab07-MCP-Ollama/lab/#pattern-3-detailed-error-context","title":"Pattern 3: Detailed Error Context","text":"<p>Detailed Error Context</p> <p>Definition: Provides comprehensive debugging information. Why: Enables effective troubleshooting while keeping user messages clean. Usage: Log details internally, expose safe messages to users.</p> <pre><code>except Exception as e:\n  print(f\"Internal error loading country data: {str(e)}\", file=sys.stderr)\n  return [TextContent(type=\"text\", text=\"An error occurred while processing country information. Please try again.\")]\n</code></pre> <p>When to use - For complex operations where debugging might be needed:</p> <ul> <li>Multi-step processes with potential failure points</li> <li>Operations involving external systems</li> <li>When you need to track error patterns over time</li> <li>Production environments where detailed logging is crucial</li> </ul> <p>Why it matters: Developers can diagnose issues effectively while users get clear, non-technical error messages.</p>"},{"location":"Lab07-MCP-Ollama/lab/#async-operations-and-performance","title":"Async Operations and Performance","text":""},{"location":"Lab07-MCP-Ollama/lab/#long-running-operations","title":"Long-Running Operations","text":"<p>Long-Running Operations</p> <p>Definition: Operations that take significant time to complete. Why: Prevents timeouts and provides feedback. Usage: Use async/await and provide progress updates.</p> <pre><code>async def analyze_country_data(country: str):\n  print(f\"Starting analysis for {country}...\", file=sys.stderr)\n  # Simulate data processing\n  await asyncio.sleep(2)\n  print(\"Analysis completed.\", file=sys.stderr)\n  return f\"Analysis result for {country}\"\n</code></pre> <p>When to use - For operations that take more than a few seconds:</p> <ul> <li>Large file processing or analysis</li> <li>Complex computations</li> <li>External API calls with potential delays</li> <li>Batch operations on multiple items</li> </ul> <p>Why it matters: Prevents timeouts, provides user feedback, enables monitoring and debugging of slow operations.</p>"},{"location":"Lab07-MCP-Ollama/lab/#caching-results","title":"Caching Results","text":"<p>Caching Results</p> <p>Definition: Stores results of expensive operations. Why: Improves response times for repeated requests. Usage: Implement a simple cache with expiration.</p> <pre><code>cache = {}\nasync def get_cached_country_info(country: str):\n  if country in cache and time.time() - cache[country]['timestamp'] &lt; 3600:  # 1 hour\n    return cache[country]['data']\n  # Fetch fresh data\n  result = await fetch_country_data(country)\n  cache[country] = {'data': result, 'timestamp': time.time()}\n  return result\n</code></pre> <p>When to use - For expensive operations that return consistent results:</p> <ul> <li>API calls to external services</li> <li>Complex calculations or data processing</li> <li>Database queries with static data</li> <li>File analysis that doesn\u2019t change frequently</li> </ul> <p>Why it matters: Dramatically improves response times, reduces resource usage, and provides better user experience for repeated requests.</p>"},{"location":"Lab07-MCP-Ollama/lab/#tool-composition","title":"Tool Composition","text":""},{"location":"Lab07-MCP-Ollama/lab/#example-multi-step-analysis","title":"Example: Multi-Step Analysis","text":"<p>Multi-Step Analysis</p> <p>Definition: Combining simple tools for complex workflows. Why: Enables sophisticated operations through tool chaining. Usage: Design tools that work well together.</p> <pre><code># Tool 1: Get country info\n# Tool 2: Analyze data\n# Tool 3: Generate report\n# LLM can chain: country_info -&gt; analyze -&gt; report\n</code></pre> <p>When to use - For workflows that require multiple processing steps:</p> <ul> <li>Data analysis pipelines</li> <li>File processing workflows</li> <li>Multi-stage computations</li> <li>Complex research tasks</li> </ul> <p>Why it matters: Breaks down complex problems into manageable, reusable components that can be combined in flexible ways.</p>"},{"location":"Lab07-MCP-Ollama/lab/#llm-tool-chaining","title":"LLM Tool Chaining","text":"<p>LLM Tool Chaining</p> <p>Definition: AI automatically sequences tool calls. Why: Enables complex reasoning without explicit programming. Usage: Design tool outputs as inputs for other tools.</p> <pre><code># Example of how an LLM might chain tools:\n# 1. Use country_info to get country data\n# 2. Use read_file to get historical data file\n# 3. Use query_database to store analysis results\n\nasync def analyze_country_trends(country: str):\n  \"\"\"LLM can automatically chain these calls\"\"\"\n\n  # Step 1: Get country information\n  country_result = await call_tool(\"country_info\", {\n    \"country\": country,\n    \"info_types\": [\"capital\", \"population\", \"height\", \"foundation_year\"]\n  })\n\n  # Step 2: Read historical data file\n  historical_data = await call_tool(\"read_file\", {\n    \"filepath\": f\"data/{country}_history.txt\"\n  })\n\n  # Step 3: Store analysis in database\n  analysis_query = f\"\"\"\n  INSERT INTO country_analysis (country, info, historical_data, timestamp)\n  VALUES ('{country}', '{country_result[0].text}', '{historical_data[0].text}', datetime('now'))\n  \"\"\"\n\n  db_result = await call_tool(\"query_database\", {\"query\": analysis_query})\n\n  return {\n    \"country_info\": country_result[0].text,\n    \"historical\": historical_data[0].text,\n    \"stored\": db_result[0].text\n  }\n</code></pre> <p>When to use - When tasks naturally break down into sequential steps:</p> <ul> <li>Research and analysis workflows</li> <li>Data processing pipelines</li> <li>Content generation chains</li> <li>Problem-solving sequences</li> </ul> <p>Why it matters: Enables complex, multi-step reasoning and problem-solving that would be difficult to implement in single tools.</p>"},{"location":"Lab07-MCP-Ollama/lab/#hands-on-exercises","title":"Hands-On Exercises","text":"<p>Exercise 1: Text Processing Tool</p> <p>Definition: A tool for analyzing and processing text content. Why: Enables text manipulation and analysis operations. Usage: Process text for counting, patterns, and metrics.</p> <p>Task: Create a new MCP tool called <code>process_text</code> that analyzes and processes text content. The tool should support multiple operations: counting words/characters/lines, finding regex patterns, and calculating reading time. Add this tool to your <code>CompleteOllamaMCPServer</code> class by updating the <code>list_tools()</code> method and <code>call_tool()</code> handler.</p> \ud83d\udca1 Complete Exercise 1 Solution Step 1: Add Tool Definition  Add to `list_tools()`:  <pre><code>Tool(\n  name=\"process_text\",\n  description=\"Analyze and process text content\",\n  inputSchema={\n    \"type\": \"object\",\n    \"properties\": {\n      \"text\": {\"type\": \"string\", \"description\": \"Text to process\"},\n      \"operations\": {\n        \"type\": \"array\",\n        \"items\": {\"type\": \"string\", \"enum\": [\"count\", \"find_pattern\", \"reading_time\"]},\n        \"description\": \"Operations to perform\"\n      },\n      \"pattern\": {\"type\": \"string\", \"description\": \"Regex pattern for find_pattern\"}\n    },\n    \"required\": [\"text\", \"operations\"]\n  }\n)\n</code></pre> Step 2: Add Handler Logic  Add to `call_tool()`:  <pre><code>elif name == \"process_text\":\n  text = arguments.get(\"text\", \"\")\n  operations = arguments.get(\"operations\", [])\n  pattern = arguments.get(\"pattern\", \"\")\n\n  result = \"\"\n  if \"count\" in operations:\n    words = len(text.split())\n    chars = len(text)\n    lines = len(text.split('\\n'))\n    result += f\"Words: {words}, Characters: {chars}, Lines: {lines}\\n\"\n\n  if \"find_pattern\" in operations and pattern:\n    import re\n    matches = re.findall(pattern, text)\n    result += f\"Pattern matches: {matches}\\n\"\n\n  if \"reading_time\" in operations:\n    words_per_minute = 200\n    minutes = len(text.split()) / words_per_minute\n    result += f\"Estimated reading time: {minutes:.1f} minutes\\n\"\n\n  return [TextContent(type=\"text\", text=result)]\n</code></pre> Step 3: Test the Tool  Test with various inputs to verify functionality.   <p>Exercise 2: JSON Validator Tool</p> <p>Definition: A tool for validating and processing JSON data. Why: Ensures data integrity and provides JSON utilities. Usage: Validate, format, and compare JSON structures.</p> <p>Task: Create a new MCP tool called <code>validate_json</code> that validates and processes JSON data. The tool should support four operations: validating JSON syntax, formatting/pretty-printing JSON, validating against a JSON schema, and comparing two JSON objects. You\u2019ll need to install the <code>jsonschema</code> package and add the necessary imports. Update your server class to include this tool in the <code>list_tools()</code> method and <code>call_tool()</code> handler.</p> \ud83d\udca1 Complete Exercise 2 Solution Step 1: Install Dependencies <pre><code>pip install jsonschema\n</code></pre> Step 2: Add Imports <pre><code>import jsonschema\n</code></pre> Step 3: Add Tool Definition  Add to `list_tools()`:  <pre><code>Tool(\n  name=\"validate_json\",\n  description=\"Validate and process JSON data\",\n  inputSchema={\n    \"type\": \"object\",\n    \"properties\": {\n      \"json\": {\"type\": \"string\", \"description\": \"JSON string to validate\"},\n      \"operation\": {\"type\": \"string\", \"enum\": [\"validate\", \"format\", \"schema_validate\", \"compare\"]},\n      \"schema\": {\"type\": \"string\", \"description\": \"JSON schema for validation\"},\n      \"json2\": {\"type\": \"string\", \"description\": \"Second JSON for comparison\"}\n    },\n    \"required\": [\"json\", \"operation\"]\n  }\n)\n</code></pre> Step 4: Add Handler Logic  Add to `call_tool()`:  <pre><code>elif name == \"validate_json\":\n  json_str = arguments.get(\"json\", \"\")\n  operation = arguments.get(\"operation\", \"validate\")\n  schema_str = arguments.get(\"schema\", \"\")\n  json2_str = arguments.get(\"json2\", \"\")\n\n  try:\n    data = json.loads(json_str)\n\n    if operation == \"validate\":\n      result = \"JSON is valid\"\n    elif operation == \"format\":\n      result = json.dumps(data, indent=2)\n    elif operation == \"schema_validate\" and schema_str:\n      schema = json.loads(schema_str)\n      jsonschema.validate(data, schema)\n      result = \"JSON validates against schema\"\n    elif operation == \"compare\" and json2_str:\n      data2 = json.loads(json2_str)\n      if data == data2:\n        result = \"JSON objects are identical\"\n      else:\n        result = \"JSON objects differ\"\n\n    return [TextContent(type=\"text\", text=result)]\n  except Exception as e:\n    return [TextContent(type=\"text\", text=f\"Error: {str(e)}\")]\n</code></pre> Step 5: Test the Tool  Test validation, formatting, and comparison operations.   <p>Exercise 3: Web Scraper Tool</p> <p>Definition: A tool for extracting content from web pages. Why: Enables data collection from web sources. Usage: Fetch and parse web content safely.</p> <p>Task: Create a new MCP tool called <code>scrape_web</code> that extracts content from web pages. The tool should fetch web pages, extract specific elements using CSS selectors, return clean text content, and handle errors gracefully. You\u2019ll need to install the <code>beautifulsoup4</code> and <code>lxml</code> packages and add the necessary imports. Update your server class to include this tool in the <code>list_tools()</code> method and <code>call_tool()</code> handler.</p> \ud83d\udca1 Complete Exercise 3 Solution Step 1: Install Dependencies <pre><code>pip install beautifulsoup4 lxml\n</code></pre> Step 2: Add Imports <pre><code>from bs4 import BeautifulSoup\n</code></pre> Step 3: Add Tool Definition  Add to `list_tools()`:  <pre><code>Tool(\n  name=\"scrape_web\",\n  description=\"Extract content from web pages\",\n  inputSchema={\n    \"type\": \"object\",\n    \"properties\": {\n      \"url\": {\"type\": \"string\", \"description\": \"URL to scrape\"},\n      \"selector\": {\"type\": \"string\", \"description\": \"CSS selector for content\"},\n      \"include_html\": {\"type\": \"boolean\", \"default\": False, \"description\": \"Include HTML tags\"}\n    },\n    \"required\": [\"url\"]\n  }\n)\n</code></pre> Step 4: Add Handler Logic  Add to `call_tool()`:  <pre><code>elif name == \"scrape_web\":\n  url = arguments.get(\"url\", \"\")\n  selector = arguments.get(\"selector\", \"\")\n  include_html = arguments.get(\"include_html\", False)\n\n  try:\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.content, 'lxml')\n\n    if selector:\n      elements = soup.select(selector)\n      if include_html:\n        content = '\\n'.join(str(el) for el in elements)\n      else:\n        content = '\\n'.join(el.get_text() for el in elements)\n    else:\n      content = soup.get_text() if not include_html else str(soup)\n\n    return [TextContent(type=\"text\", text=content)]\n  except Exception as e:\n    return [TextContent(type=\"text\", text=f\"Error scraping web: {str(e)}\")]\n</code></pre> Step 5: Test the Tool  Test with different URLs and selectors, handling errors gracefully."},{"location":"Lab07-MCP-Ollama/tasks/","title":"MCP Lab Tasks - Lab 3","text":"<p>Welcome to the MCP Lab Tasks section! </p> <p>This comprehensive collection of hands-on exercises will help you master the Model Context Protocol through practical implementation.</p> <p>Each lab has 15 exercises designed to build your skills progressively. Try to solve each exercise on your own before clicking the solution dropdown.</p>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-31-calculator-tool","title":"Exercise 3.1: Calculator Tool","text":"<p>Implement a calculator tool that supports basic arithmetic operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"calculate\") {\n    const { operation, a, b } = args;\n    let result: number;\n\n    switch (operation) {\n      case \"add\":\n        result = a + b;\n        break;\n      case \"subtract\":\n        result = a - b;\n        break;\n      case \"multiply\":\n        result = a * b;\n        break;\n      case \"divide\":\n        if (b === 0) throw new Error(\"Division by zero\");\n        result = a / b;\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-32-file-reader-tool","title":"Exercise 3.2: File Reader Tool","text":"<p>Create a tool that reads and returns file contents.</p> Solution <pre><code>import { readFileSync } from \"fs\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"read_file\") {\n    const { path } = args;\n    try {\n      const content = readFileSync(path, \"utf-8\");\n      return {\n        content: [{ type: \"text\", text: content }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-33-http-request-tool","title":"Exercise 3.3: HTTP Request Tool","text":"<p>Implement a tool that makes HTTP requests.</p> Solution <pre><code>import fetch from \"node-fetch\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"http_request\") {\n    const { url, method = \"GET\", headers = {} } = args;\n\n    try {\n      const response = await fetch(url, { method, headers });\n      const data = await response.text();\n\n      return {\n        content: [\n          { type: \"text\", text: `Status: ${response.status}` },\n          { type: \"text\", text: `Body: ${data}` }\n        ]\n      };\n    } catch (error) {\n      throw new Error(`HTTP request failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-34-json-parser-tool","title":"Exercise 3.4: JSON Parser Tool","text":"<p>Create a tool that parses and validates JSON data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_json\") {\n    const { json_string } = args;\n\n    try {\n      const parsed = JSON.parse(json_string);\n      return {\n        content: [\n          { type: \"text\", text: \"JSON is valid\" },\n          { type: \"text\", text: `Parsed: ${JSON.stringify(parsed, null, 2)}` }\n        ]\n      };\n    } catch (error) {\n      return {\n        content: [{ type: \"text\", text: `Invalid JSON: ${error.message}` }],\n        isError: true\n      };\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-35-string-manipulation-tool","title":"Exercise 3.5: String Manipulation Tool","text":"<p>Implement a tool for common string operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"string_ops\") {\n    const { operation, text } = args;\n    let result: string;\n\n    switch (operation) {\n      case \"uppercase\":\n        result = text.toUpperCase();\n        break;\n      case \"lowercase\":\n        result = text.toLowerCase();\n        break;\n      case \"reverse\":\n        result = text.split('').reverse().join('');\n        break;\n      case \"length\":\n        result = text.length.toString();\n        break;\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Result: ${result}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-36-database-query-tool","title":"Exercise 3.6: Database Query Tool","text":"<p>Create a tool that executes simple database queries.</p> Solution <pre><code>import sqlite3 from \"sqlite3\";\n\nconst db = new sqlite3.Database(':memory:');\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"db_query\") {\n    const { query } = args;\n\n    return new Promise((resolve, reject) =&gt; {\n      db.all(query, [], (err, rows) =&gt; {\n        if (err) {\n          reject(new Error(`Database error: ${err.message}`));\n        } else {\n          resolve({\n            content: [{ type: \"text\", text: JSON.stringify(rows, null, 2) }]\n          });\n        }\n      });\n    });\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-37-image-processing-tool","title":"Exercise 3.7: Image Processing Tool","text":"<p>Implement a tool that gets image metadata.</p> Solution <pre><code>import sharp from \"sharp\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"image_info\") {\n    const { image_path } = args;\n\n    try {\n      const metadata = await sharp(image_path).metadata();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Width: ${metadata.width}, Height: ${metadata.height}, Format: ${metadata.format}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Image processing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-38-code-linter-tool","title":"Exercise 3.8: Code Linter Tool","text":"<p>Create a tool that lints JavaScript/TypeScript code.</p> Solution <pre><code>import { ESLint } from \"eslint\";\n\nconst eslint = new ESLint();\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"lint_code\") {\n    const { code, filename = \"temp.js\" } = args;\n\n    try {\n      const results = await eslint.lintText(code, { filePath: filename });\n      const formatter = await eslint.loadFormatter(\"stylish\");\n      const resultText = formatter.format(results);\n\n      return {\n        content: [{ type: \"text\", text: resultText || \"No linting issues found\" }]\n      };\n    } catch (error) {\n      throw new Error(`Linting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-39-weather-api-tool","title":"Exercise 3.9: Weather API Tool","text":"<p>Implement a tool that fetches weather data.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"get_weather\") {\n    const { city } = args;\n    const apiKey = process.env.WEATHER_API_KEY;\n\n    if (!apiKey) {\n      throw new Error(\"Weather API key not configured\");\n    }\n\n    try {\n      const response = await fetch(\n        `https://api.openweathermap.org/data/2.5/weather?q=${city}&amp;appid=${apiKey}&amp;units=metric`\n      );\n\n      if (!response.ok) {\n        throw new Error(`Weather API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Weather in ${city}: ${data.weather[0].description}, ${data.main.temp}\u00b0C`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Weather fetch failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-310-git-operations-tool","title":"Exercise 3.10: Git Operations Tool","text":"<p>Create a tool for basic Git operations.</p> Solution <pre><code>import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"git_status\") {\n    try {\n      const { stdout } = await execAsync(\"git status --porcelain\");\n      return {\n        content: [{ type: \"text\", text: stdout || \"Working directory clean\" }]\n      };\n    } catch (error) {\n      throw new Error(`Git command failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-311-regex-tool","title":"Exercise 3.11: Regex Tool","text":"<p>Implement a tool for regular expression operations.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"regex_match\") {\n    const { pattern, text, flags = \"\" } = args;\n\n    try {\n      const regex = new RegExp(pattern, flags);\n      const matches = text.match(regex);\n\n      return {\n        content: [{\n          type: \"text\",\n          text: matches ? `Matches found: ${matches.join(\", \")}` : \"No matches found\"\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Regex error: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-312-unit-converter-tool","title":"Exercise 3.12: Unit Converter Tool","text":"<p>Create a tool that converts between different units.</p> Solution <pre><code>server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"convert_units\") {\n    const { value, from, to } = args;\n\n    // Simple conversion factors (could be expanded)\n    const conversions: Record&lt;string, Record&lt;string, number&gt;&gt; = {\n      celsius: { fahrenheit: (c) =&gt; c * 9/5 + 32, kelvin: (c) =&gt; c + 273.15 },\n      fahrenheit: { celsius: (f) =&gt; (f - 32) * 5/9, kelvin: (f) =&gt; (f - 32) * 5/9 + 273.15 },\n      meters: { feet: (m) =&gt; m * 3.28084, kilometers: (m) =&gt; m / 1000 },\n      feet: { meters: (f) =&gt; f / 3.28084, kilometers: (f) =&gt; f / 3280.84 }\n    };\n\n    if (conversions[from] &amp;&amp; conversions[from][to]) {\n      const result = conversions[from][to](value);\n      return {\n        content: [{ type: \"text\", text: `${value} ${from} = ${result.toFixed(2)} ${to}` }]\n      };\n    }\n\n    throw new Error(`Conversion from ${from} to ${to} not supported`);\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-313-csv-parser-tool","title":"Exercise 3.13: CSV Parser Tool","text":"<p>Implement a tool that parses CSV data.</p> Solution <pre><code>import { parse } from \"csv-parse/sync\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"parse_csv\") {\n    const { csv_data } = args;\n\n    try {\n      const records = parse(csv_data, {\n        columns: true,\n        skip_empty_lines: true\n      });\n\n      return {\n        content: [{\n          type: \"text\",\n          text: `Parsed ${records.length} rows: ${JSON.stringify(records.slice(0, 5), null, 2)}`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`CSV parsing failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-314-password-generator-tool","title":"Exercise 3.14: Password Generator Tool","text":"<p>Create a tool that generates secure passwords.</p> Solution <pre><code>import { randomBytes } from \"crypto\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"generate_password\") {\n    const { length = 12, include_special = true } = args;\n\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const specialChars = \"!@#$%^&amp;*\";\n\n    let charset = chars;\n    if (include_special) {\n      charset += specialChars;\n    }\n\n    let password = \"\";\n    const bytes = randomBytes(length);\n\n    for (let i = 0; i &lt; length; i++) {\n      password += charset[bytes[i] % charset.length];\n    }\n\n    return {\n      content: [{ type: \"text\", text: `Generated password: ${password}` }]\n    };\n  }\n});\n</code></pre>"},{"location":"Lab07-MCP-Ollama/tasks/#exercise-315-code-formatter-tool","title":"Exercise 3.15: Code Formatter Tool","text":"<p>Implement a tool that formats code using Prettier.</p> Solution <pre><code>import prettier from \"prettier\";\n\nserver.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  if (name === \"format_code\") {\n    const { code, language = \"javascript\" } = args;\n\n    try {\n      const formatted = await prettier.format(code, {\n        parser: language,\n        semi: true,\n        singleQuote: true\n      });\n\n      return {\n        content: [{ type: \"text\", text: formatted }]\n      };\n    } catch (error) {\n      throw new Error(`Code formatting failed: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"Lab08-Kagent/lab/","title":"Lab 08: K-Agent Integration","text":""},{"location":"Lab08-Kagent/lab/#overview","title":"Overview","text":"<ul> <li> <p>Welcome to the advanced MCP lab!</p> </li> <li> <p>Now that you\u2019ve mastered the fundamentals of MCP servers, tools, resources, and prompts, it\u2019s time to apply your knowledge to a real-world scenario: building and implementing a K-Agent.</p> </li> <li> <p>A K-Agent is an MCP server specifically designed to interact with Kubernetes clusters.</p> </li> <li> <p>In this lab, you\u2019ll build a focused K-Agent that communicates with a Kubernetes cluster and collects logs from all pods - a critical capability for monitoring, debugging, and operational intelligence.</p> </li> <li> <p>This lab bridges the gap between MCP theory and practical Kubernetes operations, showing how MCP servers can enhance DevOps workflows and provide AI-powered insights into cluster health and application behavior.</p> </li> </ul>"},{"location":"Lab08-Kagent/lab/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this lab, you will:</p> <ul> <li>Understand the concept and value of K-Agents (Kubernetes MCP servers)</li> <li>Use pre-configured Kubernetes cluster access</li> <li>Build MCP tools for pod log collection</li> <li>Implement error handling for cluster operations</li> </ul>"},{"location":"Lab08-Kagent/lab/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Lab 5 - MCP Prompts and Integration</li> <li>A running Kubernetes cluster (OrbStack, Docker Desktop, Minikube, kind, or remote cluster)</li> <li>kubectl installed and configured with access to your cluster (<code>kubectl cluster-info</code> should work)</li> <li>Basic understanding of Kubernetes concepts (pods, namespaces, kubectl)</li> <li>Familiarity with container orchestration principles</li> <li>Understanding of log aggregation and monitoring concepts</li> </ul> <p>Verify Kubernetes Setup</p> <ul> <li> <p>Before starting this lab, ensure your Kubernetes environment is ready:</p> <pre><code># Check cluster access\nkubectl cluster-info\n\n# Verify you can list pods\nkubectl get pods --all-namespaces\n\n# Check your kubeconfig\nkubectl config view\n</code></pre> </li> </ul>"},{"location":"Lab08-Kagent/lab/#what-is-a-k-agent","title":"What is a K-Agent?","text":"<p>A <code>**K-Agent**</code> is an <code>MCP server</code> that specializes in Kubernetes operations.</p> <p>Unlike generic MCP servers, K-Agents are designed specifically for:</p> <ul> <li>Cluster Communication: Secure, authenticated access to Kubernetes APIs</li> <li>Operational Intelligence: Real-time insights into cluster health and performance</li> <li>Log Analytics: Collection and analysis of application and system logs</li> <li>Resource Management: Monitoring and managing Kubernetes resources</li> <li>Troubleshooting: Automated diagnosis of cluster and application issues</li> </ul>"},{"location":"Lab08-Kagent/lab/#why-k-agents-matter","title":"Why K-Agents Matter","text":"<ul> <li>In modern DevOps environments, Kubernetes clusters generate enormous amounts of operational data.</li> </ul> <p>K-Agents provide:</p> <ul> <li>AI-Powered Monitoring: Intelligent analysis of logs and metrics</li> <li>Automated Troubleshooting: AI-assisted diagnosis of issues</li> <li>Operational Insights: Pattern recognition in cluster behavior</li> <li>Enhanced Observability: Structured access to distributed system data</li> <li>Seamless Integration: MCP tools that interact directly with Kubernetes resources</li> <li>Improved DevOps Workflows: Streamlined operations through AI-driven tools</li> <li>Dashboarding and Alerts: Proactive monitoring with AI-generated alerts</li> <li>Custom Tooling: Tailored MCP tools for specific Kubernetes tasks</li> </ul>"},{"location":"Lab08-Kagent/lab/#lab-architecture","title":"Lab Architecture","text":"<p>Your K-Agent will implement a focused set of capabilities:</p> <pre><code>graph TB\n    subgraph \"MCP Client (AI/Inspector)\"\n        Client[MCP Client]\n    end\n\n    subgraph \"K-Agent MCP Server\"\n        Server[K-Agent Server]\n        Tools[MCP Tools]\n        K8sClient[Kubernetes Client]\n\n        Server --&gt; Tools\n        Tools --&gt; K8sClient\n    end\n\n    subgraph \"Kubernetes Cluster\"\n        API[Kubernetes API]\n        Pods[Pods]\n        Logs[Container Logs]\n\n        API --&gt; Pods\n        Pods --&gt; Logs\n    end\n\n    Client --&gt;|\"stdio/JSON-RPC\"| Server\n    K8sClient --&gt;|\"REST API\"| API\n\n    Tools -.-&gt;|\"list_pods\"| API\n    Tools -.-&gt;|\"collect_pod_logs\"| Logs\n\n    style Server fill:#4CAF50\n    style Tools fill:#2196F3\n    style K8sClient fill:#FF9800\n    style API fill:#9C27B0</code></pre>"},{"location":"Lab08-Kagent/lab/#core-components","title":"Core Components","text":"<ol> <li> <p>Kubernetes Client Integration</p> <ul> <li>Secure cluster authentication</li> <li>API communication handling</li> <li>Error management for cluster operations</li> </ul> </li> <li> <p>Log Collection Tools</p> <ul> <li>Pod discovery across namespaces</li> <li>Log retrieval from all containers</li> <li>Structured log formatting</li> </ul> </li> <li> <p>Resource Management</p> <ul> <li>Namespace enumeration</li> <li>Pod status monitoring</li> <li>Health check capabilities</li> </ul> </li> </ol>"},{"location":"Lab08-Kagent/lab/#hands-on-exercise","title":"Hands-On Exercise","text":""},{"location":"Lab08-Kagent/lab/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>Create a new MCP server project with Kubernetes dependencies:</p> <pre><code># Create project directory and navigate to it\nmkdir k-agent-logs\ncd k-agent-logs\n</code></pre> <p></p> <ul> <li>Create a new <code>package.json</code> file inside the <code>k-agent-logs</code> directory with the following content:</li> </ul> <pre><code>{\n  \"name\": \"k-agent-logs\",\n  \"version\": \"1.0.0\",\n  \"description\": \"K-Agent MCP server for Kubernetes log collection\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx src/index.ts\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\"kubernetes\", \"mcp\", \"logs\", \"monitoring\"],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"type\": \"commonjs\",\n  \"dependencies\": {\n    \"@kubernetes/client-node\": \"^1.4.0\",\n    \"@modelcontextprotocol/sdk\": \"^1.25.2\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^25.0.3\",\n    \"tsx\": \"^4.21.0\",\n    \"typescript\": \"^5.9.3\"\n  }\n}\n</code></pre> <ul> <li>Run the following command to install the dependencies:</li> </ul> <pre><code>npm install\n</code></pre> <p>This will create <code>node_modules/</code> and <code>package-lock.json</code> in your <code>k-agent-logs</code> directory.</p>"},{"location":"Lab08-Kagent/lab/#step-2-kubernetes-client-configuration-complete-server-setup","title":"Step 2: Kubernetes Client Configuration &amp; Complete Server Setup","text":"<p>Create an <code>src</code> directory, inside the <code>k-agent-logs</code> directory, and an empty file named <code>index.ts</code> inside it:</p> <pre><code>mkdir -p src &amp;&amp; touch src/index.ts\n</code></pre> <p></p> <p>Create your complete K-Agent server by pasting the following code inside <code>src/index.ts</code>:</p> <pre><code>// Import MCP SDK components and Kubernetes client\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as k8s from \"@kubernetes/client-node\";\n\nclass KAgentServer {\n  // Store Kubernetes API clients (for talking to your cluster)\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n  private server: Server;\n\n  constructor() {\n    // Initialize connection to your Kubernetes cluster (uses ~/.kube/config)\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sConfig.loadFromDefault();\n\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Create MCP server that AI tools can connect to\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      },\n    );\n\n    // Handle incoming MCP requests (you'll add tools here next)\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // TODO: Implement MCP handlers\n  }\n\n  // Start the server and listen for connections\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Actually run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n</code></pre> <p></p> <p>Create a file named <code>tsconfig.json</code> inside the <code>k-agent-logs</code> directory (not inside <code>src</code>):</p> <pre><code>cd ..  # Go back to k-agent-logs directory\ntouch tsconfig.json\n</code></pre> <p></p> <p>Paste the following content into <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre> <p></p> <p>Test that it works:</p> <pre><code>npm run dev\n</code></pre> <p>You should see: <code>K-Agent MCP server running on stdio</code></p> <p></p> <p>!!! warning \u201cIf you get errors:\u201d - <code>Missing script: \"dev\"</code> \u2192 You didn\u2019t update package.json (go back to step 2) - <code>Cannot find module</code> \u2192 Make sure you\u2019re in the k-agent-logs directory - Other errors \u2192 Check that src/index.ts has the correct code</p>"},{"location":"Lab08-Kagent/lab/#step-3-pod-discovery-tool","title":"Step 3: Pod Discovery Tool","text":"<p>Implement pod enumeration across namespaces with the <code>list_pods</code> tool.</p> <p></p>"},{"location":"Lab08-Kagent/lab/#update-setuphandlers-method","title":"Update setupHandlers() Method","text":"<p>Open your <code>src/index.ts</code> file and find the <code>setupHandlers()</code> method. Replace the entire method with the following code:</p> <pre><code>private setupHandlers() {\n  // List available tools\n  this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        }\n      ]\n    };\n  });\n\n  // Handle tool calls\n  this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n    const { name, arguments: args } = request.params;\n\n    try {\n      switch (name) {\n        case \"list_pods\":\n          return await this.handleListPods(args);\n        default:\n          throw new McpError(\n            ErrorCode.MethodNotFound,\n            `Unknown tool: ${name}`\n          );\n      }\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  });\n}\n</code></pre> <p></p>"},{"location":"Lab08-Kagent/lab/#add-handler-methods","title":"Add Handler Methods","text":"<p>Below the <code>setupHandlers()</code> method, before the <code>async run()</code> method, add the following new methods:</p> <pre><code>private async handleListPods(args: any) {\n  const namespace = args?.namespace;\n  const pods = await this.getPods(namespace);\n\n  const podList = pods.map(pod =&gt; ({\n    name: pod.metadata?.name || 'unknown',\n    namespace: pod.metadata?.namespace || 'unknown',\n    status: pod.status?.phase || 'unknown',\n    containers: pod.spec?.containers?.map(c =&gt; c.name) || []\n  }));\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: JSON.stringify(podList, null, 2)\n      }\n    ]\n  };\n}\n\nprivate async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n  try {\n    if (namespace) {\n      const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n      return response.items || [];\n    } else {\n      const response = await this.k8sCoreApi.listPodForAllNamespaces();\n      return response.items || [];\n    }\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n\nprivate handleK8sError(error: any): Error {\n  if (error.response?.statusCode === 403) {\n    return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n  }\n\n  if (error.response?.statusCode === 404) {\n    return new Error('Resource not found: The specified pod or namespace may not exist');\n  }\n\n  return new Error(`Kubernetes operation failed: ${error.message}`);\n}\n</code></pre> <p></p> <p>Complete <code>src/index.ts</code> After Step 3</p> <p>Here\u2019s what your complete <code>src/index.ts</code> file should look like after completing Step 3:</p> <pre><code>```typescript\n// Import MCP SDK components and Kubernetes client\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  // Store Kubernetes API clients (for talking to your cluster)\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n  private server: Server;\n\n  constructor() {\n    // Initialize connection to your Kubernetes cluster (uses ~/.kube/config)\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sConfig.loadFromDefault();\n\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Create MCP server that AI tools can connect to\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      }\n    );\n\n    // Handle incoming MCP requests\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"list_pods\",\n            description: \"List all pods across namespaces with their status\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Optional: Filter by specific namespace\"\n                }\n              }\n            }\n          }\n        ]\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case \"list_pods\":\n            return await this.handleListPods(args);\n          default:\n            throw new McpError(\n              ErrorCode.MethodNotFound,\n              `Unknown tool: ${name}`\n            );\n        }\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    });\n  }\n\n  private async handleListPods(args: any) {\n    const namespace = args?.namespace;\n    const pods = await this.getPods(namespace);\n\n    const podList = pods.map(pod =&gt; ({\n      name: pod.metadata?.name || 'unknown',\n      namespace: pod.metadata?.namespace || 'unknown',\n      status: pod.status?.phase || 'unknown',\n      containers: pod.spec?.containers?.map(c =&gt; c.name) || []\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(podList, null, 2)\n        }\n      ]\n    };\n  }\n\n  private async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n    try {\n      if (namespace) {\n        const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n        return response.items || [];\n      } else {\n        const response = await this.k8sCoreApi.listPodForAllNamespaces();\n        return response.items || [];\n      }\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private handleK8sError(error: any): Error {\n    if (error.response?.statusCode === 403) {\n      return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n    }\n\n    if (error.response?.statusCode === 404) {\n      return new Error('Resource not found: The specified pod or namespace may not exist');\n    }\n\n    return new Error(`Kubernetes operation failed: ${error.message}`);\n  }\n\n  // Start the server and listen for connections\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Actually run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n```\n</code></pre> <p></p>"},{"location":"Lab08-Kagent/lab/#test-pod-discovery","title":"Test Pod Discovery","text":"<p>Test the pod listing functionality using the MCP Inspector by running:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>This will start the MCP Inspector connected to your K-Agent server and open a browser window.</p> <p>Inside the MCP Inspector UI browser window:</p> <ol> <li>Click the \u201cConnect\u201d button</li> <li>Click the \u201cTools\u201d tab</li> <li>Click \u201cList Tools\u201d - you\u2019ll see the <code>list_pods</code> tool</li> <li>Click on <code>list_pods</code></li> <li>Optionally enter a namespace name</li> <li>Click \u201cRun Tool\u201d to test it</li> </ol> <p>You should see a JSON list of all pods with their status and container names.</p>"},{"location":"Lab08-Kagent/lab/#step-4-log-collection-tool","title":"Step 4: Log Collection Tool","text":"<p>Build the core log collection functionality with the <code>collect_pod_logs</code> tool.</p> <p></p>"},{"location":"Lab08-Kagent/lab/#add-collect_pod_logs-to-tools-array","title":"Add collect_pod_logs to Tools Array","text":"<p>In your <code>src/index.ts</code> file, locate the tools array inside <code>setupHandlers()</code> method.</p> <p>Add the following second tool code to the array:</p> <pre><code>private setupHandlers() {\n  // List available tools\n  this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        },\n        {\n          name: \"collect_pod_logs\",\n          description: \"Collect logs from all containers in specified pods\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Namespace to collect logs from\"\n              },\n              podName: {\n                type: \"string\",\n                description: \"Specific pod name (optional - collects from all if not specified)\"\n              },\n              tailLines: {\n                type: \"number\",\n                description: \"Number of recent log lines to retrieve\",\n                default: 100\n              }\n            },\n            required: [\"namespace\"]\n          }\n        }\n      ]\n    };\n  });\n  // ... rest of setupHandlers\n}\n</code></pre> <p></p>"},{"location":"Lab08-Kagent/lab/#update-tool-handler-switch","title":"Update Tool Handler Switch","text":"<p>In the same <code>setupHandlers()</code> method, locate the switch statement and add the following case for <code>collect_pod_logs</code>:</p> <pre><code>switch (name) {\n  case \"list_pods\":\n    return await this.handleListPods(args);\n  case \"collect_pod_logs\":\n    return await this.handleCollectPodLogs(args);\n  default:\n    throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);\n}\n</code></pre> <p></p>"},{"location":"Lab08-Kagent/lab/#implement-log-collection-methods","title":"Implement Log Collection Methods","text":"<p>Below your existing handler methods (after <code>handleK8sError()</code>), before the <code>async run()</code> method, add the following new methods:</p> <pre><code>private async handleCollectPodLogs(args: any) {\n  const { namespace, podName, tailLines = 100 } = args;\n\n  if (!namespace) {\n    throw new Error(\"Namespace is required\");\n  }\n\n  const logs = await this.collectPodLogs(namespace, podName, tailLines);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: logs\n      }\n    ]\n  };\n}\n\nprivate async collectPodLogs(namespace: string, podName?: string, tailLines: number = 100): Promise&lt;string&gt; {\n  const pods = podName\n    ? await this.getPods(namespace).then(pods =&gt; pods.filter(p =&gt; p.metadata?.name === podName))\n    : await this.getPods(namespace);\n\n  const allLogs: string[] = [];\n\n  for (const pod of pods) {\n    if (!pod.metadata?.name) continue;\n\n    const containers = pod.spec?.containers || [];\n    for (const container of containers) {\n      try {\n        const logs = await this.getPodLogs(namespace, pod.metadata.name, container.name, tailLines);\n        allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\n${logs}\\n`);\n      } catch (error) {\n        allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\nError retrieving logs: ${error instanceof Error ? error.message : String(error)}\\n`);\n      }\n    }\n  }\n\n  return allLogs.join('\\n');\n}\n\nprivate async getPodLogs(namespace: string, podName: string, containerName: string, tailLines: number): Promise&lt;string&gt; {\n  try {\n    const response = await this.k8sCoreApi.readNamespacedPodLog({\n      name: podName,\n      namespace: namespace,\n      container: containerName,\n      tailLines: tailLines,\n      timestamps: true\n    });\n    return response || '';\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre> <p>Complete <code>src/index.ts</code> After Step 4</p> <p>Here\u2019s what your complete <code>src/index.ts</code> file should look like after completing Step 4:</p> <pre><code>```typescript\n// Import MCP SDK components and Kubernetes client\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  // Store Kubernetes API clients (for talking to your cluster)\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n  private server: Server;\n\n  constructor() {\n    // Initialize connection to your Kubernetes cluster (uses ~/.kube/config)\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sConfig.loadFromDefault();\n\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Create MCP server that AI tools can connect to\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      }\n    );\n\n    // Handle incoming MCP requests\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"list_pods\",\n            description: \"List all pods across namespaces with their status\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Optional: Filter by specific namespace\"\n                }\n              }\n            }\n          },\n          {\n            name: \"collect_pod_logs\",\n            description: \"Collect logs from all containers in specified pods\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Namespace to collect logs from\"\n                },\n                podName: {\n                  type: \"string\",\n                  description: \"Specific pod name (optional - collects from all if not specified)\"\n                },\n                tailLines: {\n                  type: \"number\",\n                  description: \"Number of recent log lines to retrieve\",\n                  default: 100\n                }\n              },\n              required: [\"namespace\"]\n            }\n          }\n        ]\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case \"list_pods\":\n            return await this.handleListPods(args);\n          case \"collect_pod_logs\":\n            return await this.handleCollectPodLogs(args);\n          default:\n            throw new McpError(\n              ErrorCode.MethodNotFound,\n              `Unknown tool: ${name}`\n            );\n        }\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    });\n  }\n\n  private async handleListPods(args: any) {\n    const namespace = args?.namespace;\n    const pods = await this.getPods(namespace);\n\n    const podList = pods.map(pod =&gt; ({\n      name: pod.metadata?.name || 'unknown',\n      namespace: pod.metadata?.namespace || 'unknown',\n      status: pod.status?.phase || 'unknown',\n      containers: pod.spec?.containers?.map(c =&gt; c.name) || []\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(podList, null, 2)\n        }\n      ]\n    };\n  }\n\n  private async handleCollectPodLogs(args: any) {\n    const { namespace, podName, tailLines = 100 } = args;\n\n    if (!namespace) {\n      throw new Error(\"Namespace is required\");\n    }\n\n    const logs = await this.collectPodLogs(namespace, podName, tailLines);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: logs\n        }\n      ]\n    };\n  }\n\n  private async collectPodLogs(namespace: string, podName?: string, tailLines: number = 100): Promise&lt;string&gt; {\n    const pods = podName\n      ? await this.getPods(namespace).then(pods =&gt; pods.filter(p =&gt; p.metadata?.name === podName))\n      : await this.getPods(namespace);\n\n    const allLogs: string[] = [];\n\n    for (const pod of pods) {\n      if (!pod.metadata?.name) continue;\n\n      const containers = pod.spec?.containers || [];\n      for (const container of containers) {\n        try {\n          const logs = await this.getPodLogs(namespace, pod.metadata.name, container.name, tailLines);\n          allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\n${logs}\\n`);\n        } catch (error) {\n          allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\nError retrieving logs: ${error instanceof Error ? error.message : String(error)}\\n`);\n        }\n      }\n    }\n\n    return allLogs.join('\\n');\n  }\n\n  private async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n    try {\n      if (namespace) {\n        const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n        return response.items || [];\n      } else {\n        const response = await this.k8sCoreApi.listPodForAllNamespaces();\n        return response.items || [];\n      }\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private async getPodLogs(namespace: string, podName: string, containerName: string, tailLines: number): Promise&lt;string&gt; {\n    try {\n      const response = await this.k8sCoreApi.readNamespacedPodLog({\n        name: podName,\n        namespace: namespace,\n        container: containerName,\n        tailLines: tailLines,\n        timestamps: true\n      });\n      return response || '';\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private handleK8sError(error: any): Error {\n    if (error.response?.statusCode === 403) {\n      return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n    }\n\n    if (error.response?.statusCode === 404) {\n      return new Error('Resource not found: The specified pod or namespace may not exist');\n    }\n\n    return new Error(`Kubernetes operation failed: ${error.message}`);\n  }\n\n  // Start the server and listen for connections\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Actually run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n```\n</code></pre> <p></p>"},{"location":"Lab08-Kagent/lab/#test-log-collection","title":"Test Log Collection","text":"<p>Test the log collection functionality with the MCP Inspector:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>This will start the MCP Inspector connected to your K-Agent server and open a browser window.</p> <p>In the MCP Inspector UI browser window:</p> <ol> <li>Click the \u201cConnect\u201d button</li> <li>Click the \u201cTools\u201d tab</li> <li>Click \u201cList Tools\u201d - you\u2019ll see both <code>list_pods</code> and <code>collect_pod_logs</code></li> <li>Click on <code>collect_pod_logs</code></li> <li>In the namespace field, enter: <code>default</code></li> <li>Click \u201cRun Tool\u201d</li> </ol> <p>You should see logs from all pods in the default namespace, formatted with pod and container names.</p>"},{"location":"Lab08-Kagent/lab/#optional-extensions","title":"Optional Extensions","text":"<p>Prerequisites</p> <p>These exercises assume you have completed Steps 1-4 and have a fully functional K-Agent server with <code>list_pods</code> and <code>collect_pod_logs</code> tools. These exercises extend the functionality beyond the core implementation.</p>"},{"location":"Lab08-Kagent/lab/#exercise-1-advanced-pod-filtering-and-sorting","title":"Exercise 1: Advanced Pod Filtering and Sorting","text":"<p>Enhance the <code>list_pods</code> tool to support filtering by status, labels, and sorting by various criteria.</p> <p>Update the list_pods tool schema in your <code>setupHandlers()</code> method to include new parameters:</p> <pre><code>{\n  name: \"list_pods\",\n  description: \"List all pods across namespaces with their status, with filtering and sorting options\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Optional: Filter by specific namespace\"\n      },\n      status: {\n        type: \"string\",\n        description: \"Optional: Filter by pod status (Running, Pending, Failed, etc.)\",\n        enum: [\"Running\", \"Pending\", \"Failed\", \"Succeeded\", \"Unknown\"]\n      },\n      labelSelector: {\n        type: \"string\",\n        description: \"Optional: Filter by label selector (e.g., 'app=nginx,env=prod')\"\n      },\n      sortBy: {\n        type: \"string\",\n        description: \"Sort results by field\",\n        enum: [\"name\", \"namespace\", \"status\", \"age\"],\n        default: \"name\"\n      }\n    }\n  }\n}\n</code></pre> <p></p> <p>Update the handleListPods method to support the new parameters:</p> <pre><code>private async handleListPods(args: any) {\n  const { namespace, status, labelSelector, sortBy = 'name' } = args;\n  let pods = await this.getPods(namespace, labelSelector);\n\n  // Filter by status if specified\n  if (status) {\n    pods = pods.filter(pod =&gt; pod.status?.phase === status);\n  }\n\n  // Map to simplified format\n  const podList = pods.map(pod =&gt; ({\n    name: pod.metadata?.name || 'unknown',\n    namespace: pod.metadata?.namespace || 'unknown',\n    status: pod.status?.phase || 'unknown',\n    containers: pod.spec?.containers?.map(c =&gt; c.name) || [],\n    age: pod.metadata?.creationTimestamp\n      ? Math.floor((Date.now() - new Date(pod.metadata.creationTimestamp).getTime()) / 1000 / 60)\n      : 0,\n    labels: pod.metadata?.labels || {}\n  }));\n\n  // Sort results\n  const sortedPods = this.sortPods(podList, sortBy);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: JSON.stringify(sortedPods, null, 2)\n      }\n    ]\n  };\n}\n</code></pre> <p></p> <p>Update the getPods method to support label selectors:</p> <pre><code>private async getPods(namespace?: string, labelSelector?: string): Promise&lt;k8s.V1Pod[]&gt; {\n  try {\n    if (namespace) {\n      const response = await this.k8sCoreApi.listNamespacedPod({\n        namespace,\n        labelSelector\n      });\n      return response.items || [];\n    } else {\n      const response = await this.k8sCoreApi.listPodForAllNamespaces({\n        labelSelector\n      });\n      return response.items || [];\n    }\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre> <p></p> <p>Add a sorting helper method after the <code>getPods</code> method:</p> <pre><code>private sortPods(pods: any[], sortBy: string): any[] {\n  return pods.sort((a, b) =&gt; {\n    switch (sortBy) {\n      case 'namespace':\n        return a.namespace.localeCompare(b.namespace);\n      case 'status':\n        return a.status.localeCompare(b.status);\n      case 'age':\n        return b.age - a.age; // Newest first\n      case 'name':\n      default:\n        return a.name.localeCompare(b.name);\n    }\n  });\n}\n</code></pre> <p></p> <p>Test the enhanced filtering:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>Try these test cases:</p> <ul> <li>List only Running pods: Set <code>status</code> to \u201cRunning\u201d</li> <li>Filter by labels: Set <code>labelSelector</code> to \u201capp=nginx\u201d</li> <li>Sort by age: Set <code>sortBy</code> to \u201cage\u201d</li> <li>Combine filters: Use namespace + status + sortBy together</li> </ul>"},{"location":"Lab08-Kagent/lab/#exercise-2-enhanced-log-analysis-with-search-and-export","title":"Exercise 2: Enhanced Log Analysis with Search and Export","text":"<p>Extend the <code>collect_pod_logs</code> tool to support log searching, filtering by severity, and exporting logs to files.</p> <p>Add a new tool <code>analyze_logs</code> to your tools array in <code>setupHandlers()</code>:</p> <pre><code>{\n  name: \"analyze_logs\",\n  description: \"Analyze and search through pod logs with filtering and export capabilities\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to analyze logs from\"\n      },\n      podName: {\n        type: \"string\",\n        description: \"Specific pod name (optional)\"\n      },\n      searchPattern: {\n        type: \"string\",\n        description: \"Regex pattern to search for in logs\"\n      },\n      severityLevel: {\n        type: \"string\",\n        description: \"Filter by log severity\",\n        enum: [\"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"]\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to analyze\",\n        default: 100\n      },\n      exportToFile: {\n        type: \"boolean\",\n        description: \"Export matching logs to a file\",\n        default: false\n      }\n    },\n    required: [\"namespace\"]\n  }\n}\n</code></pre> <p></p> <p>Add the case to your switch statement:</p> <pre><code>case \"analyze_logs\":\n  return await this.handleAnalyzeLogs(args);\n</code></pre> <p></p> <p>Implement the log analysis handler after your <code>handleCollectPodLogs</code> method:</p> <pre><code>private async handleAnalyzeLogs(args: any) {\n  const { namespace, podName, searchPattern, severityLevel, tailLines = 100, exportToFile = false } = args;\n\n  if (!namespace) {\n    throw new Error(\"Namespace is required\");\n  }\n\n  const logs = await this.collectPodLogs(namespace, podName, tailLines);\n  const analyzedLogs = this.analyzeLogs(logs, searchPattern, severityLevel);\n\n  if (exportToFile) {\n    const filename = await this.exportLogs(analyzedLogs, namespace, podName);\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Analysis complete. ${analyzedLogs.totalLines} lines analyzed, ${analyzedLogs.matchingLines} matches found.\\nExported to: ${filename}\\n\\n${analyzedLogs.summary}`\n        }\n      ]\n    };\n  }\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Analysis Results:\\n${analyzedLogs.summary}\\n\\nMatching Logs:\\n${analyzedLogs.matches.join('\\n')}`\n      }\n    ]\n  };\n}\n</code></pre> <p></p> <p>Add the log analysis helper method:</p> <pre><code>private analyzeLogs(logs: string, searchPattern?: string, severityLevel?: string) {\n  const lines = logs.split('\\n');\n  const matches: string[] = [];\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  for (const line of lines) {\n    // Filter by severity if specified\n    if (severityLevel) {\n      if (!line.includes(severityLevel)) continue;\n    }\n\n    // Search for pattern if specified\n    if (searchPattern) {\n      const regex = new RegExp(searchPattern, 'i');\n      if (regex.test(line)) {\n        matches.push(line);\n      }\n    } else {\n      matches.push(line);\n    }\n\n    // Categorize by severity\n    if (line.includes('ERROR') || line.includes('error')) {\n      errors.push(line);\n    } else if (line.includes('WARN') || line.includes('warning')) {\n      warnings.push(line);\n    }\n  }\n\n  const summary = [\n    `Total Lines: ${lines.length}`,\n    `Matching Lines: ${matches.length}`,\n    `Errors Found: ${errors.length}`,\n    `Warnings Found: ${warnings.length}`,\n    searchPattern ? `Search Pattern: ${searchPattern}` : '',\n    severityLevel ? `Severity Filter: ${severityLevel}` : ''\n  ].filter(Boolean).join('\\n');\n\n  return {\n    totalLines: lines.length,\n    matchingLines: matches.length,\n    matches: matches.slice(0, 100), // Limit to first 100 matches\n    errors,\n    warnings,\n    summary\n  };\n}\n</code></pre> <p></p> <p>Add the export helper method (requires fs module - add <code>import * as fs from 'fs';</code> at the top):</p> <pre><code>private async exportLogs(analyzedLogs: any, namespace: string, podName?: string): Promise&lt;string&gt; {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const filename = `logs_${namespace}_${podName || 'all'}_${timestamp}.txt`;\n  const filepath = `/tmp/${filename}`;\n\n  const content = [\n    `Kubernetes Log Analysis Report`,\n    `Generated: ${new Date().toISOString()}`,\n    `Namespace: ${namespace}`,\n    podName ? `Pod: ${podName}` : 'All Pods',\n    ``,\n    analyzedLogs.summary,\n    ``,\n    `=== Matching Log Entries ===`,\n    analyzedLogs.matches.join('\\n')\n  ].join('\\n');\n\n  // Note: In a real implementation, you'd want to handle file system operations more carefully\n  // For this exercise, we'll just return the intended filename\n  return filepath;\n}\n</code></pre> <p></p> <p>Test the log analysis:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>Try these test cases:</p> <ul> <li>Search for errors: Set <code>searchPattern</code> to \u201cerror\u201d and <code>severityLevel</code> to \u201cERROR\u201d</li> <li>Find warnings: Set <code>severityLevel</code> to \u201cWARN\u201d</li> <li>Export logs: Set <code>exportToFile</code> to true</li> <li>Pattern matching: Set <code>searchPattern</code> to a specific error code or message</li> </ul>"},{"location":"Lab08-Kagent/lab/#exercise-3-real-time-pod-monitoring","title":"Exercise 3: Real-Time Pod Monitoring","text":"<p>Create a new tool to monitor pod health and events in real-time, providing insights into pod lifecycle changes.</p> <p>Add the <code>monitor_pod_health</code> tool to your tools array:</p> <pre><code>{\n  name: \"monitor_pod_health\",\n  description: \"Monitor pod health, restart counts, and recent events\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to monitor\"\n      },\n      podName: {\n        type: \"string\",\n        description: \"Specific pod to monitor (optional)\"\n      },\n      includeEvents: {\n        type: \"boolean\",\n        description: \"Include recent Kubernetes events\",\n        default: true\n      }\n    },\n    required: [\"namespace\"]\n  }\n}\n</code></pre> <p></p> <p>Add the case to your switch statement:</p> <pre><code>case \"monitor_pod_health\":\n  return await this.handleMonitorPodHealth(args);\n</code></pre> <p></p> <p>Implement the monitoring handler:</p> <pre><code>private async handleMonitorPodHealth(args: any) {\n  const { namespace, podName, includeEvents = true } = args;\n\n  if (!namespace) {\n    throw new Error(\"Namespace is required\");\n  }\n\n  const pods = podName\n    ? await this.getPods(namespace).then(pods =&gt; pods.filter(p =&gt; p.metadata?.name === podName))\n    : await this.getPods(namespace);\n\n  const healthReports = [];\n\n  for (const pod of pods) {\n    if (!pod.metadata?.name) continue;\n\n    const health = this.analyzePodHealth(pod);\n    const events = includeEvents\n      ? await this.getPodEvents(namespace, pod.metadata.name)\n      : [];\n\n    healthReports.push({\n      pod: pod.metadata.name,\n      namespace: pod.metadata.namespace,\n      health,\n      events\n    });\n  }\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: JSON.stringify(healthReports, null, 2)\n      }\n    ]\n  };\n}\n</code></pre> <p></p> <p>Add the health analysis method:</p> <pre><code>private analyzePodHealth(pod: k8s.V1Pod) {\n  const status = pod.status;\n  const conditions = status?.conditions || [];\n  const containerStatuses = status?.containerStatuses || [];\n\n  // Calculate restart counts\n  const totalRestarts = containerStatuses.reduce(\n    (sum, cs) =&gt; sum + (cs.restartCount || 0),\n    0\n  );\n\n  // Check readiness\n  const readyCondition = conditions.find(c =&gt; c.type === 'Ready');\n  const isReady = readyCondition?.status === 'True';\n\n  // Check container states\n  const containerHealth = containerStatuses.map(cs =&gt; ({\n    name: cs.name,\n    ready: cs.ready,\n    restartCount: cs.restartCount || 0,\n    state: cs.state?.running ? 'Running'\n      : cs.state?.waiting ? `Waiting: ${cs.state.waiting.reason}`\n      : cs.state?.terminated ? `Terminated: ${cs.state.terminated.reason}`\n      : 'Unknown',\n    lastState: cs.lastState?.terminated\n      ? `Previously terminated: ${cs.lastState.terminated.reason}`\n      : undefined\n  }));\n\n  // Overall health assessment\n  const healthStatus =\n    status?.phase === 'Running' &amp;&amp; isReady &amp;&amp; totalRestarts === 0 ? 'Healthy' :\n    status?.phase === 'Running' &amp;&amp; totalRestarts &gt; 0 ? 'Unstable' :\n    status?.phase === 'Pending' ? 'Starting' :\n    status?.phase === 'Failed' ? 'Failed' :\n    'Unknown';\n\n  return {\n    phase: status?.phase,\n    healthStatus,\n    isReady,\n    totalRestarts,\n    age: pod.metadata?.creationTimestamp\n      ? Math.floor((Date.now() - new Date(pod.metadata.creationTimestamp).getTime()) / 1000 / 60)\n      : 0,\n    conditions: conditions.map(c =&gt; ({\n      type: c.type,\n      status: c.status,\n      reason: c.reason,\n      message: c.message\n    })),\n    containers: containerHealth\n  };\n}\n</code></pre> <p></p> <p>Add the events retrieval method:</p> <pre><code>private async getPodEvents(namespace: string, podName: string): Promise&lt;any[]&gt; {\n  try {\n    const response = await this.k8sCoreApi.listNamespacedEvent({\n      namespace,\n      fieldSelector: `involvedObject.name=${podName}`\n    });\n\n    const events = (response.items || [])\n      .sort((a, b) =&gt; {\n        const timeA = a.lastTimestamp || a.firstTimestamp || '';\n        const timeB = b.lastTimestamp || b.firstTimestamp || '';\n        return timeB.localeCompare(timeA);\n      })\n      .slice(0, 10) // Last 10 events\n      .map(event =&gt; ({\n        type: event.type,\n        reason: event.reason,\n        message: event.message,\n        count: event.count,\n        time: event.lastTimestamp || event.firstTimestamp\n      }));\n\n    return events;\n  } catch (error) {\n    console.error('Failed to retrieve events:', error);\n    return [];\n  }\n}\n</code></pre> <p></p> <p>Test the monitoring functionality:</p> <pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>Try these test cases:</p> <ul> <li>Monitor a specific pod: Set <code>namespace</code> and <code>podName</code></li> <li>Check all pods in namespace: Set only <code>namespace</code></li> <li>Include events: Set <code>includeEvents</code> to true</li> <li>Look for unhealthy pods with high restart counts</li> </ul> <p>Extension Ideas</p> <p>Now that you have a robust K-Agent, consider these additional enhancements:</p> <pre><code>- **Resource Metrics**: Add CPU/memory usage monitoring using the Metrics API\n- **Multi-Cluster Support**: Extend to work with multiple Kubernetes clusters\n- **Alerting**: Implement threshold-based alerts for restart counts or error rates\n- **Log Aggregation**: Integrate with log aggregation systems like ELK or Loki\n- **Historical Analysis**: Store and analyze trends over time\n- **Auto-Remediation**: Add tools to automatically restart or scale problematic pods\n</code></pre>"},{"location":"Lab08-Kagent/lab/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Lab08-Kagent/lab/#common-issues","title":"Common Issues","text":"<p>\u201cKubernetes configuration not found\u201d</p> <ul> <li>Ensure <code>kubectl</code> is installed and configured</li> <li>Check <code>~/.kube/config</code> exists and is readable</li> </ul> <p>\u201cPod not found\u201d errors</p> <ul> <li>Confirm pod names and namespaces are correct</li> <li>Check pod status with <code>kubectl get pods</code></li> </ul>"},{"location":"Lab08-Kagent/lab/#debug-commands","title":"Debug Commands","text":"<pre><code># Check cluster access\nkubectl cluster-info\n\n# Verify service account permissions\nkubectl auth can-i list pods --as=system:serviceaccount:default:k-agent-sa\n\n# Check pod logs\nkubectl logs -n your-namespace your-pod-name\n</code></pre>"},{"location":"Lab08-Kagent/lab/#key-takeaways","title":"Key Takeaways","text":"<p>!!! success \u201cWhat You Learned\u201d - K-Agent Architecture: Building specialized MCP servers for Kubernetes operations - MCP Server Setup: Configuring TypeScript-based MCP servers with proper dependencies - Kubernetes Client Integration: Using the @kubernetes/client-node library to interact with clusters - Tool Implementation: Creating MCP tools for pod discovery and log collection - Error Handling: Managing Kubernetes API errors and edge cases - Testing with MCP Inspector: Using the Inspector to test and debug MCP tools</p> <p>Congratulations! You\u2019ve built a functional K-Agent with two core capabilities:</p> <ul> <li>Pod Discovery - List all pods across namespaces with status information</li> <li>Log Collection - Retrieve logs from pod containers with timestamp support</li> </ul>"},{"location":"Lab08-Kagent/lab/#whats-next","title":"What\u2019s Next?","text":"<p>Your K-Agent provides a foundation for more advanced Kubernetes automation.</p> <p>Consider exploring:</p> <ul> <li>Adding filtering, log analysis, and health monitoring</li> <li>Integrating your K-Agent with other MCP clients</li> <li>Adding more tools for resource management (deployments, services, configmaps)</li> <li>Implementing resource watching for real-time cluster monitoring</li> <li>Building custom tools specific to your set Kubernetes workflows</li> </ul>"},{"location":"Lab08-Kagent/lab/#additional-resources","title":"Additional Resources","text":"<ul> <li>Kubernetes API Documentation</li> <li>MCP SDK Reference</li> <li>Log Aggregation Patterns</li> </ul>"},{"location":"Lab08-Kagent/lab6-tasks/","title":"MCP Lab Tasks - Lab 6: K-Agent","text":"<p>Welcome to Lab 6! In this lab, you\u2019ll build a K-Agent - an MCP server specialized for Kubernetes operations with a focus on log collection from all pods.</p> <p>The exercises build progressively, starting with basic Kubernetes client setup and culminating in a complete log collection system.</p>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-61-k-agent-project-setup","title":"Exercise 6.1: K-Agent Project Setup","text":"<p>Create a new MCP server project with Kubernetes dependencies.</p> Solution <pre><code># Create project directory\nmkdir k-agent-logs\ncd k-agent-logs\n\n# Initialize Node.js project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk @kubernetes/client-node\nnpm install -D typescript @types/node tsx\n\n# Create TypeScript configuration\nnpx tsc --init --target ES2022 --module NodeNext --moduleResolution NodeNext --esModuleInterop --allowSyntheticDefaultImports --strict --skipLibCheck --forceConsistentCasingInFileNames --outDir ./dist --rootDir ./src\n\n# Create source directory structure\nmkdir -p src\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-62-basic-k-agent-server-structure","title":"Exercise 6.2: Basic K-Agent Server Structure","text":"<p>Create the basic MCP server structure with Kubernetes client initialization.</p> Solution <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  private server: Server;\n  private k8sConfig: k8s.KubeConfig;\n  private k8sCoreApi: k8s.CoreV1Api;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    // Initialize Kubernetes client\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // Tools will be added in subsequent exercises\n  }\n\n  async start() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent server started\");\n  }\n}\n\n// Start the server\nconst server = new KAgentServer();\nserver.start().catch(console.error);\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-63-kubernetes-authentication","title":"Exercise 6.3: Kubernetes Authentication","text":"<p>Implement secure Kubernetes cluster authentication with proper error handling.</p> Solution <pre><code>private loadKubeConfig(): void {\n  try {\n    this.k8sConfig.loadFromDefault();\n\n    // Validate cluster access\n    this.validateClusterAccess();\n  } catch (error) {\n    throw new Error(`Kubernetes configuration error: ${error.message}`);\n  }\n}\n\nprivate async validateClusterAccess(): Promise&lt;void&gt; {\n  try {\n    // Test API access by listing namespaces\n    await this.k8sCoreApi.listNamespace();\n  } catch (error: any) {\n    if (error.response?.statusCode === 403) {\n      throw new Error('Access denied: Insufficient permissions to access Kubernetes cluster');\n    }\n    throw new Error(`Cluster access validation failed: ${error.message}`);\n  }\n}\n\nconstructor() {\n  // ... existing constructor code ...\n\n  // Initialize Kubernetes client\n  this.loadKubeConfig();\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-64-pod-listing-tool","title":"Exercise 6.4: Pod Listing Tool","text":"<p>Implement a tool to list all pods across namespaces with their status.</p> Solution <pre><code>private setupHandlers() {\n  // Tools list handler\n  this.server.setRequestHandler(\"tools/list\", async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        }\n      ]\n    };\n  });\n\n  // Tools call handler\n  this.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n    const { name, arguments: args } = request.params;\n\n    switch (name) {\n      case \"list_pods\":\n        return await this.handleListPods(args);\n      default:\n        throw new Error(`Unknown tool: ${name}`);\n    }\n  });\n}\n\nprivate async handleListPods(args: any) {\n  try {\n    const namespace = args?.namespace;\n    const pods = namespace\n      ? await this.k8sCoreApi.listNamespacedPod(namespace)\n      : await this.k8sCoreApi.listPodForAllNamespaces();\n\n    const podInfo = pods.body.items.map(pod =&gt; ({\n      name: pod.metadata?.name,\n      namespace: pod.metadata?.namespace,\n      status: pod.status?.phase,\n      containers: pod.spec?.containers?.length || 0\n    }));\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Found ${podInfo.length} pods:\\n${podInfo.map(p =&gt;\n          `- ${p.namespace}/${p.name}: ${p.status} (${p.containers} containers)`\n        ).join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n\nprivate handleK8sError(error: any): Error {\n  if (error.response?.statusCode === 403) {\n    return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n  }\n\n  if (error.response?.statusCode === 404) {\n    return new Error('Resource not found: The specified namespace may not exist');\n  }\n\n  return new Error(`Kubernetes operation failed: ${error.message}`);\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-65-single-pod-log-collection","title":"Exercise 6.5: Single Pod Log Collection","text":"<p>Implement log collection from a specific pod.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"get_pod_logs\",\n  description: \"Get logs from a specific pod\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace of the pod\"\n      },\n      podName: {\n        type: \"string\",\n        description: \"Name of the pod\"\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to retrieve\",\n        default: 100\n      }\n    },\n    required: [\"namespace\", \"podName\"]\n  }\n}\n\n// Add to tools call handler\ncase \"get_pod_logs\":\n  return await this.handleGetPodLogs(args);\n\nprivate async handleGetPodLogs(args: any) {\n  const { namespace, podName, tailLines = 100 } = args;\n\n  try {\n    const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n      podName,\n      namespace,\n      undefined, // container\n      false, // follow\n      undefined, // previous\n      undefined, // sinceSeconds\n      undefined, // sinceTime\n      tailLines, // tailLines\n      undefined, // timestamps\n      undefined // limitBytes\n    );\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Logs from pod ${namespace}/${podName}:\\n\\n${logResponse.body}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-66-multi-pod-log-collection","title":"Exercise 6.6: Multi-Pod Log Collection","text":"<p>Extend the system to collect logs from all pods in a namespace.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"collect_namespace_logs\",\n  description: \"Collect logs from all pods in a namespace\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to collect logs from\"\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines per pod\",\n        default: 50\n      }\n    },\n    required: [\"namespace\"]\n  }\n}\n\n// Add to tools call handler\ncase \"collect_namespace_logs\":\n  return await this.handleCollectNamespaceLogs(args);\n\nprivate async handleCollectNamespaceLogs(args: any) {\n  const { namespace, tailLines = 50 } = args;\n\n  try {\n    // Get all pods in namespace\n    const podsResponse = await this.k8sCoreApi.listNamespacedPod(namespace);\n    const pods = podsResponse.body.items.filter(pod =&gt;\n      pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n    );\n\n    if (pods.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: `No running pods found in namespace ${namespace}`\n        }]\n      };\n    }\n\n    const allLogs: string[] = [];\n\n    for (const pod of pods) {\n      const podName = pod.metadata?.name!;\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          namespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        allLogs.push(`=== ${podName} ===\\n${logResponse.body}\\n`);\n      } catch (error: any) {\n        allLogs.push(`=== ${podName} ===\\nError retrieving logs: ${error.message}\\n`);\n      }\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Logs from ${pods.length} pods in namespace ${namespace}:\\n\\n${allLogs.join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-67-all-namespace-log-collection","title":"Exercise 6.7: All-Namespace Log Collection","text":"<p>Implement the core feature: collect logs from all pods across all namespaces.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"collect_all_logs\",\n  description: \"Collect logs from all pods across all namespaces\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines per pod\",\n        default: 25\n      },\n      maxPods: {\n        type: \"number\",\n        description: \"Maximum number of pods to collect logs from\",\n        default: 50\n      }\n    }\n  }\n}\n\n// Add to tools call handler\ncase \"collect_all_logs\":\n  return await this.handleCollectAllLogs(args);\n\nprivate async handleCollectAllLogs(args: any) {\n  const { tailLines = 25, maxPods = 50 } = args;\n\n  try {\n    // Get all pods across all namespaces\n    const podsResponse = await this.k8sCoreApi.listPodForAllNamespaces();\n    const pods = podsResponse.body.items\n      .filter(pod =&gt;\n        pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n      )\n      .slice(0, maxPods); // Limit for performance\n\n    if (pods.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: \"No running pods found in the cluster\"\n        }]\n      };\n    }\n\n    const allLogs: string[] = [];\n    let processedCount = 0;\n\n    for (const pod of pods) {\n      const podName = pod.metadata?.name!;\n      const namespace = pod.metadata?.namespace!;\n\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          namespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        allLogs.push(`=== ${namespace}/${podName} ===\\n${logResponse.body}\\n`);\n        processedCount++;\n      } catch (error: any) {\n        allLogs.push(`=== ${namespace}/${podName} ===\\nError retrieving logs: ${error.message}\\n`);\n      }\n    }\n\n    const summary = `Collected logs from ${processedCount} out of ${pods.length} pods (limited to ${maxPods} max)\\n\\n`;\n\n    return {\n      content: [{\n        type: \"text\",\n        text: summary + allLogs.join('\\n')\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-68-log-filtering-and-search","title":"Exercise 6.8: Log Filtering and Search","text":"<p>Add filtering capabilities to search through logs.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"search_logs\",\n  description: \"Search for specific patterns in pod logs\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to search in (optional)\"\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Text pattern to search for\"\n      },\n      caseSensitive: {\n        type: \"boolean\",\n        description: \"Whether search should be case sensitive\",\n        default: false\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to search through\",\n        default: 100\n      }\n    },\n    required: [\"pattern\"]\n  }\n}\n\n// Add to tools call handler\ncase \"search_logs\":\n  return await this.handleSearchLogs(args);\n\nprivate async handleSearchLogs(args: any) {\n  const { namespace, pattern, caseSensitive = false, tailLines = 100 } = args;\n\n  try {\n    const podsResponse = namespace\n      ? await this.k8sCoreApi.listNamespacedPod(namespace)\n      : await this.k8sCoreApi.listPodForAllNamespaces();\n\n    const runningPods = podsResponse.body.items.filter(pod =&gt;\n      pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n    );\n\n    const matches: string[] = [];\n    const flags = caseSensitive ? 'g' : 'gi';\n    const regex = new RegExp(pattern, flags);\n\n    for (const pod of runningPods) {\n      const podName = pod.metadata?.name!;\n      const podNamespace = pod.metadata?.namespace!;\n\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          podNamespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        const logs = logResponse.body;\n        const lines = logs.split('\\n');\n\n        const matchingLines = lines\n          .map((line, index) =&gt; ({ line, index }))\n          .filter(({ line }) =&gt; regex.test(line))\n          .map(({ line, index }) =&gt; `  Line ${index + 1}: ${line}`);\n\n        if (matchingLines.length &gt; 0) {\n          matches.push(`=== ${podNamespace}/${podName} ===`);\n          matches.push(...matchingLines);\n          matches.push('');\n        }\n      } catch (error) {\n        // Skip pods where we can't read logs\n      }\n    }\n\n    if (matches.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: `No logs matching pattern \"${pattern}\" found`\n        }]\n      };\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Found ${matches.length} matches for pattern \"${pattern}\":\\n\\n${matches.join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-69-resource-integration","title":"Exercise 6.9: Resource Integration","text":"<p>Create MCP resources for recent log summaries.</p> Solution <pre><code>constructor() {\n  this.server = new Server(\n    {\n      name: \"k-agent-logs\",\n      version: \"1.0.0\",\n    },\n    {\n      capabilities: {\n        tools: {},\n        resources: {},\n      },\n    }\n  );\n\n  // ... rest of constructor\n}\n\nprivate setupHandlers() {\n  // ... existing tools setup ...\n\n  // Resources handlers\n  this.server.setRequestHandler(\"resources/list\", async () =&gt; {\n    return {\n      resources: [\n        {\n          uri: \"logs://cluster/summary\",\n          name: \"Cluster Logs Summary\",\n          description: \"Summary of recent logs from all pods\",\n          mimeType: \"application/json\"\n        }\n      ]\n    };\n  });\n\n  this.server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n    const { uri } = request.params;\n\n    if (uri === \"logs://cluster/summary\") {\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify(await this.getClusterLogsSummary(), null, 2)\n        }]\n      };\n    }\n\n    throw new Error(`Resource not found: ${uri}`);\n  });\n}\n\nprivate async getClusterLogsSummary() {\n  try {\n    const podsResponse = await this.k8sCoreApi.listPodForAllNamespaces();\n    const pods = podsResponse.body.items;\n\n    const summary = {\n      timestamp: new Date().toISOString(),\n      totalPods: pods.length,\n      runningPods: pods.filter(p =&gt; p.status?.phase === 'Running').length,\n      namespaces: [...new Set(pods.map(p =&gt; p.metadata?.namespace))].length,\n      podStatusCounts: pods.reduce((acc, pod) =&gt; {\n        const phase = pod.status?.phase || 'Unknown';\n        acc[phase] = (acc[phase] || 0) + 1;\n        return acc;\n      }, {} as Record&lt;string, number&gt;)\n    };\n\n    return summary;\n  } catch (error: any) {\n    return {\n      error: `Failed to get cluster summary: ${error.message}`,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-610-error-handling-and-validation","title":"Exercise 6.10: Error Handling and Validation","text":"<p>Implement comprehensive error handling and input validation.</p> Solution <pre><code>private validateToolArguments(toolName: string, args: any): void {\n  switch (toolName) {\n    case 'list_pods':\n      if (args?.namespace &amp;&amp; typeof args.namespace !== 'string') {\n        throw new Error('namespace must be a string');\n      }\n      break;\n\n    case 'get_pod_logs':\n      if (!args?.namespace || typeof args.namespace !== 'string') {\n        throw new Error('namespace is required and must be a string');\n      }\n      if (!args?.podName || typeof args.podName !== 'string') {\n        throw new Error('podName is required and must be a string');\n      }\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      break;\n\n    case 'collect_namespace_logs':\n      if (!args?.namespace || typeof args.namespace !== 'string') {\n        throw new Error('namespace is required and must be a string');\n      }\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      break;\n\n    case 'collect_all_logs':\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      if (args?.maxPods &amp;&amp; (typeof args.maxPods !== 'number' || args.maxPods &lt; 1)) {\n        throw new Error('maxPods must be a positive number');\n      }\n      break;\n\n    case 'search_logs':\n      if (!args?.pattern || typeof args.pattern !== 'string') {\n        throw new Error('pattern is required and must be a string');\n      }\n      if (args?.namespace &amp;&amp; typeof args.namespace !== 'string') {\n        throw new Error('namespace must be a string');\n      }\n      break;\n  }\n}\n\n// Update tools call handler to include validation\nthis.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  // Validate arguments\n  this.validateToolArguments(name, args);\n\n  switch (name) {\n    // ... existing cases\n  }\n});\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-611-package-configuration","title":"Exercise 6.11: Package Configuration","text":"<p>Create proper package.json and tsconfig.json for the K-Agent.</p> Solution <p>package.json: <pre><code>{\n  \"name\": \"k-agent-logs\",\n  \"version\": \"1.0.0\",\n  \"description\": \"K-Agent MCP server for Kubernetes log collection\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\",\n    \"test\": \"echo \\\"No tests specified\\\"\"\n  },\n  \"keywords\": [\"mcp\", \"kubernetes\", \"logs\", \"monitoring\"],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@kubernetes/client-node\": \"^0.20.0\",\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre></p> <p>tsconfig.json: <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre></p>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-612-docker-configuration","title":"Exercise 6.12: Docker Configuration","text":"<p>Create a Dockerfile for containerized deployment.</p> Solution <pre><code>FROM node:18-alpine\n\n# Install kubectl\nRUN apk add --no-cache curl &amp;&amp; \\\n    curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" &amp;&amp; \\\n    install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl &amp;&amp; \\\n    rm kubectl &amp;&amp; \\\n    kubectl version --client\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nCOPY tsconfig.json ./\n\n# Install dependencies\nRUN npm ci --only=production &amp;&amp; npm cache clean --force\n\n# Copy source code\nCOPY src/ ./src/\n\n# Build TypeScript\nRUN npm run build\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs &amp;&amp; \\\n    adduser -S kagent -u 1001\n\n# Change ownership\nRUN chown -R kagent:nodejs /app\nUSER kagent\n\nEXPOSE 3000\n\nCMD [\"npm\", \"start\"]\n</code></pre>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-613-testing-the-k-agent","title":"Exercise 6.13: Testing the K-Agent","text":"<p>Create a test script to verify all functionality.</p> Solution <p>test-kagent.js: <pre><code>const { spawn } = require('child_process');\n\nasync function testKAgent() {\n  console.log('Testing K-Agent functionality...\\n');\n\n  const server = spawn('node', ['dist/index.js'], {\n    stdio: ['pipe', 'pipe', 'pipe']\n  });\n\n  // Give server time to start\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  const tests = [\n    {\n      name: 'List tools',\n      request: {\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/list',\n        params: {}\n      }\n    },\n    {\n      name: 'List pods',\n      request: {\n        jsonrpc: '2.0',\n        id: 2,\n        method: 'tools/call',\n        params: {\n          name: 'list_pods'\n        }\n      }\n    }\n  ];\n\n  for (const test of tests) {\n    console.log(`Running test: ${test.name}`);\n\n    server.stdin.write(JSON.stringify(test.request) + '\\n');\n\n    // Wait for response\n    await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n  }\n\n  server.kill();\n  console.log('\\nTesting completed!');\n}\n\ntestKAgent().catch(console.error);\n</code></pre></p>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-614-production-deployment-manifest","title":"Exercise 6.14: Production Deployment Manifest","text":"<p>Create Kubernetes deployment manifests for production deployment.</p> Solution <p>k8s-deployment.yaml: <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: k-agent-sa\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: k-agent-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/log\", \"namespaces\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: k-agent-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: k-agent-role\nsubjects:\n- kind: ServiceAccount\n  name: k-agent-sa\n  namespace: default\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: k-agent-logs\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: k-agent-logs\n  template:\n    metadata:\n      labels:\n        app: k-agent-logs\n    spec:\n      serviceAccountName: k-agent-sa\n      containers:\n      - name: k-agent\n        image: your-registry/k-agent-logs:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: k-agent-service\n  namespace: default\nspec:\n  selector:\n    app: k-agent-logs\n  ports:\n  - port: 3000\n    targetPort: 3000\n  type: ClusterIP\n</code></pre></p>"},{"location":"Lab08-Kagent/lab6-tasks/#exercise-615-complete-integration-test","title":"Exercise 6.15: Complete Integration Test","text":"<p>Create a comprehensive integration test that exercises all K-Agent capabilities.</p> Solution <p>integration-test.js: <pre><code>const { spawn } = require('child_process');\nconst fs = require('fs');\n\nasync function runIntegrationTest() {\n  console.log('\ud83d\ude80 Starting K-Agent Integration Test\\n');\n\n  const server = spawn('node', ['dist/index.js'], {\n    stdio: ['pipe', 'pipe', 'inherit']\n  });\n\n  let requestId = 1;\n\n  function sendRequest(method, params = {}) {\n    const request = {\n      jsonrpc: '2.0',\n      id: requestId++,\n      method,\n      params\n    };\n    server.stdin.write(JSON.stringify(request) + '\\n');\n  }\n\n  // Wait for server to start\n  await new Promise(resolve =&gt; setTimeout(resolve, 3000));\n\n  console.log('\ud83d\udccb Testing tools/list...');\n  sendRequest('tools/list');\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n  console.log('\ud83d\udccb Testing tools/call - list_pods...');\n  sendRequest('tools/call', {\n    name: 'list_pods',\n    arguments: { namespace: 'default' }\n  });\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  console.log('\ud83d\udccb Testing resources/list...');\n  sendRequest('resources/list');\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n  console.log('\ud83d\udccb Testing resources/read...');\n  sendRequest('resources/read', {\n    uri: 'logs://cluster/summary'\n  });\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  console.log('\ud83d\udd0d Testing search functionality...');\n  sendRequest('tools/call', {\n    name: 'search_logs',\n    arguments: {\n      pattern: 'error|Error|ERROR',\n      tailLines: 50\n    }\n  });\n\n  // Wait for all responses\n  await new Promise(resolve =&gt; setTimeout(resolve, 5000));\n\n  server.kill();\n  console.log('\\n\u2705 Integration test completed!');\n}\n\n// Run the test\nrunIntegrationTest().catch(error =&gt; {\n  console.error('\u274c Integration test failed:', error);\n  process.exit(1);\n});\n</code></pre></p>"},{"location":"Lab08-Kagent/lab8-tasks/","title":"MCP Lab Tasks - Lab 6: K-Agent","text":"<p>Welcome to Lab 6! In this lab, you\u2019ll build a K-Agent - an MCP server specialized for Kubernetes operations with a focus on log collection from all pods.</p> <p>The exercises build progressively, starting with basic Kubernetes client setup and culminating in a complete log collection system.</p>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-61-k-agent-project-setup","title":"Exercise 6.1: K-Agent Project Setup","text":"<p>Create a new MCP server project with Kubernetes dependencies.</p> Solution <pre><code># Create project directory\nmkdir k-agent-logs\ncd k-agent-logs\n\n# Initialize Node.js project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk @kubernetes/client-node\nnpm install -D typescript @types/node tsx\n\n# Create TypeScript configuration\nnpx tsc --init --target ES2022 --module NodeNext --moduleResolution NodeNext --esModuleInterop --allowSyntheticDefaultImports --strict --skipLibCheck --forceConsistentCasingInFileNames --outDir ./dist --rootDir ./src\n\n# Create source directory structure\nmkdir -p src\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-62-basic-k-agent-server-structure","title":"Exercise 6.2: Basic K-Agent Server Structure","text":"<p>Create the basic MCP server structure with Kubernetes client initialization.</p> Solution <pre><code>import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport * as k8s from '@kubernetes/client-node';\n\nclass KAgentServer {\n  private server: Server;\n  private k8sConfig: k8s.KubeConfig;\n  private k8sCoreApi: k8s.CoreV1Api;\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n\n    // Initialize Kubernetes client\n    this.k8sConfig = new k8s.KubeConfig();\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // Tools will be added in subsequent exercises\n  }\n\n  async start() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent server started\");\n  }\n}\n\n// Start the server\nconst server = new KAgentServer();\nserver.start().catch(console.error);\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-63-kubernetes-authentication","title":"Exercise 6.3: Kubernetes Authentication","text":"<p>Implement secure Kubernetes cluster authentication with proper error handling.</p> Solution <pre><code>private loadKubeConfig(): void {\n  try {\n    this.k8sConfig.loadFromDefault();\n\n    // Validate cluster access\n    this.validateClusterAccess();\n  } catch (error) {\n    throw new Error(`Kubernetes configuration error: ${error.message}`);\n  }\n}\n\nprivate async validateClusterAccess(): Promise&lt;void&gt; {\n  try {\n    // Test API access by listing namespaces\n    await this.k8sCoreApi.listNamespace();\n  } catch (error: any) {\n    if (error.response?.statusCode === 403) {\n      throw new Error('Access denied: Insufficient permissions to access Kubernetes cluster');\n    }\n    throw new Error(`Cluster access validation failed: ${error.message}`);\n  }\n}\n\nconstructor() {\n  // ... existing constructor code ...\n\n  // Initialize Kubernetes client\n  this.loadKubeConfig();\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-64-pod-listing-tool","title":"Exercise 6.4: Pod Listing Tool","text":"<p>Implement a tool to list all pods across namespaces with their status.</p> Solution <pre><code>private setupHandlers() {\n  // Tools list handler\n  this.server.setRequestHandler(\"tools/list\", async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        }\n      ]\n    };\n  });\n\n  // Tools call handler\n  this.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n    const { name, arguments: args } = request.params;\n\n    switch (name) {\n      case \"list_pods\":\n        return await this.handleListPods(args);\n      default:\n        throw new Error(`Unknown tool: ${name}`);\n    }\n  });\n}\n\nprivate async handleListPods(args: any) {\n  try {\n    const namespace = args?.namespace;\n    const pods = namespace\n      ? await this.k8sCoreApi.listNamespacedPod(namespace)\n      : await this.k8sCoreApi.listPodForAllNamespaces();\n\n    const podInfo = pods.body.items.map(pod =&gt; ({\n      name: pod.metadata?.name,\n      namespace: pod.metadata?.namespace,\n      status: pod.status?.phase,\n      containers: pod.spec?.containers?.length || 0\n    }));\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Found ${podInfo.length} pods:\\n${podInfo.map(p =&gt;\n          `- ${p.namespace}/${p.name}: ${p.status} (${p.containers} containers)`\n        ).join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n\nprivate handleK8sError(error: any): Error {\n  if (error.response?.statusCode === 403) {\n    return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n  }\n\n  if (error.response?.statusCode === 404) {\n    return new Error('Resource not found: The specified namespace may not exist');\n  }\n\n  return new Error(`Kubernetes operation failed: ${error.message}`);\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-65-single-pod-log-collection","title":"Exercise 6.5: Single Pod Log Collection","text":"<p>Implement log collection from a specific pod.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"get_pod_logs\",\n  description: \"Get logs from a specific pod\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace of the pod\"\n      },\n      podName: {\n        type: \"string\",\n        description: \"Name of the pod\"\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to retrieve\",\n        default: 100\n      }\n    },\n    required: [\"namespace\", \"podName\"]\n  }\n}\n\n// Add to tools call handler\ncase \"get_pod_logs\":\n  return await this.handleGetPodLogs(args);\n\nprivate async handleGetPodLogs(args: any) {\n  const { namespace, podName, tailLines = 100 } = args;\n\n  try {\n    const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n      podName,\n      namespace,\n      undefined, // container\n      false, // follow\n      undefined, // previous\n      undefined, // sinceSeconds\n      undefined, // sinceTime\n      tailLines, // tailLines\n      undefined, // timestamps\n      undefined // limitBytes\n    );\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Logs from pod ${namespace}/${podName}:\\n\\n${logResponse.body}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-66-multi-pod-log-collection","title":"Exercise 6.6: Multi-Pod Log Collection","text":"<p>Extend the system to collect logs from all pods in a namespace.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"collect_namespace_logs\",\n  description: \"Collect logs from all pods in a namespace\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to collect logs from\"\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines per pod\",\n        default: 50\n      }\n    },\n    required: [\"namespace\"]\n  }\n}\n\n// Add to tools call handler\ncase \"collect_namespace_logs\":\n  return await this.handleCollectNamespaceLogs(args);\n\nprivate async handleCollectNamespaceLogs(args: any) {\n  const { namespace, tailLines = 50 } = args;\n\n  try {\n    // Get all pods in namespace\n    const podsResponse = await this.k8sCoreApi.listNamespacedPod(namespace);\n    const pods = podsResponse.body.items.filter(pod =&gt;\n      pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n    );\n\n    if (pods.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: `No running pods found in namespace ${namespace}`\n        }]\n      };\n    }\n\n    const allLogs: string[] = [];\n\n    for (const pod of pods) {\n      const podName = pod.metadata?.name!;\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          namespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        allLogs.push(`=== ${podName} ===\\n${logResponse.body}\\n`);\n      } catch (error: any) {\n        allLogs.push(`=== ${podName} ===\\nError retrieving logs: ${error.message}\\n`);\n      }\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Logs from ${pods.length} pods in namespace ${namespace}:\\n\\n${allLogs.join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-67-all-namespace-log-collection","title":"Exercise 6.7: All-Namespace Log Collection","text":"<p>Implement the core feature: collect logs from all pods across all namespaces.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"collect_all_logs\",\n  description: \"Collect logs from all pods across all namespaces\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines per pod\",\n        default: 25\n      },\n      maxPods: {\n        type: \"number\",\n        description: \"Maximum number of pods to collect logs from\",\n        default: 50\n      }\n    }\n  }\n}\n\n// Add to tools call handler\ncase \"collect_all_logs\":\n  return await this.handleCollectAllLogs(args);\n\nprivate async handleCollectAllLogs(args: any) {\n  const { tailLines = 25, maxPods = 50 } = args;\n\n  try {\n    // Get all pods across all namespaces\n    const podsResponse = await this.k8sCoreApi.listPodForAllNamespaces();\n    const pods = podsResponse.body.items\n      .filter(pod =&gt;\n        pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n      )\n      .slice(0, maxPods); // Limit for performance\n\n    if (pods.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: \"No running pods found in the cluster\"\n        }]\n      };\n    }\n\n    const allLogs: string[] = [];\n    let processedCount = 0;\n\n    for (const pod of pods) {\n      const podName = pod.metadata?.name!;\n      const namespace = pod.metadata?.namespace!;\n\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          namespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        allLogs.push(`=== ${namespace}/${podName} ===\\n${logResponse.body}\\n`);\n        processedCount++;\n      } catch (error: any) {\n        allLogs.push(`=== ${namespace}/${podName} ===\\nError retrieving logs: ${error.message}\\n`);\n      }\n    }\n\n    const summary = `Collected logs from ${processedCount} out of ${pods.length} pods (limited to ${maxPods} max)\\n\\n`;\n\n    return {\n      content: [{\n        type: \"text\",\n        text: summary + allLogs.join('\\n')\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-68-log-filtering-and-search","title":"Exercise 6.8: Log Filtering and Search","text":"<p>Add filtering capabilities to search through logs.</p> Solution <pre><code>// Add to tools list\n{\n  name: \"search_logs\",\n  description: \"Search for specific patterns in pod logs\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      namespace: {\n        type: \"string\",\n        description: \"Namespace to search in (optional)\"\n      },\n      pattern: {\n        type: \"string\",\n        description: \"Text pattern to search for\"\n      },\n      caseSensitive: {\n        type: \"boolean\",\n        description: \"Whether search should be case sensitive\",\n        default: false\n      },\n      tailLines: {\n        type: \"number\",\n        description: \"Number of recent log lines to search through\",\n        default: 100\n      }\n    },\n    required: [\"pattern\"]\n  }\n}\n\n// Add to tools call handler\ncase \"search_logs\":\n  return await this.handleSearchLogs(args);\n\nprivate async handleSearchLogs(args: any) {\n  const { namespace, pattern, caseSensitive = false, tailLines = 100 } = args;\n\n  try {\n    const podsResponse = namespace\n      ? await this.k8sCoreApi.listNamespacedPod(namespace)\n      : await this.k8sCoreApi.listPodForAllNamespaces();\n\n    const runningPods = podsResponse.body.items.filter(pod =&gt;\n      pod.status?.phase === 'Running' || pod.status?.phase === 'Succeeded'\n    );\n\n    const matches: string[] = [];\n    const flags = caseSensitive ? 'g' : 'gi';\n    const regex = new RegExp(pattern, flags);\n\n    for (const pod of runningPods) {\n      const podName = pod.metadata?.name!;\n      const podNamespace = pod.metadata?.namespace!;\n\n      try {\n        const logResponse = await this.k8sCoreApi.readNamespacedPodLog(\n          podName,\n          podNamespace,\n          undefined,\n          false,\n          undefined,\n          undefined,\n          undefined,\n          tailLines\n        );\n\n        const logs = logResponse.body;\n        const lines = logs.split('\\n');\n\n        const matchingLines = lines\n          .map((line, index) =&gt; ({ line, index }))\n          .filter(({ line }) =&gt; regex.test(line))\n          .map(({ line, index }) =&gt; `  Line ${index + 1}: ${line}`);\n\n        if (matchingLines.length &gt; 0) {\n          matches.push(`=== ${podNamespace}/${podName} ===`);\n          matches.push(...matchingLines);\n          matches.push('');\n        }\n      } catch (error) {\n        // Skip pods where we can't read logs\n      }\n    }\n\n    if (matches.length === 0) {\n      return {\n        content: [{\n          type: \"text\",\n          text: `No logs matching pattern \"${pattern}\" found`\n        }]\n      };\n    }\n\n    return {\n      content: [{\n        type: \"text\",\n        text: `Found ${matches.length} matches for pattern \"${pattern}\":\\n\\n${matches.join('\\n')}`\n      }]\n    };\n  } catch (error: any) {\n    throw this.handleK8sError(error);\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-69-resource-integration","title":"Exercise 6.9: Resource Integration","text":"<p>Create MCP resources for recent log summaries.</p> Solution <pre><code>constructor() {\n  this.server = new Server(\n    {\n      name: \"k-agent-logs\",\n      version: \"1.0.0\",\n    },\n    {\n      capabilities: {\n        tools: {},\n        resources: {},\n      },\n    }\n  );\n\n  // ... rest of constructor\n}\n\nprivate setupHandlers() {\n  // ... existing tools setup ...\n\n  // Resources handlers\n  this.server.setRequestHandler(\"resources/list\", async () =&gt; {\n    return {\n      resources: [\n        {\n          uri: \"logs://cluster/summary\",\n          name: \"Cluster Logs Summary\",\n          description: \"Summary of recent logs from all pods\",\n          mimeType: \"application/json\"\n        }\n      ]\n    };\n  });\n\n  this.server.setRequestHandler(\"resources/read\", async (request) =&gt; {\n    const { uri } = request.params;\n\n    if (uri === \"logs://cluster/summary\") {\n      return {\n        contents: [{\n          uri,\n          mimeType: \"application/json\",\n          text: JSON.stringify(await this.getClusterLogsSummary(), null, 2)\n        }]\n      };\n    }\n\n    throw new Error(`Resource not found: ${uri}`);\n  });\n}\n\nprivate async getClusterLogsSummary() {\n  try {\n    const podsResponse = await this.k8sCoreApi.listPodForAllNamespaces();\n    const pods = podsResponse.body.items;\n\n    const summary = {\n      timestamp: new Date().toISOString(),\n      totalPods: pods.length,\n      runningPods: pods.filter(p =&gt; p.status?.phase === 'Running').length,\n      namespaces: [...new Set(pods.map(p =&gt; p.metadata?.namespace))].length,\n      podStatusCounts: pods.reduce((acc, pod) =&gt; {\n        const phase = pod.status?.phase || 'Unknown';\n        acc[phase] = (acc[phase] || 0) + 1;\n        return acc;\n      }, {} as Record&lt;string, number&gt;)\n    };\n\n    return summary;\n  } catch (error: any) {\n    return {\n      error: `Failed to get cluster summary: ${error.message}`,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-610-error-handling-and-validation","title":"Exercise 6.10: Error Handling and Validation","text":"<p>Implement comprehensive error handling and input validation.</p> Solution <pre><code>private validateToolArguments(toolName: string, args: any): void {\n  switch (toolName) {\n    case 'list_pods':\n      if (args?.namespace &amp;&amp; typeof args.namespace !== 'string') {\n        throw new Error('namespace must be a string');\n      }\n      break;\n\n    case 'get_pod_logs':\n      if (!args?.namespace || typeof args.namespace !== 'string') {\n        throw new Error('namespace is required and must be a string');\n      }\n      if (!args?.podName || typeof args.podName !== 'string') {\n        throw new Error('podName is required and must be a string');\n      }\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      break;\n\n    case 'collect_namespace_logs':\n      if (!args?.namespace || typeof args.namespace !== 'string') {\n        throw new Error('namespace is required and must be a string');\n      }\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      break;\n\n    case 'collect_all_logs':\n      if (args?.tailLines &amp;&amp; (typeof args.tailLines !== 'number' || args.tailLines &lt; 1)) {\n        throw new Error('tailLines must be a positive number');\n      }\n      if (args?.maxPods &amp;&amp; (typeof args.maxPods !== 'number' || args.maxPods &lt; 1)) {\n        throw new Error('maxPods must be a positive number');\n      }\n      break;\n\n    case 'search_logs':\n      if (!args?.pattern || typeof args.pattern !== 'string') {\n        throw new Error('pattern is required and must be a string');\n      }\n      if (args?.namespace &amp;&amp; typeof args.namespace !== 'string') {\n        throw new Error('namespace must be a string');\n      }\n      break;\n  }\n}\n\n// Update tools call handler to include validation\nthis.server.setRequestHandler(\"tools/call\", async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  // Validate arguments\n  this.validateToolArguments(name, args);\n\n  switch (name) {\n    // ... existing cases\n  }\n});\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-611-package-configuration","title":"Exercise 6.11: Package Configuration","text":"<p>Create proper package.json and tsconfig.json for the K-Agent.</p> Solution <p>package.json: <pre><code>{\n  \"name\": \"k-agent-logs\",\n  \"version\": \"1.0.0\",\n  \"description\": \"K-Agent MCP server for Kubernetes log collection\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx src/index.ts\",\n    \"test\": \"echo \\\"No tests specified\\\"\"\n  },\n  \"keywords\": [\"mcp\", \"kubernetes\", \"logs\", \"monitoring\"],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@kubernetes/client-node\": \"^0.20.0\",\n    \"@modelcontextprotocol/sdk\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n</code></pre></p> <p>tsconfig.json: <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n</code></pre></p>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-612-docker-configuration","title":"Exercise 6.12: Docker Configuration","text":"<p>Create a Dockerfile for containerized deployment.</p> Solution <pre><code>FROM node:18-alpine\n\n# Install kubectl\nRUN apk add --no-cache curl &amp;&amp; \\\n    curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" &amp;&amp; \\\n    install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl &amp;&amp; \\\n    rm kubectl &amp;&amp; \\\n    kubectl version --client\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nCOPY tsconfig.json ./\n\n# Install dependencies\nRUN npm ci --only=production &amp;&amp; npm cache clean --force\n\n# Copy source code\nCOPY src/ ./src/\n\n# Build TypeScript\nRUN npm run build\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs &amp;&amp; \\\n    adduser -S kagent -u 1001\n\n# Change ownership\nRUN chown -R kagent:nodejs /app\nUSER kagent\n\nEXPOSE 3000\n\nCMD [\"npm\", \"start\"]\n</code></pre>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-613-testing-the-k-agent","title":"Exercise 6.13: Testing the K-Agent","text":"<p>Create a test script to verify all functionality.</p> Solution <p>test-kagent.js: <pre><code>const { spawn } = require('child_process');\n\nasync function testKAgent() {\n  console.log('Testing K-Agent functionality...\\n');\n\n  const server = spawn('node', ['dist/index.js'], {\n    stdio: ['pipe', 'pipe', 'pipe']\n  });\n\n  // Give server time to start\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  const tests = [\n    {\n      name: 'List tools',\n      request: {\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/list',\n        params: {}\n      }\n    },\n    {\n      name: 'List pods',\n      request: {\n        jsonrpc: '2.0',\n        id: 2,\n        method: 'tools/call',\n        params: {\n          name: 'list_pods'\n        }\n      }\n    }\n  ];\n\n  for (const test of tests) {\n    console.log(`Running test: ${test.name}`);\n\n    server.stdin.write(JSON.stringify(test.request) + '\\n');\n\n    // Wait for response\n    await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n  }\n\n  server.kill();\n  console.log('\\nTesting completed!');\n}\n\ntestKAgent().catch(console.error);\n</code></pre></p>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-614-production-deployment-manifest","title":"Exercise 6.14: Production Deployment Manifest","text":"<p>Create Kubernetes deployment manifests for production deployment.</p> Solution <p>k8s-deployment.yaml: <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: k-agent-sa\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: k-agent-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/log\", \"namespaces\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: k-agent-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: k-agent-role\nsubjects:\n- kind: ServiceAccount\n  name: k-agent-sa\n  namespace: default\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: k-agent-logs\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: k-agent-logs\n  template:\n    metadata:\n      labels:\n        app: k-agent-logs\n    spec:\n      serviceAccountName: k-agent-sa\n      containers:\n      - name: k-agent\n        image: your-registry/k-agent-logs:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: k-agent-service\n  namespace: default\nspec:\n  selector:\n    app: k-agent-logs\n  ports:\n  - port: 3000\n    targetPort: 3000\n  type: ClusterIP\n</code></pre></p>"},{"location":"Lab08-Kagent/lab8-tasks/#exercise-615-complete-integration-test","title":"Exercise 6.15: Complete Integration Test","text":"<p>Create a comprehensive integration test that exercises all K-Agent capabilities.</p> Solution <p>integration-test.js: <pre><code>const { spawn } = require('child_process');\nconst fs = require('fs');\n\nasync function runIntegrationTest() {\n  console.log('\ud83d\ude80 Starting K-Agent Integration Test\\n');\n\n  const server = spawn('node', ['dist/index.js'], {\n    stdio: ['pipe', 'pipe', 'inherit']\n  });\n\n  let requestId = 1;\n\n  function sendRequest(method, params = {}) {\n    const request = {\n      jsonrpc: '2.0',\n      id: requestId++,\n      method,\n      params\n    };\n    server.stdin.write(JSON.stringify(request) + '\\n');\n  }\n\n  // Wait for server to start\n  await new Promise(resolve =&gt; setTimeout(resolve, 3000));\n\n  console.log('\ud83d\udccb Testing tools/list...');\n  sendRequest('tools/list');\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n  console.log('\ud83d\udccb Testing tools/call - list_pods...');\n  sendRequest('tools/call', {\n    name: 'list_pods',\n    arguments: { namespace: 'default' }\n  });\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  console.log('\ud83d\udccb Testing resources/list...');\n  sendRequest('resources/list');\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n  console.log('\ud83d\udccb Testing resources/read...');\n  sendRequest('resources/read', {\n    uri: 'logs://cluster/summary'\n  });\n\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  console.log('\ud83d\udd0d Testing search functionality...');\n  sendRequest('tools/call', {\n    name: 'search_logs',\n    arguments: {\n      pattern: 'error|Error|ERROR',\n      tailLines: 50\n    }\n  });\n\n  // Wait for all responses\n  await new Promise(resolve =&gt; setTimeout(resolve, 5000));\n\n  server.kill();\n  console.log('\\n\u2705 Integration test completed!');\n}\n\n// Run the test\nrunIntegrationTest().catch(error =&gt; {\n  console.error('\u274c Integration test failed:', error);\n  process.exit(1);\n});\n</code></pre></p>"},{"location":"Lab09-K8s-Event-Monitor/lab/","title":"Lab 09: K8s Event &amp; Log Monitor with Kagent","text":""},{"location":"Lab09-K8s-Event-Monitor/lab/#overview","title":"Overview","text":"<p>In this lab, you will build a complete observability solution using MCP. You will:</p> <ol> <li>Perform a minimal installation of Kagent.</li> <li>Create a custom MCP Server in Python (using the <code>mcp</code> SDK) to monitor Kubernetes events and logs.</li> <li>Register/Connect this tool to Kagent.</li> <li>Deploy Prometheus and Grafana using Helm Charts to visualize the data.</li> </ol> <p>This lab demonstrates how to extend Kagent\u2019s capabilities with custom Python-based tools and integrate K8s observability.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes Cluster: A running cluster (Docker Desktop, OrbStack, Minikube, or remote).</li> <li>kubectl: Configured to access your cluster.</li> <li>Python 3.10+: Installed on your local machine.</li> <li>Helm: Installed (<code>brew install helm</code> or equivalent).</li> <li>Kagent CLI: Installed (or we will install it).</li> </ul>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-1-install-kagent","title":"Step 1: Install Kagent","text":"<p>First, we need to set up the Kagent platform. We will perform a minimal installation for development/demo purposes.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#11-install-kagent-cli","title":"1.1 Install Kagent CLI","text":"<p>If you haven\u2019t installed the <code>kagent</code> CLI yet, run the following command:</p> <pre><code>curl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#12-install-kagent-platform","title":"1.2 Install Kagent Platform","text":"<p>Install Kagent into your cluster with the <code>demo</code> profile, which sets up the necessary components with minimal resources.</p> <pre><code>kagent install --profile demo\n</code></pre> <p>Verify the installation:</p> <pre><code>kubectl get pods -n kagent\n</code></pre> <p>Wait until all pods are in the <code>Running</code> state.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-2-create-custom-mcp-tool-python","title":"Step 2: Create Custom MCP Tool (Python)","text":"<p>We will use the MCP Python SDK to create a tool that connects to Kubernetes, collects events/logs, and exposes metrics.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#21-project-setup","title":"2.1 Project Setup","text":"<p>Create a new directory for your tool:</p> <pre><code>mkdir -p kagent-monitor/src\ncd kagent-monitor\npython3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#22-install-dependencies","title":"2.2 Install Dependencies","text":"<p>Create a <code>requirements.txt</code> file:</p> <pre><code>mcp&gt;=1.0.0\nkubernetes&gt;=28.1.0\nprometheus-client&gt;=0.19.0\n</code></pre> <p>Install the <code>requirements.txt</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#23-create-the-mcp-server","title":"2.3 Create the MCP Server","text":"<p>Create <code>src/monitor.py</code>. This script implements an MCP server that lists K8s events and collects logs.</p> <pre><code>import asyncio\nimport os\nfrom kubernetes import client, config\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Tool, TextContent\nfrom prometheus_client import start_http_server, Counter\n\n# Prometheus Metrics\nEVENTS_FETCHED = Counter('k8s_events_fetched_total', 'Total number of K8s events fetched')\n\n# Connect to K8s\ntry:\n    config.load_kube_config()\nexcept:\n    config.load_incluster_config()\n\nv1 = client.CoreV1Api()\nserver = Server(\"k8s-monitor\")\n\n@server.list_tools()\nasync def list_tools() -&gt; list[Tool]:\n    return [\n        Tool(\n            name=\"collect_logs\",\n            description=\"Collect logs and events from the Kubernetes cluster\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"namespace\": {\"type\": \"string\", \"description\": \"Namespace to filter (default: default)\"},\n                }\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:\n    if name == \"collect_logs\":\n        ns = arguments.get(\"namespace\", \"default\")\n\n        # 1. Fetch Events\n        events = v1.list_namespaced_event(ns)\n        EVENTS_FETCHED.inc(len(events.items))\n\n        event_logs = []\n        for e in events.items:\n            event_logs.append(f\"[EVENT] {e.last_timestamp} {e.type} {e.reason}: {e.message}\")\n\n        # 2. Fetch Pod Logs (Sample from first pod)\n        pods = v1.list_namespaced_pod(ns)\n        pod_logs = []\n        if pods.items:\n            p = pods.items[0]\n            try:\n                logs = v1.read_namespaced_pod_log(p.metadata.name, ns, tail_lines=5)\n                pod_logs.append(f\"[POD {p.metadata.name}] {logs}\")\n            except:\n                pod_logs.append(f\"[POD {p.metadata.name}] Could not read logs\")\n\n        full_log = \"\\n\".join(event_logs + pod_logs)\n        return [TextContent(type=\"text\", text=full_log)]\n\n    raise ValueError(f\"Unknown tool: {name}\")\n\nasync def main():\n    # Start Prometheus Metrics endpoint on port 8000\n    start_http_server(8000)\n\n    async with stdio_server() as (read, write):\n        await server.run(read, write, server.create_initialization_options())\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#24-test-the-tool-offline","title":"2.4 Test the Tool (Offline)","text":"<p>You can run the tool directly to Verify it starts:</p> <pre><code># This will listen on stdio (blocking) and Metrics port 8000\n# Press Ctrl+C to stop\nnpx @modelcontextprotocol/inspector python3 src/monitor.py\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-2-use-kmcp-to-build-the-server","title":"Step 2: Use <code>kmcp</code> to Build the Server","text":"<ul> <li>Kagent provides a CLI tool called <code>kmcp</code> that simplifies bootstrapping, building, and deploying MCP servers.</li> <li>It handles the boilerplate and provides a structured way to manage tools.</li> </ul>"},{"location":"Lab09-K8s-Event-Monitor/lab/#21-install-kmcp-cli","title":"2.1 Install <code>kmcp</code> CLI","text":"<p>Install the <code>kmcp</code> CLI on your local machine:</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/kagent-dev/kmcp/refs/heads/main/scripts/get-kmcp.sh | bash\n</code></pre> <p>Verify the installation:</p> <pre><code>kmcp --help\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#22-initialize-a-new-project","title":"2.2 Initialize a New Project","text":"<p>Create a new Python MCP project using <code>kmcp</code>. This will set up a project structure with best practices.</p> <pre><code>cd ~\nkmcp init python kagent-monitor-kmcp\ncd kagent-monitor-kmcp\n</code></pre> <p>This creates a directory structure like this:</p> <ul> <li><code>src/main.py</code>: The entry point for the server.</li> <li><code>src/tools/</code>: Directory where you can add your custom tools.</li> <li><code>requirements.txt</code>: Python dependencies.</li> <li><code>kmcp.yaml</code>: Project configuration.</li> </ul>"},{"location":"Lab09-K8s-Event-Monitor/lab/#2a3-add-dependencies","title":"2a.3 Add Dependencies","text":"<p>Edit standard <code>requirements.txt</code> to include the Kubernetes and Prometheus libraries:</p> <pre><code>echo \"kubernetes&gt;=28.1.0\" &gt;&gt; requirements.txt\necho \"prometheus-client&gt;=0.19.0\" &gt;&gt; requirements.txt\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#2a4-implement-the-tool","title":"2a.4 Implement the Tool","text":"<ul> <li>In <code>kmcp</code> projects, tools are automatically discovered from the <code>src/tools/</code> directory.</li> <li>Create a new file <code>src/tools/monitor.py</code> and add the logic.</li> </ul> <p>Create <code>src/tools/k8s_tools.py</code>:</p> <pre><code>from core.server import mcp\nfrom kubernetes import client, config\n\n# Initialize K8s client\ntry:\n    config.load_kube_config()\nexcept:\n    config.load_incluster_config()\nv1 = client.CoreV1Api()\n\n@mcp.tool(description=\"Collect logs and events from the Kubernetes cluster\")\nasync def collect_logs(namespace: str = \"default\") -&gt; str:\n    \"\"\"Collect logs and events from the Kubernetes cluster\"\"\"\n    # Fetch events\n    events = v1.list_namespaced_event(namespace)\n    output = []\n    for e in events.items:\n        output.append(f\"[EVENT] {e.last_timestamp} {e.type} {e.reason}: {e.message}\")\n    return \"\\n\".join(output)\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#2a5-run-locally-with-kmcp","title":"2a.5 Run Locally with <code>kmcp</code>","text":"<p>Run the server locally with the MCP Inspector attached:</p> <pre><code>kmcp run --project-dir .\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#2a6-build-and-push-docker-image","title":"2a.6 Build and Push Docker Image","text":"<p>Before deploying to the cluster, you need to build the Docker image and make it available to your Kubernetes cluster (by pushing to a registry or loading it directly).</p> <ol> <li>Build the image using Docker:</li> </ol> <pre><code>docker build -t nirgeier/my-kagent-monitor:v1 .\n</code></pre> <ol> <li>Push or Load the image:</li> <li>If using a Registry (Docker Hub, etc.): <pre><code>docker push nirgeier/my-kagent-monitor:v1\n</code></pre></li> <li>If using Kind: <pre><code>kind load docker-image my-kagent-monitor:v1 --name &lt;cluster-name&gt;\n</code></pre></li> <li>If using Minikube: <pre><code>minikube image load my-kagent-monitor:v1\n</code></pre></li> </ol>"},{"location":"Lab09-K8s-Event-Monitor/lab/#2a7-deploy-to-kubernetes","title":"2a.7 Deploy to Kubernetes","text":"<p>Deploy the MCP server to your cluster using <code>kmcp</code>. You must specify the image you built.</p> <pre><code># Deploy with the custom image\nkmcp deploy --namespace default --image nirgeier/my-kagent-monitor:v1\n</code></pre> <p>(Note: Ensure the image name matches exactly what you built/loaded. If you used a different name, update the command accordingly.)</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-3-verify-tool-registration","title":"Step 3: Verify Tool Registration","text":"<p>Since we used <code>kmcp deploy</code> in the previous step, the MCP server is installed and should be registered with Kagent.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#31-check-deployment-status","title":"3.1 Check Deployment Status","text":"<p>First, ensure the pod is running. Common issues include <code>ImagePullBackOff</code> if the image name is incorrect or not loaded into the cluster.</p> <pre><code>kubectl get pods -n default -l app=kagent-monitor-kmcp\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#32-verify-mcp-server-registration","title":"3.2 Verify MCP Server Registration","text":"<p>Check if the <code>MCPServer</code> resource exists:</p> <pre><code>kubectl get mcpservers -n default\n</code></pre> <p>You should see your project name (e.g., <code>kagent-monitor-kmcp</code>) in the list.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#33-optional-manual-registration","title":"3.3 (Optional) Manual Registration","text":"<p>If <code>kmcp deploy</code> failed or you want to register it manually:</p> <ol> <li> <p>Create Manifest:     Create a file <code>mcpserver.yaml</code>:</p> <pre><code>apiVersion: kagent.dev/v1alpha1\nkind: MCPServer\nmetadata:\n  name: k8s-monitor\n  namespace: default\nspec:\n  deployment:\n    args:\n      - src/main.py\n    cmd: python\n    image: nirgeier/my-kagent-monitor:v1\n    port: 3000\n  stdioTransport: {}\n  transportType: stdio\n</code></pre> </li> <li> <p>Apply Manifest:</p> <pre><code>kubectl apply -f mcpserver.yaml\n</code></pre> </li> </ol>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-4-create-the-agent","title":"Step 4: Create the Agent","text":"<p>The Kagent Dashboard displays Agent resources, not MCPServers directly. An MCPServer provides tools, but you need to create an Agent resource to make it appear in the dashboard.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#41-create-remotemcpserver-resource","title":"4.1 Create RemoteMCPServer Resource","text":"<p>First, create a <code>RemoteMCPServer</code> that provides HTTP access to the MCP server.</p> <p>Create a file <code>remotemcpserver.yaml</code>:</p> <pre><code>apiVersion: kagent.dev/v1alpha2\nkind: RemoteMCPServer\nmetadata:\n  name: k8s-monitor-mcp\n  namespace: default\n  labels:\n    app.kubernetes.io/name: k8s-monitor-mcp\n    app.kubernetes.io/part-of: kagent\nspec:\n  description: K8s Event and Log Monitor MCP Server\n  protocol: STREAMABLE_HTTP\n  url: http://k8s-monitor.default:3000/mcp\n</code></pre> <p>Apply it:</p> <pre><code>kubectl apply -f remotemcpserver.yaml\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#42-create-agent-resource","title":"4.2 Create Agent Resource","text":"<p>Now create an Agent that uses the tools from your MCP server.</p> <p>Create a file <code>agent.yaml</code>:</p> <pre><code>apiVersion: kagent.dev/v1alpha2\nkind: Agent\nmetadata:\n  name: k8s-monitor-agent\n  namespace: default\n  labels:\n    app.kubernetes.io/name: k8s-monitor-agent\n    app.kubernetes.io/part-of: kagent\nspec:\n  declarative:\n    modelConfig: default-model-config\n    systemMessage: |\n      You are a Kubernetes monitoring agent that can collect logs and events from a Kubernetes cluster.\n      Use the collect_logs tool to gather information about events and pod logs in a given namespace.\n    tools:\n      - type: McpServer\n        mcpServer:\n          apiGroup: kagent.dev\n          kind: RemoteMCPServer\n          name: k8s-monitor-mcp\n          toolNames:\n            - trace\n            - fail\n            - sleep\n    deployment:\n      resources:\n        requests:\n          cpu: 100m\n          memory: 256Mi\n        limits:\n          cpu: 500m\n          memory: 512Mi\n</code></pre> <p>Important: The <code>toolNames</code> field is required. List the tools exposed by your MCP server. You can find these by checking the MCP server logs when it starts.</p> <p>Apply it:</p> <pre><code>kubectl apply -f agent.yaml\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#43-verify-the-agent","title":"4.3 Verify the Agent","text":"<p>Check that the Agent is ready:</p> <pre><code>kubectl get agents -n default\n</code></pre> <p>You should see <code>k8s-monitor-agent</code> with <code>READY: True</code>:</p> <pre><code>NAME                TYPE          READY   ACCEPTED\nk8s-monitor-agent   Declarative   True    True\n</code></pre> <p>Also verify the RemoteMCPServer:</p> <pre><code>kubectl get remotemcpservers -n default\n</code></pre> <p>If the Agent shows <code>READY: False</code>, check the pod logs:</p> <pre><code>kubectl logs -l app.kubernetes.io/name=k8s-monitor-agent -n default\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-5-install-nginx-ingress-controller","title":"Step 5: Install NGINX Ingress Controller","text":"<p>To expose our services (like Grafana) externally, we will use an Ingress Controller. This allows us to access dashboards via a URL instead of using <code>port-forward</code>.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#41-install-via-helm","title":"4.1 Install via Helm","text":"<p>Add the ingress-nginx repository and install the chart:</p> <pre><code>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n\nhelm install ingress-nginx ingress-nginx/ingress-nginx \\\n  --namespace ingress-nginx \\\n  --create-namespace\n</code></pre> <p>Wait until the ingress controller pod is running:</p> <pre><code>kubectl get pods -n ingress-nginx\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-6-deploy-prometheus-grafana-helm","title":"Step 6: Deploy Prometheus &amp; Grafana (Helm)","text":"<p>We will deploy the observability stack using Helm Charts to visualize the metrics exposed by our tool.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#51-add-helm-repos","title":"5.1 Add Helm Repos","text":"<pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\nhelm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#52-install-prometheus","title":"5.2 Install Prometheus","text":"<p>We need to configure Prometheus to scrape our MCP tool and also know it is served under a subpath (<code>/prometheus</code>). We effectively set the <code>external-url</code> and adjust the health check probes to match that new path.</p> <p>Create <code>prometheus-config.yaml</code>:</p> <pre><code>server:\n  baseURL: /prometheus\n\n  # Fix probes to check status at /prometheus/-/ready instead of /-/ready\n  readinessProbe:\n    httpGet:\n      path: /prometheus/-/ready\n      port: 9090\n      scheme: HTTP\n    initialDelaySeconds: 30\n    periodSeconds: 5\n    timeoutSeconds: 4\n    failureThreshold: 3\n    successThreshold: 1\n\n  livenessProbe:\n    httpGet:\n      path: /prometheus/-/healthy\n      port: 9090\n      scheme: HTTP\n    initialDelaySeconds: 30\n    periodSeconds: 15\n    timeoutSeconds: 10\n    failureThreshold: 3\n    successThreshold: 1\n\nextraScrapeConfigs: |\n  - job_name: 'mcp-monitor'\n    kubernetes_sd_configs:\n      - role: pod\n    relabel_configs:\n      - source_labels: [__meta_kubernetes_pod_name]\n        regex: .*monitor.*\n        action: keep\n      - source_labels: [__address__]\n        regex: ([^:]+)(?::\\d+)?\n        replacement: ${1}:8000\n        target_label: __address__\n</code></pre> <p>Install Prometheus:</p> <pre><code>helm upgrade --install prometheus prometheus-community/prometheus -f prometheus-config.yaml\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#53-install-grafana","title":"5.3 Install Grafana","text":"<p>When deploying Grafana behind an ingress with a subpath (e.g. <code>/grafana</code>), we must configure the <code>root_url</code> and <code>serve_from_sub_path</code> settings so it generates correct links.</p> <p>Create <code>grafana-config.yaml</code>:</p> <pre><code>adminPassword: admin123\ngrafana.ini:\n  server:\n    domain: cluster.local\n    root_url: \"%(protocol)s://%(domain)s/grafana\"\n    serve_from_sub_path: true\n</code></pre> <p>Install Grafana with the configuration:</p> <pre><code>helm upgrade --install grafana grafana/grafana -f grafana-config.yaml\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#54-verify-deployments","title":"5.4 Verify Deployments","text":"<p>Ensure all pods are running before proceeding:</p> <pre><code>kubectl get pods -n default\nkubectl get pods -n ingress-nginx\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-7-expose-services-via-ingress","title":"Step 7: Expose Services via Ingress","text":"<p>Instead of using <code>port-forward</code>, we will expose Prometheus, Grafana, and the Kagent UI using the NGINX Ingress Controller. We will configure them on the hostname <code>cluster.local</code>.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#61-create-ingress-manifest","title":"6.1 Create Ingress Manifest","text":"<p>Create a file named <code>observability-ingress.yaml</code>. This defines routing rules for:</p> <ul> <li><code>/</code> -&gt; Kagent Dashboard (<code>kagent-ui</code>)</li> <li><code>/grafana</code> -&gt; Grafana</li> <li><code>/prometheus</code> -&gt; Prometheus</li> </ul> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: observability-ingress\nspec:\n  ingressClassName: nginx\n  rules:\n    - host: cluster.local\n      http:\n        paths:\n          - path: /prometheus\n            pathType: Prefix\n            backend:\n              service:\n                name: prometheus-server\n                port:\n                  number: 80\n          - path: /grafana\n            pathType: Prefix\n            backend:\n              service:\n                name: grafana\n                port:\n                  number: 80\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: kagent-ui\n                port:\n                  number: 8080\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#62-apply-the-ingress","title":"6.2 Apply the Ingress","text":"<pre><code>kubectl apply -f observability-ingress.yaml\n</code></pre>"},{"location":"Lab09-K8s-Event-Monitor/lab/#63-update-hosts-file","title":"6.3 Update Hosts File","text":"<p>To access <code>http://cluster.local</code>, map the hostname to your local machine (or the cluster IP).</p> <ol> <li> <p>Find the IP:</p> <ul> <li>Docker Desktop / OrbStack: Use <code>127.0.0.1</code>.</li> <li>Minikube: Run <code>minikube ip</code>.</li> </ul> </li> <li> <p>Edit Host File:</p> <ul> <li>Linux/macOS: <code>/etc/hosts</code></li> <li>Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li> </ul> <p>Add the following line:</p> <pre><code>127.0.0.1  cluster.local\n</code></pre> <p>(Replace <code>127.0.0.1</code> with your Minikube IP if applicable).</p> </li> </ol>"},{"location":"Lab09-K8s-Event-Monitor/lab/#step-8-access-and-configure","title":"Step 8: Access and Configure","text":"<p>Now you can access all services via the browser.</p>"},{"location":"Lab09-K8s-Event-Monitor/lab/#71-access-grafana","title":"7.1 Access Grafana","text":"<ol> <li>Navigate to http://cluster.local/grafana.</li> <li>Login:<ul> <li>User: <code>admin</code></li> <li>Password: <code>admin</code> (or the password set in <code>grafana-config.yaml</code>).</li> </ul> </li> <li>Add Data Source:<ul> <li>Go to Connections &gt; Data Sources &gt; Add data source.</li> <li>Select Prometheus.</li> <li>Connection URL: <code>http://prometheus-server</code> (Keep this as the internal K8s Service name).</li> <li>Click Save &amp; Test.</li> </ul> </li> </ol>"},{"location":"Lab09-K8s-Event-Monitor/lab/#72-access-prometheus","title":"7.2 Access Prometheus","text":"<ul> <li>Navigate to http://cluster.local/prometheus.</li> <li>You can query for <code>k8s_events_fetched_total</code> to verify your MCP tool is sending metrics.</li> </ul>"},{"location":"Lab09-K8s-Event-Monitor/lab/#73-access-kagent-dashboard-mcp-tool","title":"7.3 Access Kagent Dashboard &amp; MCP Tool","text":"<ul> <li>Navigate to http://cluster.local.</li> <li>This loads the Kagent Dashboard.</li> <li>Look for k8s-monitor (or <code>kagent-monitor-kmcp</code>) in the list of active Agents/MCP Servers.</li> <li>You can verify that Kagent sees the <code>collect_logs</code> tool capability provided by your server.</li> </ul>"},{"location":"Lab09-K8s-Event-Monitor/lab/#summary","title":"Summary","text":"<p>You have successfully:</p> <ol> <li>Installed Kagent.</li> <li>Built a Python MCP tool to collect K8s logs/events.</li> <li>Registered the tool.</li> <li>Installed NGINX Ingress Controller.</li> <li>Deployed an observability stack (Prometheus/Grafana) behind an Ingress.</li> <li>Exposed the Kagent Dashboard on the same domain.</li> </ol> <p>This setup offers a production-like environment where AI agents (via Kagent) and human operators (via Grafana) can monitor the cluster side-by-side.</p>"},{"location":"Resources/resources/","title":"Resources","text":""},{"location":"Resources/Lab01-MCP-Fundamentals/MCP-Advanced-py/","title":"MCP Advanced py","text":""},{"location":"Resources/Lab01-MCP-Fundamentals/MCP-Advanced-py/#mcp-basics-with-python","title":"MCP Basics with Python","text":"<pre><code>from mcp.server.fastmcp import FastMCP\nfrom starlette.responses import Response, JSONResponse, StreamingResponse\nfrom starlette.requests import Request\nimport types\nimport httpx\nimport json\nimport asyncio\nimport time\nimport inspect\nfrom typing import Any, Dict, List\n\n# Ollama configuration\nOLLAMA_BASE_URL = \"http://localhost:11434\"\nDEFAULT_MODEL = \"codestral:latest\"\n\n# Tool execution tracking\nTOOL_EXECUTIONS = {}\nEXECUTION_COUNTER = 0\n\nmcp = FastMCP(\"kagent-mcp-server\", port=8889)\n\n# Backwards-compat shim: some inspector tooling (fastmcp helpers)\n# expect a `_list_tools_mcp` coroutine on the server instance. Provide\n# a thin wrapper that forwards to the FastMCP `list_tools` implementation.\nasync def _list_tools_mcp(self):\n    return await self.list_tools()\n\n# Bind the method to the instance\n# MCP need to access it as an instance method later\n# This will return list of ToolMetadata objects\nmcp._list_tools_mcp = types.MethodType(_list_tools_mcp, mcp)\n\n# Common CORS headers used by the inspector (browser-based)\nHEADERS = {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET,POST,OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type,Authorization,X-Proxy-Token\",\n}\n\n# Helper functions for tool execution\ndef get_tool_function(tool_name: str):\n    \"\"\"Get the actual function for a tool by name\"\"\"\n    # Build a mapping of tool names to functions\n    tool_map = {\n        'hello': hello,\n        'add': add,\n        'ollama_generate': ollama_generate,\n        'ollama_chat': ollama_chat,\n        'ollama_list_models': ollama_list_models,\n        'code_review_prompt': code_review_prompt,\n        'debug_prompt': debug_prompt,\n    }\n    return tool_map.get(tool_name)\n\ndef validate_tool_arguments(tool_func, arguments: Dict[str, Any]) -&gt; tuple[bool, str]:\n    \"\"\"Validate arguments against function signature\"\"\"\n    try:\n        sig = inspect.signature(tool_func)\n        params = sig.parameters\n\n        # Check required arguments\n        for param_name, param in params.items():\n            if param.default == inspect.Parameter.empty and param_name not in arguments:\n                return False, f\"Missing required argument: {param_name}\"\n\n        # Check for unexpected arguments\n        for arg_name in arguments:\n            if arg_name not in params:\n                return False, f\"Unexpected argument: {arg_name}\"\n\n        return True, \"Valid\"\n    except Exception as e:\n        return False, f\"Validation error: {str(e)}\"\n\nasync def execute_tool(tool_name: str, arguments: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute a tool and return the result\"\"\"\n    global EXECUTION_COUNTER\n    execution_id = f\"exec_{EXECUTION_COUNTER}\"\n    EXECUTION_COUNTER += 1\n\n    start_time = time.time()\n\n    try:\n        tool_func = get_tool_function(tool_name)\n        if not tool_func:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": f\"Tool '{tool_name}' not found\",\n                \"duration_ms\": 0\n            }\n\n        # Validate arguments\n        valid, message = validate_tool_arguments(tool_func, arguments)\n        if not valid:\n            return {\n                \"execution_id\": execution_id,\n                \"tool\": tool_name,\n                \"success\": False,\n                \"error\": message,\n                \"duration_ms\": 0\n            }\n\n        # Execute the tool\n        if inspect.iscoroutinefunction(tool_func):\n            result = await tool_func(**arguments)\n        else:\n            result = tool_func(**arguments)\n\n        duration_ms = (time.time() - start_time) * 1000\n\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": True,\n            \"result\": result,\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n\n    except Exception as e:\n        duration_ms = (time.time() - start_time) * 1000\n        execution_record = {\n            \"execution_id\": execution_id,\n            \"tool\": tool_name,\n            \"arguments\": arguments,\n            \"success\": False,\n            \"error\": str(e),\n            \"duration_ms\": round(duration_ms, 2),\n            \"timestamp\": time.time()\n        }\n        TOOL_EXECUTIONS[execution_id] = execution_record\n        return execution_record\n\n# Example tool definitions\n# These will be automatically registered with the MCP server\n@mcp.tool()\ndef hello(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to K-Agent Labs.\"\n\n# Example tool that adds two numbers\n# Demonstrates handling of numeric inputs and outputs\n# This will become MCP tool available at /tools\n@mcp.tool()\ndef add(a: float, b: float) -&gt; str:\n    \"\"\"Adds two numbers together\"\"\"\n    result = a + b\n    return f\"The sum of {a} and {b} is {result}\"\n\n# Ollama integration tools\n@mcp.tool()\ndef ollama_generate(prompt: str, model: str = DEFAULT_MODEL, max_tokens: int = 500) -&gt; str:\n    \"\"\"Generate text using Ollama LLM\"\"\"\n    try:\n        import requests\n        response = requests.post(\n            f\"{OLLAMA_BASE_URL}/api/generate\",\n            json={\n                \"model\": model,\n                \"prompt\": prompt,\n                \"stream\": False,\n                \"options\": {\n                    \"num_predict\": max_tokens\n                }\n            },\n            timeout=60\n        )\n        if response.status_code == 200:\n            result = response.json()\n            return result.get(\"response\", \"No response from model\")\n        else:\n            return f\"Error: {response.status_code} - {response.text}\"\n    except Exception as e:\n        return f\"Error calling Ollama: {str(e)}\"\n\n@mcp.tool()\ndef ollama_chat(message: str, model: str = DEFAULT_MODEL, system: str = \"\") -&gt; str:\n    \"\"\"Chat with Ollama LLM using chat API\"\"\"\n    try:\n        import requests\n        messages = []\n        if system:\n            messages.append({\"role\": \"system\", \"content\": system})\n        messages.append({\"role\": \"user\", \"content\": message})\n\n        response = requests.post(\n            f\"{OLLAMA_BASE_URL}/api/chat\",\n            json={\n                \"model\": model,\n                \"messages\": messages,\n                \"stream\": False\n            },\n            timeout=60\n        )\n        if response.status_code == 200:\n            result = response.json()\n            return result.get(\"message\", {}).get(\"content\", \"No response\")\n        else:\n            return f\"Error: {response.status_code} - {response.text}\"\n    except Exception as e:\n        return f\"Error calling Ollama: {str(e)}\"\n\n@mcp.tool()\ndef ollama_list_models() -&gt; str:\n    \"\"\"List available Ollama models\"\"\"\n    try:\n        import requests\n        response = requests.get(f\"{OLLAMA_BASE_URL}/api/tags\", timeout=5)\n        if response.status_code == 200:\n            data = response.json()\n            models = data.get(\"models\", [])\n            if not models:\n                return \"No models available\"\n\n            result = \"Available Ollama models:\\n\"\n            for model in models:\n                name = model.get(\"name\", \"unknown\")\n                size = model.get(\"size\", 0) // (1024**3)  # Convert to GB\n                result += f\"- {name} ({size}GB)\\n\"\n            return result\n        else:\n            return f\"Error: {response.status_code}\"\n    except Exception as e:\n        return f\"Error listing models: {str(e)}\"\n\n# Prompts - Reusable prompt templates\n@mcp.prompt()\ndef code_review_prompt(code: str, language: str = \"python\") -&gt; str:\n    \"\"\"Generate a code review prompt for the given code\"\"\"\n    return f\"\"\"Please review this {language} code and provide feedback:\n\n---{language}\n{code}\n---\n\nFocus on:\n- Code quality and best practices\n- Potential bugs or issues\n- Performance improvements\n- Security concerns\n\"\"\"\n\n@mcp.prompt()\ndef debug_prompt(error_message: str, code_context: str = \"\") -&gt; str:\n    \"\"\"Generate a debugging prompt\"\"\"\n    prompt = f\"\"\"Help me debug this error:\n\nError: {error_message}\n\"\"\"\n    if code_context:\n        prompt += f\"\\n\\nCode context:\\n---\\n{code_context}\\n---\"\n    return prompt\n\n# Resource to return the source code of this server\n# Useful for inspection and learning purposes\n@mcp.resource(\"mcp://code\")\ndef get_code() -&gt; str:\n    \"\"\"Returns the source code of this server\"\"\"\n    with open(__file__, \"r\") as f:\n        return f.read()\n\n@mcp.resource(\"mcp://server-info\")\ndef get_server_info() -&gt; str:\n    \"\"\"Returns information about this MCP server\"\"\"\n    return \"\"\"K-Agent MCP Server\n\nVersion: 0.1.0\nCapabilities:\n- Tools: hello, add\n- Prompts: code_review_prompt, debug_prompt\n- Resources: code, server-info\n- Sampling: LLM sampling support\n- Roots: File system access\n\"\"\"\n\n@mcp.custom_route(\"/\", methods=[\"GET\", \"OPTIONS\"])\nasync def root_health_check(request: Request) -&gt; Response:\n    return Response(\"MCP Server Running\", status_code=200, headers=HEADERS)\n\n# Health check endpoints\n# MCP manifest endpoint, negotiation, and tools listing\n@mcp.custom_route(\"/health\", methods=[\"GET\", \"OPTIONS\"])\nasync def health_check(request: Request) -&gt; Response:\n    return Response(\"MCP Server Running\", status_code=200, headers=HEADERS)\n\n# MCP Manifest endpoint as per MCP specification\n# Provides metadata about the MCP server\n@mcp.custom_route(\"/.well-known/mcp\", methods=[\"GET\", \"OPTIONS\"])\nasync def mcp_manifest(request: Request) -&gt; JSONResponse:\n    host = request.headers.get(\"host\", \"localhost:8889\")\n    scheme = request.url.scheme or \"http\"\n    base = f\"{scheme}://{host}\"\n    manifest = {\n        \"name\": \"kagent-mcp-server\",\n        \"version\": \"0.1.0\",\n        \"base_url\": base,\n        \"transport\": \"streamable-http\",\n        \"capabilities\": {\n            \"tools\": True,\n            \"prompts\": True,\n            \"resources\": True,\n            \"sampling\": True,\n            \"roots\": True,\n            \"logging\": True\n        },\n        \"endpoints\": {\n            \"manifest\": \"/.well-known/mcp\",\n            \"health\": \"/health\",\n            \"ping\": \"/ping\",\n            \"root\": \"/\",\n            \"negotiate\": \"/negotiate\",\n            \"metadata\": \"/metadata\",\n            \"events\": \"/mcp\",\n            \"tools\": \"/tools\",\n            \"tools_execute\": \"/tools/execute\",\n            \"tools_batch\": \"/tools/batch\",\n            \"tools_stream\": \"/tools/stream\",\n            \"tools_history\": \"/tools/history\",\n            \"prompts\": \"/prompts\",\n            \"resources\": \"/resources\",\n            \"sampling\": \"/sampling\",\n            \"roots\": \"/roots\",\n            \"ollama_status\": \"/ollama/status\",\n        },\n    }\n    return JSONResponse(manifest, headers=HEADERS)\n\n# MCP Negotiation endpoint\n# Clients use this to negotiate connection parameters\n# Supports token-based authentication\n@mcp.custom_route(\"/negotiate\", methods=[\"GET\", \"POST\", \"OPTIONS\"])\nasync def negotiate(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    host = request.headers.get(\"host\", \"localhost:8889\")\n    scheme = request.url.scheme or \"http\"\n    mcp_url = f\"{scheme}://{host}/mcp\"\n\n    # Accept proxy token from query param, X-Proxy-Token header, or Authorization bearer\n    token = request.query_params.get(\"token\") or request.headers.get(\"x-proxy-token\") or request.headers.get(\"X-Proxy-Token\")\n    auth = request.headers.get(\"authorization\") or request.headers.get(\"Authorization\")\n    if not token and auth and auth.lower().startswith(\"bearer \"):\n        token = auth.split(None, 1)[1]\n\n    response = {\n        \"transport\": \"streamable-http\",\n        \"url\": mcp_url,\n    }\n\n    # Include token in response if provided\n    if token:\n        response[\"proxy_token\"] = token\n    else:\n        # When no token is provided, explicitly indicate no auth is required\n        # This helps the Inspector understand it can connect without authentication\n        response[\"requiresAuth\"] = False\n\n    return JSONResponse(response, headers=HEADERS)\n\n# Tools listing endpoint\n# Returns metadata about all registered tools\n# Used by inspectors to discover available tools\n@mcp.custom_route(\"/tools\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def tools_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    # Use the server's list_tools implementation so the inspector sees\n    # the canonical, generated tool metadata instead of a hand-written list.\n    tools = await mcp._list_tools_mcp()\n\n    serializable = []\n    for t in tools:\n        try:\n            serializable.append(t.model_dump())\n        except Exception:\n            try:\n                serializable.append(t.dict())\n            except Exception:\n                serializable.append(str(t))\n\n    return JSONResponse({\"tools\": serializable}, headers=HEADERS)\n\n# Tool execution endpoint - Execute a single tool\n@mcp.custom_route(\"/tools/execute\", methods=[\"POST\", \"OPTIONS\"])\nasync def tool_execute(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        body = await request.json()\n        tool_name = body.get(\"tool\")\n        arguments = body.get(\"arguments\", {})\n\n        if not tool_name:\n            return JSONResponse({\n                \"success\": False,\n                \"error\": \"Missing 'tool' field\"\n            }, headers=HEADERS, status_code=400)\n\n        result = await execute_tool(tool_name, arguments)\n        return JSONResponse(result, headers=HEADERS)\n\n    except Exception as e:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": f\"Execution failed: {str(e)}\"\n        }, headers=HEADERS, status_code=500)\n\n# Batch tool execution endpoint\n@mcp.custom_route(\"/tools/batch\", methods=[\"POST\", \"OPTIONS\"])\nasync def tool_batch_execute(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        body = await request.json()\n        calls = body.get(\"calls\", [])\n\n        if not calls:\n            return JSONResponse({\n                \"success\": False,\n                \"error\": \"Missing 'calls' array\"\n            }, headers=HEADERS, status_code=400)\n\n        results = []\n        for call in calls:\n            tool_name = call.get(\"tool\")\n            arguments = call.get(\"arguments\", {})\n\n            if tool_name:\n                result = await execute_tool(tool_name, arguments)\n                results.append(result)\n            else:\n                results.append({\n                    \"success\": False,\n                    \"error\": \"Missing tool name in call\"\n                })\n\n        return JSONResponse({\n            \"success\": True,\n            \"results\": results,\n            \"total\": len(results)\n        }, headers=HEADERS)\n\n    except Exception as e:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": f\"Batch execution failed: {str(e)}\"\n        }, headers=HEADERS, status_code=500)\n\n# Tool execution history endpoint\n@mcp.custom_route(\"/tools/history\", methods=[\"GET\", \"OPTIONS\"])\nasync def tool_history(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    limit = int(request.query_params.get(\"limit\", 10))\n\n    # Get recent executions\n    executions = list(TOOL_EXECUTIONS.values())\n    executions.sort(key=lambda x: x.get(\"timestamp\", 0), reverse=True)\n\n    return JSONResponse({\n        \"executions\": executions[:limit],\n        \"total\": len(executions)\n    }, headers=HEADERS)\n\n# Get specific execution details\n@mcp.custom_route(\"/tools/execution/{execution_id}\", methods=[\"GET\", \"OPTIONS\"])\nasync def tool_execution_detail(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    execution_id = request.path_params.get(\"execution_id\")\n\n    if execution_id in TOOL_EXECUTIONS:\n        return JSONResponse(TOOL_EXECUTIONS[execution_id], headers=HEADERS)\n    else:\n        return JSONResponse({\n            \"error\": f\"Execution '{execution_id}' not found\"\n        }, headers=HEADERS, status_code=404)\n\n# Streaming tool execution\n@mcp.custom_route(\"/tools/stream\", methods=[\"POST\", \"OPTIONS\"])\nasync def tool_stream_execute(request: Request):\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        body = await request.json()\n        tool_name = body.get(\"tool\")\n        arguments = body.get(\"arguments\", {})\n\n        async def generate_stream():\n            # Send start event\n            yield json.dumps({\n                \"event\": \"start\",\n                \"tool\": tool_name,\n                \"timestamp\": time.time()\n            }) + \"\\n\"\n\n            # Execute tool\n            result = await execute_tool(tool_name, arguments)\n\n            # Send result event\n            yield json.dumps({\n                \"event\": \"result\",\n                \"data\": result\n            }) + \"\\n\"\n\n            # Send end event\n            yield json.dumps({\n                \"event\": \"end\",\n                \"timestamp\": time.time()\n            }) + \"\\n\"\n\n        return StreamingResponse(\n            generate_stream(),\n            media_type=\"application/x-ndjson\",\n            headers=HEADERS\n        )\n\n    except Exception as e:\n        return JSONResponse({\n            \"success\": False,\n            \"error\": f\"Stream execution failed: {str(e)}\"\n        }, headers=HEADERS, status_code=500)\n\n# Prompts listing endpoint\n@mcp.custom_route(\"/prompts\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def prompts_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    prompts = [\n        {\n            \"name\": \"code_review_prompt\",\n            \"description\": \"Generate a code review prompt for the given code\",\n            \"arguments\": [\n                {\"name\": \"code\", \"description\": \"The code to review\", \"required\": True},\n                {\"name\": \"language\", \"description\": \"Programming language\", \"required\": False}\n            ]\n        },\n        {\n            \"name\": \"debug_prompt\",\n            \"description\": \"Generate a debugging prompt\",\n            \"arguments\": [\n                {\"name\": \"error_message\", \"description\": \"The error message\", \"required\": True},\n                {\"name\": \"code_context\", \"description\": \"Relevant code context\", \"required\": False}\n            ]\n        }\n    ]\n\n    return JSONResponse({\"prompts\": prompts}, headers=HEADERS)\n\n# Resources listing endpoint\n@mcp.custom_route(\"/resources\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def resources_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    resources = [\n        {\n            \"uri\": \"mcp://code\",\n            \"name\": \"Server Source Code\",\n            \"description\": \"Returns the source code of this server\",\n            \"mimeType\": \"text/plain\"\n        },\n        {\n            \"uri\": \"mcp://server-info\",\n            \"name\": \"Server Information\",\n            \"description\": \"Returns information about this MCP server\",\n            \"mimeType\": \"text/plain\"\n        }\n    ]\n\n    return JSONResponse({\"resources\": resources}, headers=HEADERS)\n\n# Ping endpoint for connection health checks\n@mcp.custom_route(\"/ping\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def ping(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    return JSONResponse({\n        \"status\": \"ok\",\n        \"timestamp\": __import__('time').time(),\n        \"server\": \"kagent-mcp-server\"\n    }, headers=HEADERS)\n\n# Sampling endpoint - LLM sampling capability using Ollama\n@mcp.custom_route(\"/sampling\", methods=[\"POST\", \"OPTIONS\"])\nasync def sampling(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    body = await request.json() if request.method == \"POST\" else {}\n    prompt = body.get(\"prompt\", \"\")\n    max_tokens = body.get(\"maxTokens\", 100)\n    model = body.get(\"model\", DEFAULT_MODEL)\n\n    try:\n        async with httpx.AsyncClient(timeout=60.0) as client:\n            response = await client.post(\n                f\"{OLLAMA_BASE_URL}/api/generate\",\n                json={\n                    \"model\": model,\n                    \"prompt\": prompt,\n                    \"stream\": False,\n                    \"options\": {\n                        \"num_predict\": max_tokens\n                    }\n                }\n            )\n\n            if response.status_code == 200:\n                result = response.json()\n                return JSONResponse({\n                    \"completion\": result.get(\"response\", \"\"),\n                    \"stopReason\": \"endTurn\" if result.get(\"done\") else \"length\",\n                    \"model\": model,\n                    \"context\": result.get(\"context\", [])\n                }, headers=HEADERS)\n            else:\n                return JSONResponse({\n                    \"error\": f\"Ollama error: {response.status_code}\",\n                    \"completion\": \"\",\n                    \"stopReason\": \"error\",\n                    \"model\": model\n                }, headers=HEADERS, status_code=500)\n    except Exception as e:\n        return JSONResponse({\n            \"error\": f\"Failed to connect to Ollama: {str(e)}\",\n            \"completion\": \"\",\n            \"stopReason\": \"error\",\n            \"model\": model\n        }, headers=HEADERS, status_code=500)\n\n# Roots endpoint - File system roots\n@mcp.custom_route(\"/roots\", methods=[\"POST\", \"GET\", \"OPTIONS\"])\nasync def roots_list(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    import os\n    roots = [\n        {\n            \"uri\": f\"file://{os.getcwd()}\",\n            \"name\": \"Current Directory\"\n        }\n    ]\n\n    return JSONResponse({\"roots\": roots}, headers=HEADERS)\n\n# Ollama status endpoint\n@mcp.custom_route(\"/ollama/status\", methods=[\"GET\", \"OPTIONS\"])\nasync def ollama_status(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    try:\n        async with httpx.AsyncClient(timeout=5.0) as client:\n            response = await client.get(f\"{OLLAMA_BASE_URL}/api/tags\")\n            if response.status_code == 200:\n                data = response.json()\n                models = data.get(\"models\", [])\n                return JSONResponse({\n                    \"status\": \"connected\",\n                    \"url\": OLLAMA_BASE_URL,\n                    \"models_count\": len(models),\n                    \"models\": [{\n                        \"name\": m.get(\"name\"),\n                        \"size\": m.get(\"size\"),\n                        \"modified\": m.get(\"modified_at\")\n                    } for m in models],\n                    \"default_model\": DEFAULT_MODEL\n                }, headers=HEADERS)\n            else:\n                return JSONResponse({\n                    \"status\": \"error\",\n                    \"url\": OLLAMA_BASE_URL,\n                    \"error\": f\"HTTP {response.status_code}\"\n                }, headers=HEADERS)\n    except Exception as e:\n        return JSONResponse({\n            \"status\": \"disconnected\",\n            \"url\": OLLAMA_BASE_URL,\n            \"error\": str(e)\n        }, headers=HEADERS)\n\n# Server metadata endpoint\n@mcp.custom_route(\"/metadata\", methods=[\"GET\", \"OPTIONS\"])\nasync def metadata(request: Request) -&gt; JSONResponse:\n    # Handle OPTIONS preflight\n    if request.method == \"OPTIONS\":\n        return JSONResponse({}, headers=HEADERS)\n\n    return JSONResponse({\n        \"serverInfo\": {\n            \"name\": \"kagent-mcp-server\",\n            \"version\": \"0.1.0\",\n            \"protocolVersion\": \"2024-11-05\"\n        },\n        \"capabilities\": {\n            \"tools\": {\"listChanged\": False},\n            \"prompts\": {\"listChanged\": False},\n            \"resources\": {\"subscribe\": False, \"listChanged\": False},\n            \"logging\": {},\n            \"sampling\": {},\n            \"roots\": {\"listChanged\": False}\n        }\n    }, headers=HEADERS)\n\n# Add CORS middleware to handle preflight requests for all endpoints\n@mcp.custom_route(\"/mcp\", methods=[\"OPTIONS\"])\nasync def mcp_options(request: Request) -&gt; Response:\n    \"\"\"Handle CORS preflight for the MCP endpoint\"\"\"\n    return Response(status_code=200, headers=HEADERS)\n\n# Main entry point to run the MCP server\ndef main():\n    # Start the MCP server with streamable-http transport\n    # Mounted at /mcp path\n    # This will listen on port 8889 as configured above\n    mcp.run(transport=\"streamable-http\", mount_path=\"/mcp\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Resources/Lab01-MCP-Fundamentals/MCP-Basics-py/","title":"MCP Basics py","text":""},{"location":"Resources/Lab01-MCP-Fundamentals/MCP-Basics-py/#mcp-basics-with-python","title":"MCP Basics with Python","text":"<pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create server instance\nmcp = FastMCP(\"kagent-mcp-server\")\n\n@mcp.tool()\ndef hello(name: str) -&gt; str:\n    \"\"\"Returns a friendly greeting message\"\"\"\n    return f\"Hello, {name}! Welcome to K-Agent Labs.\"\n\n@mcp.tool()\ndef add(a: float, b: float) -&gt; str:\n    \"\"\"Adds two numbers together\"\"\"\n    result = a + b\n    return f\"The sum of {a} and {b} is {result}\"\n\ndef main():\n    # Initialize and run the server\n    mcp.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Resources/Lab01-MCP-Fundamentals/MCP-Basics-ts/","title":"MCP Server Example (TS)","text":"<pre><code>#!/usr/bin/env node\n\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * K-Agent MCP Server\n * A simple Model Context Protocol server with example tools\n */\n\n// Create server instance\nconst server = new Server(\n  {\n    name: \"kagent-mcp-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\n// List available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n  return {\n    tools: [\n      {\n        name: \"hello\",\n        description: \"Returns a friendly greeting message\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            name: {\n              type: \"string\",\n              description: \"Name to greet\",\n            },\n          },\n          required: [\"name\"],\n        },\n      },\n      {\n        name: \"add\",\n        description: \"Adds two numbers together\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            a: {\n              type: \"number\",\n              description: \"First number\",\n            },\n            b: {\n              type: \"number\",\n              description: \"Second number\",\n            },\n          },\n          required: [\"a\", \"b\"],\n        },\n      },\n    ],\n  };\n});\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  switch (name) {\n    case \"hello\": {\n      const nameArg = args?.name as string;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Hello, ${nameArg}! Welcome to K-Agent Labs.`,\n          },\n        ],\n      };\n    }\n\n    case \"add\": {\n      const a = args?.a as number;\n      const b = args?.b as number;\n      const result = a + b;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `The sum of ${a} and ${b} is ${result}`,\n          },\n        ],\n      };\n    }\n\n    default:\n      throw new Error(`Unknown tool: ${name}`);\n  }\n});\n\n// Start the server\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"K-Agent MCP Server running on stdio\");\n}\n\nmain().catch((error) =&gt; {\n  console.error(\"Server error:\", error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step01-imports/","title":"Step01 imports","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 1: Imports\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step02-ctor/","title":"Step02 ctor","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 1: Imports\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step03-init/","title":"Step03 init","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 1: Imports\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step04-tools/","title":"Step04 tools","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 4: Register Tools\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step05-tool-handlers/","title":"Step05 tool handlers","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 5: Register Tool Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n    self.register_tool_handlers()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step06-resources/","title":"Step06 resources","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 6: Register Resources\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n      \"\"\"\n      Return the list of available resources.\n      This is called when clients want to discover what resources are available.\n      \"\"\"\n      return [\n        Resource(\n          uri=\"resource://server-info\",\n          name=\"Server Information\",\n          description=\"Information about this MCP server\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://data-store\",\n          name=\"Data Store\",\n          description=\"Current contents of the data store\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://welcome\",\n          name=\"Welcome Message\",\n          description=\"Welcome message and server capabilities\",\n          mimeType=\"text/plain\"\n        )\n      ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n    self.register_tool_handlers()\n    self.register_resources()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step07-resource-handlers/","title":"Step07 resource handlers","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 7: Register Resource Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n      \"\"\"\n      Return the list of available resources.\n      This is called when clients want to discover what resources are available.\n      \"\"\"\n      return [\n        Resource(\n          uri=\"resource://server-info\",\n          name=\"Server Information\",\n          description=\"Information about this MCP server\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://data-store\",\n          name=\"Data Store\",\n          description=\"Current contents of the data store\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://welcome\",\n          name=\"Welcome Message\",\n          description=\"Welcome message and server capabilities\",\n          mimeType=\"text/plain\"\n        )\n      ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n\n  def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n    async def read_resource(uri: Any) -&gt; str:\n      \"\"\"\n      Handle resource read requests.\n      This is called when a client wants to read a resource.\n      \"\"\"\n      # Extract the URI string from the AnyUrl object\n      uri_str = str(uri)\n\n      if uri_str == \"resource://server-info\":\n        info = {\n          \"name\": \"complete-mcp-server\",\n          \"version\": \"1.0.0\",\n          \"description\": \"A comprehensive MCP server implementation\",\n          \"capabilities\": {\n            \"tools\": 4,\n            \"resources\": 3,\n            \"prompts\": 2\n          }\n        }\n        return json.dumps(info, indent=2)\n\n      elif uri_str == \"resource://data-store\":\n        return json.dumps(self.data_store, indent=2)\n\n      elif uri_str == \"resource://welcome\":\n        return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n      else:\n        raise ValueError(f\"Unknown resource: {uri_str}\")\n\n    print(\"Resource handlers implemented\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n    self.register_tool_handlers()\n    self.register_resources()\n    self.register_resource_handlers()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step08-prompts/","title":"Step08 prompts","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 8: Register Prompts\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,    ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n      \"\"\"\n      Return the list of available resources.\n      This is called when clients want to discover what resources are available.\n      \"\"\"\n      return [\n        Resource(\n          uri=\"resource://server-info\",\n          name=\"Server Information\",\n          description=\"Information about this MCP server\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://data-store\",\n          name=\"Data Store\",\n          description=\"Current contents of the data store\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://welcome\",\n          name=\"Welcome Message\",\n          description=\"Welcome message and server capabilities\",\n          mimeType=\"text/plain\"\n        )\n      ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n\n  def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n    async def read_resource(uri: Any) -&gt; str:\n      \"\"\"\n      Handle resource read requests.\n      This is called when a client wants to read a resource.\n      \"\"\"\n      # Extract the URI string from the AnyUrl object\n      uri_str = str(uri)\n\n      if uri_str == \"resource://server-info\":\n        info = {\n          \"name\": \"complete-mcp-server\",\n          \"version\": \"1.0.0\",\n          \"description\": \"A comprehensive MCP server implementation\",\n          \"capabilities\": {\n            \"tools\": 4,\n            \"resources\": 3,\n            \"prompts\": 2\n          }\n        }\n        return json.dumps(info, indent=2)\n\n      elif uri_str == \"resource://data-store\":\n        return json.dumps(self.data_store, indent=2)\n\n      elif uri_str == \"resource://welcome\":\n        return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n      else:\n        raise ValueError(f\"Unknown resource: {uri_str}\")\n\n    print(\"Resource handlers implemented\")\n\n  def register_prompts(self):\n    \"\"\"Register prompt templates for clients.\"\"\"\n\n    @self.server.list_prompts()\n    async def list_prompts() -&gt; list[Prompt]:\n      \"\"\"\n      Return the list of available prompts.\n      This is called when clients want to discover what prompts are available.\n      \"\"\"\n      return [\n        Prompt(\n          name=\"analyze-data\",\n          description=\"Analyze data stored in the server\",\n          arguments=[\n            {\n              \"name\": \"key\",\n              \"description\": \"The key of the data to analyze\",\n              \"required\": True\n            }\n          ]\n        ),\n        Prompt(\n          name=\"calculate-scenario\",\n          description=\"Walk through a calculation scenario\",\n          arguments=[\n            {\n              \"name\": \"operation\",\n              \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n              \"required\": True\n            }\n          ]\n        )\n      ]\n\n    print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n    self.register_tool_handlers()\n    self.register_resources()\n    self.register_resource_handlers()\n    self.register_prompts()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step09-prompt-handlers/","title":"Step09 prompt handlers","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 9: Register Prompt Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n      \"\"\"\n      Return the list of available resources.\n      This is called when clients want to discover what resources are available.\n      \"\"\"\n      return [\n        Resource(\n          uri=\"resource://server-info\",\n          name=\"Server Information\",\n          description=\"Information about this MCP server\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://data-store\",\n          name=\"Data Store\",\n          description=\"Current contents of the data store\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://welcome\",\n          name=\"Welcome Message\",\n          description=\"Welcome message and server capabilities\",\n          mimeType=\"text/plain\"\n        )\n      ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n\n  def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n    async def read_resource(uri: Any) -&gt; str:\n      \"\"\"\n      Handle resource read requests.\n      This is called when a client wants to read a resource.\n      \"\"\"\n      # Extract the URI string from the AnyUrl object\n      uri_str = str(uri)\n\n      if uri_str == \"resource://server-info\":\n        info = {\n          \"name\": \"complete-mcp-server\",\n          \"version\": \"1.0.0\",\n          \"description\": \"A comprehensive MCP server implementation\",\n          \"capabilities\": {\n            \"tools\": 4,\n            \"resources\": 3,\n            \"prompts\": 2\n          }\n        }\n        return json.dumps(info, indent=2)\n\n      elif uri_str == \"resource://data-store\":\n        return json.dumps(self.data_store, indent=2)\n\n      elif uri_str == \"resource://welcome\":\n        return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n      else:\n        raise ValueError(f\"Unknown resource: {uri_str}\")\n\n    print(\"Resource handlers implemented\")\n\n  def register_prompts(self):\n    \"\"\"Register prompt templates for clients.\"\"\"\n\n    @self.server.list_prompts()\n    async def list_prompts() -&gt; list[Prompt]:\n      \"\"\"\n      Return the list of available prompts.\n      This is called when clients want to discover what prompts are available.\n      \"\"\"\n      return [\n        Prompt(\n          name=\"analyze-data\",\n          description=\"Analyze data stored in the server\",\n          arguments=[\n            {\n              \"name\": \"key\",\n              \"description\": \"The key of the data to analyze\",\n              \"required\": True\n            }\n          ]\n        ),\n        Prompt(\n          name=\"calculate-scenario\",\n          description=\"Walk through a calculation scenario\",\n          arguments=[\n            {\n              \"name\": \"operation\",\n              \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n              \"required\": True\n            }\n          ]\n        )\n      ]\n\n    print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n  def register_prompt_handlers(self):\n    \"\"\"Implement prompt generation logic.\"\"\"\n\n    @self.server.get_prompt()\n    async def get_prompt(name: str, arguments: dict) -&gt; list[TextContent]:\n      \"\"\"\n      Handle prompt generation requests.\n      This is called when a client wants to get a prompt.\n      \"\"\"\n      if name == \"analyze-data\":\n        key = arguments.get(\"key\", \"unknown\")\n        value = self.data_store.get(key, \"not found\")\n\n        prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n        return [TextContent(type=\"text\", text=prompt_text)]\n\n      elif name == \"calculate-scenario\":\n        operation = arguments.get(\"operation\", \"add\")\n\n        prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n        return [TextContent(type=\"text\", text=prompt_text)]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown prompt '{name}'\"\n        )]\n\n    print(\"Prompt handlers implemented\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n    self.register_tool_handlers()\n    self.register_resources()\n    self.register_resource_handlers()\n    self.register_prompts()\n    self.register_prompt_handlers()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step10-lifecycle/","title":"Step10 lifecycle","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 10: Lifecycle Handlers\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n      \"\"\"\n      Return the list of available resources.\n      This is called when clients want to discover what resources are available.\n      \"\"\"\n      return [\n        Resource(\n          uri=\"resource://server-info\",\n          name=\"Server Information\",\n          description=\"Information about this MCP server\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://data-store\",\n          name=\"Data Store\",\n          description=\"Current contents of the data store\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://welcome\",\n          name=\"Welcome Message\",\n          description=\"Welcome message and server capabilities\",\n          mimeType=\"text/plain\"\n        )\n      ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n\n  def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n    async def read_resource(uri: Any) -&gt; str:\n      \"\"\"\n      Handle resource read requests.\n      This is called when a client wants to read a resource.\n      \"\"\"\n      # Extract the URI string from the AnyUrl object\n      uri_str = str(uri)\n\n      if uri_str == \"resource://server-info\":\n        info = {\n          \"name\": \"complete-mcp-server\",\n          \"version\": \"1.0.0\",\n          \"description\": \"A comprehensive MCP server implementation\",\n          \"capabilities\": {\n            \"tools\": 4,\n            \"resources\": 3,\n            \"prompts\": 2\n          }\n        }\n        return json.dumps(info, indent=2)\n\n      elif uri_str == \"resource://data-store\":\n        return json.dumps(self.data_store, indent=2)\n\n      elif uri_str == \"resource://welcome\":\n        return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n      else:\n        raise ValueError(f\"Unknown resource: {uri_str}\")\n\n    print(\"Resource handlers implemented\")\n\n  def register_prompts(self):\n    \"\"\"Register prompt templates for clients.\"\"\"\n\n    @self.server.list_prompts()\n    async def list_prompts() -&gt; list[Prompt]:\n      \"\"\"\n      Return the list of available prompts.\n      This is called when clients want to discover what prompts are available.\n      \"\"\"\n      return [\n        Prompt(\n          name=\"analyze-data\",\n          description=\"Analyze data stored in the server\",\n          arguments=[\n            {\n              \"name\": \"key\",\n              \"description\": \"The key of the data to analyze\",\n              \"required\": True\n            }\n          ]\n        ),\n        Prompt(\n          name=\"calculate-scenario\",\n          description=\"Walk through a calculation scenario\",\n          arguments=[\n            {\n              \"name\": \"operation\",\n              \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n              \"required\": True\n            }\n          ]\n        )\n      ]\n\n    print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n  def register_prompt_handlers(self):\n    \"\"\"Implement prompt generation logic.\"\"\"\n\n    @self.server.get_prompt()\n    async def get_prompt(name: str, arguments: dict) -&gt; list[TextContent]:\n      \"\"\"\n      Handle prompt generation requests.\n      This is called when a client wants to get a prompt.\n      \"\"\"\n      if name == \"analyze-data\":\n        key = arguments.get(\"key\", \"unknown\")\n        value = self.data_store.get(key, \"not found\")\n\n        prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n        return [TextContent(type=\"text\", text=prompt_text)]\n\n      elif name == \"calculate-scenario\":\n        operation = arguments.get(\"operation\", \"add\")\n\n        prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n        return [TextContent(type=\"text\", text=prompt_text)]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown prompt '{name}'\"\n        )]\n\n    print(\"Prompt handlers implemented\")\n\n  def setup_lifecycle_handlers(self):\n    \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n    # Note: MCP servers typically don't have explicit lifecycle hooks\n    # This is a conceptual method showing where such logic would go\n    print(\"Lifecycle management configured\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n    self.register_tool_handlers()\n    self.register_resources()\n    self.register_resource_handlers()\n    self.register_prompts()\n    self.register_prompt_handlers()\n    self.setup_lifecycle_handlers()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step11-main/","title":"Step11 main","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 11: Main Execution\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n  GetPromptResult,\n  PromptMessage,\n)\nimport sys\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  \"\"\"\n\n  def __init__(self):\n  \"\"\"Initialize the MCP Server instance.\"\"\"\n  self.server = Server(\"complete-mcp-server\")\n  self.data_store = {}  # Simple in-memory data storage\n  print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n  \"\"\"Register all available tools with the MCP server.\"\"\"\n\n  @self.server.list_tools()\n  async def list_tools() -&gt; list[Tool]:\n  \"\"\"\n  Return the list of available tools.\n  This is called when clients want to discover what tools are available.\n  \"\"\"\n  return [\n    Tool(\n    name=\"calculate\",\n    description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n    inputSchema={\n      \"type\": \"object\",\n      \"properties\": {\n      \"operation\": {\n        \"type\": \"string\",\n        \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n        \"description\": \"The operation to perform\"\n      },\n      \"a\": {\n        \"type\": \"number\",\n        \"description\": \"First number\"\n      },\n      \"b\": {\n        \"type\": \"number\",\n        \"description\": \"Second number\"\n      }\n      },\n      \"required\": [\"operation\", \"a\", \"b\"]\n    }\n    ),\n    Tool(\n    name=\"store_data\",\n    description=\"Store a key-value pair in the server's data store\",\n    inputSchema={\n      \"type\": \"object\",\n      \"properties\": {\n      \"key\": {\n        \"type\": \"string\",\n        \"description\": \"The key to store\"\n      },\n      \"value\": {\n        \"type\": \"string\",\n        \"description\": \"The value to store\"\n      }\n      },\n      \"required\": [\"key\", \"value\"]\n    }\n    ),\n    Tool(\n    name=\"retrieve_data\",\n    description=\"Retrieve a value from the server's data store\",\n    inputSchema={\n      \"type\": \"object\",\n      \"properties\": {\n      \"key\": {\n        \"type\": \"string\",\n        \"description\": \"The key to retrieve\"\n      }\n      },\n      \"required\": [\"key\"]\n    }\n    ),\n    Tool(\n    name=\"echo\",\n    description=\"Echo back the input text\",\n    inputSchema={\n      \"type\": \"object\",\n      \"properties\": {\n      \"text\": {\n        \"type\": \"string\",\n        \"description\": \"Text to echo back\"\n      }\n      },\n      \"required\": [\"text\"]\n    }\n    )\n  ]\n\n  print(\"Tools registered: calculate, store_data, retrieve_data, echo\")\n\n  def register_tool_handlers(self):\n  \"\"\"Implement the actual logic for each tool.\"\"\"\n\n  @self.server.call_tool()\n  async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n  \"\"\"\n  Handle tool execution requests.\n  This is called when a client wants to execute a tool.\n  \"\"\"\n  if name == \"calculate\":\n    operation = arguments.get(\"operation\")\n    a = arguments.get(\"a\")\n    b = arguments.get(\"b\")\n\n    if operation == \"add\":\n    result = a + b\n    elif operation == \"subtract\":\n    result = a - b\n    elif operation == \"multiply\":\n    result = a * b\n    elif operation == \"divide\":\n    if b == 0:\n      return [TextContent(\n      type=\"text\",\n      text=\"Error: Cannot divide by zero\"\n      )]\n    result = a / b\n    else:\n    return [TextContent(\n      type=\"text\",\n      text=f\"Error: Unknown operation '{operation}'\"\n    )]\n\n    return [TextContent(\n    type=\"text\",\n    text=f\"Result: {a} {operation} {b} = {result}\"\n    )]\n\n  elif name == \"store_data\":\n    key = arguments.get(\"key\")\n    value = arguments.get(\"value\")\n    self.data_store[key] = value\n    return [TextContent(\n    type=\"text\",\n    text=f\"Stored: {key} = {value}\"\n    )]\n\n  elif name == \"retrieve_data\":\n    key = arguments.get(\"key\")\n    value = self.data_store.get(key)\n    if value is None:\n    return [TextContent(\n      type=\"text\",\n      text=f\"Error: Key '{key}' not found\"\n    )]\n    return [TextContent(\n    type=\"text\",\n    text=f\"Retrieved: {key} = {value}\"\n    )]\n\n  elif name == \"echo\":\n    text = arguments.get(\"text\")\n    return [TextContent(\n    type=\"text\",\n    text=f\"Echo: {text}\"\n    )]\n\n  else:\n    return [TextContent(\n    type=\"text\",\n    text=f\"Error: Unknown tool '{name}'\"\n    )]\n\n  print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n  \"\"\"Register resources that clients can access.\"\"\"\n\n  @self.server.list_resources()\n  async def list_resources() -&gt; list[Resource]:\n  \"\"\"\n  Return the list of available resources.\n  This is called when clients want to discover what resources are available.\n  \"\"\"\n  return [\n    Resource(\n    uri=\"resource://server-info\",\n    name=\"Server Information\",\n    description=\"Information about this MCP server\",\n    mimeType=\"application/json\"\n    ),\n    Resource(\n    uri=\"resource://data-store\",\n    name=\"Data Store\",\n    description=\"Current contents of the data store\",\n    mimeType=\"application/json\"\n    ),\n    Resource(\n    uri=\"resource://welcome\",\n    name=\"Welcome Message\",\n    description=\"Welcome message and server capabilities\",\n    mimeType=\"text/plain\"\n    )\n  ]\n\n  print(\"Resources registered: server-info, data-store, welcome\")\n\n  def register_resource_handlers(self):\n  \"\"\"Implement resource retrieval logic.\"\"\"\n\n  @self.server.read_resource()\n  async def read_resource(uri: Any) -&gt; str:\n    \"\"\"\n    Handle resource read requests.\n    This is called when a client wants to read a resource.\n    \"\"\"\n    # Extract the URI string from the AnyUrl object\n    uri_str = str(uri)\n\n    if uri_str == \"resource://server-info\":\n      info = {\n      \"name\": \"complete-mcp-server\",\n      \"version\": \"1.0.0\",\n      \"description\": \"A comprehensive MCP server implementation\",\n      \"capabilities\": {\n        \"tools\": 4,\n        \"resources\": 3,\n        \"prompts\": 2\n      }\n    }\n    return json.dumps(info, indent=2)\n\n  elif uri_str == \"resource://data-store\":\n    return json.dumps(self.data_store, indent=2)\n\n  elif uri_str == \"resource://welcome\":\n    return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n  else:\n    raise ValueError(f\"Unknown resource: {uri_str}\")\n\n  print(\"Resource handlers implemented\")\n\n  def register_prompts(self):\n  \"\"\"Register prompt templates for clients.\"\"\"\n\n  @self.server.list_prompts()\n  async def list_prompts() -&gt; list[Prompt]:\n  \"\"\"\n  Return the list of available prompts.\n  This is called when clients want to discover what prompts are available.\n  \"\"\"\n  return [\n    Prompt(\n    name=\"analyze-data\",\n    description=\"Analyze data stored in the server\",\n    arguments=[\n      {\n      \"name\": \"key\",\n      \"description\": \"The key of the data to analyze\",\n      \"required\": True\n      }\n    ]\n    ),\n    Prompt(\n    name=\"calculate-scenario\",\n    description=\"Walk through a calculation scenario\",\n    arguments=[\n      {\n      \"name\": \"operation\",\n      \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n      \"required\": True\n      }\n    ]\n    )\n  ]\n\n  print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n  def register_prompt_handlers(self):\n  \"\"\"Implement prompt generation logic.\"\"\"\n\n  @self.server.get_prompt()\n  async def get_prompt(name: str, arguments: dict) -&gt; GetPromptResult:\n  \"\"\"\n  Handle prompt generation requests.\n  This is called when a client wants to get a prompt.\n  \"\"\"\n  if name == \"analyze-data\":\n    key = arguments.get(\"key\", \"unknown\")\n    value = self.data_store.get(key, \"not found\")\n\n    prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n    return GetPromptResult(\n    messages=[\n      PromptMessage(\n      role=\"user\",\n      content=TextContent(type=\"text\", text=prompt_text)\n      )\n    ]\n    )\n\n  elif name == \"calculate-scenario\":\n    operation = arguments.get(\"operation\", \"add\")\n\n    prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n    return GetPromptResult(\n    messages=[\n      PromptMessage(\n      role=\"user\",\n      content=TextContent(type=\"text\", text=prompt_text)\n      )\n    ]\n    )\n\n  else:\n    # Helper to create error message in correct format\n    return GetPromptResult(\n    messages=[\n      PromptMessage(\n      role=\"user\",\n      content=TextContent(\n        type=\"text\",\n        text=f\"Error: Unknown prompt '{name}'\"\n      )\n      )\n    ]\n    )\n\n  print(\"Prompt handlers implemented\")\n\n  def setup_lifecycle_handlers(self):\n  \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n  # Note: MCP servers typically don't have explicit lifecycle hooks\n  # This is a conceptual method showing where such logic would go\n  print(\"Lifecycle management configured\")\n\n  async def run(self):\n  \"\"\"Run the MCP server.\"\"\"\n  # Initialize everything\n  self.register_tools()\n  self.register_tool_handlers()\n  self.register_resources()\n  self.register_resource_handlers()\n  self.register_prompts()\n  self.register_prompt_handlers()\n  self.setup_lifecycle_handlers()\n\n  # Connect to stdio\n  async with stdio_server() as (read_stream, write_stream):\n  print(\"Server running on stdio...\")\n  await self.server.run(\n    read_stream,\n    write_stream,\n    self.server.create_initialization_options()\n  )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n  asyncio.run(main())\n  except KeyboardInterrupt:\n  print(\"Server stopped by user\")\n  except Exception as e:\n  print(f\"Error: {e}\")\n  sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step12-rag/","title":"Step12 rag","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 12: RAG (Retrieval Augmented Generation)\n\"\"\"\n\nimport asyncio\nimport csv\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n  GetPromptResult,\n  PromptMessage,\n)\nimport sys\n\n# Initialize an in-memory users\nusers = []\n\ndef load_users(csv_file_path: str):\n  \"\"\"Load users from a CSV file.\"\"\"\n  global users\n  users = []\n\n  try:\n    with open(csv_file_path, 'r', encoding='utf-8') as f:\n      reader = csv.DictReader(f)\n      for i, row in enumerate(reader):\n        # Assuming CSV has 'content' and 'id' columns or similar\n        # Adjust column names as needed\n        content = row.get('content') or row.get('text') or list(row.values())[0]\n        doc_id = row.get('id') or f\"doc_{i}\"\n\n        if content:\n          users.append({\"id\": doc_id, \"content\": content})\n\n    print(f\"Loaded {len(users)} documents into users.\")\n  except Exception as e:\n    print(f\"Error loading users: {e}\")\n\n# Load the users\n# Make sure you have a 'users.csv' file in the same directory\n# Format: id,content\nload_users(\"users.csv\")\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  - RAG capabilities\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        ),\n        Tool(\n          name=\"filter_users_by_city\",\n          description=\"Filter and return users who live in a specific city\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"city\": {\n                \"type\": \"string\",\n                \"description\": \"The city to filter users by\"\n              }\n            },\n            \"required\": [\"city\"]\n          }\n        ),\n        Tool(\n          name=\"filter_users_by_age\",\n          description=\"Filter and return users who are older than the specified minimum age\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"min_age\": {\n                \"type\": \"number\",\n                \"description\": \"The minimum age to filter users by\"\n              }\n            },\n            \"required\": [\"min_age\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo, filter_users_by_city, filter_users_by_age\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      elif name == \"filter_users_by_city\":\n        city = arguments.get(\"city\", \"\")\n        filtered_users = []\n        target_city = city.lower().strip()\n\n        for user in users:\n          # Assuming user dict has 'city' key (loaded from CSV)\n          u_city = user.get(\"city\", \"\").lower()\n\n          if u_city == target_city:\n             filtered_users.append(f\"User {user.get('id')}: {user.get('content')} (City: {u_city})\")\n\n        if not filtered_users:\n          result = f\"No users found in {city}.\"\n        else:\n          result = \"\\n\".join(filtered_users)\n\n        return [TextContent(type=\"text\", text=result)]\n\n      elif name == \"filter_users_by_age\":\n        min_age = arguments.get(\"min_age\", 0)\n        filtered_users = []\n\n        for user in users:\n          # Assuming user dict has 'age' (or 'value') key\n          u_age = user.get(\"age\", user.get(\"value\", 0))\n\n          try:\n            u_age = int(u_age)\n          except ValueError:\n            continue\n\n          if u_age &gt; min_age:\n             filtered_users.append(f\"User {user.get('id')}: {user.get('content')} (Age: {u_age})\")\n\n        if not filtered_users:\n          result = f\"No users found older than {min_age}.\"\n        else:\n          result = \"\\n\".join(filtered_users)\n\n        return [TextContent(type=\"text\", text=result)]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n      \"\"\"\n      Return the list of available resources.\n      This is called when clients want to discover what resources are available.\n      \"\"\"\n      return [\n        Resource(\n          uri=\"resource://server-info\",\n          name=\"Server Information\",\n          description=\"Information about this MCP server\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://data-store\",\n          name=\"Data Store\",\n          description=\"Current contents of the data store\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://welcome\",\n          name=\"Welcome Message\",\n          description=\"Welcome message and server capabilities\",\n          mimeType=\"text/plain\"\n        )\n      ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n\n  def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n    async def read_resource(uri: Any) -&gt; str:\n      \"\"\"\n      Handle resource read requests.\n      This is called when a client wants to read a resource.\n      \"\"\"\n      # Extract the URI string from the AnyUrl object\n      uri_str = str(uri)\n\n      if uri_str == \"resource://server-info\":\n        info = {\n          \"name\": \"complete-mcp-server\",\n          \"version\": \"1.0.0\",\n          \"description\": \"A comprehensive MCP server implementation\",\n          \"capabilities\": {\n            \"tools\": 6,\n            \"resources\": 3,\n            \"prompts\": 2\n          }\n        }\n        return json.dumps(info, indent=2)\n\n      elif uri_str == \"resource://data-store\":\n        return json.dumps(self.data_store, indent=2)\n\n      elif uri_str == \"resource://welcome\":\n        return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n- RAG: Retrieval Augmented Generation for user filtering\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n      else:\n        raise ValueError(f\"Unknown resource: {uri_str}\")\n\n    print(\"Resource handlers implemented\")\n\n  def register_prompts(self):\n    \"\"\"Register prompt templates for clients.\"\"\"\n\n    @self.server.list_prompts()\n    async def list_prompts() -&gt; list[Prompt]:\n      \"\"\"\n      Return the list of available prompts.\n      This is called when clients want to discover what prompts are available.\n      \"\"\"\n      return [\n        Prompt(\n          name=\"analyze-data\",\n          description=\"Analyze data stored in the server\",\n          arguments=[\n            {\n              \"name\": \"key\",\n              \"description\": \"The key of the data to analyze\",\n              \"required\": True\n            }\n          ]\n        ),\n        Prompt(\n          name=\"calculate-scenario\",\n          description=\"Walk through a calculation scenario\",\n          arguments=[\n            {\n              \"name\": \"operation\",\n              \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n              \"required\": True\n            }\n          ]\n        )\n      ]\n\n    print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n  def register_prompt_handlers(self):\n    \"\"\"Implement prompt generation logic.\"\"\"\n\n    @self.server.get_prompt()\n    async def get_prompt(name: str, arguments: dict) -&gt; GetPromptResult:\n      \"\"\"\n      Handle prompt generation requests.\n      This is called when a client wants to get a prompt.\n      \"\"\"\n      if name == \"analyze-data\":\n        key = arguments.get(\"key\", \"unknown\")\n        value = self.data_store.get(key, \"not found\")\n\n        prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n        return GetPromptResult(\n          messages=[\n            PromptMessage(\n              role=\"user\",\n              content=TextContent(type=\"text\", text=prompt_text)\n            )\n          ]\n        )\n\n      elif name == \"calculate-scenario\":\n        operation = arguments.get(\"operation\", \"add\")\n\n        prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n        return GetPromptResult(\n          messages=[\n            PromptMessage(\n              role=\"user\",\n              content=TextContent(type=\"text\", text=prompt_text)\n            )\n          ]\n        )\n\n      else:\n        return GetPromptResult(\n          messages=[\n            PromptMessage(\n              role=\"user\",\n              content=TextContent(\n                type=\"text\",\n                text=f\"Error: Unknown prompt '{name}'\"\n              )\n            )\n          ]\n        )\n\n    print(\"Prompt handlers implemented\")\n\n  def setup_lifecycle_handlers(self):\n    \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n    print(\"Lifecycle management configured\")\n\n  async def run(self):\n    \"\"\"Run the MCP server.\"\"\"\n    # Initialize everything\n    self.register_tools()\n    self.register_tool_handlers()\n    self.register_resources()\n    self.register_resource_handlers()\n    self.register_prompts()\n    self.register_prompt_handlers()\n    self.setup_lifecycle_handlers()\n\n    # Connect to stdio\n    async with stdio_server() as (read_stream, write_stream):\n      print(\"Server running on stdio...\")\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\nasync def main():\n  \"\"\"Main entry point.\"\"\"\n  server = CompleteMCPServer()\n  await server.run()\n\nif __name__ == \"__main__\":\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"Server stopped by user\")\n  except Exception as e:\n    print(f\"Error: {e}\")\n    sys.exit(1)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/step13-main/","title":"Step13 main","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP (Model Context Protocol) Server Implementation\nBuilt step by step for learning purposes.\nStep 13: Main Entry Point - Complete Orchestration\n\"\"\"\n\nimport asyncio\nimport csv\nimport json\nfrom typing import Any, Optional\n\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n  Tool,\n  Resource,\n  Prompt,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n  GetPromptResult,\n  PromptMessage,\n)\nimport sys\n\n# Initialize an in-memory users\nusers = []\n\ndef load_users(csv_file_path: str):\n  \"\"\"Load users from a CSV file.\"\"\"\n  global users\n  users = []\n\n  try:\n    with open(csv_file_path, 'r', encoding='utf-8') as f:\n      reader = csv.DictReader(f)\n      for i, row in enumerate(reader):\n        # Assuming CSV has 'content' and 'id' columns or similar\n        # Adjust column names as needed\n        content = row.get('content') or row.get('text') or list(row.values())[0]\n        doc_id = row.get('id') or f\"doc_{i}\"\n\n        if content:\n          users.append({\"id\": doc_id, \"content\": content})\n\n    print(f\"Loaded {len(users)} documents into users.\")\n  except Exception as e:\n    print(f\"Error loading users: {e}\")\n\n# Load the users\n# Make sure you have a 'users.csv' file in the same directory\n# Format: id,content\nload_users(\"users.csv\")\n\nclass CompleteMCPServer:\n  \"\"\"\n  A comprehensive MCP Server implementation showcasing all protocol features.\n\n  This class demonstrates:\n  - Server initialization\n  - Tool registration and execution\n  - Resource management\n  - Prompt templates\n  - Request handling\n  - RAG capabilities\n  \"\"\"\n\n  def __init__(self):\n    \"\"\"Initialize the MCP Server instance.\"\"\"\n    self.server = Server(\"complete-mcp-server\")\n    self.data_store = {}  # Simple in-memory data storage\n    print(\"Server instance created successfully!\")\n\n  def register_tools(self):\n    \"\"\"Register all available tools with the MCP server.\"\"\"\n\n    @self.server.list_tools()\n    async def list_tools() -&gt; list[Tool]:\n      \"\"\"\n      Return the list of available tools.\n      This is called when clients want to discover what tools are available.\n      \"\"\"\n      return [\n        Tool(\n          name=\"calculate\",\n          description=\"Perform mathematical operations (add, subtract, multiply, divide)\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                \"description\": \"The operation to perform\"\n              },\n              \"a\": {\n                \"type\": \"number\",\n                \"description\": \"First number\"\n              },\n              \"b\": {\n                \"type\": \"number\",\n                \"description\": \"Second number\"\n              }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n          }\n        ),\n        Tool(\n          name=\"store_data\",\n          description=\"Store a key-value pair in the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to store\"\n              },\n              \"value\": {\n                \"type\": \"string\",\n                \"description\": \"The value to store\"\n              }\n            },\n            \"required\": [\"key\", \"value\"]\n          }\n        ),\n        Tool(\n          name=\"retrieve_data\",\n          description=\"Retrieve a value from the server's data store\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key to retrieve\"\n              }\n            },\n            \"required\": [\"key\"]\n          }\n        ),\n        Tool(\n          name=\"echo\",\n          description=\"Echo back the input text\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"text\": {\n                \"type\": \"string\",\n                \"description\": \"Text to echo back\"\n              }\n            },\n            \"required\": [\"text\"]\n          }\n        ),\n        Tool(\n          name=\"filter_users_by_city\",\n          description=\"Filter and return users who live in a specific city\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"city\": {\n                \"type\": \"string\",\n                \"description\": \"The city to filter users by\"\n              }\n            },\n            \"required\": [\"city\"]\n          }\n        ),\n        Tool(\n          name=\"filter_users_by_age\",\n          description=\"Filter and return users who are older than the specified minimum age\",\n          inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n              \"min_age\": {\n                \"type\": \"number\",\n                \"description\": \"The minimum age to filter users by\"\n              }\n            },\n            \"required\": [\"min_age\"]\n          }\n        )\n      ]\n\n    print(\"Tools registered: calculate, store_data, retrieve_data, echo, filter_users_by_city, filter_users_by_age\")\n\n  def register_tool_handlers(self):\n    \"\"\"Implement the actual logic for each tool.\"\"\"\n\n    @self.server.call_tool()\n    async def call_tool(name: str, arguments: Any) -&gt; list[TextContent]:\n      \"\"\"\n      Handle tool execution requests.\n      This is called when a client wants to execute a tool.\n      \"\"\"\n      if name == \"calculate\":\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n\n        if operation == \"add\":\n          result = a + b\n        elif operation == \"subtract\":\n          result = a - b\n        elif operation == \"multiply\":\n          result = a * b\n        elif operation == \"divide\":\n          if b == 0:\n            return [TextContent(\n              type=\"text\",\n              text=\"Error: Cannot divide by zero\"\n            )]\n          result = a / b\n        else:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Unknown operation '{operation}'\"\n          )]\n\n        return [TextContent(\n          type=\"text\",\n          text=f\"Result: {a} {operation} {b} = {result}\"\n        )]\n\n      elif name == \"store_data\":\n        key = arguments.get(\"key\")\n        value = arguments.get(\"value\")\n        self.data_store[key] = value\n        return [TextContent(\n          type=\"text\",\n          text=f\"Stored: {key} = {value}\"\n        )]\n\n      elif name == \"retrieve_data\":\n        key = arguments.get(\"key\")\n        value = self.data_store.get(key)\n        if value is None:\n          return [TextContent(\n            type=\"text\",\n            text=f\"Error: Key '{key}' not found\"\n          )]\n        return [TextContent(\n          type=\"text\",\n          text=f\"Retrieved: {key} = {value}\"\n        )]\n\n      elif name == \"echo\":\n        text = arguments.get(\"text\")\n        return [TextContent(\n          type=\"text\",\n          text=f\"Echo: {text}\"\n        )]\n\n      elif name == \"filter_users_by_city\":\n        city = arguments.get(\"city\", \"\")\n        filtered_users = []\n        target_city = city.lower().strip()\n\n        for user in users:\n          # Assuming user dict has 'city' key (loaded from CSV)\n          u_city = user.get(\"city\", \"\").lower()\n\n          if u_city == target_city:\n             filtered_users.append(f\"User {user.get('id')}: {user.get('content')} (City: {u_city})\")\n\n        if not filtered_users:\n          result = f\"No users found in {city}.\"\n        else:\n          result = \"\\n\".join(filtered_users)\n\n        return [TextContent(type=\"text\", text=result)]\n\n      elif name == \"filter_users_by_age\":\n        min_age = arguments.get(\"min_age\", 0)\n        filtered_users = []\n\n        for user in users:\n          # Assuming user dict has 'age' (or 'value') key\n          u_age = user.get(\"age\", user.get(\"value\", 0))\n\n          try:\n            u_age = int(u_age)\n          except ValueError:\n            continue\n\n          if u_age &gt; min_age:\n             filtered_users.append(f\"User {user.get('id')}: {user.get('content')} (Age: {u_age})\")\n\n        if not filtered_users:\n          result = f\"No users found older than {min_age}.\"\n        else:\n          result = \"\\n\".join(filtered_users)\n\n        return [TextContent(type=\"text\", text=result)]\n\n      else:\n        return [TextContent(\n          type=\"text\",\n          text=f\"Error: Unknown tool '{name}'\"\n        )]\n\n    print(\"Tool handlers implemented\")\n\n  def register_resources(self):\n    \"\"\"Register resources that clients can access.\"\"\"\n\n    @self.server.list_resources()\n    async def list_resources() -&gt; list[Resource]:\n      \"\"\"\n      Return the list of available resources.\n      This is called when clients want to discover what resources are available.\n      \"\"\"\n      return [\n        Resource(\n          uri=\"resource://server-info\",\n          name=\"Server Information\",\n          description=\"Information about this MCP server\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://data-store\",\n          name=\"Data Store\",\n          description=\"Current contents of the data store\",\n          mimeType=\"application/json\"\n        ),\n        Resource(\n          uri=\"resource://welcome\",\n          name=\"Welcome Message\",\n          description=\"Welcome message and server capabilities\",\n          mimeType=\"text/plain\"\n        )\n      ]\n\n    print(\"Resources registered: server-info, data-store, welcome\")\n\n  def register_resource_handlers(self):\n    \"\"\"Implement resource retrieval logic.\"\"\"\n\n    @self.server.read_resource()\n    async def read_resource(uri: Any) -&gt; str:\n      \"\"\"\n      Handle resource read requests.\n      This is called when a client wants to read a resource.\n      \"\"\"\n      # Extract the URI string from the AnyUrl object\n      uri_str = str(uri)\n\n      uri = str(uri)  # Ensure uri is a string\n      if uri_str == \"resource://server-info\":\n        info = {\n          \"name\": \"complete-mcp-server\",\n          \"version\": \"1.0.0\",\n          \"description\": \"A comprehensive MCP server implementation\",\n          \"capabilities\": {\n            \"tools\": 6,\n            \"resources\": 3,\n            \"prompts\": 2\n          }\n        }\n        return json.dumps(info, indent=2)\n\n      elif uri_str == \"resource://data-store\":\n        return json.dumps(self.data_store, indent=2)\n\n      elif uri_str == \"resource://welcome\":\n        return \"\"\"Welcome to the Complete MCP Server!\n\nThis server demonstrates all MCP protocol capabilities:\n- Tools: Execute operations and computations\n- Resources: Access data and information\n- Prompts: Get structured prompt templates\n- RAG: Retrieval Augmented Generation for user filtering\n\nExplore the available tools and resources to see what this server can do.\"\"\"\n\n      else:\n        raise ValueError(f\"Unknown resource: {uri_str}\")\n\n    print(\"Resource handlers implemented\")\n\n  def register_prompts(self):\n    \"\"\"Register prompt templates for clients.\"\"\"\n\n    @self.server.list_prompts()\n    async def list_prompts() -&gt; list[Prompt]:\n      \"\"\"\n      Return the list of available prompts.\n      This is called when clients want to discover what prompts are available.\n      \"\"\"\n      return [\n        Prompt(\n          name=\"analyze-data\",\n          description=\"Analyze data stored in the server\",\n          arguments=[\n            {\n              \"name\": \"key\",\n              \"description\": \"The key of the data to analyze\",\n              \"required\": True\n            }\n          ]\n        ),\n        Prompt(\n          name=\"calculate-scenario\",\n          description=\"Walk through a calculation scenario\",\n          arguments=[\n            {\n              \"name\": \"operation\",\n              \"description\": \"The operation to demonstrate (add, subtract, multiply, divide)\",\n              \"required\": True\n            }\n          ]\n        )\n      ]\n\n    print(\"Prompts registered: analyze-data, calculate-scenario\")\n\n  def register_prompt_handlers(self):\n    \"\"\"Implement prompt generation logic.\"\"\"\n\n    @self.server.get_prompt()\n    async def get_prompt(name: str, arguments: dict) -&gt; GetPromptResult:\n      \"\"\"\n      Handle prompt generation requests.\n      This is called when a client wants to get a prompt.\n      \"\"\"\n      if name == \"analyze-data\":\n        key = arguments.get(\"key\", \"unknown\")\n        value = self.data_store.get(key, \"not found\")\n\n        prompt_text = f\"\"\"Analyze the following data from the server:\n\nKey: {key}\nValue: {value}\n\nPlease provide:\n1. A description of what this data represents\n2. Any patterns or insights you notice\n3. Suggestions for how this data could be used\n\nUse the retrieve_data tool if you need to fetch additional context.\"\"\"\n\n        return GetPromptResult(\n          messages=[\n            PromptMessage(\n              role=\"user\",\n              content=TextContent(type=\"text\", text=prompt_text)\n            )\n          ]\n        )\n\n      elif name == \"calculate-scenario\":\n        operation = arguments.get(\"operation\", \"add\")\n\n        prompt_text = f\"\"\"Let's work through a {operation} calculation scenario.\n\nUse the calculate tool with the operation '{operation}'.\nFor example:\n- Choose two numbers (a and b)\n- Execute: calculate(operation=\"{operation}\", a=10, b=5)\n- Explain the result\n\nThis demonstrates how to use computational tools in the MCP server.\"\"\"\n\n        return GetPromptResult(\n          messages=[\n            PromptMessage(\n              role=\"user\",\n              content=TextContent(type=\"text\", text=prompt_text)\n            )\n          ]\n        )\n\n      else:\n        return GetPromptResult(\n          messages=[\n            PromptMessage(\n              role=\"user\",\n              content=TextContent(\n                type=\"text\",\n                text=f\"Error: Unknown prompt '{name}'\"\n              )\n            )\n          ]\n        )\n\n    print(\"Prompt handlers implemented\")\n\n  def setup_lifecycle_handlers(self):\n    \"\"\"Setup lifecycle management (conceptual for MCP).\"\"\"\n    print(\"Lifecycle management configured\")\n\n  async def run(self):\n    \"\"\"Start the MCP server and begin serving requests.\"\"\"\n    print(\"Starting MCP server...\")\n    print(\"Server is now running and ready to accept connections\")\n\n    async with stdio_server() as (read_stream, write_stream):\n      await self.server.run(\n        read_stream,\n        write_stream,\n        self.server.create_initialization_options()\n      )\n\n\nasync def main():\n  \"\"\"\n  Main entry point for the MCP server.\n\n  This function orchestrates the complete server setup and execution:\n  1. Creates server instance (constructor)\n  2. Registers tools\n  3. Registers tool handlers\n  4. Registers resources\n  5. Registers resource handlers\n  6. Registers prompts\n  7. Registers prompt handlers\n  8. Sets up lifecycle handlers\n  9. Runs the server\n  \"\"\"\n  print(\"=\"*80)\n  print(\"\ud83c\udf1f COMPLETE MCP SERVER - STARTING\")\n  print(\"=\"*80)\n\n  # Step 1: Create server instance\n  server = CompleteMCPServer()\n\n  # Step 2: Register tools\n  server.register_tools()\n\n  # Step 3: Register tool handlers\n  server.register_tool_handlers()\n\n  # Step 4: Register resources\n  server.register_resources()\n\n  # Step 5: Register resource handlers\n  server.register_resource_handlers()\n\n  # Step 6: Register prompts\n  server.register_prompts()\n\n  # Step 7: Register prompt handlers\n  server.register_prompt_handlers()\n\n  # Step 8: Setup lifecycle handlers\n  server.setup_lifecycle_handlers()\n\n  print(\"=\"*80)\n  print(\"All components registered successfully!\")\n  print(\"=\"*80)\n\n  # Step 9: Run the server\n  await server.run()\n\n\nif __name__ == \"__main__\":\n  \"\"\"\n  Entry point when script is run directly.\n\n  This runs when you execute: python mcp_server.py\n  \"\"\"\n  try:\n    asyncio.run(main())\n  except KeyboardInterrupt:\n    print(\"\\n\ud83d\udc4b Server shutdown complete\")\n    sys.exit(0)\n</code></pre>"},{"location":"Resources/Lab06-MCP-Workflow/test_client/","title":"Test client","text":"<pre><code>#!/bin/bash\n\n# Determine the directory where this script is located\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" &amp;&amp; pwd)\"\nPROJECT_ROOT=\"$SCRIPT_DIR\" # Run from the same directory\n# Define the server script path\nSERVER_SCRIPT=\"${SCRIPT_DIR}/mcp_server.py\"\n\n# Navigate to the project root directory\ncd \"$PROJECT_ROOT\"\n\n# Check if the virtual environment exists\nif [ -d \".venv\" ]; then\n  echo \"Activating virtual environment...\"\n  source .venv/bin/activate\nelse\n  echo \"Creating virtual environment...\"\n  python3 -m venv .venv\n  source .venv/bin/activate\n  echo \"Installing requirements...\"\n  pip install -r requirements.txt\nfi\n\nif [ ! -f \"$SERVER_SCRIPT\" ]; then\n  echo \"Error: Server file $SERVER_SCRIPT not found\"\n  exit 1\nfi\n\necho \"Starting MCP Inspector with server...\"\necho \"URL should open in your browser shortly...\"\necho \"Press Ctrl+C to stop.\"\n\n# Use the python executable from the virtual environment\nPYTHON_EXEC=\"$PROJECT_ROOT/.venv/bin/python3\"\n\nnpx @modelcontextprotocol/inspector \"$PYTHON_EXEC\" \"$SERVER_SCRIPT\"\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step00-getting-started/","title":"Lab 07 - 00: Getting Started","text":""},{"location":"Resources/Lab07-MCP-Ollama/step00-getting-started/#step-00-prerequisites-data-files","title":"Step 00 - Prerequisites data files","text":"capitals.csvfoundation_year.csvheight.csvpopulation.csvrequirements.txt <pre><code>country,capital\nAfghanistan,Kabul\nAlbania,Tirana\nAlgeria,Algiers\nAndorra,Andorra la Vella\nAngola,Luanda\nAntigua and Barbuda,Saint John's\nArgentina,Buenos Aires\nArmenia,Yerevan\nAustralia,Canberra\nAustria,Vienna\nAzerbaijan,Baku\nBahamas,Nassau\nBahrain,Manama\nBangladesh,Dhaka\nBarbados,Bridgetown\nBelarus,Minsk\nBelgium,Brussels\nBelize,Belmopan\nBenin,Porto-Novo\nBhutan,Thimphu\nBolivia,Sucre\nBosnia and Herzegovina,Sarajevo\nBotswana,Gaborone\nBrazil,Bras\u00edlia\nBrunei,Bandar Seri Begawan\nBulgaria,Sofia\nBurkina Faso,Ouagadougou\nBurundi,Gitega\nCabo Verde,Praia\nCambodia,Phnom Penh\nCameroon,Yaound\u00e9\nCanada,Ottawa\nCentral African Republic,Bangui\nChad,N'Djamena\nChile,Santiago\nChina,Beijing\nColombia,Bogot\u00e1\nComoros,Moroni\nCongo,Brazzaville\nCosta Rica,San Jos\u00e9\nC\u00f4te d'Ivoire,Yamoussoukro\nCroatia,Zagreb\nCuba,Havana\nCyprus,Nicosia\nCzechia,Prague\nDenmark,Copenhagen\nDjibouti,Djibouti\nDominica,Roseau\nDominican Republic,Santo Domingo\nDRC,Kinshasa\nEcuador,Quito\nEgypt,Cairo\nEl Salvador,San Salvador\nEquatorial Guinea,Malabo\nEritrea,Asmara\nEstonia,Tallinn\nEswatini,Mbabane\nEthiopia,Addis Ababa\nFiji,Suva\nFinland,Helsinki\nFrance,Paris\nGabon,Libreville\nGambia,Banjul\nGeorgia,Tbilisi\nGermany,Berlin\nGhana,Accra\nGreece,Athens\nGrenada,Saint George's\nGuatemala,Guatemala City\nGuinea,Conakry\nGuinea-Bissau,Bissau\nGuyana,Georgetown\nHaiti,Port-au-Prince\nHonduras,Tegucigalpa\nHungary,Budapest\nIceland,Reykjav\u00edk\nIndia,New Delhi\nIndonesia,Jakarta\nIran,Tehran\nIraq,Baghdad\nIreland,Dublin\nIsrael,Jerusalem\nItaly,Rome\nJamaica,Kingston\nJapan,Tokyo\nJordan,Amman\nKazakhstan,Astana\nKenya,Nairobi\nKiribati,Tarawa\nKuwait,Kuwait City\nKyrgyzstan,Bishkek\nLaos,Vientiane\nLatvia,Riga\nLebanon,Beirut\nLesotho,Maseru\nLiberia,Monrovia\nLibya,Tripoli\nLiechtenstein,Vaduz\nLithuania,Vilnius\nLuxembourg,Luxembourg\nMadagascar,Antananarivo\nMalawi,Lilongwe\nMalaysia,Kuala Lumpur\nMaldives,Mal\u00e9\nMali,Bamako\nMalta,Valletta\nMarshall Islands,Majuro\nMauritania,Nouakchott\nMauritius,Port Louis\nMexico,Mexico City\nMicronesia,Palikir\nMoldova,Chisinau\nMonaco,Monaco\nMongolia,Ulaanbaatar\nMontenegro,Podgorica\nMorocco,Rabat\nMozambique,Maputo\nMyanmar,Naypyidaw\nNamibia,Windhoek\nNauru,Yaren\nNepal,Kathmandu\nNetherlands,Amsterdam\nNew Zealand,Wellington\nNicaragua,Managua\nNiger,Niamey\nNigeria,Abuja\nNorth Korea,Pyongyang\nNorth Macedonia,Skopje\nNorway,Oslo\nOman,Muscat\nPakistan,Islamabad\nPalau,Ngerulmud\nPanama,Panama City\nPapua New Guinea,Port Moresby\nParaguay,Asunci\u00f3n\nPeru,Lima\nPhilippines,Manila\nPoland,Warsaw\nPortugal,Lisbon\nQatar,Doha\nRomania,Bucharest\nRussia,Moscow\nRwanda,Kigali\nSaint Kitts and Nevis,Basseterre\nSaint Lucia,Castries\nSaint Vincent and the Grenadines,Kingstown\nSamoa,Apia\nSan Marino,San Marino\nS\u00e3o Tom\u00e9 and Pr\u00edncipe,S\u00e3o Tom\u00e9\nSaudi Arabia,Riyadh\nSenegal,Dakar\nSerbia,Belgrade\nSeychelles,Victoria\nSierra Leone,Freetown\nSingapore,Singapore\nSlovakia,Bratislava\nSlovenia,Ljubljana\nSolomon Islands,Honiara\nSomalia,Mogadishu\nSouth Africa,Pretoria\nSouth Korea,Seoul\nSouth Sudan,Juba\nSpain,Madrid\nSri Lanka,Sri Jayawardenepura Kotte\nSudan,Khartoum\nSuriname,Paramaribo\nSweden,Stockholm\nSwitzerland,Bern\nSyria,Damascus\nTaiwan,Taipei\nTajikistan,Dushanbe\nTanzania,Dodoma\nThailand,Bangkok\nTimor-Leste,Dili\nTogo,Lom\u00e9\nTonga,Nuku'alofa\nTrinidad and Tobago,Port of Spain\nTunisia,Tunis\nTurkey,Ankara\nTurkmenistan,Ashgabat\nTuvalu,Funafuti\nUganda,Kampala\nUkraine,Kyiv\nUnited Arab Emirates,Abu Dhabi\nUnited Kingdom,London\nUnited States,Washington D.C.\nUruguay,Montevideo\nUzbekistan,Tashkent\nVanuatu,Port Vila\nVenezuela,Caracas\nVietnam,Hanoi\nYemen,Sana'a\nZambia,Lusaka\nZimbabwe,Harare\n</code></pre> <pre><code>country,foundation_year\nAfghanistan,1919\nAlbania,1912\nAlgeria,1962\nAndorra,1278\nAngola,1975\nAntigua and Barbuda,1981\nArgentina,1816\nArmenia,1991\nAustralia,1901\nAustria,1955\nAzerbaijan,1991\nBahamas,1973\nBahrain,1971\nBangladesh,1971\nBarbados,1966\nBelarus,1991\nBelgium,1830\nBelize,1981\nBenin,1960\nBhutan,1907\nBolivia,1825\nBosnia and Herzegovina,1992\nBotswana,1966\nBrazil,1822\nBrunei,1984\nBulgaria,1908\nBurkina Faso,1960\nBurundi,1962\nCabo Verde,1975\nCambodia,1953\nCameroon,1960\nCanada,1867\nCentral African Republic,1960\nChad,1960\nChile,1818\nChina,1949\nColombia,1810\nComoros,1975\nCongo,1960\nCosta Rica,1821\nC\u00f4te d'Ivoire,1960\nCroatia,1991\nCuba,1902\nCyprus,1960\nCzechia,1993\nDenmark,1849\nDjibouti,1977\nDominica,1978\nDominican Republic,1844\nDRC,1960\nEcuador,1830\nEgypt,1922\nEl Salvador,1821\nEquatorial Guinea,1968\nEritrea,1993\nEstonia,1991\nEswatini,1968\nEthiopia,-100\nFiji,1970\nFinland,1917\nFrance,843\nGabon,1960\nGambia,1965\nGeorgia,1991\nGermany,1871\nGhana,1957\nGreece,1821\nGrenada,1974\nGuatemala,1821\nGuinea,1958\nGuinea-Bissau,1973\nGuyana,1966\nHaiti,1804\nHonduras,1821\nHungary,1000\nIceland,1944\nIndia,1947\nIndonesia,1945\nIran,1501\nIraq,1932\nIreland,1921\nIsrael,1948\nItaly,1861\nJamaica,1962\nJapan,660\nJordan,1946\nKazakhstan,1991\nKenya,1963\nKiribati,1979\nKuwait,1961\nKyrgyzstan,1991\nLaos,1953\nLatvia,1991\nLebanon,1943\nLesotho,1966\nLiberia,1847\nLibya,1951\nLiechtenstein,1719\nLithuania,1990\nLuxembourg,1890\nMadagascar,1960\nMalawi,1964\nMalaysia,1957\nMaldives,1965\nMali,1960\nMalta,1964\nMarshall Islands,1986\nMauritania,1960\nMauritius,1968\nMexico,1821\nMicronesia,1986\nMoldova,1991\nMonaco,1297\nMongolia,1921\nMontenegro,2006\nMorocco,1956\nMozambique,1975\nMyanmar,1948\nNamibia,1990\nNauru,1968\nNepal,1768\nNetherlands,1581\nNew Zealand,1907\nNicaragua,1821\nNiger,1960\nNigeria,1960\nNorth Korea,1948\nNorth Macedonia,1991\nNorway,1905\nOman,1650\nPakistan,1947\nPalau,1994\nPanama,1903\nPapua New Guinea,1975\nParaguay,1811\nPeru,1821\nPhilippines,1898\nPoland,1918\nPortugal,1143\nQatar,1971\nRomania,1859\nRussia,1991\nRwanda,1962\nSaint Kitts and Nevis,1983\nSaint Lucia,1979\nSaint Vincent and the Grenadines,1979\nSamoa,1962\nSan Marino,301\nS\u00e3o Tom\u00e9 and Pr\u00edncipe,1975\nSaudi Arabia,1932\nSenegal,1960\nSerbia,2006\nSeychelles,1976\nSierra Leone,1961\nSingapore,1965\nSlovakia,1993\nSlovenia,1991\nSolomon Islands,1978\nSomalia,1960\nSouth Africa,1910\nSouth Korea,1948\nSouth Sudan,2011\nSpain,1469\nSri Lanka,1948\nSudan,1956\nSuriname,1975\nSweden,1523\nSwitzerland,1291\nSyria,1946\nTaiwan,1949\nTajikistan,1991\nTanzania,1961\nThailand,1238\nTimor-Leste,2002\nTogo,1960\nTonga,1839\nTrinidad and Tobago,1962\nTunisia,1956\nTurkey,1923\nTurkmenistan,1991\nTuvalu,1978\nUganda,1962\nUkraine,1991\nUnited Arab Emirates,1971\nUnited Kingdom,1066\nUnited States,1776\nUruguay,1825\nUzbekistan,1991\nVanuatu,1980\nVenezuela,1811\nVietnam,1945\nYemen,1990\nZambia,1964\nZimbabwe,1980\n</code></pre> <pre><code>country,height\nAfghanistan,1884\nAlbania,708\nAlgeria,800\nAndorra,1996\nAngola,1112\nAntigua and Barbuda,65\nArgentina,595\nArmenia,1792\nAustralia,330\nAustria,910\nAzerbaijan,384\nBahamas,13\nBahrain,35\nBangladesh,85\nBarbados,180\nBelarus,160\nBelgium,181\nBelize,173\nBenin,273\nBhutan,3280\nBolivia,1192\nBosnia and Herzegovina,500\nBotswana,1013\nBrazil,320\nBrunei,478\nBulgaria,472\nBurkina Faso,297\nBurundi,1504\nCabo Verde,450\nCambodia,126\nCameroon,667\nCanada,487\nCentral African Republic,635\nChad,543\nChile,1871\nChina,1840\nColombia,593\nComoros,719\nCongo,430\nCosta Rica,746\nC\u00f4te d'Ivoire,250\nCroatia,331\nCuba,108\nCyprus,91\nCzechia,433\nDenmark,34\nDjibouti,430\nDominica,572\nDominican Republic,424\nDRC,726\nEcuador,1117\nEgypt,321\nEl Salvador,442\nEquatorial Guinea,577\nEritrea,853\nEstonia,61\nEswatini,305\nEthiopia,1330\nFiji,132\nFinland,164\nFrance,375\nGabon,377\nGambia,34\nGeorgia,1431\nGermany,263\nGhana,190\nGreece,498\nGrenada,260\nGuatemala,759\nGuinea,472\nGuinea-Bissau,70\nGuyana,207\nHaiti,470\nHonduras,684\nHungary,143\nIceland,557\nIndia,160\nIndonesia,367\nIran,1308\nIraq,312\nIreland,118\nIsrael,508\nItaly,538\nJamaica,253\nJapan,438\nJordan,812\nKazakhstan,387\nKenya,762\nKiribati,2\nKuwait,108\nKyrgyzstan,2988\nLaos,710\nLatvia,87\nLebanon,1250\nLesotho,2161\nLiberia,243\nLibya,423\nLiechtenstein,1706\nLithuania,110\nLuxembourg,325\nMadagascar,615\nMalawi,779\nMalaysia,538\nMaldives,2\nMali,343\nMalta,91\nMarshall Islands,2\nMauritania,276\nMauritius,370\nMexico,1111\nMicronesia,107\nMoldova,147\nMonaco,63\nMongolia,1528\nMontenegro,1086\nMorocco,909\nMozambique,345\nMyanmar,702\nNamibia,1141\nNauru,21\nNepal,3265\nNetherlands,30\nNew Zealand,388\nNicaragua,298\nNiger,474\nNigeria,380\nNorth Korea,440\nNorth Macedonia,741\nNorway,460\nOman,310\nPakistan,900\nPalau,63\nPanama,360\nPapua New Guinea,667\nParaguay,178\nPeru,1555\nPhilippines,442\nPoland,173\nPortugal,372\nQatar,28\nRomania,414\nRussia,600\nRwanda,1598\nSaint Kitts and Nevis,261\nSaint Lucia,301\nSaint Vincent and the Grenadines,390\nSamoa,109\nSan Marino,749\nS\u00e3o Tom\u00e9 and Pr\u00edncipe,204\nSaudi Arabia,665\nSenegal,69\nSerbia,442\nSeychelles,284\nSierra Leone,279\nSingapore,15\nSlovakia,458\nSlovenia,492\nSolomon Islands,458\nSomalia,410\nSouth Africa,1033\nSouth Korea,282\nSouth Sudan,422\nSpain,660\nSri Lanka,228\nSudan,568\nSuriname,246\nSweden,320\nSwitzerland,1350\nSyria,514\nTaiwan,1121\nTajikistan,3186\nTanzania,1018\nThailand,287\nTimor-Leste,552\nTogo,236\nTonga,72\nTrinidad and Tobago,83\nTunisia,246\nTurkey,1132\nTurkmenistan,230\nTuvalu,2\nUganda,1100\nUkraine,175\nUnited Arab Emirates,149\nUnited Kingdom,162\nUnited States,760\nUruguay,109\nUzbekistan,450\nVanuatu,646\nVenezuela,450\nVietnam,398\nYemen,999\nZambia,1138\nZimbabwe,961\n</code></pre> population.csv <pre><code>country,population\nAfghanistan,40000000\nAlbania,2800000\nAlgeria,45000000\nAndorra,80000\nAngola,35000000\nAntigua and Barbuda,100000\nArgentina,46000000\nArmenia,3000000\nAustralia,26000000\nAustria,9000000\nAzerbaijan,10000000\nBahamas,400000\nBahrain,1800000\nBangladesh,170000000\nBarbados,300000\nBelarus,9200000\nBelgium,11600000\nBelize,400000\nBenin,13000000\nBhutan,800000\nBolivia,12000000\nBosnia and Herzegovina,3200000\nBotswana,2400000\nBrazil,216000000\nBrunei,450000\nBulgaria,6400000\nBurkina Faso,23000000\nBurundi,13000000\nCabo Verde,600000\nCambodia,17000000\nCameroon,28000000\nCanada,39000000\nCentral African Republic,5000000\nChad,18000000\nChile,20000000\nChina,1412000000\nColombia,52000000\nComoros,900000\nCongo,6000000\nCosta Rica,5200000\nC\u00f4te d'Ivoire,29000000\nCroatia,3800000\nCuba,11100000\nCyprus,1300000\nCzechia,10700000\nDenmark,5900000\nDjibouti,1100000\nDominica,72000\nDominican Republic,11000000\nDRC,100000000\nEcuador,18000000\nEgypt,110000000\nEl Salvador,6500000\nEquatorial Guinea,1700000\nEritrea,3700000\nEstonia,1300000\nEswatini,1200000\nEthiopia,125000000\nFiji,900000\nFinland,5600000\nFrance,68000000\nGabon,2400000\nGambia,2700000\nGeorgia,3700000\nGermany,83000000\nGhana,34000000\nGreece,10200000\nGrenada,120000\nGuatemala,19000000\nGuinea,14000000\nGuinea-Bissau,2100000\nGuyana,800000\nHaiti,11700000\nHonduras,11000000\nHungary,9600000\nIceland,380000\nIndia,1418000000\nIndonesia,280000000\nIran,89000000\nIraq,44000000\nIreland,5200000\nIsrael,9700000\nItaly,59000000\nJamaica,3000000\nJapan,124000000\nJordan,11000000\nKazakhstan,20000000\nKenya,57000000\nKiribati,130000\nKuwait,4300000\nKyrgyzstan,6800000\nLaos,7500000\nLatvia,1800000\nLebanon,5500000\nLesotho,2300000\nLiberia,5300000\nLibya,7200000\nLiechtenstein,39000\nLithuania,2700000\nLuxembourg,660000\nMadagascar,30000000\nMalawi,21000000\nMalaysia,34000000\nMaldives,600000\nMali,23000000\nMalta,570000\nMarshall Islands,42000\nMauritania,4900000\nMauritius,1300000\nMexico,128000000\nMicronesia,110000\nMoldova,2500000\nMonaco,40000\nMongolia,3400000\nMontenegro,620000\nMorocco,38000000\nMozambique,33000000\nMyanmar,55000000\nNamibia,2600000\nNauru,11000\nNepal,31000000\nNetherlands,17800000\nNew Zealand,5200000\nNicaragua,6900000\nNiger,27000000\nNigeria,230000000\nNorth Korea,26000000\nNorth Macedonia,1800000\nNorway,5500000\nOman,5500000\nPakistan,240000000\nPalau,18000\nPanama,4500000\nPapua New Guinea,10000000\nParaguay,7200000\nPeru,34000000\nPhilippines,117000000\nPoland,38000000\nPortugal,10200000\nQatar,2900000\nRomania,19000000\nRussia,144000000\nRwanda,14000000\nSaint Kitts and Nevis,54000\nSaint Lucia,180000\nSaint Vincent and the Grenadines,110000\nSamoa,225000\nSan Marino,34000\nS\u00e3o Tom\u00e9 and Pr\u00edncipe,230000\nSaudi Arabia,37000000\nSenegal,18000000\nSerbia,6600000\nSeychelles,100000\nSierra Leone,8600000\nSingapore,6000000\nSlovakia,5500000\nSlovenia,2100000\nSolomon Islands,720000\nSomalia,18000000\nSouth Africa,62000000\nSouth Korea,52000000\nSouth Sudan,13000000\nSpain,48000000\nSri Lanka,22000000\nSudan,48000000\nSuriname,620000\nSweden,10500000\nSwitzerland,8800000\nSyria,23000000\nTaiwan,23600000\nTajikistan,10000000\nTanzania,65000000\nThailand,72000000\nTimor-Leste,1400000\nTogo,9000000\nTonga,110000\nTrinidad and Tobago,1400000\nTunisia,12400000\nTurkey,86000000\nTurkmenistan,6500000\nTuvalu,12000\nUganda,49000000\nUkraine,36000000\nUnited Arab Emirates,10000000\nUnited Kingdom,68000000\nUnited States,345000000\nUruguay,3500000\nUzbekistan,36000000\nVanuatu,320000\nVenezuela,28000000\nVietnam,99000000\nYemen,32000000\nZambia,20000000\nZimbabwe,16000000\n</code></pre> <pre><code>country,population\nAfghanistan,40000000\nAlbania,2800000\nAlgeria,45000000\nAndorra,80000\nAngola,35000000\nAntigua and Barbuda,100000\nArgentina,46000000\nArmenia,3000000\nAustralia,26000000\nAustria,9000000\nAzerbaijan,10000000\nBahamas,400000\nBahrain,1800000\nBangladesh,170000000\nBarbados,300000\nBelarus,9200000\nBelgium,11600000\nBelize,400000\nBenin,13000000\nBhutan,800000\nBolivia,12000000\nBosnia and Herzegovina,3200000\nBotswana,2400000\nBrazil,216000000\nBrunei,450000\nBulgaria,6400000\nBurkina Faso,23000000\nBurundi,13000000\nCabo Verde,600000\nCambodia,17000000\nCameroon,28000000\nCanada,39000000\nCentral African Republic,5000000\nChad,18000000\nChile,20000000\nChina,1412000000\nColombia,52000000\nComoros,900000\nCongo,6000000\nCosta Rica,5200000\nC\u00f4te d'Ivoire,29000000\nCroatia,3800000\nCuba,11100000\nCyprus,1300000\nCzechia,10700000\nDenmark,5900000\nDjibouti,1100000\nDominica,72000\nDominican Republic,11000000\nDRC,100000000\nEcuador,18000000\nEgypt,110000000\nEl Salvador,6500000\nEquatorial Guinea,1700000\nEritrea,3700000\nEstonia,1300000\nEswatini,1200000\nEthiopia,125000000\nFiji,900000\nFinland,5600000\nFrance,68000000\nGabon,2400000\nGambia,2700000\nGeorgia,3700000\nGermany,83000000\nGhana,34000000\nGreece,10200000\nGrenada,120000\nGuatemala,19000000\nGuinea,14000000\nGuinea-Bissau,2100000\nGuyana,800000\nHaiti,11700000\nHonduras,11000000\nHungary,9600000\nIceland,380000\nIndia,1418000000\nIndonesia,280000000\nIran,89000000\nIraq,44000000\nIreland,5200000\nIsrael,9700000\nItaly,59000000\nJamaica,3000000\nJapan,124000000\nJordan,11000000\nKazakhstan,20000000\nKenya,57000000\nKiribati,130000\nKuwait,4300000\nKyrgyzstan,6800000\nLaos,7500000\nLatvia,1800000\nLebanon,5500000\nLesotho,2300000\nLiberia,5300000\nLibya,7200000\nLiechtenstein,39000\nLithuania,2700000\nLuxembourg,660000\nMadagascar,30000000\nMalawi,21000000\nMalaysia,34000000\nMaldives,600000\nMali,23000000\nMalta,570000\nMarshall Islands,42000\nMauritania,4900000\nMauritius,1300000\nMexico,128000000\nMicronesia,110000\nMoldova,2500000\nMonaco,40000\nMongolia,3400000\nMontenegro,620000\nMorocco,38000000\nMozambique,33000000\nMyanmar,55000000\nNamibia,2600000\nNauru,11000\nNepal,31000000\nNetherlands,17800000\nNew Zealand,5200000\nNicaragua,6900000\nNiger,27000000\nNigeria,230000000\nNorth Korea,26000000\nNorth Macedonia,1800000\nNorway,5500000\nOman,5500000\nPakistan,240000000\nPalau,18000\nPanama,4500000\nPapua New Guinea,10000000\nParaguay,7200000\nPeru,34000000\nPhilippines,117000000\nPoland,38000000\nPortugal,10200000\nQatar,2900000\nRomania,19000000\nRussia,144000000\nRwanda,14000000\nSaint Kitts and Nevis,54000\nSaint Lucia,180000\nSaint Vincent and the Grenadines,110000\nSamoa,225000\nSan Marino,34000\nS\u00e3o Tom\u00e9 and Pr\u00edncipe,230000\nSaudi Arabia,37000000\nSenegal,18000000\nSerbia,6600000\nSeychelles,100000\nSierra Leone,8600000\nSingapore,6000000\nSlovakia,5500000\nSlovenia,2100000\nSolomon Islands,720000\nSomalia,18000000\nSouth Africa,62000000\nSouth Korea,52000000\nSouth Sudan,13000000\nSpain,48000000\nSri Lanka,22000000\nSudan,48000000\nSuriname,620000\nSweden,10500000\nSwitzerland,8800000\nSyria,23000000\nTaiwan,23600000\nTajikistan,10000000\nTanzania,65000000\nThailand,72000000\nTimor-Leste,1400000\nTogo,9000000\nTonga,110000\nTrinidad and Tobago,1400000\nTunisia,12400000\nTurkey,86000000\nTurkmenistan,6500000\nTuvalu,12000\nUganda,49000000\nUkraine,36000000\nUnited Arab Emirates,10000000\nUnited Kingdom,68000000\nUnited States,345000000\nUruguay,3500000\nUzbekistan,36000000\nVanuatu,320000\nVenezuela,28000000\nVietnam,99000000\nYemen,32000000\nZambia,20000000\nZimbabwe,16000000\n</code></pre> <pre><code>mcp&gt;=0.1.0\nollama&gt;=0.1.0\npandas&gt;=1.3.0\nrequests&gt;=2.25.0\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step01-imports/","title":"Lab 07 - 01: Imports","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete MCP Server with Ollama Integration\nStep 1: Imports\n\"\"\"\n\nimport asyncio\nimport json\nimport os\nimport sqlite3\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nimport ollama\nimport pandas as pd\nimport requests\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import (\n    Resource,\n    Tool,\n    TextContent,\n    ImageContent,\n    TextResourceContents,\n    Prompt,\n    GetPromptResult,\n    CallToolResult,\n    ListResourcesResult,\n    ListToolsResult,\n    ReadResourceResult,\n    ListPromptsResult,\n)\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step02-skeleton-code/","title":"Lab 07 - 02: Skeleton Code","text":"<pre><code>class CompleteOllamaMCPServer:\n    def __init__(self):\n        self.server = Server(\"complete-ollama-mcp-server\")\n        self._setup_handlers()\n\n    def _setup_handlers(self):\n        # Will be implemented in subsequent steps\n        pass\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step03-constructor/","title":"Lab 07 - 03: Constructor","text":"<pre><code>def __init__(self):\n    self.server = Server(\"complete-ollama-mcp-server\")\n    self.db_path = \"data.db\"\n    self.ollama_client = ollama.Client()\n    self.country_data = self._load_country_data()\n    self._setup_handlers()\n\ndef _load_country_data(self):\n    \"\"\"Load country information from CSV files for RAG retrieval.\"\"\"\n    data = {}\n    script_dir = Path(__file__).parent\n    info_types = ['capital', 'population', 'height', 'foundation_year']\n    for info_type in info_types:\n        try:\n            file_path = script_dir / f'{info_type}.csv'\n            df = pd.read_csv(file_path)\n            # Convert country names to lowercase for case-insensitive matching\n            data[info_type] = dict(zip(df['country'].str.lower(), df[info_type]))\n        except Exception as e:\n            print(f\"Error loading {info_type}.csv: {e}\", file=sys.stderr)\n            data[info_type] = {}\n    return data\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step04-list-tools/","title":"Lab 07 - 04: Register Tools","text":"<pre><code>@self.server.list_tools()\nasync def list_tools() -&gt; List[Tool]:\n  return [\n    Tool(\n      name=\"country_info\",\n      description=\"Get country information using RAG from CSV databases\",\n      inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n          \"country\": {\n            \"type\": \"string\",\n            \"description\": \"The country name to get information for\"\n          },\n          \"info_types\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"string\", \"enum\": [\"capital\", \"population\", \"height\", \"foundation_year\"]},\n            \"description\": \"Types of information to retrieve\"\n          }\n        },\n        \"required\": [\"country\"]\n      }\n    ),\n    Tool(\n      name=\"read_file\",\n      description=\"Read and analyze file contents with metadata\",\n      inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n          \"filepath\": {\n            \"type\": \"string\",\n            \"description\": \"Absolute path to the file to read\"\n          },\n          \"max_size\": {\n            \"type\": \"number\",\n            \"default\": 1048576,\n            \"description\": \"Maximum file size in bytes (default 1MB)\"\n          },\n          \"encoding\": {\n            \"type\": \"string\",\n            \"default\": \"utf-8\",\n            \"description\": \"File encoding\"\n          }\n        },\n        \"required\": [\"filepath\"]\n      }\n    ),\n    Tool(\n      name=\"query_database\",\n      description=\"Execute SELECT queries on SQLite database\",\n      inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n          \"query\": {\n            \"type\": \"string\",\n            \"description\": \"SELECT SQL query to execute\"\n          },\n          \"database\": {\n            \"type\": \"string\",\n            \"default\": \"data.db\",\n            \"description\": \"Database file path\"\n          }\n        },\n        \"required\": [\"query\"]\n      }\n    )\n  ]\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step05-call-tools/","title":"Step 05: Tool Handlers","text":"<p>Add this method to your class:</p> <pre><code>@self.server.call_tool()\nasync def call_tool(name: str, arguments: Dict[str, Any]) -&gt; List[TextContent]:\n    if name == \"country_info\":\n        country = arguments.get(\"country\", \"\").lower()\n        info_types = arguments.get(\"info_types\", [])\n\n        if not country:\n            raise ValueError(\"Country name is required\")\n\n        if not info_types:\n            info_types = [\"capital\", \"population\", \"height\", \"foundation_year\"]\n\n        retrieved_info = {}\n        for info_type in info_types:\n            # Safe access to nested dictionary\n            type_data = self.country_data.get(info_type, {})\n            if country in type_data:\n                retrieved_info[info_type] = type_data[country]\n            else:\n                retrieved_info[info_type] = f\"Information not available (Data loaded: {len(type_data)} records)\"\n\n        # Use Ollama to generate a formatted response\n        prompt = f\"Format the following information about {country.title()} into a nice, readable response: {json.dumps(retrieved_info, indent=2)}\"\n\n        try:\n            # Use llama3.2 as detected on your system\n            response = self.ollama_client.generate(\n                model='llama3.2',\n                prompt=prompt,\n                options={'temperature': 0.7, 'max_tokens': 300}\n            )\n\n            result = response['response'].strip()\n\n            return [TextContent(type=\"text\", text=result)]\n\n        except Exception as e:\n            # Fallback if Ollama fails\n            return [TextContent(type=\"text\", text=f\"Error getting AI response: {str(e)}\\n\\nRaw Data: {retrieved_info}\")]\n\n    elif name == \"read_file\":\n        filepath = arguments.get(\"filepath\", \"\")\n        max_size = arguments.get(\"max_size\", 1048576)\n        encoding = arguments.get(\"encoding\", \"utf-8\")\n\n        if not filepath:\n            raise ValueError(\"File path is required\")\n\n        path = Path(filepath)\n        if not path.exists():\n            raise ValueError(f\"File not found: {filepath}\")\n\n        if not path.is_file():\n            raise ValueError(f\"Path is not a file: {filepath}\")\n\n        file_size = path.stat().st_size\n        if file_size &gt; max_size:\n            raise ValueError(f\"File too large: {file_size} bytes (max: {max_size})\")\n\n        try:\n            with open(path, 'r', encoding=encoding) as f:\n                content = f.read()\n\n            metadata = f\"File: {path.name}\\nSize: {file_size} bytes\\nEncoding: {encoding}\\n\\n\"\n            result = metadata + \"Content:\\n\" + content\n\n            return [TextContent(type=\"text\", text=result)]\n\n        except Exception as e:\n            return [TextContent(type=\"text\", text=f\"Error reading file: {str(e)}\")]\n\n    elif name == \"query_database\":\n        query = arguments.get(\"query\", \"\").strip()\n        database = arguments.get(\"database\", self.db_path)\n\n        if not query:\n            raise ValueError(\"Query is required\")\n\n        if not query.upper().startswith(\"SELECT\"):\n            raise ValueError(\"Only SELECT queries are allowed\")\n\n        try:\n            conn = sqlite3.connect(database)\n            cursor = conn.cursor()\n\n            cursor.execute(query)\n            rows = cursor.fetchall()\n            columns = [desc[0] for desc in cursor.description]\n\n            conn.close()\n\n            if not rows:\n                result = \"No results found.\"\n            else:\n                # Format as table\n                result = \"| \" + \" | \".join(columns) + \" |\\n\"\n                result += \"|\" + \"|\".join([\"---\"] * len(columns)) + \"|\\n\"\n                for row in rows:\n                    result += \"| \" + \" | \".join(str(cell) for cell in row) + \" |\\n\"\n\n            return [TextContent(type=\"text\", text=result)]\n\n        except Exception as e:\n            return [TextContent(type=\"text\", text=f\"Database error: {str(e)}\")]\n\n    else:\n        raise ValueError(f\"Unknown tool: {name}\")\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step06-list-resources/","title":"Lab 07 - 06: Register Resources","text":"<pre><code>@self.server.list_resources()\nasync def list_resources() -&gt; List[Resource]:\n  return [\n    Resource(\n      uri=\"resource://server-info\",\n      name=\"Server Information\",\n      description=\"Basic information about this MCP server\",\n      mimeType=\"application/json\"\n    ),\n    Resource(\n      uri=\"resource://ollama-models\",\n      name=\"Available Ollama Models\",\n      description=\"List of available Ollama models\",\n      mimeType=\"application/json\"\n    )\n  ]\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step07-read-resources/","title":"Step 07: Resource Handlers","text":""},{"location":"Resources/Lab07-MCP-Ollama/step07-read-resources/#method-read_resource","title":"Method <code>read_resource</code>","text":"<p>Capabilities:</p> <ul> <li>Implements resource reading logic</li> <li>Handles resource requests and returns content</li> </ul> <p>Why This Runs Fifth:</p> <ul> <li>Connects resource URIs to actual content</li> <li>Makes resources accessible to clients</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.read_resource()\nasync def read_resource(self, uri: str) -&gt; str:\n  uri_str = str(uri).strip()\n\n  # Debug log to help diagnose the mismatch\n  print(f\"DEBUG: Requesting URI: '{uri_str}'\", file=sys.stderr)\n\n  # Allow exact match or match without scheme to be robust\n  if uri_str == \"resource://server-info\" or uri_str.endswith(\"server-info\"):\n    info = {\n      \"name\": \"Complete Ollama MCP Server\",\n      \"version\": \"1.0.0\",\n      \"capabilities\": [\"tools\", \"resources\", \"ollama-integration\"],\n      \"tools\": [\"country_info\", \"read_file\", \"query_database\"],\n      \"country_database\": \"193 UN member states with capitals, populations, topographic heights, and foundation years\"\n    }\n    return json.dumps(info, indent=2)\n\n  elif uri_str == \"resource://ollama-models\" or uri_str.endswith(\"ollama-models\"):\n    try:\n      models = self.ollama_client.list()\n      return json.dumps(models, indent=2)\n    except Exception as e:\n      return json.dumps({\"error\": str(e)}, indent=2)\n\n  else:\n    raise ValueError(f\"Unknown resource: {uri_str}\")\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step08-list-prompts/","title":"Step08 list prompts","text":"<pre><code>@self.server.list_prompts()\nasync def list_prompts() -&gt; List[Prompt]:\n  return [\n    Prompt(\n      name=\"analyze-country-data\",\n      description=\"Analyze country data and provide insights\",\n      arguments=[\n        {\n          \"name\": \"country\",\n          \"description\": \"Country to analyze\",\n          \"required\": True\n        }\n      ]\n    )\n  ]\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step09-get_prompt/","title":"Step 09: Prompt Handlers","text":""},{"location":"Resources/Lab07-MCP-Ollama/step09-get_prompt/#method-get_prompt","title":"Method <code>get_prompt</code>","text":"<p>Capabilities:</p> <ul> <li>Generates prompt content.</li> <li>Handles prompt requests and returns structured messages.</li> </ul> <p>Why This Runs Seventh:</p> <ul> <li>Connects prompt templates to actual content.</li> <li>Makes prompts usable by clients.</li> </ul> <p>Add this method to your class:</p> <pre><code>@self.server.get_prompt()\nasync def get_prompt(name: str, arguments: Dict[str, Any]) -&gt; GetPromptResult:\n    if name == \"analyze-country-data\":\n        country = arguments.get(\"country\", \"Unknown Country\")\n        prompt_text = f\"\"\"Analyze the data for {country} and provide insights:\n\n1. Use the country_info tool to get information about the country's capital, population, topographic height, and foundation year\n2. Analyze the retrieved information and provide interesting facts\n3. Consider historical context and geographical significance\n4. Provide recommendations or interesting trivia based on the data\n\nPlease provide a comprehensive country analysis.\"\"\"\n\n        return GetPromptResult(\n            description=f\"Country analysis prompt for {country}\",\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": {\n                        \"type\": \"text\",\n                        \"text\": prompt_text\n                    }\n                }\n            ]\n        )\n\n    else:\n        raise ValueError(f\"Unknown prompt: {name}\")\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step10-setup-handlers/","title":"Lab 07 - 10: Setup Handlers","text":"<pre><code>def _setup_handlers(self):\n    # Handlers are registered automatically via decorators\n    pass\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step11-run-server/","title":"Lab 07 - 11: Run Server","text":"<pre><code>async def run(self):\n    async with stdio_server() as (read_stream, write_stream):\n        await self.server.run(read_stream, write_stream, self.server.create_initialization_options())\n</code></pre>"},{"location":"Resources/Lab07-MCP-Ollama/step12-main-entry-point/","title":"Lab 07 - 12: Main Entry Point","text":"<pre><code>async def main():\n    server = CompleteOllamaMCPServer()\n    await server.run()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step01-prerequisites/","title":"Step01 prerequisites","text":"<pre><code># Step 01: Prerequisites and Environment Setup\n\n## Prerequisites Checklist\n\nBefore starting the K-Agent lab, ensure you have the following:\n\n### Required Tools\n\n1. **Node.js 18+** - JavaScript runtime\n   ```bash\n   node --version  # Should be v18 or higher\n   ```\n</code></pre> <ol> <li>npm - Package manager</li> </ol> <pre><code>npm --version\n</code></pre> <ol> <li>kubectl - Kubernetes CLI</li> </ol> <pre><code>kubectl version --client\n</code></pre> <ol> <li>A Running Kubernetes Cluster</li> <li>Docker Desktop with Kubernetes enabled</li> <li>Minikube</li> <li>Kind</li> <li>OrbStack</li> <li>Cloud-managed (EKS, GKE, AKS)</li> </ol>"},{"location":"Resources/Lab08-Kagent/step01-prerequisites/#verify-cluster-access","title":"Verify Cluster Access","text":"<pre><code># Check cluster connectivity\nkubectl cluster-info\n\n# List all namespaces\nkubectl get namespaces\n\n# List pods across all namespaces\nkubectl get pods --all-namespaces\n\n# Check your current context\nkubectl config current-context\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step01-prerequisites/#expected-output","title":"Expected Output","text":"<pre><code>Kubernetes control plane is running at https://127.0.0.1:6443\nCoreDNS is running at https://127.0.0.1:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step01-prerequisites/#troubleshooting","title":"Troubleshooting","text":"<p>No cluster found:</p> <pre><code># For Docker Desktop - Enable Kubernetes in Preferences\n# For Minikube\nminikube start\n\n# For Kind\nkind create cluster\n\n# For OrbStack - Enable Kubernetes in settings\n</code></pre> <p>kubectl not configured:</p> <pre><code># Check kubeconfig location\necho $KUBECONFIG\nls -la ~/.kube/config\n\n# Set the context\nkubectl config use-context &lt;your-context-name&gt;\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step02-project-setup/","title":"Step02 project setup","text":"<pre><code># Step 02: Project Setup\n\n## Create the K-Agent Project Directory\n\n```bash\n# Create project directory\nmkdir k-agent-logs\ncd k-agent-logs\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step02-project-setup/#initialize-packagejson","title":"Initialize package.json","text":"<p>Create a <code>package.json</code> file with the following content:</p> <pre><code>{\n  \"name\": \"k-agent-logs\",\n  \"version\": \"1.0.0\",\n  \"description\": \"K-Agent MCP server for Kubernetes log collection\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx src/index.ts\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\"kubernetes\", \"mcp\", \"logs\", \"monitoring\"],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"type\": \"commonjs\",\n  \"dependencies\": {\n    \"@kubernetes/client-node\": \"^1.4.0\",\n    \"@modelcontextprotocol/sdk\": \"^1.25.2\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^25.0.3\",\n    \"tsx\": \"^4.21.0\",\n    \"typescript\": \"^5.9.3\"\n  }\n}\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step02-project-setup/#install-dependencies","title":"Install Dependencies","text":"<pre><code>npm install\n</code></pre> <p>This installs:</p> <ul> <li>@kubernetes/client-node - Official Kubernetes client for Node.js</li> <li>@modelcontextprotocol/sdk - MCP SDK for building servers</li> <li>tsx - TypeScript execution for development</li> <li>typescript - TypeScript compiler</li> </ul>"},{"location":"Resources/Lab08-Kagent/step02-project-setup/#create-project-structure","title":"Create Project Structure","text":"<pre><code>mkdir -p src\ntouch src/index.ts\n</code></pre> <p>Your project should now look like:</p> <pre><code>k-agent-logs/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 package-lock.json\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step03-typescript-config/","title":"Step03 typescript config","text":"<pre><code># Step 03: TypeScript Configuration\n\n## Create tsconfig.json\n\nCreate a `tsconfig.json` file in the root of your project (not inside `src`):\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step03-typescript-config/#configuration-explanation","title":"Configuration Explanation","text":"Option Description <code>target: ES2022</code> Modern JavaScript output <code>module: commonjs</code> Node.js compatible module system <code>outDir: ./dist</code> Compiled output directory <code>rootDir: ./src</code> Source code directory <code>strict: true</code> Enable all strict type checks <code>esModuleInterop: true</code> Better CommonJS/ESM interop <code>declaration: true</code> Generate .d.ts files <code>sourceMap: true</code> Generate source maps for debugging"},{"location":"Resources/Lab08-Kagent/step03-typescript-config/#project-structure-after-this-step","title":"Project Structure After This Step","text":"<pre><code>k-agent-logs/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u2514\u2500\u2500 tsconfig.json\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step03-typescript-config/#verify-configuration","title":"Verify Configuration","text":"<pre><code># Test TypeScript compilation (should succeed with empty file)\nnpm run build\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step04-imports/","title":"Step04 imports","text":"<pre><code># Step 04: Imports and Dependencies\n\n## Understanding the Imports\n\nAdd the following imports to your `src/index.ts` file:\n\n```typescript\n// MCP SDK - Server Infrastructure\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\n// MCP SDK - Protocol Types and Schemas\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n// Kubernetes Client\nimport * as k8s from \"@kubernetes/client-node\";\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step04-imports/#import-breakdown","title":"Import Breakdown","text":""},{"location":"Resources/Lab08-Kagent/step04-imports/#mcp-server-components","title":"MCP Server Components","text":"Import Purpose <code>Server</code> Core MCP server class - handles all protocol communication <code>StdioServerTransport</code> Transport layer for stdin/stdout communication"},{"location":"Resources/Lab08-Kagent/step04-imports/#mcp-types-and-schemas","title":"MCP Types and Schemas","text":"Import Purpose <code>CallToolRequestSchema</code> Schema for tool execution requests <code>ErrorCode</code> Standard MCP error codes <code>ListResourcesRequestSchema</code> Schema for resource listing <code>ListToolsRequestSchema</code> Schema for tool listing <code>McpError</code> Custom MCP error class <code>ReadResourceRequestSchema</code> Schema for resource reading"},{"location":"Resources/Lab08-Kagent/step04-imports/#kubernetes-client","title":"Kubernetes Client","text":"Import Purpose <code>k8s</code> Full Kubernetes client library <code>k8s.KubeConfig</code> Configuration loader <code>k8s.CoreV1Api</code> Core API (pods, services, namespaces) <code>k8s.AppsV1Api</code> Apps API (deployments, replicasets)"},{"location":"Resources/Lab08-Kagent/step04-imports/#why-these-imports","title":"Why These Imports?","text":"<ol> <li>MCP SDK provides the server infrastructure and protocol handling</li> <li>Kubernetes Client enables API communication with your cluster</li> <li>Type Schemas ensure type-safe request/response handling</li> </ol>"},{"location":"Resources/Lab08-Kagent/step05-class-structure/","title":"Step05 class structure","text":"<pre><code># Step 05: K-Agent Server Class Structure\n\n## Define the KAgentServer Class\n\nAdd the class definition to your `src/index.ts`:\n\n```typescript\nclass KAgentServer {\n  // Kubernetes API clients\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n\n  // MCP Server instance\n  private server: Server;\n\n  constructor() {\n    // Initialize Kubernetes configuration\n    this.k8sConfig = new k8s.KubeConfig();\n    try {\n      this.k8sConfig.loadFromDefault();\n    } catch (error) {\n      console.error(\"Warning: Could not load Kubernetes configuration.\");\n      console.error(\"Make sure kubectl is configured.\");\n      console.error(\n        \"Error:\",\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n\n    // Create Kubernetes API clients\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Initialize MCP server\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      },\n    );\n\n    // Setup request handlers\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // Will be implemented in next steps\n  }\n\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Create and run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step05-class-structure/#class-structure-explanation","title":"Class Structure Explanation","text":""},{"location":"Resources/Lab08-Kagent/step05-class-structure/#properties","title":"Properties","text":"Property Type Purpose <code>k8sConfig</code> <code>KubeConfig</code> Loads and manages kubeconfig <code>k8sAppsApi</code> <code>AppsV1Api</code> Apps API for deployments <code>k8sCoreApi</code> <code>CoreV1Api</code> Core API for pods/logs <code>server</code> <code>Server</code> MCP server instance"},{"location":"Resources/Lab08-Kagent/step05-class-structure/#constructor-flow","title":"Constructor Flow","text":"<ol> <li>Load Configuration - Reads <code>~/.kube/config</code> or in-cluster config</li> <li>Create API Clients - Instantiates typed K8s API clients</li> <li>Initialize MCP Server - Creates server with name and capabilities</li> <li>Setup Handlers - Registers tool and resource handlers</li> </ol>"},{"location":"Resources/Lab08-Kagent/step05-class-structure/#run-method","title":"Run Method","text":"<ul> <li>Creates stdio transport for client communication</li> <li>Connects server to transport</li> <li>Begins listening for JSON-RPC requests</li> </ul>"},{"location":"Resources/Lab08-Kagent/step06-tool-registration/","title":"Step06 tool registration","text":"<pre><code># Step 06: Tool Registration\n\n## Register Tools in setupHandlers()\n\nUpdate the `setupHandlers()` method to register available tools:\n\n```typescript\nprivate setupHandlers() {\n  // List available tools\n  this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n    return {\n      tools: [\n        {\n          name: \"list_pods\",\n          description: \"List all pods across namespaces with their status\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Optional: Filter by specific namespace\"\n              }\n            }\n          }\n        },\n        {\n          name: \"collect_pod_logs\",\n          description: \"Collect logs from all containers in specified pods\",\n          inputSchema: {\n            type: \"object\",\n            properties: {\n              namespace: {\n                type: \"string\",\n                description: \"Namespace to collect logs from\"\n              },\n              podName: {\n                type: \"string\",\n                description: \"Specific pod name (optional - collects from all if not specified)\"\n              },\n              tailLines: {\n                type: \"number\",\n                description: \"Number of recent log lines to retrieve\",\n                default: 100\n              }\n            },\n            required: [\"namespace\"]\n          }\n        }\n      ]\n    };\n  });\n\n  // Tool call handler will be added in next step\n}\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step06-tool-registration/#tool-definitions-explained","title":"Tool Definitions Explained","text":""},{"location":"Resources/Lab08-Kagent/step06-tool-registration/#list_pods-tool","title":"list_pods Tool","text":"Property Value Description <code>name</code> <code>list_pods</code> Tool identifier <code>description</code> String What the tool does <code>inputSchema</code> JSON Schema Validates inputs <p>Input Parameters:</p> <ul> <li><code>namespace</code> (optional): Filter to specific namespace</li> </ul>"},{"location":"Resources/Lab08-Kagent/step06-tool-registration/#collect_pod_logs-tool","title":"collect_pod_logs Tool","text":"Property Value Description <code>name</code> <code>collect_pod_logs</code> Tool identifier <code>required</code> <code>[\"namespace\"]</code> Required parameters <p>Input Parameters:</p> <ul> <li><code>namespace</code> (required): Target namespace</li> <li><code>podName</code> (optional): Specific pod filter</li> <li><code>tailLines</code> (optional, default: 100): Log line count</li> </ul>"},{"location":"Resources/Lab08-Kagent/step06-tool-registration/#json-schema-format","title":"JSON Schema Format","text":"<p>The <code>inputSchema</code> uses JSON Schema to define:</p> <ul> <li>Parameter types (<code>string</code>, <code>number</code>)</li> <li>Required fields</li> <li>Default values</li> <li>Descriptions for AI understanding</li> </ul> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step07-tool-handlers/","title":"Step07 tool handlers","text":"<pre><code># Step 07: Tool Call Handlers\n\n## Add Tool Call Handler to setupHandlers()\n\nAdd the following after the `ListToolsRequestSchema` handler:\n\n```typescript\n// Handle tool calls\nthis.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n  const { name, arguments: args } = request.params;\n\n  try {\n    switch (name) {\n      case \"list_pods\":\n        return await this.handleListPods(args);\n      case \"collect_pod_logs\":\n        return await this.handleCollectPodLogs(args);\n      default:\n        throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);\n    }\n  } catch (error) {\n    throw new McpError(\n      ErrorCode.InternalError,\n      `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n});\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step07-tool-handlers/#handler-flow","title":"Handler Flow","text":"<pre><code>Client Request\n    \u2193\nCallToolRequestSchema Handler\n    \u2193\nExtract: { name, arguments }\n    \u2193\nSwitch by Tool Name\n    \u251c\u2500\u2500 list_pods \u2192 handleListPods()\n    \u251c\u2500\u2500 collect_pod_logs \u2192 handleCollectPodLogs()\n    \u2514\u2500\u2500 unknown \u2192 McpError\n    \u2193\nReturn Result or Error\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step07-tool-handlers/#error-handling","title":"Error Handling","text":"<p>The handler uses <code>McpError</code> with standard error codes:</p> ErrorCode Usage <code>MethodNotFound</code> Unknown tool name <code>InternalError</code> Execution failure <code>InvalidParams</code> Bad input (you can add)"},{"location":"Resources/Lab08-Kagent/step07-tool-handlers/#response-format","title":"Response Format","text":"<p>All tool handlers return:</p> <pre><code>{\n  content: [\n    {\n      type: \"text\",\n      text: \"result string\",\n    },\n  ];\n}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step08-list-pods/","title":"Step08 list pods","text":"<pre><code># Step 08: List Pods Implementation\n\n## Implement handleListPods Method\n\nAdd the following methods to your class:\n\n```typescript\nprivate async handleListPods(args: any) {\n  const namespace = args?.namespace;\n  const pods = await this.getPods(namespace);\n\n  const podList = pods.map(pod =&gt; ({\n    name: pod.metadata?.name || 'unknown',\n    namespace: pod.metadata?.namespace || 'unknown',\n    status: pod.status?.phase || 'unknown',\n    containers: pod.spec?.containers?.map(c =&gt; c.name) || []\n  }));\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: JSON.stringify(podList, null, 2)\n      }\n    ]\n  };\n}\n\nprivate async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n  try {\n    if (namespace) {\n      const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n      return response.items || [];\n    } else {\n      const response = await this.k8sCoreApi.listPodForAllNamespaces();\n      return response.items || [];\n    }\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n\nprivate handleK8sError(error: any): Error {\n  if (error.response?.statusCode === 403) {\n    return new Error('Access denied: Insufficient permissions to access Kubernetes resources');\n  }\n\n  if (error.response?.statusCode === 404) {\n    return new Error('Resource not found: The specified pod or namespace may not exist');\n  }\n\n  return new Error(`Kubernetes operation failed: ${error.message}`);\n}\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step08-list-pods/#method-breakdown","title":"Method Breakdown","text":""},{"location":"Resources/Lab08-Kagent/step08-list-pods/#handlelistpods","title":"handleListPods","text":"<ol> <li>Extract optional <code>namespace</code> from arguments</li> <li>Call <code>getPods()</code> to fetch pod list</li> <li>Transform pods to simplified format</li> <li>Return JSON-formatted result</li> </ol>"},{"location":"Resources/Lab08-Kagent/step08-list-pods/#getpods","title":"getPods","text":"Scenario API Call With namespace <code>listNamespacedPod({ namespace })</code> Without namespace <code>listPodForAllNamespaces()</code>"},{"location":"Resources/Lab08-Kagent/step08-list-pods/#handlek8serror","title":"handleK8sError","text":"<p>Translates Kubernetes API errors to user-friendly messages:</p> Status Code Meaning 403 Permission denied 404 Resource not found Other Generic K8s error"},{"location":"Resources/Lab08-Kagent/step08-list-pods/#example-output","title":"Example Output","text":"<pre><code>[\n  {\n    \"name\": \"nginx-deployment-abc123\",\n    \"namespace\": \"default\",\n    \"status\": \"Running\",\n    \"containers\": [\"nginx\"]\n  },\n  {\n    \"name\": \"redis-master-xyz789\",\n    \"namespace\": \"production\",\n    \"status\": \"Running\",\n    \"containers\": [\"redis\"]\n  }\n]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step09-log-collection/","title":"Step09 log collection","text":"<pre><code># Step 09: Log Collection Implementation\n\n## Implement Log Collection Methods\n\nAdd these methods to your class:\n\n```typescript\nprivate async handleCollectPodLogs(args: any) {\n  const { namespace, podName, tailLines = 100 } = args;\n\n  if (!namespace) {\n    throw new Error(\"Namespace is required\");\n  }\n\n  const logs = await this.collectPodLogs(namespace, podName, tailLines);\n\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: logs\n      }\n    ]\n  };\n}\n\nprivate async collectPodLogs(\n  namespace: string,\n  podName?: string,\n  tailLines: number = 100\n): Promise&lt;string&gt; {\n  // Get pods - either specific or all in namespace\n  const pods = podName\n    ? await this.getPods(namespace).then(pods =&gt;\n        pods.filter(p =&gt; p.metadata?.name === podName)\n      )\n    : await this.getPods(namespace);\n\n  const allLogs: string[] = [];\n\n  for (const pod of pods) {\n    if (!pod.metadata?.name) continue;\n\n    // Iterate through all containers in the pod\n    const containers = pod.spec?.containers || [];\n    for (const container of containers) {\n      try {\n        const logs = await this.getPodLogs(\n          namespace,\n          pod.metadata.name,\n          container.name,\n          tailLines\n        );\n        allLogs.push(`=== ${pod.metadata.name}/${container.name} ===\\n${logs}\\n`);\n      } catch (error) {\n        allLogs.push(\n          `=== ${pod.metadata.name}/${container.name} ===\\n` +\n          `Error retrieving logs: ${error instanceof Error ? error.message : String(error)}\\n`\n        );\n      }\n    }\n  }\n\n  return allLogs.join('\\n');\n}\n\nprivate async getPodLogs(\n  namespace: string,\n  podName: string,\n  containerName: string,\n  tailLines: number\n): Promise&lt;string&gt; {\n  try {\n    const response = await this.k8sCoreApi.readNamespacedPodLog({\n      name: podName,\n      namespace: namespace,\n      container: containerName,\n      tailLines: tailLines,\n      timestamps: true\n    });\n    return response || '';\n  } catch (error) {\n    throw this.handleK8sError(error);\n  }\n}\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step09-log-collection/#method-breakdown","title":"Method Breakdown","text":""},{"location":"Resources/Lab08-Kagent/step09-log-collection/#handlecollectpodlogs","title":"handleCollectPodLogs","text":"<ol> <li>Destructure arguments with default values</li> <li>Validate required namespace</li> <li>Call <code>collectPodLogs()</code> orchestrator</li> <li>Return formatted result</li> </ol>"},{"location":"Resources/Lab08-Kagent/step09-log-collection/#collectpodlogs-orchestrator","title":"collectPodLogs (Orchestrator)","text":"<p>Flow:</p> <pre><code>1. Get pods (filtered or all)\n2. For each pod:\n   a. For each container:\n      - Try to get logs\n      - Add to result (success or error)\n3. Join all logs with separators\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step09-log-collection/#getpodlogs","title":"getPodLogs","text":"<p>Kubernetes API parameters:</p> Parameter Description <code>name</code> Pod name <code>namespace</code> Pod namespace <code>container</code> Container name (required for multi-container pods) <code>tailLines</code> Number of lines from end <code>timestamps</code> Include timestamps"},{"location":"Resources/Lab08-Kagent/step09-log-collection/#example-output","title":"Example Output","text":"<pre><code>=== nginx-deployment-abc123/nginx ===\n2024-01-15T10:30:45.123Z GET /api/health 200 5ms\n2024-01-15T10:30:46.456Z GET /api/status 200 3ms\n\n=== redis-master-xyz789/redis ===\n1:C 15 Jan 10:30:45.789 * Redis starting\n1:C 15 Jan 10:30:45.790 * Ready to accept connections\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step10-complete-code/","title":"Step10 complete code","text":"<pre><code># Step 10: Complete K-Agent Server Code\n\n## Complete src/index.ts\n\n```typescript\n// Import MCP SDK components and Kubernetes client\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ErrorCode,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport * as k8s from \"@kubernetes/client-node\";\n\nclass KAgentServer {\n  // Store Kubernetes API clients (for talking to your cluster)\n  private k8sConfig: k8s.KubeConfig;\n  private k8sAppsApi: k8s.AppsV1Api;\n  private k8sCoreApi: k8s.CoreV1Api;\n  private server: Server;\n\n  constructor() {\n    // Initialize connection to your Kubernetes cluster (uses ~/.kube/config)\n    this.k8sConfig = new k8s.KubeConfig();\n    try {\n      this.k8sConfig.loadFromDefault();\n    } catch (error) {\n      console.error(\"Warning: Could not load Kubernetes configuration.\");\n      console.error(\"Make sure kubectl is configured.\");\n      console.error(\n        \"Error:\",\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n\n    this.k8sAppsApi = this.k8sConfig.makeApiClient(k8s.AppsV1Api);\n    this.k8sCoreApi = this.k8sConfig.makeApiClient(k8s.CoreV1Api);\n\n    // Create MCP server that AI tools can connect to\n    this.server = new Server(\n      {\n        name: \"k-agent-logs\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n        },\n      },\n    );\n\n    // Handle incoming MCP requests\n    this.setupHandlers();\n  }\n\n  private setupHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: \"list_pods\",\n            description: \"List all pods across namespaces with their status\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Optional: Filter by specific namespace\",\n                },\n              },\n            },\n          },\n          {\n            name: \"collect_pod_logs\",\n            description: \"Collect logs from all containers in specified pods\",\n            inputSchema: {\n              type: \"object\",\n              properties: {\n                namespace: {\n                  type: \"string\",\n                  description: \"Namespace to collect logs from\",\n                },\n                podName: {\n                  type: \"string\",\n                  description:\n                    \"Specific pod name (optional - collects from all if not specified)\",\n                },\n                tailLines: {\n                  type: \"number\",\n                  description: \"Number of recent log lines to retrieve\",\n                  default: 100,\n                },\n              },\n              required: [\"namespace\"],\n            },\n          },\n        ],\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case \"list_pods\":\n            return await this.handleListPods(args);\n          case \"collect_pod_logs\":\n            return await this.handleCollectPodLogs(args);\n          default:\n            throw new McpError(\n              ErrorCode.MethodNotFound,\n              `Unknown tool: ${name}`,\n            );\n        }\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    });\n  }\n\n  private async handleListPods(args: any) {\n    const namespace = args?.namespace;\n    const pods = await this.getPods(namespace);\n\n    const podList = pods.map((pod) =&gt; ({\n      name: pod.metadata?.name || \"unknown\",\n      namespace: pod.metadata?.namespace || \"unknown\",\n      status: pod.status?.phase || \"unknown\",\n      containers: pod.spec?.containers?.map((c) =&gt; c.name) || [],\n    }));\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(podList, null, 2),\n        },\n      ],\n    };\n  }\n\n  private async handleCollectPodLogs(args: any) {\n    const { namespace, podName, tailLines = 100 } = args;\n\n    if (!namespace) {\n      throw new Error(\"Namespace is required\");\n    }\n\n    const logs = await this.collectPodLogs(namespace, podName, tailLines);\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: logs,\n        },\n      ],\n    };\n  }\n\n  private async collectPodLogs(\n    namespace: string,\n    podName?: string,\n    tailLines: number = 100,\n  ): Promise&lt;string&gt; {\n    const pods = podName\n      ? await this.getPods(namespace).then((pods) =&gt;\n          pods.filter((p) =&gt; p.metadata?.name === podName),\n        )\n      : await this.getPods(namespace);\n\n    const allLogs: string[] = [];\n\n    for (const pod of pods) {\n      if (!pod.metadata?.name) continue;\n\n      const containers = pod.spec?.containers || [];\n      for (const container of containers) {\n        try {\n          const logs = await this.getPodLogs(\n            namespace,\n            pod.metadata.name,\n            container.name,\n            tailLines,\n          );\n          allLogs.push(\n            `=== ${pod.metadata.name}/${container.name} ===\\n${logs}\\n`,\n          );\n        } catch (error) {\n          allLogs.push(\n            `=== ${pod.metadata.name}/${container.name} ===\\nError retrieving logs: ${error instanceof Error ? error.message : String(error)}\\n`,\n          );\n        }\n      }\n    }\n\n    return allLogs.join(\"\\n\");\n  }\n\n  private async getPods(namespace?: string): Promise&lt;k8s.V1Pod[]&gt; {\n    try {\n      if (namespace) {\n        const response = await this.k8sCoreApi.listNamespacedPod({ namespace });\n        return response.items || [];\n      } else {\n        const response = await this.k8sCoreApi.listPodForAllNamespaces();\n        return response.items || [];\n      }\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private async getPodLogs(\n    namespace: string,\n    podName: string,\n    containerName: string,\n    tailLines: number,\n  ): Promise&lt;string&gt; {\n    try {\n      const response = await this.k8sCoreApi.readNamespacedPodLog({\n        name: podName,\n        namespace: namespace,\n        container: containerName,\n        tailLines: tailLines,\n        timestamps: true,\n      });\n      return response || \"\";\n    } catch (error) {\n      throw this.handleK8sError(error);\n    }\n  }\n\n  private handleK8sError(error: any): Error {\n    if (error.response?.statusCode === 403) {\n      return new Error(\n        \"Access denied: Insufficient permissions to access Kubernetes resources\",\n      );\n    }\n\n    if (error.response?.statusCode === 404) {\n      return new Error(\n        \"Resource not found: The specified pod or namespace may not exist\",\n      );\n    }\n\n    return new Error(`Kubernetes operation failed: ${error.message}`);\n  }\n\n  // Start the server and listen for connections\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    console.error(\"K-Agent MCP server running on stdio\");\n  }\n}\n\n// Actually run the server\nconst server = new KAgentServer();\nserver.run().catch(console.error);\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step10-complete-code/#file-summary","title":"File Summary","text":"Lines Component 1-13 Imports 15-46 Constructor &amp; initialization 48-96 setupHandlers() - tool registration 98-144 Tool handler methods 146-188 Kubernetes API methods 190-206 Error handling &amp; server run"},{"location":"Resources/Lab08-Kagent/step10-complete-code/#verify-the-code","title":"Verify the Code","text":"<pre><code># Check for syntax errors\nnpm run build\n\n# Test development mode\nnpm run dev\n</code></pre> <p>Expected output:</p> <pre><code>K-Agent MCP server running on stdio\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step11-testing/","title":"Step11 testing","text":"<pre><code># Step 11: Testing with MCP Inspector\n\n## Build and Run\n\n```bash\n# Build the TypeScript code\nnpm run build\n\n# Start the server in development mode\nnpm run dev\n```\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step11-testing/#using-mcp-inspector","title":"Using MCP Inspector","text":"<p>MCP Inspector is a web-based debugging tool for MCP servers.</p>"},{"location":"Resources/Lab08-Kagent/step11-testing/#start-inspector","title":"Start Inspector","text":"<pre><code>npx @modelcontextprotocol/inspector node_modules/.bin/tsx src/index.ts\n</code></pre> <p>This will:</p> <ol> <li>Start your K-Agent server</li> <li>Launch MCP Inspector web interface</li> <li>Open your browser automatically</li> </ol>"},{"location":"Resources/Lab08-Kagent/step11-testing/#connect-to-server","title":"Connect to Server","text":"<ol> <li>Click the \u201cConnect\u201d button at the bottom left</li> <li>Wait for \u201cConnected\u201d status (green indicator)</li> <li>You should see \u201ck-agent-logs v1.0.0\u201d in the title</li> </ol>"},{"location":"Resources/Lab08-Kagent/step11-testing/#test-list_pods-tool","title":"Test list_pods Tool","text":"<ol> <li>Click the \u201cTools\u201d tab</li> <li>Click \u201cList Tools\u201d to refresh</li> <li>Click on <code>list_pods</code></li> <li>Optionally enter a namespace in the input field</li> <li>Click \u201cRun Tool\u201d</li> </ol> <p>Expected Result:</p> <pre><code>[\n  {\n    \"name\": \"coredns-abc123\",\n    \"namespace\": \"kube-system\",\n    \"status\": \"Running\",\n    \"containers\": [\"coredns\"]\n  }\n]\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step11-testing/#test-collect_pod_logs-tool","title":"Test collect_pod_logs Tool","text":"<ol> <li>Click on <code>collect_pod_logs</code> in the tools list</li> <li>In the namespace field, enter: <code>kube-system</code></li> <li>Optionally specify a podName</li> <li>Set tailLines to <code>50</code></li> <li>Click \u201cRun Tool\u201d</li> </ol> <p>Expected Result:</p> <pre><code>=== coredns-abc123/coredns ===\n2024-01-15T10:30:45.123Z [INFO] CoreDNS-1.11.1\n2024-01-15T10:30:45.124Z linux/amd64, go1.21.1\n...\n</code></pre>"},{"location":"Resources/Lab08-Kagent/step11-testing/#troubleshooting","title":"Troubleshooting","text":"Issue Solution \u201cCannot connect\u201d Ensure server is running \u201cPermission denied\u201d Check kubectl permissions \u201cNo pods found\u201d Verify cluster is running \u201cTimeout\u201d Increase wait time, check cluster"},{"location":"Resources/Lab08-Kagent/step11-testing/#alternative-manual-testing","title":"Alternative: Manual Testing","text":"<p>You can also test by piping JSON-RPC messages:</p> <pre><code># Test tools/list\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/list\",\"params\":{}}' | npm run dev\n\n# Test list_pods tool\necho '{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"list_pods\",\"arguments\":{}}}' | npm run dev\n</code></pre> <pre><code>\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step01-install-kagent/","title":"Step 1: Install Kagent","text":"<pre><code># 1.1 Install Kagent CLI\ncurl https://raw.githubusercontent.com/kagent-dev/kagent/refs/heads/main/scripts/get-kagent | bash\n\n# Install Kagent Platform\nkagent install --profile demo\n\n# 1.3 Verify Installation\nkubectl get pods -n kagent\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step02-create-mcp-server/","title":"Step 2: Create Custom MCP Tool (Python)","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step02-create-mcp-server/#21-project-setup","title":"2.1 Project Setup","text":"<pre><code>mkdir -p kagent-monitor/src\ncd kagent-monitor\npython3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step02-create-mcp-server/#22-create-requirementstxt","title":"2.2 Create requirements.txt","text":"<p>Create the file <code>requirements.txt</code> with the following content:</p> <pre><code>mcp&gt;=1.0.0\nkubernetes&gt;=28.1.0\nprometheus-client&gt;=0.19.0\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step02-create-mcp-server/#23-install-dependencies","title":"2.3 Install Dependencies","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step02-create-mcp-server/#24-create-monitorpy","title":"2.4 Create monitor.py","text":"<p>Create the file <code>src/monitor.py</code> with the following content:</p> <pre><code>import asyncio\nimport os\nfrom kubernetes import client, config\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Tool, TextContent\nfrom prometheus_client import start_http_server, Counter\n\n# Prometheus Metrics\nEVENTS_FETCHED = Counter('k8s_events_fetched_total', 'Total number of K8s events fetched')\n\n# Connect to K8s\ntry:\n    config.load_kube_config()\nexcept:\n    config.load_incluster_config()\n\nv1 = client.CoreV1Api()\nserver = Server(\"k8s-monitor\")\n\n@server.list_tools()\nasync def list_tools() -&gt; list[Tool]:\n    return [\n        Tool(\n            name=\"collect_logs\",\n            description=\"Collect logs and events from the Kubernetes cluster\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"namespace\": {\"type\": \"string\", \"description\": \"Namespace to filter (default: default)\"},\n                }\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:\n    if name == \"collect_logs\":\n        ns = arguments.get(\"namespace\", \"default\")\n\n        # 1. Fetch Events\n        events = v1.list_namespaced_event(ns)\n        EVENTS_FETCHED.inc(len(events.items))\n\n        event_logs = []\n        for e in events.items:\n            event_logs.append(f\"[EVENT] {e.last_timestamp} {e.type} {e.reason}: {e.message}\")\n\n        # 2. Fetch Pod Logs (Sample from first pod)\n        pods = v1.list_namespaced_pod(ns)\n        pod_logs = []\n        if pods.items:\n            p = pods.items[0]\n            try:\n                logs = v1.read_namespaced_pod_log(p.metadata.name, ns, tail_lines=5)\n                pod_logs.append(f\"[POD {p.metadata.name}] {logs}\")\n            except:\n                pod_logs.append(f\"[POD {p.metadata.name}] Could not read logs\")\n\n        full_log = \"\\n\".join(event_logs + pod_logs)\n        return [TextContent(type=\"text\", text=full_log)]\n\n    raise ValueError(f\"Unknown tool: {name}\")\n\nasync def main():\n    # Start Prometheus Metrics endpoint on port 8000\n    start_http_server(8000)\n\n    async with stdio_server() as (read, write):\n        await server.run(read, write, server.create_initialization_options())\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step02-create-mcp-server/#25-test-the-tool","title":"2.5 Test the Tool","text":"<pre><code>npx @modelcontextprotocol/inspector python3 src/monitor.py\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/","title":"Step 3: Use kmcp to Build the Server","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#31-install-kmcp-cli","title":"3.1 Install kmcp CLI","text":"<pre><code>curl -fsSL https://raw.githubusercontent.com/kagent-dev/kmcp/refs/heads/main/scripts/get-kmcp.sh | bash\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#32-initialize-project","title":"3.2 Initialize Project","text":"<pre><code>cd ~\nkmcp init python kagent-monitor-kmcp\ncd kagent-monitor-kmcp\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#33-add-dependencies","title":"3.3 Add Dependencies","text":"<pre><code>echo \"kubernetes&gt;=28.1.0\" &gt;&gt; requirements.txt\necho \"prometheus-client&gt;=0.19.0\" &gt;&gt; requirements.txt\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#34-create-k8s_toolspy","title":"3.4 Create k8s_tools.py","text":"<p>Create the file <code>src/k8s_tools.py</code> with the following content:</p> <pre><code>from core.server import mcp\nfrom kubernetes import client, config\n\n# Initialize K8s client\ntry:\n    config.load_kube_config()\nexcept:\n    config.load_incluster_config()\nv1 = client.CoreV1Api()\n\n@mcp.tool(description=\"Collect logs and events from the Kubernetes cluster\")\nasync def collect_logs(namespace: str = \"default\") -&gt; str:\n    \"\"\"Collect logs and events from the Kubernetes cluster\"\"\"\n    # Fetch events\n    events = v1.list_namespaced_event(namespace)\n    output = []\n    for e in events.items:\n        output.append(f\"[EVENT] {e.last_timestamp} {e.type} {e.reason}: {e.message}\")\n    return \"\\n\".join(output)\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#35-run-locally","title":"3.5 Run Locally","text":"<pre><code>kmcp run --project-dir .\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#36-build-docker-image","title":"3.6 Build Docker Image","text":"<pre><code>docker build -t nirgeier/my-kagent-monitor:v1 .\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#37-push-or-load-image","title":"3.7 Push or Load Image","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#docker-hub","title":"Docker Hub","text":"<pre><code>docker push nirgeier/my-kagent-monitor:v1\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#kind","title":"Kind","text":"<pre><code>kind load docker-image my-kagent-monitor:v1 --name &lt;cluster-name&gt;\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#minikube","title":"Minikube","text":"<pre><code>minikube image load my-kagent-monitor:v1\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step03-kmcp-build/#38-deploy-to-kubernetes","title":"3.8 Deploy to Kubernetes","text":"<pre><code>kmcp deploy --namespace default --image nirgeier/my-kagent-monitor:v1\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step04-verify-registration/","title":"Step 4: Verify Tool Registration","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step04-verify-registration/#41-check-deployment-status","title":"4.1 Check Deployment Status","text":"<pre><code>kubectl get pods -n default -l app=kagent-monitor-kmcp\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step04-verify-registration/#42-verify-mcp-server-registration","title":"4.2 Verify MCP Server Registration","text":"<pre><code>kubectl get mcpservers -n default\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step04-verify-registration/#43-manual-registration-optional","title":"4.3 Manual Registration (Optional)","text":"<p>Create the file <code>mcpserver.yaml</code> with the following content:</p> <pre><code>apiVersion: kagent.dev/v1alpha1\nkind: MCPServer\nmetadata:\n  name: k8s-monitor\n  namespace: default\n  labels:\n    app.kubernetes.io/name: k8s-monitor\n    app.kubernetes.io/part-of: kagent\n    app.kubernetes.io/component: mcp-server\nspec:\n  deployment:\n    args:\n      - src/main.py\n    cmd: python\n    image: nirgeier/my-kagent-monitor:v1\n    port: 3000\n  stdioTransport: {}\n  transportType: stdio\n</code></pre> <p>Then apply it:</p> <pre><code>kubectl apply -f mcpserver.yaml\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step05-create-agent/","title":"Step 5: Create the Agent","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step05-create-agent/#51-create-remotemcpserver","title":"5.1 Create RemoteMCPServer","text":"<p>Create the file <code>remotemcpserver.yaml</code> with the following content:</p> <pre><code>apiVersion: kagent.dev/v1alpha2\nkind: RemoteMCPServer\nmetadata:\n  name: k8s-monitor-mcp\n  namespace: default\n  labels:\n    app.kubernetes.io/name: k8s-monitor-mcp\n    app.kubernetes.io/part-of: kagent\nspec:\n  description: K8s Event and Log Monitor MCP Server\n  protocol: STREAMABLE_HTTP\n  url: http://k8s-monitor.default:3000/mcp\n</code></pre> <p>Then apply it:</p> <pre><code>kubectl apply -f remotemcpserver.yaml\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step05-create-agent/#52-create-agent","title":"5.2 Create Agent","text":"<p>Create the file <code>agent.yaml</code> with the following content:</p> <pre><code>apiVersion: kagent.dev/v1alpha2\nkind: Agent\nmetadata:\n  name: k8s-monitor-agent\n  namespace: default\n  labels:\n    app.kubernetes.io/name: k8s-monitor-agent\n    app.kubernetes.io/part-of: kagent\nspec:\n  declarative:\n    modelConfig: default-model-config\n    systemMessage: |\n      You are a Kubernetes monitoring agent that can collect logs and events from a Kubernetes cluster.\n      Use the collect_logs tool to gather information about events and pod logs in a given namespace.\n    tools:\n      - type: McpServer\n        mcpServer:\n          apiGroup: kagent.dev\n          kind: RemoteMCPServer\n          name: k8s-monitor-mcp\n          toolNames:\n            - trace\n            - fail\n            - sleep\n    deployment:\n      resources:\n        requests:\n          cpu: 100m\n          memory: 256Mi\n        limits:\n          cpu: 500m\n          memory: 512Mi\n</code></pre> <p>Then apply it:</p> <pre><code>kubectl apply -f agent.yaml\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step05-create-agent/#53-verify-the-agent","title":"5.3 Verify the Agent","text":"<pre><code>kubectl get agents -n default\n</code></pre> <p>Expected output:</p> <pre><code>NAME                TYPE          READY   ACCEPTED\nk8s-monitor-agent   Declarative   True    True\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step05-create-agent/#54-verify-remotemcpserver","title":"5.4 Verify RemoteMCPServer","text":"<pre><code>kubectl get remotemcpservers -n default\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step05-create-agent/#55-debug-if-ready-false","title":"5.5 Debug (if READY: False)","text":"<pre><code>kubectl logs -l app.kubernetes.io/name=k8s-monitor-agent -n default\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step06-install-ingress/","title":"Step 6: Install NGINX Ingress Controller","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step06-install-ingress/#61-install-via-helm","title":"6.1 Install via Helm","text":"<pre><code>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n\nhelm install ingress-nginx ingress-nginx/ingress-nginx \\\n  --namespace ingress-nginx \\\n  --create-namespace\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step06-install-ingress/#62-verify-installation","title":"6.2 Verify Installation","text":"<pre><code>kubectl get pods -n ingress-nginx\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step07-deploy-prometheus-grafana/","title":"Step 7: Deploy Prometheus &amp; Grafana","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step07-deploy-prometheus-grafana/#71-add-helm-repos","title":"7.1 Add Helm Repos","text":"<pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\nhelm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step07-deploy-prometheus-grafana/#72-create-prometheus-config","title":"7.2 Create Prometheus Config","text":"<p>Create the file <code>prometheus-config.yaml</code> with the following content:</p> <pre><code>server:\n  baseURL: /prometheus\n\n  # Fix probes to check status at /prometheus/-/ready instead of /-/ready\n  readinessProbe:\n    httpGet:\n      path: /prometheus/-/ready\n      port: 9090\n      scheme: HTTP\n    initialDelaySeconds: 30\n    periodSeconds: 5\n    timeoutSeconds: 4\n    failureThreshold: 3\n    successThreshold: 1\n\n  livenessProbe:\n    httpGet:\n      path: /prometheus/-/healthy\n      port: 9090\n      scheme: HTTP\n    initialDelaySeconds: 30\n    periodSeconds: 15\n    timeoutSeconds: 10\n    failureThreshold: 3\n    successThreshold: 1\n\nextraScrapeConfigs: |\n  - job_name: 'mcp-monitor'\n    kubernetes_sd_configs:\n      - role: pod\n    relabel_configs:\n      - source_labels: [__meta_kubernetes_pod_name]\n        regex: .*monitor.*\n        action: keep\n      - source_labels: [__address__]\n        regex: ([^:]+)(?::\\d+)?\n        replacement: ${1}:8000\n        target_label: __address__\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step07-deploy-prometheus-grafana/#73-create-grafana-config","title":"7.3 Create Grafana Config","text":"<p>Create the file <code>grafana-config.yaml</code> with the following content:</p> <pre><code>adminPassword: admin123\ngrafana.ini:\n  server:\n    domain: cluster.local\n    root_url: \"%(protocol)s://%(domain)s/grafana\"\n    serve_from_sub_path: true\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step07-deploy-prometheus-grafana/#74-install-prometheus","title":"7.4 Install Prometheus","text":"<pre><code>helm upgrade --install prometheus prometheus-community/prometheus -f prometheus-config.yaml\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step07-deploy-prometheus-grafana/#75-install-grafana","title":"7.5 Install Grafana","text":"<pre><code>helm upgrade --install grafana grafana/grafana -f grafana-config.yaml\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step07-deploy-prometheus-grafana/#76-verify-deployments","title":"7.6 Verify Deployments","text":"<pre><code>kubectl get pods -n default\nkubectl get pods -n ingress-nginx\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step08-expose-ingress/","title":"Step 8: Expose Services via Ingress","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step08-expose-ingress/#81-create-ingress-manifest","title":"8.1 Create Ingress Manifest","text":"<p>Create the file <code>observability-ingress.yaml</code> with the following content:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: observability-ingress\nspec:\n  ingressClassName: nginx\n  rules:\n    - host: cluster.local\n      http:\n        paths:\n          - path: /prometheus\n            pathType: Prefix\n            backend:\n              service:\n                name: prometheus-server\n                port:\n                  number: 80\n          - path: /grafana\n            pathType: Prefix\n            backend:\n              service:\n                name: grafana\n                port:\n                  number: 80\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: kagent-ui\n                port:\n                  number: 8080\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step08-expose-ingress/#82-apply-ingress","title":"8.2 Apply Ingress","text":"<pre><code>kubectl apply -f observability-ingress.yaml\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step08-expose-ingress/#83-update-hosts-file","title":"8.3 Update Hosts File","text":""},{"location":"Resources/Lab09-K8S-Event-Monitor/step08-expose-ingress/#find-the-ip","title":"Find the IP","text":"<ul> <li>Docker Desktop / OrbStack: Use <code>127.0.0.1</code></li> <li>Minikube: Run <code>minikube ip</code></li> </ul>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step08-expose-ingress/#edit-host-file","title":"Edit Host File","text":"<ul> <li>Linux/macOS: <code>/etc/hosts</code></li> <li>Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li> </ul> <p>Add:</p> <pre><code>127.0.0.1  cluster.local\n</code></pre>"},{"location":"Resources/Lab09-K8S-Event-Monitor/step08-expose-ingress/#84-access-services","title":"8.4 Access Services","text":"<ul> <li>Kagent Dashboard: http://cluster.local</li> <li>Grafana: http://cluster.local/grafana</li> <li>User: <code>admin</code></li> <li>Password: <code>admin123</code></li> <li>Prometheus: http://cluster.local/prometheus</li> </ul>"},{"location":"Tasks/","title":"List of tasks","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/","title":"Task: Install and Setup Roo Code","text":"<ul> <li>This guide outlines the steps to install Roo Code (formerly Cline), configure it with custom instructions and MCP (Model Context Protocol), and demonstrates a usage example with a hypothetical \u201cContext7\u201d MCP server.</li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#1-install-roo-code","title":"1. Install Roo Code","text":"<p>Roo Code is an autonomous coding agent extension for VS Code.</p> <ol> <li>Open VS Code.</li> <li>Go to the Extensions view (Click the square icon on the sidebar or press <code>Cmd+Shift+X</code>).</li> <li>Search for \u201cRoo Code\u201d.</li> <li>Look for the extension published by RooVeterinaryInc (ID: <code>RooVeterinaryInc.roo-cline</code>).</li> <li>Click Install.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#2-setup-roo-code","title":"2. Setup Roo Code","text":"<ol> <li>Once installed, you need to configure Roo Code.</li> <li>Open the Roo Code sidebar by clicking the Roo Code icon on the sidebar.</li> <li>You will see the main Roo Code interface.</li> <li>We will go over the key configuration options during the lecture.</li> <li> <p>Adding API Keys (Use exiting or create new keys as needed) https://aistudio.google.com/api-keys</p> <p></p> <p></p> </li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#3-configuring-roo-code-features","title":"3. Configuring Roo Code Features","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#create-profile","title":"Create Profile","text":"<p>Creating a Profile</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Profile icon (user icon).</li> <li>Click \u201cCreate Profile\u201d.</li> <li>Fill in your details and preferences.</li> <li>Click \u201cSave Profile\u201d.</li> <li>Your profile will help Roo Code tailor its responses to your coding style and preferences.</li> <li>You can create multiple profiles for different projects or coding styles.</li> <li>Switch between profiles as needed.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#api-keys","title":"API Keys","text":"<p>Setting Up API Keys</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Settings (gear icon).</li> <li>Scroll to \u201cAPI Keys\u201d.</li> <li>Enter your API keys for the models you want to use (e.g., OpenAI, Google Gemini).</li> <li>Click \u201cSave\u201d.</li> <li>Roo Code will use these keys to access the respective language models for code generation and assistance.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#modes","title":"Modes","text":"<p>Setting Up Modes</p> <ol> <li>Open the Roo Code sidebar.</li> <li>Click the Settings (gear icon).</li> <li>Scroll to \u201cDefault Mode\u201d.</li> <li>Select your preferred default mode (e.g., Code, Architect, Ask).</li> <li>Click \u201cSave\u201d.</li> <li>This setting determines how Roo Code will approach tasks by default.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#4-advanced-configuration","title":"4. Advanced Configuration","text":""},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#mcp-servers","title":"MCP Servers","text":"<ul> <li>MCP (Model Context Protocol) allows Roo Code to connect to external tools and data sources.</li> </ul> <p>Setting Up MCP Servers</p> <ol> <li>In the Roo Code sidebar, click the MCP icon (server icon) or go to Settings &gt; MCP Servers.</li> <li>Click \u201cEdit MCP Settings\u201d (Global or Project).  </li> <li>This will open a JSON file for the MCP settings.</li> <li>Add your MCP servers to the <code>mcpServers</code> object.<ul> <li>Each server configuration includes the command to start the server, arguments, and environment variables if needed.</li> </ul> </li> <li>Save the file. </li> <li>Roo Code will now be able to use these MCP servers for enhanced context and capabilities.</li> </ol>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#additional-settings","title":"Additional Settings","text":"<ul> <li> <p>We will cover these in the lecture.</p> Setting Description Auto-Approve Automatically approve Roo Code\u2019s suggested changes. Slash Commands Enable or disable slash commands for quick actions. Context Configure how much file context Roo Code uses when generating code (Tabs, limits etc.). Prompts Customize prompt templates for different modes. </li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#4-adding-custom-instructions","title":"4. Adding Custom Instructions","text":"<ul> <li>Adding custom instructions to Roo Code is a powerful way to enforce coding standards, project context, or specific AI behaviors. </li> <li>There are three primary ways to do this: Project-specific files, the UI (Prompts Tab), and Global configuration.</li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#1-project-specific-instructions-recommended","title":"1. Project-Specific Instructions (Recommended)","text":"<ul> <li>This is the best way to ensure that any developer working on your specific project gets the same AI behavior.</li> </ul> <p>Method A: The <code>.roo/rules/</code> Directory (Modern)</p> <ul> <li> <p>Roo Code now looks for a directory in your project root to load instructions.</p> <p>Setting Up Custom Rules</p> <ul> <li>Create a folder named <code>.roo/rules/</code> in your project\u2019s root directory.  </li> <li>Roo Code will read all files in this directory and apply the instructions when working on the project.   </li> <li>Example filenames:  <pre><code>  coding-standards.md\n  project-context.md\n  api-guidelines.md\n  testing-instructions.md\n</code></pre></li> <li>Add any number of <code>.md</code> (Markdown) files in this directory. <pre><code>  your-project/\n  \u251c\u2500\u2500 .roo/\n  \u2502   \u2514\u2500\u2500 rules/\n  \u2502       \u251c\u2500\u2500 coding-standards.md\n  \u2502       \u251c\u2500\u2500 project-context.md\n  \u2502       \u2514\u2500\u2500 api-guidelines.md\n  \u2514\u2500\u2500 src/\n      \u2514\u2500\u2500 main.py\n\n  # Each file can contain specific instructions or context for Roo Code.      \n</code></pre></li> <li>Example content for <code>coding-standards.md</code>:     <pre><code># Coding Standards\n- Follow PEP 8 for Python code.\n- Use meaningful variable names.\n- Write unit tests for all new features.\n</code></pre></li> <li>This method allows for easy version control and sharing of instructions with your team.</li> <li>Roo Code will automatically pick up changes to these files.</li> </ul> </li> </ul>"},{"location":"Tasks/000-Setup-RooCode/000-Setup-RooCode/#2-using-the-prompts-tab-in-the-ui-globalquick-edits","title":"2. Using the Prompts Tab in the UI (Global/Quick Edits)","text":"<ul> <li>You can also add custom instructions directly through the Roo Code UI.</li> <li> <p>This method is less ideal for project-specific instructions but can be useful for quick adjustments.</p> <p>Adding Custom Prompts via UI</p> <ul> <li>Open the Roo Code sidebar.</li> <li>Click on the Prompts tab.</li> <li>Here, you can add or edit custom prompts for different modes.</li> <li>Save your changes.</li> </ul> <ul> <li>Roo Code will use these prompts when generating code.</li> </ul> </li> </ul>"}]}